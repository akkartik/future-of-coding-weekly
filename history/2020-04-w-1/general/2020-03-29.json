[
    {
        "client_msg_id": "07dc1203-ee8a-4bbe-8d75-75676cb7c1ef",
        "type": "message",
        "text": "I don't care what language or system you use, you will invariably find repeated sequences in whatever you are building. A macro system allows you to inline what would have been a function call/return block. Macros have positives - they are faster than function calls, and can be customized, so they are more powerful in a way. Macros are used extensively in assembler, and with enough macros Microsoft Assembler can look a lot like a higher level language. But macros make debugging much harder, because now you can't step through your source code, but instead have to step through the generated source code, and thus you now have a second form of your source code (the output of the pre-processor) to consider. The other drawback of highly nested macros is that your source code size could explode geometrically. It all depends on how deeply nested the macros get. In some sense, you can think of a LISP program as a giant pile of nested macros, which makes them super powerful and also super hard to read.\n\nYou can play games with your language primitives, and pretend you don't have IF statements, or subroutines with CALL/RETURN, or LOOPS, etc., but it must at the end of the day devolve into the instruction set of the 50 year old computer we are using, which has only a very tiny set of atomic operations such as a 2-way branch, a n-way branch, call/return, arithmetic, etc.\n\nRe-use of some kind of formatting or methodology is desirable (if not mandatory), and i don't care what you call it, it will be some kind of subroutine that is called, and what goes down into a sub-function must come back up. This isn't tyranny, it is like arithmetic, a fact of existence that sub-patterns will be identified, coded, and re-used extensively. The more sub-patterns you can identify, the shorter your programs will be. All great programmers code in exactly the same way; instinctively seeking the minimal surface area of the program, by balancing number of sub-functions, and placing them into layers so that they have as few interconnections as possible.",
        "user": "UEQ6M68H0",
        "ts": "1585522725.024900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1585522851.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IsfUh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't care what language or system you use, you will invariably find repeated sequences in whatever you are building. A macro system allows you to inline what would have been a function call/return block. Macros have positives - they are faster than function calls, and can be customized, so they are more powerful in a way. Macros are used extensively in assembler, and with enough macros Microsoft Assembler can look a lot like a higher level language. But macros make debugging much harder, because now you can't step through your source code, but instead have to step through the generated source code, and thus you now have a second form of your source code (the output of the pre-processor) to consider. The other drawback of highly nested macros is that your source code size could explode geometrically. It all depends on how deeply nested the macros get. In some sense, you can think of a LISP program as a giant pile of nested macros, which makes them super powerful and also super hard to read.\n\nYou can play games with your language primitives, and pretend you don't have IF statements, or subroutines with CALL/RETURN, or LOOPS, etc., but it must at the end of the day devolve into the instruction set of the 50 year old computer we are using, which has only a very tiny set of atomic operations such as a 2-way branch, a n-way branch, call/return, arithmetic, etc.\n\nRe-use of some kind of formatting or methodology is desirable (if not mandatory), and i don't care what you call it, it will be some kind of subroutine that is called, and what goes down into a sub-function must come back up. This isn't tyranny, it is like arithmetic, a fact of existence that sub-patterns will be identified, coded, and re-used extensively. The more sub-patterns you can identify, the shorter your programs will be. All great programmers code in exactly the same way; instinctively seeking the minimal surface area of the program, by balancing number of sub-functions, and placing them into layers so that they have as few interconnections as possible."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "6e97572f-390b-44ac-bfcb-7ed7ca72ad51",
        "type": "message",
        "text": "The things you said about macros only apply to textual/text-file languages wherein the expansion of a macro means inserting a bunch of text inline and feeding the result into a naive compiler. If you throw away implementation preconceptions and just think of a (parameterized) macro as \"here is a pattern for achieving a behaviour, now fill in the blanks\", then no problems immediately arise. The concept is not problematic, but realisations of it can be.",
        "user": "UCGAK10LS",
        "ts": "1585523408.025200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585524158.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MKo5h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The things you said about macros only apply to textual/text-file languages wherein the expansion of a macro means inserting a bunch of text inline and feeding the result into a naive compiler. If you throw away implementation preconceptions and just think of a (parameterized) macro as \"here is a pattern for achieving a behaviour, now fill in the blanks\", then no problems immediately arise. The concept is not problematic, but realisations of it can be."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "ea3e2016-a523-4a90-8754-92f0c591ba55",
        "type": "message",
        "text": "And I disagree with the rest of your assertions about call/return, but I already gave that counter-argument earlier in the thread.",
        "user": "UCGAK10LS",
        "ts": "1585523492.025400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585524046.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6L5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And I disagree with the rest of your assertions about call/return, but I already gave that counter-argument earlier in the thread."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    }
]