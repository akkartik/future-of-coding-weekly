[
    {
        "client_msg_id": "6270dd32-6663-453c-a0a0-08856598ce6c",
        "type": "message",
        "text": "I didn't really get this post. Isn't generalization the status quo? Software makes generalization easy; I think that's where a lot of our problems arise.",
        "user": "UCUSW7WVD",
        "ts": "1586244603.169600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Zofnt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't really get this post. Isn't generalization the status quo? Software makes generalization easy; I think that's where a lot of our problems arise."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586193289.167900",
        "parent_user_id": "UAHHWT22U"
    },
    {
        "client_msg_id": "1923aa16-9301-4883-baae-7f26d40c200a",
        "type": "message",
        "text": "Reading list from Philip Guo\u2019s *Human-Centered Programming Tools* class at UCSD\n<http://pgbovine.net/human-centered-programming-tools.htm>",
        "user": "UF1ATC4RF",
        "ts": "1586258844.170700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1QdRQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Reading list from Philip Guo\u2019s "
                            },
                            {
                                "type": "text",
                                "text": "Human-Centered Programming Tools",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " class at UCSD\n"
                            },
                            {
                                "type": "link",
                                "url": "http://pgbovine.net/human-centered-programming-tools.htm"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586258844.170700",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1586312747.176000",
        "reply_users": [
            "U010RH58PL7",
            "UDKTZSD6H"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U010RH58PL7",
                    "UBSMEUXAA",
                    "UU45NNMHT",
                    "UDKTZSD6H"
                ],
                "count": 4
            },
            {
                "name": "100",
                "users": [
                    "UU45NNMHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "FF20C9B2-EB81-4CF5-BE51-4C5D14108BFF",
        "type": "message",
        "text": "I agree with the author that generalization is the correct path. I think what he means is that a grand simplification of the current programming Complexity would be an excellent way forward. That is the thrust of my Beads project and even Early in the total Process it is working very well. There\u2019s so much unnecessary underlying complexity in the Intel/arm Hardware\ufffc And operating systems that can be generalized away, and you can reduce the APIs you have to learn by a factor of 10 easily enough. \n\nGeneralizing computation is one part of the project but the other is convincing people to recognize the generalization and simplification\ufffc as forward progress\ufffc. Not only do you have the not invented here syndrome that engineers always fall prey to, you also have entrenched incumbents who\ufffc With their power and groups of followers maintain the status quo. So it\u2019s actually quite hostile environment that structurally prevents change.\ufffc",
        "user": "UEQ6M68H0",
        "ts": "1586266920.173400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4i75z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with the author that generalization is the correct path. I think what he means is that a grand simplification of the current programming Complexity would be an excellent way forward. That is the thrust of my Beads project and even Early in the total Process it is working very well. There\u2019s so much unnecessary underlying complexity in the Intel/arm Hardware\ufffc And operating systems that can be generalized away, and you can reduce the APIs you have to learn by a factor of 10 easily enough. \n\n"
                            },
                            {
                                "type": "text",
                                "text": "Generalizing computation is one part of the project but the other is convincing people to recognize the generalization "
                            },
                            {
                                "type": "text",
                                "text": "and "
                            },
                            {
                                "type": "text",
                                "text": "simplification"
                            },
                            {
                                "type": "text",
                                "text": "\ufffc as forward progress\ufffc. "
                            },
                            {
                                "type": "text",
                                "text": "Not only do you have the not invented here syndrome that engineers always fall prey to, you also have "
                            },
                            {
                                "type": "text",
                                "text": "entrenched incumbents who\ufffc With their power and groups of followers maintain the status quo. So it\u2019s actually quite hostile environment that structurally prevents change.\ufffc"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586193289.167900",
        "parent_user_id": "UAHHWT22U"
    },
    {
        "client_msg_id": "5e825e9f-dbf9-4d00-bb68-430fba8f47e2",
        "type": "message",
        "text": "If anyone's looking for quick, live, visceral ways of 'feeling the pain of the user' for programming languages, his pythontutor site has an anonymous chat-based live help feature. You can just hop on and help someone with their coding, and connect to real frustrations and confusions (and help someone out!)\n\n<http://pythontutor.com/visualize.html#mode=edit>",
        "user": "U010RH58PL7",
        "ts": "1586266944.173600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H9Mr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If anyone's looking for quick, live, visceral ways of 'feeling the pain of the user' for programming languages, his pythontutor site has an anonymous chat-based live help feature. You can just hop on and help someone with their coding, and connect to real frustrations and confusions (and help someone out!)\n\n"
                            },
                            {
                                "type": "link",
                                "url": "http://pythontutor.com/visualize.html#mode=edit"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586258844.170700",
        "parent_user_id": "UF1ATC4RF"
    },
    {
        "client_msg_id": "6a6e1fa3-69f5-45a7-b784-fc7a1b2beefa",
        "type": "message",
        "text": "We can be more specific than \u201clowers the ceiling.\u201d Viscosity is one of the main barriers to structured editors.",
        "user": "U010SQSJGLS",
        "ts": "1586268476.173800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W1jq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We can be more specific than \u201clowers the ceiling.\u201d Viscosity is one of the main barriers to structured editors."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585950579.096100",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "e0f06248-6d45-435e-942d-e4d20ba0fbb7",
        "type": "message",
        "text": "We can talk more about this if you\u2019re interested. The Cognitive Dimensions of Notation framework gives a useful vocabulary for talking about the tradeoffs in this space.",
        "user": "U010SQSJGLS",
        "ts": "1586269937.174000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0aK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We can talk more about this if you\u2019re interested. The Cognitive Dimensions of Notation framework gives a useful vocabulary for talking about the tradeoffs in this space."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585950579.096100",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "6a53ddf5-2ce9-4609-b5f1-5739d66f7be0",
        "type": "message",
        "text": "He first (correctly) makes the observation that the world isn't black (radical change) or white (incremental only), but its a subtle grey (it depends). But then he immediately makes the same mistake again by heralding one extreme (generalization) as \"the solution\". Much like with radical vs incremental, an extreme (generalization) can never be the solution. I find most applications of generalization extremely damaging, in terms of complexity and inefficiency it brings. People are scared of specialized software because they're scared it won't be able to do all things for all people, but the benefits it brings in terms of simplicity and efficiency can be huge. That's not to say that I would claim \"specialized\" is now the holy grail, but rather that the truth is again.. grey.",
        "user": "UHDQ62M4P",
        "ts": "1586274986.174300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U4X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "He first (correctly) makes the observation that the world isn't black (radical change) or white (incremental only), but its a subtle grey (it depends). But then he immediately makes the same mistake again by heralding one extreme (generalization) as \"the solution\". Much like with radical vs incremental, an extreme (generalization) can never be the solution. I find most applications of generalization extremely damaging, in terms of complexity and inefficiency it brings. People are scared of specialized software because they're scared it won't be able to do all things for all people, but the benefits it brings in terms of simplicity and efficiency can be huge. That's not to say that I would claim \"specialized\" is now the holy grail, but rather that the truth is again.. grey."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586193289.167900",
        "parent_user_id": "UAHHWT22U"
    },
    {
        "client_msg_id": "4806caf0-974e-4548-9d58-2ac8579d91cc",
        "type": "message",
        "text": "Besides that, incrementalism tends to win over radicalism not because radicalism isn't better.. it's because incrementalism has a better process: a) it can be done better over longer time, b) it can better fit in feeble programmer brains, and c) it gives better feedback along the way",
        "user": "UHDQ62M4P",
        "ts": "1586275297.174500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Het3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Besides that, incrementalism tends to win over radicalism not because radicalism isn't better.. it's because incrementalism has a better process: a) it can be done better over longer time, b) it can better fit in feeble programmer brains, and c) it gives better feedback along the way"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586193289.167900",
        "parent_user_id": "UAHHWT22U"
    },
    {
        "client_msg_id": "9af9bd08-3c4f-4702-a9e4-a04cdaa3b5d1",
        "type": "message",
        "text": "All of modern technology is basically incrementalism. Every year we improve some process, and in the case of computer hardware the steady improvement led to a million to 1 price/performance improvement when compared to 30 years ago. However, the same cannot be said of software. Incrementalism has been very ineffective in software. `C++` has been through what 20 versions, each time adding more crap to its already bloated design, and if anything it is getting worse and the complexity level of `C++` is absurd at this point. `Perl` is another language whose accretion process had led to `Perl 6` where reportedly random strings have a high probability of being valid code. That is another clear example of incrementalism being not better. Computer languages are one of the few areas where conceptual integrity, simplicity, elegance and generality confer great benefits, and I assert that languages represent a quantum level jump when they are introduced, and that many of them are damaged over time as the original author leaves and a committee of lesser minds takes over and throws in too much. The productivity difference between machine language and assembler was huge, and FORTRAN was a big jump over Assembler. The question is what is next in the `Algol` family, Transformation languages family (`LISP`), and the other lesser known families? Calling something radical is introducing a political concept that doesn't really apply. As for your point about specialized languages and tools, they are indeed very practical and useful, and the fears that people have about using them are mostly unfounded. Specialized languages can make short work out of what might otherwise be a difficult task. I once did some extremely complex text processing, and used the `Icon` language, and I don't think the task could have been accomplished in another language, because Icon is the king of text, being Griswold's evolution over 20 years of `SNOBOL`.  Yet hardly anyone has heard of Icon or used it.  So i agree that people are superstitious and keep using the top five languages even when contraindicated. Basically they have a few hand tools and when they need to do some specialized task they reach for a hammer, saw and chisel instead of the transmogrified reverse entabulator tool that is perfect for the job.",
        "user": "UEQ6M68H0",
        "ts": "1586286731.175700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1586286933.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kEG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "All of modern technology is basically incrementalism. Every year we improve some process, and in the case of computer hardware the steady improvement led to a million to 1 price/performance improvement when compared to 30 years ago. However, the same cannot be said of software. Incrementalism has been very ineffective in software. "
                            },
                            {
                                "type": "text",
                                "text": "C++",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has been through what 20 versions, each time adding more crap to its already bloated design, and if anything it is getting worse and the complexity level of "
                            },
                            {
                                "type": "text",
                                "text": "C++",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is absurd at this point. "
                            },
                            {
                                "type": "text",
                                "text": "Perl",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is another language whose accretion process had led to "
                            },
                            {
                                "type": "text",
                                "text": "Perl 6",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " where reportedly random strings have a high probability of being valid code. That is another clear example of incrementalism being not better. Computer languages are one of the few areas where conceptual integrity, simplicity, elegance and generality confer great benefits, and I assert that languages represent a quantum level jump when they are introduced, and that many of them are damaged over time as the original author leaves and a committee of lesser minds takes over and throws in too much. The productivity difference between machine language and assembler was huge, and FORTRAN was a big jump over Assembler. The question is what is next in the "
                            },
                            {
                                "type": "text",
                                "text": "Algol",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " family, Transformation languages family ("
                            },
                            {
                                "type": "text",
                                "text": "LISP",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), and the other lesser known families? Calling something radical is introducing a political concept that doesn't really apply. As for your point about specialized languages and tools, they are indeed very practical and useful, and the fears that people have about using them are mostly unfounded. Specialized languages can make short work out of what might otherwise be a difficult task. I once did some extremely complex text processing, and used the "
                            },
                            {
                                "type": "text",
                                "text": "Icon",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " language, and I don't think the task could have been accomplished in another language, because Icon is the king of text, being Griswold's evolution over 20 years of "
                            },
                            {
                                "type": "text",
                                "text": "SNOBOL",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  Yet hardly anyone has heard of Icon or used it.  So i agree that people are superstitious and keep using the top five languages even when contraindicated. Basically they have a few hand tools and when they need to do some specialized task they reach for a hammer, saw and chisel instead of the transmogrified reverse entabulator tool that is perfect for the job."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586193289.167900",
        "parent_user_id": "UAHHWT22U"
    }
]