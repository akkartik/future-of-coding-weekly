[
    {
        "client_msg_id": "47ae07e3-e426-496a-847a-9212109552a8",
        "type": "message",
        "text": "Isn't the fact that map cannot be interrupted its most attractive feature?",
        "user": "UA14TGLTC",
        "ts": "1586396460.103700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SXqNp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Isn't the fact that map cannot be interrupted its most attractive feature?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586366880.096300",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "17064d74-2cdd-4fd8-ad9d-db9e457aca44",
        "type": "message",
        "text": "<@UA14TGLTC> APL and its other \"array language\" descendants such as J and K failed in the marketplace in part because of their inability to stop on demand. A FOR loop that is presented in the language as the preferred looping mechanism is a straitjacket. This is also one of the reasons dataflow languages never get out of their little ghetto, because unlike A/V signal processing and a few other purely stream oriented processing tasks where there is no stopping, most of the real world is about looking for things and stopping at some point; maybe because the user only requested the first 100 records, or because the program realizes that something has gone wrong and it is time stop. If you have enough nesting the amount of unnecessary work could be considerable.  It also common in nested loops to exit out an outer loop on some condition; this is not available with the atomic map operation which considers the loop as one atomic action. I call this problem \"insufficient granularity\", and in the paragon language linked recently by <@UFB8STN7K> you can see they have an iterate across node operatopm, but no conditions attached to the loop.  This type of language construction is maddening to the users, because when you prevent something in the syntax it boxes you in. It is so tempting in new language design to want to eliminate the historical primitive operations, so as to become \"higher level\". I think this is one of the reasons why many of these no-code/low code projects are fated to be niche products.",
        "user": "UEQ6M68H0",
        "ts": "1586405817.104100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1586405896.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TlPty",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " APL and its other \"array language\" descendants such as J and K failed in the marketplace in part because of their inability to stop on demand. A FOR loop that is presented in the language as the preferred looping mechanism is a straitjacket. This is also one of the reasons dataflow languages never get out of their little ghetto, because unlike A/V signal processing and a few other purely stream oriented processing tasks where there is no stopping, most of the real world is about looking for things and stopping at some point; maybe because the user only requested the first 100 records, or because the program realizes that something has gone wrong and it is time stop. If you have enough nesting the amount of unnecessary work could be considerable.  It also common in nested loops to exit out an outer loop on some condition; this is not available with the atomic map operation which considers the loop as one atomic action. I call this problem \"insufficient granularity\", and in the paragon language linked recently by "
                            },
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " you can see they have an iterate across node operatopm, but no conditions attached to the loop.  This type of language construction is maddening to the users, because when you prevent something in the syntax it boxes you in. It is so tempting in new language design to want to eliminate the historical primitive operations, so as to become \"higher level\". I think this is one of the reasons why many of these no-code/low code projects are fated to be niche products."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586366880.096300",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "201e96d1-fa21-48ef-9c32-fdea8345add1",
        "type": "message",
        "text": "<@UD6EXQVM0> Nice blog post :slightly_smiling_face:, it must have taken some time to write it!\n\nAs others mentioned, I also feel it could use some \"introduction\" up front -&gt; it talks about principles of programming, but then quickly gets into something specific and it is hard to see from there what is coming next or when it is coming.\nThis first part, about making a tool where you end up extracting a function -&gt; it feels like it should be a chapter of its own. You could call it Seeing Through The Eye of the Tool Writer if you wish or smth, but it feels like more than just introduction.\n\nAlso, I agree blog post could benefit from list of these principles upfront, just to give us an idea of what we are getting into.\n\nIf I would be nitpicking, I would say that WithoutSuffix method should be named RemoveSuffix -&gt; WithoutSuffix sounds like it checks if there is such suffix and returns bool.\n\nMost of stuff sounds fine to me otherwise, easy to agree with! But that is also because it is pretty general. At the end if I had to recap couple of main thoughts I got from this, it would be hard, because there was a lot of things said and everything felt similarly important. What if you could summarize each chapter/principle into one or two sentences that are the \"takeaway\" for that principle?",
        "user": "UUB7RA7PF",
        "ts": "1586425719.104700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=GSkq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " Nice blog post "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ", it must have taken some time to write it!\n\nAs others mentioned, I also feel it could use some \"introduction\" up front -> it talks about principles of programming, but then quickly gets into something specific and it is hard to see from there what is coming next or when it is coming.\nThis first part, about making a tool where you end up extracting a function -> it feels like it should be a chapter of its own. You could call it Seeing Through The Eye of the Tool Writer if you wish or smth, but it feels like more than just introduction.\n\nAlso, I agree blog post could benefit from list of these principles upfront, just to give us an idea of what we are getting into.\n\nIf I would be nitpicking, I would say that WithoutSuffix method should be named RemoveSuffix -> WithoutSuffix sounds like it checks if there is such suffix and returns bool.\n\nMost of stuff sounds fine to me otherwise, easy to agree with! But that is also because it is pretty general. At the end if I had to recap couple of main thoughts I got from this, it would be hard, because there was a lot of things said and everything felt similarly important. What if you could summarize each chapter/principle into one or two sentences that are the \"takeaway\" for that principle?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586366880.096300",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "82202f68-9a24-403f-a846-06138f4baed3",
        "type": "message",
        "text": "<@UEQ6M68H0>\nI wrote a B+tree for JavaScript (sorted-btree on npm) a couple of years ago. I performed various optimizations based on microbenchmarks and beat out competing libraries. Still, it was much slower than my more complex B+ tree (an AList B+tree) in C#; the C# version should have been slower if the languages were the same speed. An optimized JS engine offers tricks to let you get closer to native speed, but in general, you can't expect to get close to native speed.\n\nI guess I failed to mention a major benefit of tests: making your app safe for changes. You want to be able to change things and see if you broke something major without *any* manual testing. Facebook's motto is \"move fast and break things\" but it's not literally OK for devs to break Facebook - but if FB has comprehensive tests, devs can be trusted to change things more. Your suggestion sound like just making it easier to do manual tests?\n\nOh and I specifically said _nested_ for-loops, not for-loops in general. And my B+tree for JavaScript gives you higher-order functions that *can* stop, so no, stopping is not a feature unique to for-loops. Besides, I was talking about the _order_ of teaching things, not whether they should be taught at all.\n\n<@UUB7RA7PF> If it returned bool, it would have been called HasSuffix. I didn't call it RemoveSuffix because it doesn't actually remove the suffix, it creates a new string without the suffix. While C# strings are immutable, keep in mind that mutable strings remain common in the PL landscape (C++ and Ruby)",
        "user": "UD6EXQVM0",
        "ts": "1586441758.104900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1586445299.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O7b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": "\nI wrote a B+tree for JavaScript (sorted-btree on npm) a couple of years ago. I performed various optimizations based on microbenchmarks and beat out competing libraries. Still, it was much slower than my more complex B+ tree (an AList B+tree) in C#; the C# version should have been slower if the languages were the same speed. An optimized JS engine offers tricks to let you get closer to native speed, but in general, you can't expect to get close to native speed.\n\nI guess I failed to mention a major benefit of tests: making your app safe for changes. You want to be able to change things and see if you broke something major without "
                            },
                            {
                                "type": "text",
                                "text": "any",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " manual testing. Facebook's motto is \"move fast and break things\" but it's not literally OK for devs to break Facebook - but if FB has comprehensive tests, devs can be trusted to change things more. Your suggestion sound like just making it easier to do manual tests?\n\nOh and I specifically said "
                            },
                            {
                                "type": "text",
                                "text": "nested",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for-loops, not for-loops in general. And my B+tree for JavaScript gives you higher-order functions that "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " stop, so no, stopping is not a feature unique to for-loops. Besides, I was talking about the "
                            },
                            {
                                "type": "text",
                                "text": "order",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of teaching things, not whether they should be taught at all.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UUB7RA7PF"
                            },
                            {
                                "type": "text",
                                "text": " If it returned bool, it would have been called HasSuffix. I didn't call it RemoveSuffix because it doesn't actually remove the suffix, it creates a new string without the suffix. While C# strings are immutable, keep in mind that mutable strings remain common in the PL landscape (C++ and Ruby)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586366880.096300",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "0d66e649-b19a-462d-a970-f97a51a442c7",
        "type": "message",
        "text": "<@UD6EXQVM0> Good point, I would also name it HasSuffix if I was going for bool version. I haven't worked with mutable strings/values for some time so maybe that biased me somewhat :slightly_smiling_face: -&gt; what you say makes sense! Thanks for the discussion.",
        "user": "UUB7RA7PF",
        "ts": "1586441907.105200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DQG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " Good point, I would also name it HasSuffix if I was going for bool version. I haven't worked with mutable strings/values for some time so maybe that biased me somewhat "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " -> what you say makes sense! Thanks for the discussion."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586366880.096300",
        "parent_user_id": "UD6EXQVM0",
        "reactions": [
            {
                "name": "simple_smile",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    }
]