[
    {
        "client_msg_id": "e60e884f-e080-44bc-9b22-d5b087474912",
        "type": "message",
        "text": "One problem in the world today is that if you take a widely used program and add a warning to it in some situation, people get mad at you. No matter how useful the warning is, how insidious the situation it protects you against.\n\nThe reason for this seems to be that not everyone who sees a warning is empowered to fix the underlying cause. You might use a library that does something warning-worthy. You can't change the library yourself to fix the warning.\n\nQuestion for live-program enthusiasts like <@U013ZLJARC7>[1][2]: I wonder how much this problem is caused by overusing batch-programming and an insufficiently expressive communication channel for warnings. I made up a wishlist at <https://lobste.rs/s/vgnnjt/we_are_stuck_with_egrep_fgrep_unless_you#c_gqhemo> that might be interesting to think about together.\n\nOn the other hand, I see Common Lisp people get annoyed about similar issues: <https://mailman.common-lisp.net/pipermail/asdf-devel/2022-January/006680.html>\n\n[1] <https://futureofcoding.slack.com/archives/CCL5VVBAN/p1665503282267399>\n[2] <https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1665594315849469>",
        "user": "UCUSW7WVD",
        "ts": "1665807995.450199",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://lobste.rs/s/vgnnjt/we_are_stuck_with_egrep_fgrep_unless_you#c_gqhemo",
                "thumb_url": "https://lobste.rs/apple-touch-icon-144.png",
                "thumb_width": 144,
                "thumb_height": 144,
                "service_icon": "https://lobste.rs/apple-touch-icon.png",
                "id": 1,
                "original_url": "https://lobste.rs/s/vgnnjt/we_are_stuck_with_egrep_fgrep_unless_you#c_gqhemo",
                "fallback": "We are stuck with egrep and fgrep (unless you like beating people)",
                "text": "16 comments",
                "title": "We are stuck with egrep and fgrep (unless you like beating people)",
                "title_link": "https://lobste.rs/s/vgnnjt/we_are_stuck_with_egrep_fgrep_unless_you#c_gqhemo",
                "service_name": "lobste.rs"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5jsBj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One problem in the world today is that if you take a widely used program and add a warning to it in some situation, people get mad at you. No matter how useful the warning is, how insidious the situation it protects you against.\n\nThe reason for this seems to be that not everyone who sees a warning is empowered to fix the underlying cause. You might use a library that does something warning-worthy. You can't change the library yourself to fix the warning.\n\nQuestion for live-program enthusiasts like "
                            },
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": "[1][2]: I wonder how much this problem is caused by overusing batch-programming and an insufficiently expressive communication channel for warnings. I made up a wishlist at "
                            },
                            {
                                "type": "link",
                                "url": "https://lobste.rs/s/vgnnjt/we_are_stuck_with_egrep_fgrep_unless_you#c_gqhemo"
                            },
                            {
                                "type": "text",
                                "text": " that might be interesting to think about together.\n\nOn the other hand, I see Common Lisp people get annoyed about similar issues: "
                            },
                            {
                                "type": "link",
                                "url": "https://mailman.common-lisp.net/pipermail/asdf-devel/2022-January/006680.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\n[1] "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/CCL5VVBAN/p1665503282267399"
                            },
                            {
                                "type": "text",
                                "text": "\n[2] "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C03RR0W5DGC/p1665594315849469"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "reply_count": 11,
        "reply_users_count": 5,
        "latest_reply": "1665937954.923249",
        "reply_users": [
            "UJBAJNFLK",
            "UKJGU23KP",
            "UCUSW7WVD",
            "U013ZLJARC7",
            "U02028JHX37"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "2811a019-81d2-4706-b84e-00d7a7cc6371",
        "type": "message",
        "text": "Not sure this is an issue of live vs. batch. It's more an issue of dependency handling in the Open Source world. In the world of artisanal and industrial products, clients deal with a single supplier, who is responsible for the product sold, including all its components from the supply chain. Commercial software works much like that as well. In Open Source, everybody is responsible for their piece of code but not for its dependencies. In theory, it's the end user who installs everything who is responsible for the correct working of the assembly, but the typical end user can't really do much about technical problems.\n\nUltimately, it's the ambiguous self-image that Open Source developers (both individuals and communities) have. They want to be part of a network of like-minded developers who share code, but they also want large-scale adoption by end users. They end up advertising their products to end users while at the same time proclaiming in the small print not to be responsible for any problems. That's a mismatch between advertising and hard promises that's not so different from commercial vendors.",
        "user": "UJBAJNFLK",
        "ts": "1665815712.994899",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rka9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not sure this is an issue of live vs. batch. It's more an issue of dependency handling in the Open Source world. In the world of artisanal and industrial products, clients deal with a single supplier, who is responsible for the product sold, including all its components from the supply chain. Commercial software works much like that as well. In Open Source, everybody is responsible for their piece of code but not for its dependencies. In theory, it's the end user who installs everything who is responsible for the correct working of the assembly, but the typical end user can't really do much about technical problems.\n\nUltimately, it's the ambiguous self-image that Open Source developers (both individuals and communities) have. They want to be part of a network of like-minded developers who share code, but they also want large-scale adoption by end users. They end up advertising their products to end users while at the same time proclaiming in the small print not to be responsible for any problems. That's a mismatch between advertising and hard promises that's not so different from commercial vendors."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0245E9RB2B",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "6F42B473-B680-46E9-893A-4851F55081F0",
        "type": "message",
        "text": "At a very abstract level, I want to say: the problem is that this is a build time warning expressed as a runtime warning.",
        "user": "UKJGU23KP",
        "ts": "1665855905.424989",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UKJGU23KP",
            "ts": "1665855938.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XUg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At a very abstract level, I want to say: the problem is that this is a build time warning expressed as a runtime warning."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5af42ecc-89b6-4b14-b6b6-7a7a52e1a5ab",
        "type": "message",
        "text": "Exactly. But the point of live program folks seems to be that we should care about such distinctions _less_ ...",
        "user": "UCUSW7WVD",
        "ts": "1665856080.195479",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HiTEh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Exactly. But the point of live program folks seems to be that we should care about such distinctions _less_ ..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "1a06221a-2032-49f8-a977-137847442713",
        "type": "message",
        "text": "I... mostly don't care about extra warnings? Also, agree with <@UJBAJNFLK> that this looks like a deps thing, not a live/batch thing.",
        "user": "U013ZLJARC7",
        "ts": "1665873603.000209",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z=jUR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I... mostly don't care about extra warnings? Also, agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " that this looks like a deps thing, not a live/batch thing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "b7e698eb-37a2-442a-a8e0-b3d9e54b48ae",
        "type": "message",
        "text": "<@UKJGU23KP> Yes, exactly. But technology follows incentives. If someone (person or institution) profits (making money, not being sued) from a software assembly working fine for end users, then that someone will create the tools to deal with potential runtime warnings at build time.",
        "user": "UJBAJNFLK",
        "ts": "1665905777.436949",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0h5b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKJGU23KP"
                            },
                            {
                                "type": "text",
                                "text": " Yes, exactly. But technology follows incentives. If someone (person or institution) profits (making money, not being sued) from a software assembly working fine for end users, then that someone will create the tools to deal with potential runtime warnings at build time."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "f46d7d2d-e655-4a14-9367-1f7f0bada283",
        "type": "message",
        "text": "<@UCUSW7WVD> The live programming environments from the 1970s and 1980s were indeed designed in a context where the person using the system was both the end user and a competent developer. So it's the user who is the manager of the top-level software assembly. BTW, the idea of free software (Stallman's famount printer driver story) goes back to the same context. Neither free software nor live environments have been adapted to today's context of software as an industrial product for non-expert users.",
        "user": "UJBAJNFLK",
        "ts": "1665905946.390279",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1665905970.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2JL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " The live programming environments from the 1970s and 1980s were indeed designed in a context where the person using the system was both the end user and a competent developer. So it's the user who is the manager of the top-level software assembly. BTW, the idea of free software (Stallman's famount printer driver story) goes back to the same context. Neither free software nor live environments have been adapted to today's context of software as an industrial product for non-expert users."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7ffb3950-cfc4-45d9-81c1-61676da1985a",
        "type": "message",
        "text": "<@UJBAJNFLK> I don\u2019t agree that OSS developers aren\u2019t responsible for their programs\u2019 dependencies. They may not care about such responsibility, but then they\u2019re irresponsible (and are making low-quality software). What is a true end-user\u2019s problem is assembling *independent* programs into one they need, and that\u2019s where the real hard-to-resolve impedances kick in (the OSS developers don\u2019t have much incentive to cooperate, unless their userbases overlap totally; end-users usually don\u2019t have the specialty to harmonize the programs). Note that these aren\u2019t problems with dependencies, as the constituent programs can (and are meant to) function independently.",
        "user": "U02028JHX37",
        "ts": "1665917280.259979",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vXB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I don\u2019t agree that OSS developers aren\u2019t responsible for their programs\u2019 dependencies. They may not care about such responsibility, but then they\u2019re irresponsible (and are making low-quality software). What is a true end-user\u2019s problem is assembling "
                            },
                            {
                                "type": "text",
                                "text": "independent",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " programs into one they need, and that\u2019s where the real hard-to-resolve impedances kick in (the OSS developers don\u2019t have much incentive to cooperate, unless their userbases overlap totally; end-users usually don\u2019t have the specialty to harmonize the programs). Note that these aren\u2019t problems with dependencies, as the constituent programs can (and are meant to) function independently."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9e35b127-cdb3-430b-b21d-09a3154e7c42",
        "type": "message",
        "text": "<@U02028JHX37> Assembling software is an issue both for library dependencies and for \"independent program\" dependencies. In fact, there is little difference between the two other than the interface technology (linking vs. process calls). In both cases, the issue is not bad will nor incompetence, but insufficiencies in both the social structures and the technical infrastructure for software development. The only way an OSS developer can take full responsibility for dependencies is by maintaining forks of everything, and that's beyond most developers' means (but I suspect that this is what Microsoft etc. do).",
        "user": "UJBAJNFLK",
        "ts": "1665926984.928439",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ttw7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02028JHX37"
                            },
                            {
                                "type": "text",
                                "text": " Assembling software is an issue both for library dependencies and for \"independent program\" dependencies. In fact, there is little difference between the two other than the interface technology (linking vs. process calls). In both cases, the issue is not bad will nor incompetence, but insufficiencies in both the social structures and the technical infrastructure for software development. The only way an OSS developer can take full responsibility for dependencies is by maintaining forks of everything, and that's beyond most developers' means (but I suspect that this is what Microsoft etc. do)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "acad6135-a63a-4299-9936-7ecfb998dc77",
        "type": "message",
        "text": "<@UJBAJNFLK> When some software has an explicit dependency, then surely the developer uses it consciously (of course, it often gets impractical for some transitive dependencies burrowed under many others). Now, assuming that such a dependency is used only by that one program (it's properly isolated, not being a shared library), then any defect should only come from the dependency itself or from the interaction between the dependency and the program. In the former case, the programmer should have chosen something that works; in the latter, it's probably his fault it doesn't work (unless it's a bug, in which case he unfortunately has to work around it). Yes, I know that in some environments, even isolated dependencies might clash (I've seen this happen with npm packages), but then, why bother using such environments?",
        "user": "U02028JHX37",
        "ts": "1665933150.897019",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HrKIX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " When some software has an explicit dependency, then surely the developer uses it consciously (of course, it often gets impractical for some transitive dependencies burrowed under many others). Now, assuming that such a dependency is used only by that one program (it's properly isolated, not being a shared library), then any defect should only come from the dependency itself or from the interaction between the dependency and the program. In the former case, the programmer should have chosen something that works; in the latter, it's probably his fault it doesn't work (unless it's a bug, in which case he unfortunately has to work around it). Yes, I know that in some environments, even isolated dependencies might clash (I've seen this happen with npm packages), but then, why bother using such environments?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "75b928ae-e41a-47c8-a06c-1783decbcc4a",
        "type": "message",
        "text": "<@U02028JHX37> The main issue in practice is dependencies evolving, breaking compatibility intentionally or through bugs creeping in.\nAn example from my own past: in the 1990s, I was part of the team that launched the Scientific Python ecosystem. Our main sustainability worry was \"what if Guido is hit by a bus?\" We had doubts about Python's survival chance for lack of community support. That turned out to be no issue: Python became immensely popular in the 2000s and developed a large developer community.\nBut then... Python 3 came along, and the Python developer community ended up actively killing Python 2. Lots of domain-specific scientific libraries (including one of my own: <https://github.com/khinsen/MMTK/>) have become very hard to use because of everyone dropping support for Python 2. And we typically don't have the means for a porting effort to Python 3. So were we negligent in the 1990s for adopting Python 2 as a dependency?",
        "user": "UJBAJNFLK",
        "ts": "1665937182.454149",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+GvFk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02028JHX37"
                            },
                            {
                                "type": "text",
                                "text": " The main issue in practice is dependencies evolving, breaking compatibility intentionally or through bugs creeping in.\nAn example from my own past: in the 1990s, I was part of the team that launched the Scientific Python ecosystem. Our main sustainability worry was \"what if Guido is hit by a bus?\" We had doubts about Python's survival chance for lack of community support. That turned out to be no issue: Python became immensely popular in the 2000s and developed a large developer community.\nBut then... Python 3 came along, and the Python developer community ended up actively killing Python 2. Lots of domain-specific scientific libraries (including one of my own: "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/khinsen/MMTK/"
                            },
                            {
                                "type": "text",
                                "text": ") have become very hard to use because of everyone dropping support for Python 2. And we typically don't have the means for a porting effort to Python 3. So were we negligent in the 1990s for adopting Python 2 as a dependency?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02028JHX37"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e4dda1e2-c519-498d-979c-6c8dc64f5f82",
        "type": "message",
        "text": "I see. Developing libraries is a risk in this regard (your userbase isn't really \"your\"). I had standalone \"binaries\" in mind (usually some pipeline utilities, but also more robust programs). These then depend only on the OS (or the shell).",
        "user": "U02028JHX37",
        "ts": "1665937954.923249",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VJe7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see. Developing libraries is a risk in this regard (your userbase isn't really \"your\"). I had standalone \"binaries\" in mind (usually some pipeline utilities, but also more robust programs). These then depend only on the OS (or the shell)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665807995.450199",
        "parent_user_id": "UCUSW7WVD"
    }
]