[
    {
        "client_msg_id": "c5b485c7-4069-4bcd-b709-8ffb95d85f4c",
        "type": "message",
        "text": "Programming a Problem-Oriented Language (1970) [pdf] - <http://www.forth.org/POL.pdf|http://www.forth.org/POL.pdf>",
        "user": "UPVBV34EL",
        "ts": "1665629494.534679",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "czbOz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Programming a Problem-Oriented Language (1970) [pdf] - "
                            },
                            {
                                "type": "link",
                                "url": "http://www.forth.org/POL.pdf",
                                "text": "http://www.forth.org/POL.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9cef13d4-ca0f-4fd6-afb7-c034708e390f",
        "type": "message",
        "text": "tylr, a tiny tile-based structure editor\n\nAbstract: Structure editors designed for keyboard input often struggle to resolve the tension between maintaining hierarchical term structure and offering efficient linear editing affordances. Contemporary designs either compromise structure by deferring to text near the leaves or else maintain structure by permitting only edits that transform the selected term.\n\nHowever, visually adjacent sequences (e.g. of operators, operands, and individual delimiters) do not always cleave cleanly to term boundaries, so even experienced users report difficulties with selection and code restructuring tasks. We propose a novel approach to structure editing, tile-based editing, that maintains term structure while offering linear selection and modification affordances.\n\nThe idea is to allow disassembly of terms into linearly sequenced tiles and shards around user selections, while guiding the user through restructuring actions and automatically inserting holes in a manner that ensures reassembly into a term. This paper introduces tylr, a tiny tile-based editor designed primarily to highlight this uniquely flexible set of affordances.\n\nWe evaluated tylr with a lab study where participants performed simple code transcription and modification tasks using tylr as well as a text editor and a structure editor built on JetBrains MPS, a state-of-the-art keyboard-driven structure editor generator.\n\nOur results indicate that participants frequently made use of tylr's selection expressivity, and that this flexibility helped them complete some modification tasks significantly more quickly than with the MPS editor.\n\nWe further observed that a few participants completed some tasks more quickly using tylr than with text, but were in general slowed by a number of limitations in our current design and implementation. We discuss these limitations and suggest future research and design directions aiming toward more flexible structure editing interfaces.\n\n<https://www.youtube.com/watch?v=rlUC8glDACE>",
        "user": "UBN9AFS0N",
        "ts": "1665652216.887019",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1665652334.000000"
        },
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=rlUC8glDACE",
                "thumb_url": "https://i.ytimg.com/vi/rlUC8glDACE/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/rlUC8glDACE?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen title=\"[TyDe&#39;22]  tylr, a tiny tile-based structure editor\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=rlUC8glDACE",
                "fallback": "YouTube Video: [TyDe'22]  tylr, a tiny tile-based structure editor",
                "title": "[TyDe'22]  tylr, a tiny tile-based structure editor",
                "title_link": "https://www.youtube.com/watch?v=rlUC8glDACE",
                "author_name": "ACM SIGPLAN",
                "author_link": "https://www.youtube.com/channel/UCwG9512Wm7jSS6Iqshz4Dpg",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GQn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "tylr, a tiny tile-based structure editor\n\nAbstract: Structure editors designed for keyboard input often struggle to resolve the tension between maintaining hierarchical term structure and offering efficient linear editing affordances. Contemporary designs either compromise structure by deferring to text near the leaves or else maintain structure by permitting only edits that transform the selected term.\n\nHowever, visually adjacent sequences (e.g. of operators, operands, and individual delimiters) do not always cleave cleanly to term boundaries, so even experienced users report difficulties with selection and code restructuring tasks. We propose a novel approach to structure editing, tile-based editing, that maintains term structure while offering linear selection and modification affordances.\n\nThe idea is to allow disassembly of terms into linearly sequenced tiles and shards around user selections, while guiding the user through restructuring actions and automatically inserting holes in a manner that ensures reassembly into a term. This paper introduces tylr, a tiny tile-based editor designed primarily to highlight this uniquely flexible set of affordances.\n\nWe evaluated tylr with a lab study where participants performed simple code transcription and modification tasks using tylr as well as a text editor and a structure editor built on JetBrains MPS, a state-of-the-art keyboard-driven structure editor generator.\n\nOur results indicate that participants frequently made use of tylr's selection expressivity, and that this flexibility helped them complete some modification tasks significantly more quickly than with the MPS editor.\n\nWe further observed that a few participants completed some tasks more quickly using tylr than with text, but were in general slowed by a number of limitations in our current design and implementation. We discuss these limitations and suggest future research and design directions aiming toward more flexible structure editing interfaces.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=rlUC8glDACE"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "reply_count": 10,
        "reply_users_count": 3,
        "latest_reply": "1665756420.703409",
        "reply_users": [
            "U0296ACR13M",
            "U02U0AS3J49",
            "UBN9AFS0N"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1665756420.703409",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UPVBV34EL",
                    "U023V63MF6V"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F",
                    "U0296ACR13M"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "6000e010-9589-4506-91bf-70b4361c916c",
        "type": "message",
        "text": "Super interesting! Been following the progress of Tylr and this couldn't be more timely as I've been working on very much the same challenge of assembling term structures from linear parts and disassembling them back for editing. Was there someone from the Tylr team in here?\n\nAshamed to say that I've done almost no hands on or under the hood research of the existing structure editors before starting to write my own, but I would imagine that, unless the child kinds of all terms are known (or the user selects the kind themselves), basically all of the editors have to do assembling from linear parts to some extent and the innovation in Tylr is being able to disassemble as well?\n\nAs for the demo, shouldn't it be possible for a structure editor to just allow pushing the argument(s) to their next possible position up/down the term tree without disassembling. Just need to know the linear order of the leaves? I feel like my editor should be able to and I wonder if I'm not seeing something.. Of course there's the question of how to expose it to the user..\n\nAnother thing that I've been thinking regards this is whether disassembling the whole expression/body is prefereable in all cases or would you still want keep parts of it as terms and therefore be able to render term specific UI in between the linear parts. Like, what if there's a multi dimensional array in your expression that is always rendered with a specific UI and can't reasonably be disassembled to linear parts..\n\nLastly, I wonder how much of the cases where it feels that disassembling is beneficial are due to the pro-code like syntax and because the editing patterns that people are used to. Btw, did the users in Tylr's study have programming experience? What if the braces wouldn't exist (or were just decorators) and user would just select the two arguments and press/click right twice to move them to be the last arguments of the first function?",
        "user": "U0296ACR13M",
        "ts": "1665660929.082319",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q4het",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Super interesting! Been following the progress of Tylr and this couldn't be more timely as I've been working on very much the same challenge of assembling term structures from linear parts and disassembling them back for editing. Was there someone from the Tylr team in here?\n\nAshamed to say that I've done almost no hands on or under the hood research of the existing structure editors before starting to write my own, but I would imagine that, unless the child kinds of all terms are known (or the user selects the kind themselves), basically all of the editors have to do assembling from linear parts to some extent and the innovation in Tylr is being able to disassemble as well?\n\nAs for the demo, shouldn't it be possible for a structure editor to just allow pushing the argument(s) to their next possible position up/down the term tree without disassembling. Just need to know the linear order of the leaves? I feel like my editor should be able to and I wonder if I'm not seeing something.. Of course there's the question of how to expose it to the user..\n\nAnother thing that I've been thinking regards this is whether disassembling the whole expression/body is prefereable in all cases or would you still want keep parts of it as terms and therefore be able to render term specific UI in between the linear parts. Like, what if there's a multi dimensional array in your expression that is always rendered with a specific UI and can't reasonably be disassembled to linear parts..\n\nLastly, I wonder how much of the cases where it feels that disassembling is beneficial are due to the pro-code like syntax and because the editing patterns that people are used to. Btw, did the users in Tylr's study have programming experience? What if the braces wouldn't exist (or were just decorators) and user would just select the two arguments and press/click right twice to move them to be the last arguments of the first function?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6b2651d6-8770-4dc1-b565-f6f01fa32279",
        "type": "message",
        "text": "Is the criticism demonstrated in MPS also valid for block-based editors? The same task, in a block-based editor, would just be drag and drop twice, which seems exactly what the person wants to do. You would need something more like a statement stack than an array block to be able to do function calls with an arbitrary number of arguments, easily.  And that list-of-arbitrary-length hasn't been implemented in Blockly, yet, AFAIK. But it seems feasible. In which case the task you describe would amount to dragging and dropping the two terms where you want them.",
        "user": "U02U0AS3J49",
        "ts": "1665679929.096889",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3B3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is the criticism demonstrated in MPS also valid for block-based editors? The same task, in a block-based editor, would just be drag and drop twice, which seems exactly what the person wants to do. You would need something more like a statement stack than an array block to be able to do function calls with an arbitrary number of arguments, easily.  And that list-of-arbitrary-length hasn't been implemented in Blockly, yet, AFAIK. But it seems feasible. In which case the task you describe would amount to dragging and dropping the two terms where you want them."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "8f09f748-0fdc-4644-be3c-53524b138249",
        "type": "message",
        "text": "I know there are criticisms of drag and drop as an interface on other grounds, but it feels like TYLR only really solves the problem of letting people who want to use linear text continue to select text the way they are used to, while maintaining a structure-aware interface. Which isn't a problem in things like Scratch. Is that fair? Or am I missing some other way the same problem arises in block-based editors?",
        "user": "U02U0AS3J49",
        "ts": "1665680734.772979",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9Z78",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know there are criticisms of drag and drop as an interface on other grounds, but it feels like TYLR only really solves the problem of letting people who want to use linear text continue to select text the way they are used to, while maintaining a structure-aware interface. Which isn't a problem in things like Scratch. Is that fair? Or am I missing some other way the same problem arises in block-based editors?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "fa4a5fa4-2ecc-4ee3-b9be-f54e5943aedc",
        "type": "message",
        "text": "the target audience of tylr is not going to use block-based editors",
        "user": "UBN9AFS0N",
        "ts": "1665687078.491779",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f6lf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the target audience of tylr is not going to use block-based editors"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "86e25503-af8a-48ef-86ce-0c9efffb4391",
        "type": "message",
        "text": "Arguably, \"tiles\" are trying to be a text interface and a block interface at the same time, so I'm not sure that is strictly true. It just seems to let you choose an arbitrary string of text, turn that into a block, and then let you insert it only the places that block will fit.",
        "user": "U02U0AS3J49",
        "ts": "1665687778.420699",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R=tx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Arguably, \"tiles\" are trying to be a text interface and a block interface at the same time, so I'm not sure that is strictly true. It just seems to let you choose an arbitrary string of text, turn that into a block, and then let you insert it only the places that block will fit."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "e9c6017c-1633-4f2f-99f1-9d87ac35aa43",
        "type": "message",
        "text": "Perhaps the example is bad, and the better example in the context of block-based editors is that there is no ability to select an arbitrary sub-portion of the serialized representation of a term. Like in TYLR you can select and cut and paste `*4` omitting the first operand, but in a block based editor you cannot, you can only drag `_*4`. I'm just not sure that is a valid criticism of block-based editors, either, because it presumes that being able to deal with the serialization directly is good, and block based editors reject that assertion. But I'm also not sure it isn't, because maybe people who use structural editors would like to be able to wrap `*4` around any term that could serve as the first operand. Maybe the criticism is that block based editors allow you to insert something inside a term, before a term, after a term, but do not allow you to wrap one, and this does?",
        "user": "U02U0AS3J49",
        "ts": "1665689042.779119",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DS2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps the example is bad, and the better example in the context of block-based editors is that there is no ability to select an arbitrary sub-portion of the serialized representation of a term. Like in TYLR you can select and cut and paste "
                            },
                            {
                                "type": "text",
                                "text": "*4",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " omitting the first operand, but in a block based editor you cannot, you can only drag "
                            },
                            {
                                "type": "text",
                                "text": "_*4",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I'm just not sure that is a valid criticism of block-based editors, either, because it presumes that being able to deal with the serialization directly is good, and block based editors reject that assertion. But I'm also not sure it isn't, because maybe people who use structural editors would like to be able to wrap "
                            },
                            {
                                "type": "text",
                                "text": "*4",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " around any term that could serve as the first operand. Maybe the criticism is that block based editors allow you to insert something inside a term, before a term, after a term, but do not allow you to wrap one, and this does?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "3b90c089-6365-4d35-bf98-9925a836b434",
        "type": "message",
        "text": "If that's the criticism, it's valid, I suppose.",
        "user": "U02U0AS3J49",
        "ts": "1665689314.862219",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "856",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If that's the criticism, it's valid, I suppose."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "3538ab75-352f-43f2-a1f9-bfa062f8c936",
        "type": "message",
        "text": "<@U02U0AS3J49> that's actually a much more convincing case for being able to disassemble terms! I felt that there is value in what Tylr is demoing, but that their example is not the most convincing one. Now the question is, how often do you actually need to move root and one child, leaving the other behind..",
        "user": "U0296ACR13M",
        "ts": "1665723170.638499",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vYMhw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02U0AS3J49"
                            },
                            {
                                "type": "text",
                                "text": " that's actually a much more convincing case for being able to disassemble terms! I felt that there is value in what Tylr is demoing, but that their example is not the most convincing one. Now the question is, how often do you actually need to move root and one child, leaving the other behind.."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "10cc4384-bb44-49a8-a485-d7d90d7a115b",
        "type": "message",
        "text": "Of course, it could be that being able to disassemble improves interactions a bit here and there, although there's no killer case for it.",
        "user": "U0296ACR13M",
        "ts": "1665723313.695129",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZtvB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Of course, it could be that being able to disassemble improves interactions a bit here and there, although there's no killer case for it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6bd656ae-f9ef-4327-8253-0d5bc147b771",
        "type": "message",
        "text": "Yes. More than that, I'm not sure you couldn't make a block-based editor work that way. If CTRL+drag allowed you to place a term outside another term instead of inside it, changing what qualifies as a place you can drop it, you could drop *4 on top of whatever you like. You could even have three modes, one for matching external only (the default now), one for matching internal only, and one for matching both. But again... who needs it? Anyone? I don't know.",
        "user": "U02U0AS3J49",
        "ts": "1665756420.703409",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6z0zT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes. More than that, I'm not sure you couldn't make a block-based editor work that way. If CTRL+drag allowed you to place a term outside another term instead of inside it, changing what qualifies as a place you can drop it, you could drop *4 on top of whatever you like. You could even have three modes, one for matching external only (the default now), one for matching internal only, and one for matching both. But again... who needs it? Anyone? I don't know."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1665652216.887019",
        "parent_user_id": "UBN9AFS0N"
    }
]