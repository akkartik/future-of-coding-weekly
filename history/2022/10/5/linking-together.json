[
    {
        "client_msg_id": "ad3665b3-af54-4250-912d-c5a5fa50c97a",
        "type": "message",
        "text": "I really appreciated the <https://futureofcoding.org/episodes/058|latest FoC ep> about \"The Structure of a Programming Language Revolution\". I'm in The Academy, and I'm perpetually fascinated by what's happened to academic PL. This essay provided some missing links. Thanks <@UC2A2ARPT> &amp; <@UK3LH8CF5>!\n\nOne fun aha I had afterwards: The systems vs. languages distinction helps clear up something I've always wondered about prototypal object-oriented programming. Namely, why use prototypes at all? Rather than writing:\n```// Version A\n\nfunction Dog () { }\n\nDog.prototype = {\n  bark: function () { ... },\n  fetch: function () { ... },\n}```\nyou could just write:\n```// Version B\n\nfunction bark () { ... }\nfunction fetch () { ... }\n\nfunction Dog () {\n  this.bark = bark;\n  this.fetch = fetch;\n}```\nSure, maybe that's a hair less ergonomic. There's a (extremely tiny bit) more memory used to store the slots. But that hardly seems worth inventing a whole new language feature and making such a big deal about it.\n\nI think part of the answer is that prototypal inheritance was born in Self, a programming _system_. If you want to modify a \"prototype\" in a programming _language_, the two approaches above are equivalent. You modify the (literal) prototype in version A, or you modify the constructor in version B, and then you re-run your code. But if you want to modify a \"prototype\" in a programming _system_, you'll discover you already have a bunch of instances of the class running around. Version B doesn't work, because it only changes how new instances are constructed, not how existing instances behave. A live connection between the instance and its prototype is required to enable live development in a living system.\n\nI feel like Dan Brown over here, finding secret traces of the past in the present.\n\n(Ominous hole in my theory: This doesn't explain why prototypes were brought into Javascript, where they ostensibly no longer had much use.)",
        "user": "UBKNXPBAB",
        "ts": "1664945940.180779",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "If2X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I really appreciated the "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.org/episodes/058",
                                "text": "latest FoC ep"
                            },
                            {
                                "type": "text",
                                "text": " about \"The Structure of a Programming Language Revolution\". I'm in The Academy, and I'm perpetually fascinated by what's happened to academic PL. This essay provided some missing links. Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " & "
                            },
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": "!\n\nOne fun aha I had afterwards: The systems vs. languages distinction helps clear up something I've always wondered about prototypal object-oriented programming. Namely, why use prototypes at all? Rather than writing:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "// Version A\n\nfunction Dog () { }\n\nDog.prototype = {\n  bark: function () { ... },\n  fetch: function () { ... },\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you could just write:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "// Version B\n\nfunction bark () { ... }\nfunction fetch () { ... }\n\nfunction Dog () {\n  this.bark = bark;\n  this.fetch = fetch;\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure, maybe that's a hair less ergonomic. There's a (extremely tiny bit) more memory used to store the slots. But that hardly seems worth inventing a whole new language feature and making such a big deal about it.\n\nI think part of the answer is that prototypal inheritance was born in Self, a programming "
                            },
                            {
                                "type": "text",
                                "text": "system",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". If you want to modify a \"prototype\" in a programming "
                            },
                            {
                                "type": "text",
                                "text": "language",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the two approaches above are equivalent. You modify the (literal) prototype in version A, or you modify the constructor in version B, and then you re-run your code. But if you want to modify a \"prototype\" in a programming "
                            },
                            {
                                "type": "text",
                                "text": "system",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", you'll discover you already have a bunch of instances of the class running around. Version B doesn't work, because it only changes how new instances are constructed, not how existing instances behave. A live connection between the instance and its prototype is required to enable live development in a living system.\n\nI feel like Dan Brown over here, finding secret traces of the past in the present.\n\n(Ominous hole in my theory: This doesn't explain why prototypes were brought into Javascript, where they ostensibly no longer had much use.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664945940.180779",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1665274641.131949",
        "reply_users": [
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "U02U0AS3J49",
                    "UFPRPSA4S"
                ],
                "count": 3
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "9bfc0009-c8f3-401b-8d34-690953f1c035",
        "type": "message",
        "text": "An Incremental Approach to Compiler Construction by Abdulaziz Ghuloum - <http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf>",
        "user": "UPVBV34EL",
        "ts": "1664973127.253869",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7xJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An Incremental Approach to Compiler Construction by Abdulaziz Ghuloum - "
                            },
                            {
                                "type": "link",
                                "url": "http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UML4ZEKDK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "56ed433c-9fa1-4738-9505-564cec457fb9",
        "type": "message",
        "text": "\"Programmable Ink\" by Szymon Kaliski (Strange Loop 2022)\n\nSketching with pen &amp; paper is a powerful way to think through ideas, but ink on paper is static. Dynamic behavior, on the other hand, requires programming -- which lacks the immediacy of the canvas: it's indirect, abstract, symbolic, and full of bureaucracy. What if we could harness the power of modern tablet computers to combine the intimacy of ink with the power of computation?\n\nNote: <@UC2A2ARPT> <@UF6RLAL7J> and <@UAJ9DV971> were involved in this project and a new iteration has started with <@U01DWJSAF2B>\n\n<https://www.youtube.com/watch?v=ifYuvgXZ108>",
        "user": "UBN9AFS0N",
        "ts": "1664978203.366459",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1664978291.000000"
        },
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=ifYuvgXZ108",
                "thumb_url": "https://i.ytimg.com/vi/ifYuvgXZ108/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/ifYuvgXZ108?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen title=\"&quot;Programmable Ink&quot; by Szymon Kaliski (Strange Loop 2022)\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=ifYuvgXZ108",
                "fallback": "YouTube Video: \"Programmable Ink\" by Szymon Kaliski (Strange Loop 2022)",
                "title": "\"Programmable Ink\" by Szymon Kaliski (Strange Loop 2022)",
                "title_link": "https://www.youtube.com/watch?v=ifYuvgXZ108",
                "author_name": "Strange Loop Conference",
                "author_link": "https://www.youtube.com/c/StrangeLoopConf",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hXMz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Programmable Ink\" by Szymon Kaliski (Strange Loop 2022)\n\nSketching with pen & paper is a powerful way to think through ideas, but ink on paper is static. Dynamic behavior, on the other hand, requires programming -- which lacks the immediacy of the canvas: it's indirect, abstract, symbolic, and full of bureaucracy. What if we could harness the power of modern tablet computers to combine the intimacy of ink with the power of computation?\n\nNote: "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UF6RLAL7J"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "user",
                                "user_id": "UAJ9DV971"
                            },
                            {
                                "type": "text",
                                "text": " were involved in this project and a new iteration has started with "
                            },
                            {
                                "type": "user",
                                "user_id": "U01DWJSAF2B"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=ifYuvgXZ108"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "reply_count": 14,
        "reply_users_count": 5,
        "latest_reply": "1665072079.775719",
        "reply_users": [
            "UF6RLAL7J",
            "UC2A2ARPT",
            "U02U0AS3J49",
            "UJBAJNFLK",
            "U02LHNW0VLP"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1665072079.775719",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F",
                    "U03GBV8B58V",
                    "UML4ZEKDK",
                    "U040R67M66L",
                    "U02E4DAQGSZ",
                    "U0123H7JRDM",
                    "U013ZLJARC7",
                    "UMV4B97GT",
                    "UP00ZLX6G",
                    "UAJ9DV971"
                ],
                "count": 10
            },
            {
                "name": "wave",
                "users": [
                    "UF6RLAL7J"
                ],
                "count": 1
            },
            {
                "name": "clap",
                "users": [
                    "U040R67M66L"
                ],
                "count": 1
            },
            {
                "name": "exploding_head",
                "users": [
                    "U02U0AS3J49",
                    "U013HU44GLS"
                ],
                "count": 2
            },
            {
                "name": "star-struck",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            },
            {
                "name": "+1::skin-tone-5",
                "users": [
                    "UBSMEUXAA"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7974d4a2-ca81-4686-906f-56775e42818f",
        "type": "message",
        "text": "<@UBKNXPBAB> was also involved, and a ton of other people who are not (afaik) in this Slack; thanks everyone! :slightly_smiling_face:",
        "user": "UF6RLAL7J",
        "ts": "1664981193.830839",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WfmQc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBKNXPBAB"
                            },
                            {
                                "type": "text",
                                "text": " was also involved, and a ton of other people who are not (afaik) in this Slack; thanks everyone! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "2dd3bfc5-9b89-491b-bc8b-803ce9b778c6",
        "type": "message",
        "text": "Congrats <@UF6RLAL7J>! I'm excited to watch this when I get home.",
        "user": "UC2A2ARPT",
        "ts": "1664983003.623679",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RFcMi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Congrats "
                            },
                            {
                                "type": "user",
                                "user_id": "UF6RLAL7J"
                            },
                            {
                                "type": "text",
                                "text": "! I'm excited to watch this when I get home."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "the_horns",
                "users": [
                    "UF6RLAL7J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4d429bf4-85af-4ce2-9e16-8a21adaf0cc0",
        "type": "message",
        "text": "Holy shit that is cool, and I'm only at the InkBase part. :slightly_smiling_face:",
        "user": "U02U0AS3J49",
        "ts": "1664993889.799749",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JzgS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Holy shit that is cool, and I'm only at the InkBase part. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "67fcca74-a460-42ea-9ef8-5d1df61c9722",
        "type": "message",
        "text": "Yeah, untangle overlaps considerably with the constrained, multiple-world tools I'm using, but with a much more human visual interface. What tool are you using under the hood to do the model finding and indicate if the constraints hold?",
        "user": "U02U0AS3J49",
        "ts": "1664995850.184189",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qKPNT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, untangle overlaps considerably with the constrained, multiple-world tools I'm using, but with a much more human visual interface. What tool are you using under the hood to do the model finding and indicate if the constraints hold?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "68455e6e-6639-4284-8539-971342ed7052",
        "type": "message",
        "text": "I *love* that if they don't hold, it tells you which don't, instead of telling you nothing.",
        "user": "U02U0AS3J49",
        "ts": "1664996241.547839",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VxIpB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I "
                            },
                            {
                                "type": "text",
                                "text": "love ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "that if they don't hold, it tells you which don't, instead of telling you nothing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U040R67M66L"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "12deb79d-639f-46e8-ade8-9486f3884180",
        "type": "message",
        "text": "Wow. That's how I want to work with a computer!",
        "user": "UJBAJNFLK",
        "ts": "1665034158.437539",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hws",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wow. That's how I want to work with a computer!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UF6RLAL7J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9fd84ff5-dc7a-467b-8ce4-7ab3a2ce90d1",
        "type": "message",
        "text": "Wondering.. the presentation of those three tools suggests that some common underlying technology is a commodity not worth discussing any more: the recognition of hand-drawn objects and their subsequent manipulation by code. Is that true? Are there well-understood algorithms for this? Maybe even ready-made implementations?",
        "user": "UJBAJNFLK",
        "ts": "1665034307.793319",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1hp5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wondering.. the presentation of those three tools suggests that some common underlying technology is a commodity not worth discussing any more: the recognition of hand-drawn objects and their subsequent manipulation by code. Is that true? Are there well-understood algorithms for this? Maybe even ready-made implementations?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "22f93732-b1eb-4509-a89e-6a18556d39bf",
        "type": "message",
        "text": "&gt; What tool are you using under the hood to do the model finding and indicate if the constraints hold?\nthis is built using a very small part of z3; if we hit `unsat` we permute the set of constraints progressively removing more and more of them until we hit some results -- is that what you were asking?\n\n&gt;  the presentation of those three tools suggests that some common underlying technology is a commodity not worth discussing any more: the recognition of hand-drawn objects and their subsequent manipulation by code. Is that true? Are there well-understood algorithms for this? Maybe even ready-made implementations?\nto the contrary; there's pretty much no \"recognition\" happening in any of the demos (the very small exception is the delta symbol and star symbol recognition in the \"sketchy charts\" part) -- everything else happens by spatial relations from known objects -- this is definitely a big technical challenge, especially since \"AI\" doesn't vibe well with what we're after (it's an unpredictable black-box)",
        "user": "UF6RLAL7J",
        "ts": "1665034997.007549",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fBl3",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What tool are you using under the hood to do the model finding and indicate if the constraints hold?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is built using a very small part of z3; if we hit "
                            },
                            {
                                "type": "text",
                                "text": "unsat",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " we permute the set of constraints progressively removing more and more of them until we hit some results -- is that what you were asking?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " the presentation of those three tools suggests that some common underlying technology is a commodity not worth discussing any more: the recognition of hand-drawn objects and their subsequent manipulation by code. Is that true? Are there well-understood algorithms for this? Maybe even ready-made implementations?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "to the contrary; there's pretty much no \"recognition\" happening in any of the demos (the very small exception is the delta symbol and star symbol recognition in the \"sketchy charts\" part) -- everything else happens by spatial relations from known objects -- this is definitely a big technical challenge, especially since \"AI\" doesn't vibe well with what we're after (it's an unpredictable black-box)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6f2b3da6-f7a6-4b03-a81c-37a045588547",
        "type": "message",
        "text": "I was thinking of recognition at a lower level of abstraction. Such as recognizing a box or a tick mark as an object distinct from the other pen strokes on the page, and then moving it around.",
        "user": "UJBAJNFLK",
        "ts": "1665037073.547749",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1665037254.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KFBq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was thinking of recognition at a lower level of abstraction. Such as recognizing a box or a tick mark as an object distinct from the other pen strokes on the page, and then moving it around."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6c188abb-0df3-4891-b5df-f715eebe2adf",
        "type": "message",
        "text": "Unrelated thought: these tools explore two roughly orthogonal aspects of computing: visual vs. symbolic, and formal/rigid vs. informal/fuzzy. I love the expression \"tyranny of formalisms\". I'll use it next time I talk to a static type system missionary :wink:",
        "user": "UJBAJNFLK",
        "ts": "1665037212.524769",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GCT3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unrelated thought: these tools explore two roughly orthogonal aspects of computing: visual vs. symbolic, and formal/rigid vs. informal/fuzzy. I love the expression \"tyranny of formalisms\". I'll use it next time I talk to a static type system missionary "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UF6RLAL7J"
                ],
                "count": 1
            },
            {
                "name": "joy",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7111192e-9160-494f-b8ae-142c86a3b3b6",
        "type": "message",
        "text": "&gt; Such as recognizing a box or a tick mark as an object distinct from the other pen strokes on the page, and then moving it around. \nyes, this is what I was trying to answer; we don't do that, and I don't think this is really possible to be 100% perfect -- for example a box can be drawn in 1,2,3,4 strokes (or more if you're sloppy), and then it's easy to make one that's slightly rotated, or skewed, or.... - I don't believe there's a heuristic that can cover all of that, and work out all the time -&gt; so one direction from here is to do the best we can and accept that there can be errors/miscategorizations (which I think is not great -- because then you have to adjust how you draw things to make the computer understand you, and you're one step closer to just filling forms again), and another direction (that I'm more interested in) is to figure out different systemic approach to the problem so 'recognition' is not needed",
        "user": "UF6RLAL7J",
        "ts": "1665038728.664769",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UF6RLAL7J",
            "ts": "1665038847.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XCug",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Such as recognizing a box or a tick mark as an object distinct from the other pen strokes on the page, and then moving it around. "
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yes, this is what I was trying to answer; we don't do that, and I don't think this is really possible to be 100% perfect -- for example a box can be drawn in 1,2,3,4 strokes (or more if you're sloppy), and then it's easy to make one that's slightly rotated, or skewed, or.... - I don't believe there's a heuristic that can cover all of that, and work out all the time -> so one direction from here is to do the best we can and accept that there can be errors/miscategorizations (which I think is not great -- because then you have to adjust how you draw things to make the computer understand you, and you're one step closer to just filling forms again), and another direction (that I'm more interested in) is to figure out different systemic approach to the problem so 'recognition' is not needed"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "3d551b28-faec-451e-b670-8992db23ebd0",
        "type": "message",
        "text": "Notes on this talk in my digital garden (on computer-aided research): <https://science-in-the-digital-era.khinsen.net/#Programmable%20ink>",
        "user": "UJBAJNFLK",
        "ts": "1665038755.339959",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZqG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Notes on this talk in my digital garden (on computer-aided research): "
                            },
                            {
                                "type": "link",
                                "url": "https://science-in-the-digital-era.khinsen.net/#Programmable%20ink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "A889AB5A-91F9-44BD-8BFA-C42B5624D5E7",
        "type": "message",
        "text": "Awesome <@UF6RLAL7J> ",
        "user": "U02LHNW0VLP",
        "ts": "1665071707.897019",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0i+aj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Awesome "
                            },
                            {
                                "type": "user",
                                "user_id": "UF6RLAL7J"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "6df0e9c3-eef2-453b-b7ec-2cff4a45fc88",
        "type": "message",
        "text": "Yeah, z3, plus permutations on constraints was the answer I was looking for, thanks!",
        "user": "U02U0AS3J49",
        "ts": "1665072079.775719",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ct/H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, z3, plus permutations on constraints was the answer I was looking for, thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1664978203.366459",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "df92e840-9e1d-4bf5-a018-709b1bb84dec",
        "type": "message",
        "text": "Allow me to try to add some more context...\n\n\n[tl;dr]\n\u2022 Inheritance is about data structuring.  The only difference between Prototype-based Inheritance and Class-based Inheritance consists of RULES about WHEN it is legal to structure and re-structure data.\n\u2022 \u2018Self\u2019 corralled prototypal inheritance.  \u2018Smalltalk\u2019 corralled class-based inheritance.  Both, borrowed from previous ideas.\n\u2022 All big inventions in programming stem from the use of dynamic languages.\n\u2022 Class-based inheritance is Waterfall Design. Protoype-based inheritance allows iterative design.\n\u2022 JavaScript was based on Lisp.  JavaScript designs-in prototype-based inheritance better than Common Lisp, Scheme, Clojure, Racket, etc., etc.\n[background]\n\nIn the beginning there was assembler.\n\nThere are 2 types of assembler\n1. line-oriented\n2. tree-oriented\nAssembler is characterized by\n\u2022 ultra-simple syntax (usually prefix notation)\n\u2022 commands with operands.\nLine-oriented assembler is what we call \u201cassembler\u201d.\n\nTree-oriented assembler is what we call \u201clisp\u201d.\n\nAssembler gives you a toolbox of functionality, but, if you want to structure your data you have to do it manually.\n\nIn assembler, nothing stops you from re-structuring your data on the fly.\n\nThe result, though, can be hard to understand.  This is part of what we call \u201creadability\u201d.  The term \u201creadability\u201d is usually used to mean human readability (aside: but, there\u2019s also machine readability ; note that textual \u201creadability\u201d does not mean the use of general English prose, but, only a well-defined, restricted subset of English)\n\nOne of the tennets of Computer Science is Don\u2019t Repeat Yourself (DRY).\n\nInheritance is simply a way of structuring data in a DRY way.  If you\u2019ve structured your data, don\u2019t do it again, copy the template.\n\nSo-called \u201cprototypal inheritance\u201d is a way of structuring data that can allow changes to the structure at runtime.\n\n\u201cClass-based inheritance\u201d is an optimization of prototypal inheritance.  In class-based inheritance, you separate your Red Smarties from the rest (a Smartie is an M&amp;M, a \u201cred Smartie\u201d tastes \u201cbetter\u201d).  If you apply the class-based optimization, then, you can compile-out data structuring.  The compiler can help make your resulting code tighter and more check-able, but, you are allowed to structure your data ONLY at compile-time.  And, the result is less-confusing.  Nothing should change at runtime.  Dynamic-anything is \u201cbad\u201d (aside: this is a fundamental problem with pub/sub).\n\nOptimization culls creativity, but, results in a notation that has certain \u201chuman readability\u201d properties.  Optimization is \u201cbad\u201d during Design (\u201cpremature optimization\u201d), but Optimization is \u201cgood\u201d during Production Engineering (what we mistakenly call \u201cprogramming\u201d).\n\nSelf and Smalltalk are syntaxes draped over assembler.  Self does not insist that you pre-define all data structures, Smalltalk does insist on pre-definition.  The tools for inheritance always existed, but Self coined the phrase \u201cprototype\u201d and Smalltalk coined the phrase \u201cclass\u201d (actually, Smalltalk borrowed the concept from a previous language, but we won\u2019t go there now).\n\nJavaScript was originally based on Lisp.  In trying to keep the flavour of a \u201cdynamic language\u201d, JS does not insist on pre-defining all data structures before runtime.  IMO, JS does this better than the Common Lisp, the Scheme, the Racket, the Clojure variants of Lisp.  In Common Lisp, the designers chose to jump directly to premature-optimization using classes and built that concept in as syntactic baubles (\u201cdefclass\u201d), that cause programmers to think in a Certain Way, even though the tools for less-calcified data structuring are still present (but, generally ignored by class-indoctrinated programmers).\n\nIdeas calcified by compile-time optimizations cause programmers to think in Certain Ways and disallow other interesting forms of Creativity.\n\nThere IS another way to optimize - as seen in JIT and 1970's compiler technologies (e.g. gcc, OCG) and linking loaders.  Optimize at runtime.  Treat optimizers as barnacles attacking only already-working programs.  Premature optimization has led us to building and using compiler-appeasement languages and has snipped off other creative avenues of thought.\n\nOr, we could more simply divide programming into 2 camps (aka \u201cdivide and conquer\u201d): (1) Design (2) Optimize.  This division happens all of the time in more mature industries - products are released, and, only later, the products are cost-optimized.  In fact, this division is so severe that it is given the name \u201cProduction Engineering\u201d.  In contrast, Software uses the single term \u201cEngineering\u201d to mean \u201cArchitecture\u201d and \u201cEngineering\u201d and \u201cProduction Engineering\u201d and \u201cTest Engineering\u201d and \u201cDeployment Engineering\u201d, and ...)\n\nIf you Design and Optimize all in one go, you are involved in a Cottage Industry. In a Cottage Industry, the same person, or a group, wears all of the hats.\n\nClass-based inheritance is Waterfall Design.  You must know everything about the data before you can write correct classes.  Prototype inheritance can be iterative, you can change your mind later, you can incrementally alter the templates as you learn more about the problem space.\n\nCompilers can be built to compile programs if the programs obey the rules of class-based inheritance.  Compilers cannot, in general, compile programs that do not follow the rules of class-based inheritance, e.g. compilers cannot compile prototype-based inheritance, but, can compile class-based inheritance.\n\n\n[conclusions]\n\nI would argue that Self did not invent prototypal inheritance, but corralled the ideas and created the name.  Self\u2019s contribution is the exploration of the space of data structuring and of making optimization be a continuum that can be applied at different times - not just at compile-time.  This exploration ultimately led to the concept of JIT.\n\nJavaScript was designed to allow \u201cdynamic\u201d programming (whether it succeeded, can be argued) and was originally based on Lisp.  Prototypal inheritance is less constraining than class-based inheritance, therefore, was made a part of the design of JavaScript.\n\nTo me \u201csystem\u201d means \u201cdynamic language\u201d.  And \u201cgeneral purpose programming language\u201d means \u201cstatic language\u201d.  Each kind is \u201cgood\u201d and each kind is \u201cbad\u201d.\n\nIMO, all big inventions in programming stem from the use of dynamic languages, and, ultimately from the use of assembler. GC, first-class-functions, Haskell, REPLs, etc., etc.\n\nThe only difference between class-based inheritance and prototype-based inheritance is *when* it happens.  Both, class-based and prototype-based inheritance can structure data at compile time.  In prototype inheritance, though, data can, also, be structured and re-structured at runtime.  Runtime restructuring is not allowed in class-based inheritance.\n\nClass-based inheritance is Waterfall Design.   Protoype inheritance allows iterative design.\n\n\nmiscellaneous:\n\n3 OO-ish data structuring techniques\n1. classes\n2. prototypes\n3. mixins\n2 is like 1, with some of the compile-time-only restrictions removed. The mixin idea, 3, looks like OOP, but is very different.  In class-oriented OOP, you have a vector of operations associated with each class.  In mixins, the reverse is true - you have a class without operations.  Operations \u201cdecide\u201d on-the-fly if they can be applied to a cross-product of parameters.  All three methods get rid of explicit \u201cif-then-else\u201d based on type (which is the really big win - \u201cif-then-else\u201d is just bad).  Mixins go beyond simple class-based inheritance - you can specialize operations on /value/ instead of type, you can create :before and :after methods. Capability depends on the method (\u201coperation\u201d) and not on the class. For a simple, nonsensical example, you can write a \u201cplus\u201d method that works on {int x int} and another \u201cplus\u201d method that works on {int x string} and another \u201cplus\u201d method that works only on {nil x int}\n\n\u2022 question to self: can you remove defclass from Lisp and leave only mixins?  lisp already has deftype, why do you need defclass?\n\u2022 lisp isn\u2019t a programming language, it\u2019s a soup\n\u2022 mixins \u2263 assembler for constructing various kinds of class / prototype / whatever-based languages.  I like to use the term \u201catoms\u201d when discussing fundamental building blocks.  In my view, \u201cmixins\u201d are \u201catoms\u201d whereas classes and prototypes are \u201cmolecules\u201d constructed out of \u201catoms\u201d. \n",
        "user": "UGWUJUZHT",
        "ts": "1665274641.131949",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v+Ds",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Allow me to try to add some more context...\n\n\n[tl;dr]\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Inheritance is about data structuring.  The only difference between Prototype-based Inheritance and Class-based Inheritance consists of RULES about WHEN it is legal to structure and re-structure data."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u2018Self\u2019 corralled prototypal inheritance.  \u2018Smalltalk\u2019 corralled class-based inheritance.  Both, borrowed from previous ideas."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "All big inventions in programming stem from the use of dynamic languages."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Class-based inheritance is Waterfall Design. Protoype-based inheritance allows iterative design."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "JavaScript was based on Lisp.  JavaScript designs-in prototype-based inheritance better than Common Lisp, Scheme, Clojure, Racket, etc., etc."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n[background]\n\nIn the beginning there was assembler.\n\nThere are 2 types of assembler\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "line-oriented"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "tree-oriented"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAssembler is characterized by\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "ultra-simple syntax (usually prefix notation)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "commands with operands."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nLine-oriented assembler is what we call \u201cassembler\u201d.\n\nTree-oriented assembler is what we call \u201clisp\u201d.\n\nAssembler gives you a toolbox of functionality, but, if you want to structure your data you have to do it manually.\n\nIn assembler, nothing stops you from re-structuring your data on the fly.\n\nThe result, though, can be hard to understand.  This is part of what we call \u201creadability\u201d.  The term \u201creadability\u201d is usually used to mean human readability (aside: but, there\u2019s also machine readability ; note that textual \u201creadability\u201d does not mean the use of general English prose, but, only a well-defined, restricted subset of English)\n\nOne of the tennets of Computer Science is Don\u2019t Repeat Yourself (DRY).\n\nInheritance is simply a way of structuring data in a DRY way.  If you\u2019ve structured your data, don\u2019t do it again, copy the template.\n\nSo-called \u201cprototypal inheritance\u201d is a way of structuring data that can allow changes to the structure at runtime.\n\n\u201cClass-based inheritance\u201d is an optimization of prototypal inheritance.  In class-based inheritance, you separate your Red Smarties from the rest (a Smartie is an M&M, a \u201cred Smartie\u201d tastes \u201cbetter\u201d).  If you apply the class-based optimization, then, you can compile-out data structuring.  The compiler can help make your resulting code tighter and more check-able, but, you are allowed to structure your data ONLY at compile-time.  And, the result is less-confusing.  Nothing should change at runtime.  Dynamic-anything is \u201cbad\u201d (aside: this is a fundamental problem with pub/sub).\n\nOptimization culls creativity, but, results in a notation that has certain \u201chuman readability\u201d properties.  Optimization is \u201cbad\u201d during Design (\u201cpremature optimization\u201d), but Optimization is \u201cgood\u201d during Production Engineering (what we mistakenly call \u201cprogramming\u201d).\n\nSelf and Smalltalk are syntaxes draped over assembler.  Self does not insist that you pre-define all data structures, Smalltalk does insist on pre-definition.  The tools for inheritance always existed, but Self coined the phrase \u201cprototype\u201d and Smalltalk coined the phrase \u201cclass\u201d (actually, Smalltalk borrowed the concept from a previous language, but we won\u2019t go there now).\n\nJavaScript was originally based on Lisp.  In trying to keep the flavour of a \u201cdynamic language\u201d, JS does not insist on pre-defining all data structures before runtime.  IMO, JS does this better than the Common Lisp, the Scheme, the Racket, the Clojure variants of Lisp.  In Common Lisp, the designers chose to jump directly to premature-optimization using classes and built that concept in as syntactic baubles (\u201cdefclass\u201d), that cause programmers to think in a Certain Way, even though the tools for less-calcified data structuring are still present (but, generally ignored by class-indoctrinated programmers).\n\nIdeas calcified by compile-time optimizations cause programmers to think in Certain Ways and disallow other interesting forms of Creativity.\n\nThere IS another way to optimize - as seen in JIT and 1970's compiler technologies (e.g. gcc, OCG) and linking loaders.  Optimize at runtime.  Treat optimizers as barnacles attacking only already-working programs.  Premature optimization has led us to building and using compiler-appeasement languages and has snipped off other creative avenues of thought.\n\nOr, we could more simply divide programming into 2 camps (aka \u201cdivide and conquer\u201d): (1) Design (2) Optimize.  This division happens all of the time in more mature industries - products are released, and, only later, the products are cost-optimized.  In fact, this division is so severe that it is given the name \u201cProduction Engineering\u201d.  In contrast, Software uses the single term \u201cEngineering\u201d to mean \u201cArchitecture\u201d and \u201cEngineering\u201d and \u201cProduction Engineering\u201d and \u201cTest Engineering\u201d and \u201cDeployment Engineering\u201d, and ...)\n\nIf you Design and Optimize all in one go, you are involved in a Cottage Industry. In a Cottage Industry, the same person, or a group, wears all of the hats.\n\nClass-based inheritance is Waterfall Design.  You must know everything about the data before you can write correct classes.  Prototype inheritance can be iterative, you can change your mind later, you can incrementally alter the templates as you learn more about the problem space.\n\nCompilers can be built to compile programs if the programs obey the rules of class-based inheritance.  Compilers cannot, in general, compile programs that do not follow the rules of class-based inheritance, e.g. compilers cannot compile prototype-based inheritance, but, can compile class-based inheritance.\n\n\n[conclusions]\n\nI would argue that Self did not invent prototypal inheritance, but corralled the ideas and created the name.  Self\u2019s contribution is the exploration of the space of data structuring and of making optimization be a continuum that can be applied at different times - not just at compile-time.  This exploration ultimately led to the concept of JIT.\n\nJavaScript was designed to allow \u201cdynamic\u201d programming (whether it succeeded, can be argued) and was originally based on Lisp.  Prototypal inheritance is less constraining than class-based inheritance, therefore, was made a part of the design of JavaScript.\n\nTo me \u201csystem\u201d means \u201cdynamic language\u201d.  And \u201cgeneral purpose programming language\u201d means \u201cstatic language\u201d.  Each kind is \u201cgood\u201d and each kind is \u201cbad\u201d.\n\nIMO, all big inventions in programming stem from the use of dynamic languages, and, ultimately from the use of assembler. GC, first-class-functions, Haskell, REPLs, etc., etc.\n\nThe only difference between class-based inheritance and prototype-based inheritance is "
                            },
                            {
                                "type": "text",
                                "text": "when",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " it happens.  Both, class-based and prototype-based inheritance can structure data at compile time.  In prototype inheritance, though, data can, also, be structured and re-structured at runtime.  Runtime restructuring is not allowed in class-based inheritance.\n\nClass-based inheritance is Waterfall Design.   Protoype inheritance allows iterative design.\n\n\nmiscellaneous:\n\n3 OO-ish data structuring techniques\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "classes"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "prototypes"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "mixins"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n2 is like 1, with some of the compile-time-only restrictions removed. The mixin idea, 3, looks like OOP, but is very different.  In class-oriented OOP, you have a vector of operations associated with each class.  In mixins, the reverse is true - you have a class without operations.  Operations \u201cdecide\u201d on-the-fly if they can be applied to a cross-product of parameters.  All three methods get rid of explicit \u201cif-then-else\u201d based on type (which is the really big win - \u201cif-then-else\u201d is just bad).  Mixins go beyond simple class-based inheritance - you can specialize operations on /value/ instead of type, you can create :before and :after methods. Capability depends on the method (\u201coperation\u201d) and not on the class. For a simple, nonsensical example, you can write a \u201cplus\u201d method that works on {int x int} and another \u201cplus\u201d method that works on {int x string} and another \u201cplus\u201d method that works only on {nil x int}\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "question to self: can you remove defclass from Lisp and leave only mixins?  lisp already has deftype, why do you need defclass?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "lisp isn\u2019t a programming language, it\u2019s a soup"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "mixins \u2263 assembler for constructing various kinds of class / prototype / whatever-based languages.  I like to use the term \u201catoms\u201d when discussing fundamental building blocks.  In my view, \u201cmixins\u201d are \u201catoms\u201d whereas classes and prototypes are \u201cmolecules\u201d constructed out of \u201catoms\u201d. "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ],
        "thread_ts": "1664945940.180779",
        "parent_user_id": "UBKNXPBAB"
    }
]