[
    {
        "client_msg_id": "5e40374f-ba72-4130-a449-611b736cc1cc",
        "type": "message",
        "text": "I\u2019d really love to know if anyone knows of literature on _generating examples_ in mathematically robust ways. It\u2019s hard to search for literature on this because of how Google interprets the query. I know there\u2019s work here in formal language theory, as it\u2019s usually straightforward to generate a sentence given a formal grammar. But I really want to know what work has been done in a more general context of mathematical structures.\n\nQuestions like \u201d what is the simplest example of structure X\u201d or \u201csmallest example that can be differentiated from the others\u201d or \u201csimplest counter-example\u201d. I know there\u2019s work on example-driven programming and the like, which I assume would have some relevance, but I\u2019ve had no luck finding much. I just have to assume that this is a question that some mathematicians somewhere have asked before.",
        "user": "U014WA16VNJ",
        "ts": "1645553705.079219",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U014WA16VNJ",
            "ts": "1645554039.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "26adx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019d really love to know if anyone knows of literature on "
                            },
                            {
                                "type": "text",
                                "text": "generating examples ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "in mathematically robust ways. It\u2019s hard to search for literature on this because of how Google interprets the query. I know there\u2019s work here in formal language theory, as it\u2019s usually straightforward to generate a sentence given a formal grammar. But I really want to know what work has been done in a more general context of mathematical structures.\n\nQuestions like \u201d what is the simplest example of structure X\u201d or \u201csmallest example that can be differentiated from the others\u201d or \u201csimplest counter-example\u201d. I know there\u2019s work on example-driven programming and the like, which I assume would have some relevance, but I\u2019ve had no luck finding much. I just have to assume that this is a question that some mathematicians somewhere have asked before."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "reply_count": 15,
        "reply_users_count": 8,
        "latest_reply": "1645778298.211919",
        "reply_users": [
            "U014WA16VNJ",
            "UQ706GB9U",
            "UGWUJUZHT",
            "U016VUZGUUQ",
            "U02U0AS3J49",
            "UKJGU23KP",
            "UJBAJNFLK",
            "UFEQUBNNT"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "d9ea077a-0298-4ad1-9849-be1a6a663ba5",
        "type": "message",
        "text": "Also, there was a talk I watched ages ago, don\u2019t remember the context, it demonstrated a system that automatically generated the smallest possible example of an input that would break a test. I think it was probably from the functional programming folks and may have been in the context of its type system. It was super neat. Does anyone know what I\u2019m talking about and where I might find it?",
        "user": "U014WA16VNJ",
        "ts": "1645553713.253719",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a7b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, there was a talk I watched ages ago, don\u2019t remember the context, it demonstrated a system that automatically generated the smallest possible example of an input that would break a test. I think it was probably from the functional programming folks and may have been in the context of its type system. It was super neat. Does anyone know what I\u2019m talking about and where I might find it?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U02028JHX37"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "baca5392-59a6-414c-acec-4fa2ca15c560",
        "type": "message",
        "text": "is this for testing? you might find a something with <https://en.wikipedia.org/wiki/QuickCheck|quickcheck> or its related research.",
        "user": "UQ706GB9U",
        "ts": "1645554089.612259",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZSZZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "is this for testing? you might find a something with "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/QuickCheck",
                                "text": "quickcheck"
                            },
                            {
                                "type": "text",
                                "text": " or its related research."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "29727c7f-b929-4862-a6ae-e5b70d1a9204",
        "type": "message",
        "text": "Not for testing, looking for theoretical work as the question is relevant to my current research. QuickCheck might be what I saw before! I\u2019ll check it out.",
        "user": "U014WA16VNJ",
        "ts": "1645554178.087529",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kYG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not for testing, looking for theoretical work as the question is relevant to my current research. QuickCheck might be what I saw before! I\u2019ll check it out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "08069590-1986-40c1-824b-d9cf106b6fb8",
        "type": "message",
        "text": "From the QuickCheck wiki:\n&gt; assertions are written about logical properties that a\u00a0<https://en.wikipedia.org/wiki/Subroutine|function>\u00a0should fulfill. Then QuickCheck attempts to generate a test case that\u00a0<https://en.wikipedia.org/wiki/Falsifiability|falsifies>\u00a0such assertions. Once such a test case is found, QuickCheck tries to reduce it to a minimal failing subset by removing or simplifying input data\ntotally in line with the stuff I\u2019m looking for, thanks!",
        "user": "U014WA16VNJ",
        "ts": "1645554273.552049",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5/Dxq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From the QuickCheck wiki:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "assertions are written about logical properties that a\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Subroutine",
                                "text": "function"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0should fulfill. Then QuickCheck attempts to generate a test case that\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Falsifiability",
                                "text": "falsifies"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0such assertions. Once such a test case is found, QuickCheck tries to reduce it to a minimal failing subset by removing or simplifying input data"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\ntotally in line with the stuff I\u2019m looking for, thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "e8883472-f041-44c5-bc02-22a04a3cdc11",
        "type": "message",
        "text": "This reminds me of Barliman <https://www.youtube.com/watch?v=er_lLvkklsk>",
        "user": "UGWUJUZHT",
        "ts": "1645554393.697999",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=er_lLvkklsk",
                "thumb_url": "https://i.ytimg.com/vi/er_lLvkklsk/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/er_lLvkklsk?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=er_lLvkklsk",
                "fallback": "YouTube Video: Barliman: trying the halting problem backwards, blindfolded - William Byrd, Greg Rosenblatt",
                "title": "Barliman: trying the halting problem backwards, blindfolded - William Byrd, Greg Rosenblatt",
                "title_link": "https://www.youtube.com/watch?v=er_lLvkklsk",
                "author_name": "ClojureTV",
                "author_link": "https://www.youtube.com/user/ClojureTV",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v7W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This reminds me of Barliman "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=er_lLvkklsk"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U014WA16VNJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "12b5f0b3-ec51-4c7e-90e3-cef7e0e41ebe",
        "type": "message",
        "text": "Besides Quickcheck, I thought of model-checking software like Z3 (very easy to play with in Python!), Alloy, MiniZinc, maybe even TLA+. I haven't used the latter three (which are not an exhaustive list either), but they seem to be very powerful.",
        "user": "U016VUZGUUQ",
        "ts": "1645558506.900199",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WoQI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Besides Quickcheck, I thought of model-checking software like Z3 (very easy to play with in Python!), Alloy, MiniZinc, maybe even TLA+. I haven't used the latter three (which are not an exhaustive list either), but they seem to be very powerful."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "fd0469a7-7030-42a4-aab3-ffc73109ea7a",
        "type": "message",
        "text": "I would add Lean4 to the counter-example-finding list.",
        "user": "U02U0AS3J49",
        "ts": "1645574891.724909",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qWnK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would add Lean4 to the counter-example-finding list."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "5C75B1A7-EF79-4B3E-875B-96D57E2325B7",
        "type": "message",
        "text": "This seems relevant: <https://hackage.haskell.org/package/smallcheck|https://hackage.haskell.org/package/smallcheck>",
        "user": "UKJGU23KP",
        "ts": "1645630152.475949",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://hackage.haskell.org/package/smallcheck",
                "service_icon": "https://hackage.haskell.org/static/favicon.png",
                "id": 1,
                "original_url": "https://hackage.haskell.org/package/smallcheck",
                "fallback": "Hackage: smallcheck",
                "text": "A property-based testing library",
                "title": "smallcheck",
                "title_link": "https://hackage.haskell.org/package/smallcheck",
                "service_name": "Hackage"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uXU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This seems relevant: "
                            },
                            {
                                "type": "link",
                                "url": "https://hackage.haskell.org/package/smallcheck",
                                "text": "https://hackage.haskell.org/package/smallcheck"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "022f7ded-221c-4208-8a0a-fb111946ca49",
        "type": "message",
        "text": "\"Property-based testing\" is the more general keyword to search for. QuickCheck is its best-known implementation, but theoretical work doesn't necessarily refer to it.",
        "user": "UJBAJNFLK",
        "ts": "1645634234.034139",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dRP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Property-based testing\" is the more general keyword to search for. QuickCheck is its best-known implementation, but theoretical work doesn't necessarily refer to it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U014WA16VNJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2711b938-3b63-42b8-b36a-fbca267dd011",
        "type": "message",
        "text": "Hopefully \u2018property-based testing\u2019 can help me find relevant research. It still seems slightly off what I\u2019m looking for, but it\u2019s closer. I\u2019m less interested in programming languages here, and hoping there\u2019s some more general mathematical work along these lines. I\u2019d love to have a framework to talk about things like \u201ca tree with a branching factor of 5\u201d, \u201ca partially ordered set\u201d, \u201ca directed graph containing a subgraph that is equivalent to a binary tree\u201d and to talk about these general kinds of structures and properties with some formal notion(s) of \u201cexamples\u201d.",
        "user": "U014WA16VNJ",
        "ts": "1645635870.066779",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RK2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hopefully \u2018property-based testing\u2019 can help me find relevant research. It still seems slightly off what I\u2019m looking for, but it\u2019s closer. I\u2019m less interested in programming languages here, and hoping there\u2019s some more general mathematical work along these lines. I\u2019d love to have a framework to talk about things like \u201ca tree with a branching factor of 5\u201d, \u201ca partially ordered set\u201d, \u201ca directed graph containing a subgraph that is equivalent to a binary tree\u201d and to talk about these general kinds of structures and properties with some formal notion(s) of \u201cexamples\u201d."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "59ab9953-084b-4b5c-ba7c-f9a93f39f885",
        "type": "message",
        "text": "It sounds to me like you want to use a model-checker too. If you give one a program and a condition, they're designed to give you example states the program can get into that satisfy the condition, but they're more general than that. If you input a model that describes graphs generally, and encode a condition that corresponds to \"branching factor of 5\" then a model-checker will give you an example of such a graph. Many examples, if you ask for them!",
        "user": "UFEQUBNNT",
        "ts": "1645687334.914769",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hX3/L",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It sounds to me like you want to use a model-checker too. If you give one a program and a condition, they're designed to give you example states the program can get into that satisfy the condition, but they're more general than that. If you input a model that describes graphs generally, and encode a condition that corresponds to \"branching factor of 5\" then a model-checker will give you an example of such a graph. Many examples, if you ask for them!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U014WA16VNJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2ffb3562-a86d-49f7-bc5f-3f06ff5faae6",
        "type": "message",
        "text": "Something else that might be useful is L-systems (<https://en.wikipedia.org/wiki/L-system>), used mainly for simulating plant growth.",
        "user": "UJBAJNFLK",
        "ts": "1645689690.499889",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hALHB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Something else that might be useful is L-systems ("
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/L-system"
                            },
                            {
                                "type": "text",
                                "text": "), used mainly for simulating plant growth."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "9cad9d73-fa43-4fa9-b61f-bdf0eb71eb83",
        "type": "message",
        "text": "BTW, I am currently exploring this space as well in the context of my digital scientific notation Leibniz. Its context definitions are meant to be minimal and thus small, so generating random terms from them could well turn out useful for understanding a scientific model.",
        "user": "UJBAJNFLK",
        "ts": "1645689810.737829",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1PrF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "BTW, I am currently exploring this space as well in the context of my digital scientific notation Leibniz. Its context definitions are meant to be minimal and thus small, so generating random terms from them could well turn out useful for understanding a scientific model."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "4bbb7f6d-ecf5-45d4-b813-5f23a85c7d96",
        "type": "message",
        "text": "Also quickspec and symbolic execution come to mind as relevant (<https://hackage.haskell.org/package/quickspec-2.1.5/docs/QuickSpec.html>)",
        "user": "UKJGU23KP",
        "ts": "1645758686.983149",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kl8z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also quickspec and symbolic execution come to mind as relevant ("
                            },
                            {
                                "type": "link",
                                "url": "https://hackage.haskell.org/package/quickspec-2.1.5/docs/QuickSpec.html"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "3e146ffb-a8e0-4773-ae2f-70d1090a718e",
        "type": "message",
        "text": "I didn't know QuickSpec, which looks very relevant, thanks!",
        "user": "UJBAJNFLK",
        "ts": "1645778298.211919",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7F8Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't know QuickSpec, which looks very relevant, thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1645553705.079219",
        "parent_user_id": "U014WA16VNJ"
    }
]