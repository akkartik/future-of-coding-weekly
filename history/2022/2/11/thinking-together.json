[
    {
        "client_msg_id": "76241c68-d344-44d7-9ea7-125c9eb9d658",
        "type": "message",
        "text": "I\u2019m designing an UI for adding blocks in visual programming (similar to Scratch) without having to drag-and-drop, and wondering if there are any good ideas in other tools. Any block or outline UI:s for visual programming that handle keyboard navigation and/or focus caret (edit point) well?",
        "user": "UEQ7QL15F",
        "ts": "1644580203.691829",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mxup",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m designing an UI for adding blocks in visual programming (similar to Scratch) without having to drag-and-drop, and wondering if there are any good ideas in other tools. Any block or outline UI:s for visual programming that handle keyboard navigation and/or focus caret (edit point) well?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "reply_count": 13,
        "reply_users_count": 6,
        "latest_reply": "1644812442.914029",
        "reply_users": [
            "UEQ7QL15F",
            "U013ZLJARC7",
            "UGWUJUZHT",
            "U02U0AS3J49",
            "UBKNXPBAB",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "a4493699-1d0c-49ee-8474-d6c300ee15cb",
        "type": "message",
        "text": "\u201cSemantic Editors\u201d here are maybe somewhat related (Hazel, Syntactor, Fructure), even though they are not based on blocks.\n<https://github.com/pel-daniel/mind-bicycles>",
        "user": "UEQ7QL15F",
        "ts": "1644581185.850349",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ7QL15F",
            "ts": "1644581213.000000"
        },
        "attachments": [
            {
                "from_url": "https://github.com/pel-daniel/mind-bicycles",
                "image_url": "https://opengraph.githubassets.com/ac84fb0e524d1f6de81f1f644e5ed74041a34e9af08087226f66d40612abeb4f/pel-daniel/mind-bicycles",
                "image_width": 500,
                "image_height": 250,
                "image_bytes": 104417,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/pel-daniel/mind-bicycles",
                "fallback": "GitHub: GitHub - pel-daniel/mind-bicycles: List of future of programming projects",
                "text": "List of future of programming projects. Contribute to pel-daniel/mind-bicycles development by creating an account on GitHub.",
                "title": "GitHub - pel-daniel/mind-bicycles: List of future of programming projects",
                "title_link": "https://github.com/pel-daniel/mind-bicycles",
                "service_name": "GitHub"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rbYW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\u201cSemantic Editors\u201d here are maybe somewhat related (Hazel, Syntactor, Fructure), even though they are not based on blocks.\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/pel-daniel/mind-bicycles"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "9b6667bd-3a1c-4b50-bf22-ebe6e4d5930d",
        "type": "message",
        "text": "The Fructure approach would be very interesting for a block editor. :+1::skin-tone-2:",
        "user": "U013ZLJARC7",
        "ts": "1644583204.071439",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nxnJ5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The Fructure approach would be very interesting for a block editor. "
                            },
                            {
                                "type": "emoji",
                                "name": "+1",
                                "skin_tone": 2
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4166ef0b-6636-41cb-99ac-42d404b10a51",
        "type": "message",
        "text": "IMO: Emacs\u2019 mark and point\n1. set cursor, click key, graphical object appears at cursor\n2. set mark, set cursor, click key, graphical object appears between mark and point\n(I like to think that every operation must be bound to a keystroke.  A mouse requires a whole hand, a keyboard allows the use of 10 fingers.)",
        "user": "UGWUJUZHT",
        "ts": "1644586036.872259",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aR4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IMO: Emacs\u2019 mark and point\n1. set cursor, click key, graphical object appears at cursor\n2. set mark, set cursor, click key, graphical object appears between mark and point\n(I like to think that every operation must be bound to a keystroke.  A mouse requires a whole hand, a keyboard allows the use of 10 fingers.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F"
                ],
                "count": 1
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "125b8c76-035e-4d9b-a94d-0b162c5c19ce",
        "type": "message",
        "text": "Blockly Developer Tools is an eat-your-own-dogfood method of generating block definitions using a block interface, and Blockly supports a rudimentary keyboard navigation.",
        "user": "U02U0AS3J49",
        "ts": "1644594332.838619",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bW3d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Blockly Developer Tools is an eat-your-own-dogfood method of generating block definitions using a block interface, and Blockly supports a rudimentary keyboard navigation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "05a26475-86d1-4ac3-85d4-271bcec67dfa",
        "type": "message",
        "text": "Blockly generally has an approach to variables and functions where you declare them, and then they become new blocks in the interface. I'm using a similar approach in Blawx for categories, objects, and attributes.",
        "user": "U02U0AS3J49",
        "ts": "1644594992.325799",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PUI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Blockly generally has an approach to variables and functions where you declare them, and then they become new blocks in the interface. I'm using a similar approach in Blawx for categories, objects, and attributes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "e37a52ce-7a18-4ad3-bc12-a23593fc15d4",
        "type": "message",
        "text": "Keyboard control of block-based programming is a really interesting direction. I haven't seen it done before. With structure editors modeled after textual code (Hazel / Fructure / Lamdu), there's a clear target of \"make keyboard interaction emulate keyboard interaction with text\". Your situation feels more open-ended.\n\nYou might want to look into how spreadsheets handle keyboard navigation. Or what <@UBJGA440K>'s done with his latest Flowsheets demo, linked to from <https://twitter.com/Glench/status/1488185413516857347>.",
        "user": "UBKNXPBAB",
        "ts": "1644608611.318509",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q7REV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Keyboard control of block-based programming is a really interesting direction. I haven't seen it done before. With structure editors modeled after textual code (Hazel / Fructure / Lamdu), there's a clear target of \"make keyboard interaction emulate keyboard interaction with text\". Your situation feels more open-ended.\n\nYou might want to look into how spreadsheets handle keyboard navigation. Or what "
                            },
                            {
                                "type": "user",
                                "user_id": "UBJGA440K"
                            },
                            {
                                "type": "text",
                                "text": "'s done with his latest Flowsheets demo, linked to from "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/Glench/status/1488185413516857347"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "ef9dcf56-6633-4f41-856d-7cf268591735",
        "type": "message",
        "text": "<@UEQ7QL15F>, I've been thinking about this problem a little, today, and I have an idea. The blocks in Blockly all have a default textual representation. You could build a blockly plugin that allows the user to type, but everything is auto-completed to the text representation of the blocks that are currently available, so you can't type anything that doesn't generate blocks. new line creates a new block in the current stack, increasing and decreasing the indent moves the cursor in and out of stacks and fields. You could also allow the blocks to define their own alternative name for use in the auto-complete field, so you could type \"rule\", and you would auto-complete to \"when we know ___ we also know ___\". Whatever you have currently entered shows up on a scratch-pad. Hit enter twice in a row, and whatever you currently have (including spaces you haven't filled in the text version) gets dropped onto the workspace for you. Targetting is hard, so to start I would say put the first one in the middle of the workspace, and if the user continues to type without scrolling, put subsequent entries below that one. I think that could work, and I think it could be written in such a way that it would work for anyone using Blockly, not just for a particular block set, as long as the blocks all have text on them. But it might be a good idea to add details to the block definitions for how the text version should read, since internal inputs and fields can be named pretty arcanely. I think it would be a really smart way to combat the \"visual programming is not for experts\" nonsense.",
        "user": "U02U0AS3J49",
        "ts": "1644616512.067049",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FB0P8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ7QL15F"
                            },
                            {
                                "type": "text",
                                "text": ", I've been thinking about this problem a little, today, and I have an idea. The blocks in Blockly all have a default textual representation. You could build a blockly plugin that allows the user to type, but everything is auto-completed to the text representation of the blocks that are currently available, so you can't type anything that doesn't generate blocks. new line creates a new block in the current stack, increasing and decreasing the indent moves the cursor in and out of stacks and fields. You could also allow the blocks to define their own alternative name for use in the auto-complete field, so you could type \"rule\", and you would auto-complete to \"when we know ___ we also know ___\". Whatever you have currently entered shows up on a scratch-pad. Hit enter twice in a row, and whatever you currently have (including spaces you haven't filled in the text version) gets dropped onto the workspace for you. Targetting is hard, so to start I would say put the first one in the middle of the workspace, and if the user continues to type without scrolling, put subsequent entries below that one. I think that could work, and I think it could be written in such a way that it would work for anyone using Blockly, not just for a particular block set, as long as the blocks all have text on them. But it might be a good idea to add details to the block definitions for how the text version should read, since internal inputs and fields can be named pretty arcanely. I think it would be a really smart way to combat the \"visual programming is not for experts\" nonsense."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "85c6a5de-d77b-4aeb-b158-ad2fda3c9457",
        "type": "message",
        "text": "Actually, that's such a cool feature idea, I'm adding it to my backlog.",
        "user": "U02U0AS3J49",
        "ts": "1644616594.640989",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AJX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Actually, that's such a cool feature idea, I'm adding it to my backlog."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "b90cf1b5-7cd1-4394-82cc-beb275317f71",
        "type": "message",
        "text": "With Scratch, I thought at first that dragging blocks would be tedious in a way that it mostly isn't.  Fairly standard code completion techniques may play well with a block language: just show me what blocks would likely fit here.  Two other surprisingly nice Scratch things: (1) you can change the selector popups for blocks in your well, giving them more of a tool/template feel, (2) double clicking on lone groups of blocks in the middle of your workspace executes them.  Now I'm reminded of Acme's middle click to execute code.",
        "user": "UA14TGLTC",
        "ts": "1644645875.231979",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jbz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "With Scratch, I thought at first that dragging blocks would be tedious in a way that it mostly isn't.  Fairly standard code completion techniques may play well with a block language: just show me what blocks would likely fit here.  Two other surprisingly nice Scratch things: (1) you can change the selector popups for blocks in your well, giving them more of a tool/template feel, (2) double clicking on lone groups of blocks in the middle of your workspace executes them.  Now I'm reminded of Acme's middle click to execute code."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "354f2e20-d7dd-4de6-a9f2-29257d8c10c8",
        "type": "message",
        "text": "Yeah, I get a lot of pushback from \"traditional programmers\" about the downsides of the visual syntax. But the fact of the matter is that I can type, and I don't hate using it. Pair programming, mob programming, code review, all of these are attempts to increase the ratio of thinking to typing, so going slower may not be a bad thing.",
        "user": "U02U0AS3J49",
        "ts": "1644772354.577709",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rj/u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I get a lot of pushback from \"traditional programmers\" about the downsides of the visual syntax. But the fact of the matter is that I can type, and I don't hate using it. Pair programming, mob programming, code review, all of these are attempts to increase the ratio of thinking to typing, so going slower may not be a bad thing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "938add20-03d8-4061-8be0-ff60198238c3",
        "type": "message",
        "text": "What I do find tedious is how difficult it is to navigate your code. Line-wrapping means that text has a fixed width, and there are lots of good methods for page-up, page-down, etc. The same don't exist in the visual interfaces I've used.",
        "user": "U02U0AS3J49",
        "ts": "1644772436.959599",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zdxO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I do find tedious is how difficult it is to navigate your code. Line-wrapping means that text has a fixed width, and there are lots of good methods for page-up, page-down, etc. The same don't exist in the visual interfaces I've used."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "1a72d91f-ce7e-4095-8066-1e94a12bb378",
        "type": "message",
        "text": "I didn't know about the double-click feature in Scratch, that's cool. I might add it to question blocks in Blawx. Thanks for the tip!",
        "user": "U02U0AS3J49",
        "ts": "1644772514.577159",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "P7qT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't know about the double-click feature in Scratch, that's cool. I might add it to question blocks in Blawx. Thanks for the tip!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    },
    {
        "client_msg_id": "3f7eedf1-b0f4-4fdf-a724-61ece14440bb",
        "type": "message",
        "text": "Keep in mind that traditional programmers are relatively good at what traditional programming entails.  Many other people take one look at that and back away... slowly.",
        "user": "UA14TGLTC",
        "ts": "1644812442.914029",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xic",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Keep in mind that traditional programmers are relatively good at what traditional programming entails.  Many other people take one look at that and back away... slowly."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1644580203.691829",
        "parent_user_id": "UEQ7QL15F"
    }
]