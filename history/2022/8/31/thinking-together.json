[
    {
        "client_msg_id": "5f35acea-b268-48e1-bcb3-b9ba9d8df030",
        "type": "message",
        "text": "What are alternative solutions to variables and scopes? Is there a proven abstraction that end users easily understand?",
        "user": "UBN9AFS0N",
        "ts": "1661962300.475609",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aDS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are alternative solutions to variables and scopes? Is there a proven abstraction that end users easily understand?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "reply_count": 38,
        "reply_users_count": 9,
        "latest_reply": "1662154679.863649",
        "reply_users": [
            "U03CEGR3HSL",
            "U03GBV8B58V",
            "UJBAJNFLK",
            "U040R67M66L",
            "UDQBTJ211",
            "UCGAK10LS",
            "U02E4DAQGSZ",
            "U03US9D90HW",
            "U02U0AS3J49"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1662154679.863649"
    },
    {
        "client_msg_id": "2337789a-dccc-4f21-9000-b2e4f00c30f3",
        "type": "message",
        "text": "Brian Harvey used to say that dynamic scope is what you get if you don't think about scope, so that's why it is easier for beginners to understand. But it still involves variables and a type of scoping.\n\nMaybe I'm suffering from a lack of imagination here, but I'm not sure how to easily perform abstraction without giving things names. Names are what help us humans remember the meaning and usage of a thing or a behavior. If one tried to create some form of graphical language where things were displayed but could not be named, I feel like the first thing people would ask for is the ability to use names so they're not stuck thinking about this thing and that thing and the other thing.\n\nIt did not take long for early programmers to invent so-called floating labels, allowing them to name pieces of code and data in memory. Even in spreadsheets, the ability to name cells and ranges makes formulas substantially easier to read.\n<https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED|https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED>\n\nOutside of computers, imagine trying to tell someone how to make a sandwich without using any names.",
        "user": "U03CEGR3HSL",
        "ts": "1661963815.079349",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED",
                "image_url": "https://static.cambridge.org/covers/PSP_0_0_0/mathematical_proceedings of the cambridge philosophical society.jpg?send-full-size-image=true",
                "image_width": 176,
                "image_height": 250,
                "image_bytes": 298396,
                "service_icon": "https://www.cambridge.org/core/cambridge-core/public/images/favicon.ico",
                "id": 1,
                "original_url": "https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED",
                "fallback": "Cambridge Core: The use of a \u2018floating address\u2019 system for orders in an automatic digital computer | Mathematical Proceedings of the Cambridge Philosophical Society | Cambridge Core",
                "text": "The use of a \u2018floating address\u2019 system for orders in an automatic digital computer - Volume 49 Issue 1",
                "title": "The use of a \u2018floating address\u2019 system for orders in an automatic digital computer | Mathematical Proceedings of the Cambridge Philosophical Society | Cambridge Core",
                "title_link": "https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED",
                "service_name": "Cambridge Core"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HWt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Brian Harvey used to say that dynamic scope is what you get if you don't think about scope, so that's why it is easier for beginners to understand. But it still involves variables and a type of scoping.\n\nMaybe I'm suffering from a lack of imagination here, but I'm not sure how to easily perform abstraction without giving things names. Names are what help us humans remember the meaning and usage of a thing or a behavior. If one tried to create some form of graphical language where things were displayed but could not be named, I feel like the first thing people would ask for is the ability to use names so they're not stuck thinking about this thing and that thing and the other thing.\n\nIt did not take long for early programmers to invent so-called floating labels, allowing them to name pieces of code and data in memory. Even in spreadsheets, the ability to name cells and ranges makes formulas substantially easier to read.\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED",
                                "text": "https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED"
                            },
                            {
                                "type": "text",
                                "text": "\n\nOutside of computers, imagine trying to tell someone how to make a sandwich without using any names."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS",
                    "UA14TGLTC",
                    "U03FPD8BF19"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "b43b6d4d-7889-4f16-819f-8ea86043edf7",
        "type": "message",
        "text": "I think we're bounded by human biology in what kind of scopes we can reason about. We're spatial creatures (2D/3D plus time).\n\nI'm not aware of alternative solutions, but there are variations with important differences in their relationship to end users.\n\nAll scopes are essentially a set of nested spatial containers, but the spatial borders in traditional programming are functions and classes which is where the problems start for non-coders.\n\nThe best example of spatial scopes that make sense for end users are spreadsheet rows and columns, which are much more natural. The variables \"need a place to hang on the wall\" in the end user's mind, and a function doesn't tick that box (it's a position in a text file, but essentially non-spatial).\n\nFrom here I guess the remaining directions are 3D scopes or Graph scopes which is essentially the input/output model seen with node/flow-based programming.",
        "user": "U03GBV8B58V",
        "ts": "1661964348.255999",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03GBV8B58V",
            "ts": "1661964395.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "07POx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think we're bounded by human biology in what kind of scopes we can reason about. We're spatial creatures (2D/3D plus time).\n\nI'm not aware of alternative solutions, but there are variations with important differences in their relationship to end users.\n\nAll scopes are essentially a set of nested spatial containers, but the spatial borders in traditional programming are functions and classes which is where the problems start for non-coders.\n\nThe best example of spatial scopes that make sense for end users are spreadsheet rows and columns, which are much more natural. The variables \"need a place to hang on the wall\" in the end user's mind, and a function doesn't tick that box (it's a position in a text file, but essentially non-spatial).\n\nFrom here I guess the remaining directions are 3D scopes or Graph scopes which is essentially the input/output model seen with node/flow-based programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "eb4541e9-309f-41a8-a388-dc097239530c",
        "type": "message",
        "text": "The alternative I am trying out myself in my Leibniz project (<https://github.com/khinsen/leibniz-pharo>) is no scopes, or if you prefer a single scope. To make this practical, code units must be kept very small, which actually helps to keep them understandable. That means: no \"standard libraries\" with tons of definitions that might one day be useful. Small bits of functionality must be explicitly included.\n\nThe inspiration for this is mathematical notation in textbooks and research articles. They don't have scopes. Every bit of notation, once introduced, is valid for the whole text.",
        "user": "UJBAJNFLK",
        "ts": "1661965168.600759",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NDbb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The alternative I am trying out myself in my Leibniz project ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/khinsen/leibniz-pharo"
                            },
                            {
                                "type": "text",
                                "text": ") is no scopes, or if you prefer a single scope. To make this practical, code units must be kept very small, which actually helps to keep them understandable. That means: no \"standard libraries\" with tons of definitions that might one day be useful. Small bits of functionality must be explicitly included.\n\nThe inspiration for this is mathematical notation in textbooks and research articles. They don't have scopes. Every bit of notation, once introduced, is valid for the whole text."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U040R67M66L",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a4f06924-ce10-4d04-a899-49249285a38b",
        "type": "message",
        "text": "I've thought about creating a single-scope logic/\"relational\" language where \"functions\" are sets of rules about how the variables relate to one another. I guess it's not too terribly different from a database, per se, where variables are rows and rules are constraints.  Moreso inspired by Prolog, only Prolog rules take explicit arguments.\n\nI honestly have no idea if this is a _good_ idea, and in all probability it's probably a bad one.",
        "user": "U040R67M66L",
        "ts": "1661967094.055919",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U040R67M66L",
            "ts": "1661973699.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xRPZX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've thought about creating a single-scope logic/\"relational\" language where \"functions\" are sets of rules about how the variables relate to one another. I guess it's not too terribly different from a database, per se, where variables are rows and rules are constraints.  Moreso inspired by Prolog, only Prolog rules take explicit arguments.\n\nI honestly have no idea if this is a "
                            },
                            {
                                "type": "text",
                                "text": "good",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " idea, and in all probability it's probably a bad one."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d3c5d0fe-6f07-4b8d-8b31-abc60b4db16e",
        "type": "message",
        "text": "Wikipedia titles are globally unique, they just put the scope in brackets afterwards e.g. \"Franz Ferdinand (band)\".",
        "user": "UDQBTJ211",
        "ts": "1661973016.755509",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VBx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wikipedia titles are globally unique, they just put the scope in brackets afterwards e.g. \"Franz Ferdinand (band)\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8523A42E-B098-4F00-ADA1-B800509A3FB8",
        "type": "message",
        "text": "The PL I\u2019m designing doesn\u2019t have nested scopes. It\u2019s a relational programming language (Datalog-inspired) \u2014 it\u2019s the only paradigm I know of where such a thing is possible (with some hard work!).\n\nAs a program gets large, the absence of a syntactic boundary (e.g. a file, or a code block) for limiting the places a definition can be accessed from becomes a problem. But I think it\u2019s an easily solvable one.\n\nVariables, on the other hand, will remain essential for as long as humans use natural language.",
        "user": "UCGAK10LS",
        "ts": "1662001111.432409",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1662007884.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TqpV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The PL I\u2019m designing doesn\u2019t have nested scopes. It\u2019s a relational programming language (Datalog-inspired) \u2014 it\u2019s the only paradigm I know of where such a thing is possible (with some hard work!)."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "As a program gets large, the absence of a syntactic boundary (e.g. a file, or a code block) for limiting the places a definition can be accessed from becomes a problem. But I think it\u2019s an easily solvable one."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Variables, on the other hand, will remain essential for as long as humans use natural language"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U040R67M66L"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "FFF78B3E-75BC-4D26-8219-061529BBF904",
        "type": "message",
        "text": "<@UDQBTJ211> That looks more like an ad-hoc namespace than a scope to me.",
        "user": "UJBAJNFLK",
        "ts": "1662014446.658859",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hgM1O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": " That"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "looks"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "more"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "like"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "an"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "ad-hoc"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "namespace"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "than"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "a"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "scope"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "to"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "me."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "4fb99581-e76b-4fdd-9021-aeaefefc2df1",
        "type": "message",
        "text": "the old programs were declare all your variable in advance and/or only have a single global scope which is extremely easy to understand with the negative drawback of not scaling to large programs or not handling temporary internal control flow variables very well (internal loop variables have to go to the top). Still, pretty good IMHO if you want fast understanding of a snippet of code.",
        "user": "U02E4DAQGSZ",
        "ts": "1662017262.141839",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "etp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the old programs were declare all your variable in advance and/or only have a single global scope which is extremely easy to understand with the negative drawback of not scaling to large programs or not handling temporary internal control flow variables very well (internal loop variables have to go to the top). Still, pretty good IMHO if you want fast understanding of a snippet of code."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "d93a48b6-5dfb-4c06-8fbf-fdd5a8eb7c0b",
        "type": "message",
        "text": "<@UJBAJNFLK> yeah you are right.\n\nI think scope in the sense of actively restricting the ability to talk about something from another context is not user friendly. Chris Granger talks about this in one of his talks where he demoed Eve at a local event (at Dynamicland I think). There were lots of non-programmers there. They couldn't understand why you could point to a deeply nested variable on the screen, but not just pull that value out and use it where you want.\n\nI think the lack of scope in Excel (and autonaming of variables) is one of the reasons it is user friendly. It still has namespaces but you can refer to anything you can see (even across different files if you use a fully qualified path reference).",
        "user": "UDQBTJ211",
        "ts": "1662019842.339559",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UDQBTJ211",
            "ts": "1662019886.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ku0JT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " yeah you are right.\n\nI think scope in the sense of actively restricting the ability to talk about something from another context is not user friendly. Chris Granger talks about this in one of his talks where he demoed Eve at a local event (at Dynamicland I think). There were lots of non-programmers there. They couldn't understand why you could point to a deeply nested variable on the screen, but not just pull that value out and use it where you want.\n\nI think the lack of scope in Excel (and autonaming of variables) is one of the reasons it is user friendly. It still has namespaces but you can refer to anything you can see (even across different files if you use a fully qualified path reference)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "eee501db-ab55-465d-a152-e7ee37c4147c",
        "type": "message",
        "text": "Smalltalk doesn't have scopes either. Namespaces, yes: a global one (class names etc.), one per class for instance variables, and one per method for local variables, which are not allowed to shadow instance variables. I can't remember anyone complaining about the lack of scopes in Smalltalk.",
        "user": "UJBAJNFLK",
        "ts": "1662028061.125219",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Hyr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Smalltalk doesn't have scopes either. Namespaces, yes: a global one (class names etc.), one per class for instance variables, and one per method for local variables, which are not allowed to shadow instance variables. I can't remember anyone complaining about the lack of scopes in Smalltalk."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "5fc1b3c2-588b-4049-8f08-d7558f8dadd1",
        "type": "message",
        "text": "I find scopes to be a useful abstraction. Not necessarily for the initial creation of a program. I believe they resolve two issues:\n1. Single-user error on text entry: You may not intend to use a particular variable in certain contexts. Scopes are a useful way to make sure that a typo doesn't result in unintentional usage.\n2. Multi-user idea communication: When designing large systems it is useful to hide certain details of the system, especially if a particular use would largely result in errors. For example, if the use of a variable `i` is used multiple times in a single method to iterate through multiple lists it is useful that different `i`s in different scopes are associated with different lists. It communicates an idea to other developers that the \"mental load\" introduced by the variable need only relate to the matter at hand and can be ignored outside of that context.\nIn a similar way to dynamic vs typed languages you can get away _without_ scopes with a little bit of discipline. Encoding the restrictions seems a useful way to communicate intentions of the code though. In traditional implementations it really doesn't put much burden on the author as types can in some cases.",
        "user": "U03US9D90HW",
        "ts": "1662050280.817169",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/yI6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find scopes to be a useful abstraction. Not necessarily for the initial creation of a program. I believe they resolve two issues:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Single-user error on text entry: You may not intend to use a particular variable in certain contexts. Scopes are a useful way to make sure that a typo doesn't result in unintentional usage."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Multi-user idea communication: When designing large systems it is useful to hide certain details of the system, especially if a particular use would largely result in errors. For example, if the use of a variable "
                                    },
                                    {
                                        "type": "text",
                                        "text": "i",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " is used multiple times in a single method to iterate through multiple lists it is useful that different "
                                    },
                                    {
                                        "type": "text",
                                        "text": "i",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "s in different scopes are associated with different lists. It communicates an idea to other developers that the \"mental load\" introduced by the variable need only relate to the matter at hand and can be ignored outside of that context."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIn a similar way to dynamic vs typed languages you can get away "
                            },
                            {
                                "type": "text",
                                "text": "without",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " scopes with a little bit of discipline. Encoding the restrictions seems a useful way to communicate intentions of the code though. In traditional implementations it really doesn't put much burden on the author as types can in some cases."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "663a619e-a36e-4abe-b4fd-d8ae9820e5a0",
        "type": "message",
        "text": "By default, definitions are unbounded, or bounded only by document. Redefinitions are bounded, and only explicitly. Redefinitions can be referred to outside the boundary of the definition but only explicitly. \"1. Minister means the Minister of Health.\" \"2. In this section, Minister means the Minister of Revenue.\" \"3. The Minister, as that term is defined in section 2.\" Is that \"scope\" or \"namespace\"? I'm thinking namespace?",
        "user": "U02U0AS3J49",
        "ts": "1662135011.308359",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/nV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "By default, definitions are unbounded, or bounded only by document. Redefinitions are bounded, and only explicitly. Redefinitions can be referred to outside the boundary of the definition but only explicitly. \"1. Minister means the Minister of Health.\" \"2. In this section, Minister means the Minister of Revenue.\" \"3. The Minister, as that term is defined in section 2.\" Is that \"scope\" or \"namespace\"? I'm thinking namespace?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "f1a2ff92-e24a-403f-88f8-237101692397",
        "type": "message",
        "text": "I would say that approach is proven.",
        "user": "U02U0AS3J49",
        "ts": "1662135192.427889",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D10pc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would say that approach is proven."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "446a161b-c83f-4e13-8a13-4365df7ab012",
        "type": "message",
        "text": "The distinction to me is that something _does not exist at all_ outside of its scope, whereas outside of its namespace it just goes by a different name.\n\nScope is inherently confusing from an author who has an omniscient view of the program.",
        "user": "UDQBTJ211",
        "ts": "1662135220.188829",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MzHT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The distinction to me is that something "
                            },
                            {
                                "type": "text",
                                "text": "does not exist at all",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " outside of its scope, whereas outside of its namespace it just goes by a different name.\n\nScope is inherently confusing from an author who has an omniscient view of the program."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1::skin-tone-2",
                "users": [
                    "U02U0AS3J49"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7cd6b35d-be11-4eb5-941a-1c10436e8602",
        "type": "message",
        "text": "It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, but this is fool's gold, the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all",
        "user": "UDQBTJ211",
        "ts": "1662135416.798429",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pGZfz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, but this is fool's gold, the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U02U0AS3J49",
                    "U040R67M66L"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "8aebb534-e452-4bcc-ad1e-449a604fdd84",
        "type": "message",
        "text": "<@UJBAJNFLK> local variables and arguments in Smalltalk blocks are lexically scooped. That's what makes it possible to implement conditionals and iteration by passing a block to a method.",
        "user": "U03CEGR3HSL",
        "ts": "1662136326.448549",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ltr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " local variables and arguments in Smalltalk blocks are lexically scooped. That's what makes it possible to implement conditionals and iteration by passing a block to a method."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "43747398-65b5-4551-b016-f48099628cb4",
        "type": "message",
        "text": "&gt; It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, *but this is fool's gold*, the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all\nI disagree with this, specifically the bold part. In almost every scenario the goal should be to get feedback as early as possible. Ideally you can look at a program and know what it does just like you can look at text in a book and know what it says. In many large programs it is difficult to run all of the code through a debugger, sometimes taking double digit numbers of minutes. For example, major games take minutes to compile, run, and load into maps.\n\nThere are certainly use cases where you can lean more on a debugger, like scripting. Even in these scenarios most developers prefer to be able to look at code and know what it does rather than have to run it through a debugger.",
        "user": "U03US9D90HW",
        "ts": "1662140924.539159",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03US9D90HW",
            "ts": "1662140935.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xzdYR",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, "
                            },
                            {
                                "type": "text",
                                "text": "but this is fool's gold",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I disagree with this, specifically the bold part. In almost every scenario the goal should be to get feedback as early as possible. Ideally you can look at a program and know what it does just like you can look at text in a book and know what it says. In many large programs it is difficult to run all of the code through a debugger, sometimes taking double digit numbers of minutes. For example, major games take minutes to compile, run, and load into maps.\n\nThere are certainly use cases where you can lean more on a debugger, like scripting. Even in these scenarios most developers prefer to be able to look at code and know what it does rather than have to run it through a debugger."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "4b4d9553-65db-4013-8518-a3193b31d9e6",
        "type": "message",
        "text": "I think your concerns are about the current-of-programming, aren't they?\n\nYeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done _overnight_. This is bad. I would be wary of basing philosophical positions on that though.\n\n\"If we adopt this language feature, compile times will be faster\" is exactly the sort of tradeoff I'd classify as fool's gold.",
        "user": "UDQBTJ211",
        "ts": "1662142581.221269",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GqnQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think your concerns are about the current-of-programming, aren't they?\n\nYeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done "
                            },
                            {
                                "type": "text",
                                "text": "overnight",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". This is bad. I would be wary of basing philosophical positions on that though.\n\n\"If we adopt this language feature, compile times will be faster\" is exactly the sort of tradeoff I'd classify as fool's gold."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "type": "message",
        "text": "<@U03CEGR3HSL> In Pharo (the only Smalltalk I have experience with), there are no lexical scopes. Re-declaring an argument or a local variable in a nested block is forbidden (see screenshots).\n\nBlocks passed into a method are a different story. Their local variables are invisible from the method that uses them, so I wouldn't call that lexical scopes either, but that's certainly debatable.",
        "files": [
            {
                "id": "F0419FZQAF3",
                "created": 1662144949,
                "timestamp": 1662144949,
                "name": "Screenshot 2022-09-02 at 20.49.43.png",
                "title": "Screenshot 2022-09-02 at 20.49.43.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UJBAJNFLK",
                "editable": false,
                "size": 39776,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F0419FZQAF3/screenshot_2022-09-02_at_20.49.43.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F0419FZQAF3/download/screenshot_2022-09-02_at_20.49.43.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419FZQAF3-c1eecfe9bb/screenshot_2022-09-02_at_20.49.43_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419FZQAF3-c1eecfe9bb/screenshot_2022-09-02_at_20.49.43_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419FZQAF3-c1eecfe9bb/screenshot_2022-09-02_at_20.49.43_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 352,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419FZQAF3-c1eecfe9bb/screenshot_2022-09-02_at_20.49.43_160.png",
                "original_w": 468,
                "original_h": 457,
                "thumb_tiny": "AwAuADDQ+bJ+ZfypwIzjIzQKTGSfmP50AOopu3/aNOx70AFFFFADaUdTTc/NjI+lLyehFADqKQhs8EYo54wRQAtFJhvUUtADDnGdxH0pBv6ZBp+OMGjbQAg398Uoz3xRj/OaMD3/ADoAWikxS0Af/9k=",
                "permalink": "https://futureofcoding.slack.com/files/UJBAJNFLK/F0419FZQAF3/screenshot_2022-09-02_at_20.49.43.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F0419FZQAF3-a6646baa62",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            },
            {
                "id": "F040WT4K7T4",
                "created": 1662144956,
                "timestamp": 1662144956,
                "name": "Screenshot 2022-09-02 at 20.51.34.png",
                "title": "Screenshot 2022-09-02 at 20.51.34.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UJBAJNFLK",
                "editable": false,
                "size": 12322,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F040WT4K7T4/screenshot_2022-09-02_at_20.51.34.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F040WT4K7T4/download/screenshot_2022-09-02_at_20.51.34.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F040WT4K7T4-73886d0352/screenshot_2022-09-02_at_20.51.34_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F040WT4K7T4-73886d0352/screenshot_2022-09-02_at_20.51.34_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F040WT4K7T4-73886d0352/screenshot_2022-09-02_at_20.51.34_360.png",
                "thumb_360_w": 319,
                "thumb_360_h": 97,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F040WT4K7T4-73886d0352/screenshot_2022-09-02_at_20.51.34_160.png",
                "original_w": 319,
                "original_h": 97,
                "thumb_tiny": "AwAOADDQwzDhyv0ph3jGGJ9elSAEUuB6DmgCPe+7oT7cU7c2fuGnY5zS0DEBJ6jFLRRQI//Z",
                "permalink": "https://futureofcoding.slack.com/files/UJBAJNFLK/F040WT4K7T4/screenshot_2022-09-02_at_20.51.34.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F040WT4K7T4-2cadce5052",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            },
            {
                "id": "F0419G0LYG1",
                "created": 1662144962,
                "timestamp": 1662144962,
                "name": "Screenshot 2022-09-02 at 20.52.44.png",
                "title": "Screenshot 2022-09-02 at 20.52.44.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UJBAJNFLK",
                "editable": false,
                "size": 15948,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F0419G0LYG1/screenshot_2022-09-02_at_20.52.44.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F0419G0LYG1/download/screenshot_2022-09-02_at_20.52.44.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419G0LYG1-886ed22849/screenshot_2022-09-02_at_20.52.44_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419G0LYG1-886ed22849/screenshot_2022-09-02_at_20.52.44_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419G0LYG1-886ed22849/screenshot_2022-09-02_at_20.52.44_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 74,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419G0LYG1-886ed22849/screenshot_2022-09-02_at_20.52.44_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 99,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F0419G0LYG1-886ed22849/screenshot_2022-09-02_at_20.52.44_160.png",
                "original_w": 579,
                "original_h": 119,
                "thumb_tiny": "AwAJADDQxkDBP504EjjFFLQAhJ/uk0An+6aWigBM+1LRRQB//9k=",
                "permalink": "https://futureofcoding.slack.com/files/UJBAJNFLK/F0419G0LYG1/screenshot_2022-09-02_at_20.52.44.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F0419G0LYG1-3ddc75e075",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "UJBAJNFLK",
        "ts": "1662144969.810409",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Knxy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U03CEGR3HSL"
                            },
                            {
                                "type": "text",
                                "text": " In Pharo (the only Smalltalk I have experience with), there are no lexical scopes. Re-declaring an argument or a local variable in a nested block is forbidden (see screenshots).\n\nBlocks passed into a method are a different story. Their local variables are invisible from the method that uses them, so I wouldn't call that lexical scopes either, but that's certainly debatable."
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "fd42fe80-a78f-4b96-846e-a7299b0a279e",
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "73b0f91e-7599-4ac5-a0e2-a0cf59cff8a2",
        "type": "message",
        "text": "<@UJBAJNFLK> thank you, I was unaware of that limitation/feature. I think I see your point now about how if you just forbid variables from ever being shadowed, programmers don't need to think about scope.",
        "user": "U03CEGR3HSL",
        "ts": "1662145282.127409",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dr3n5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " thank you, I was unaware of that limitation/feature. I think I see your point now about how if you just forbid variables from ever being shadowed, programmers don't need to think about scope."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "e013be3d-f898-4ddf-8abf-a0bcc7fc1d02",
        "type": "message",
        "text": "&gt; I think your concerns are about the current-of-programming, aren't they?\n&gt; \n&gt; Yeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done _overnight_. This is bad. I would be wary of basing philosophical positions on that though.\n&gt; \n&gt; \"If we adopt this language feature, compile times will be faster\" is exactly the sort of tradeoff I'd classify as fool's gold.\nI feel like this is putting words in my mouth. I'm making this argument for past, present and future: it was true, it is true, and it will continue to be true. *Looking at something and knowing it works is better than having to take extra steps to find out if it works*.\n\nGames are only used as an example. I've also done OS development where the same is true. I provided scripting as a counter example where maybe your argument is stronger: it's easier to run and debug scripts. I'd be curious if you have any realistic examples where people would prefer \"[making] the computer help with debugging\" over being able to \"[debug] in your head\" (I changed the gerunds in your quotes). I can't think of any. Seems like you always want to look at a program and know it works where possible and debugging only needs to come into the picture when that fails.",
        "user": "U03US9D90HW",
        "ts": "1662149764.267169",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fms6",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think your concerns are about the current-of-programming, aren't they?\n\nYeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done "
                            },
                            {
                                "type": "text",
                                "text": "overnight",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". This is bad. I would be wary of basing philosophical positions on that though.\n\n\"If we adopt this language feature, compile times will be faster\" is exactly the sort of tradeoff I'd classify as fool's gold."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI feel like this is putting words in my mouth. I'm making this argument for past, present and future: it was true, it is true, and it will continue to be true. "
                            },
                            {
                                "type": "text",
                                "text": "Looking at something and knowing it works is better than having to take extra steps to find out if it works",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nGames are only used as an example. I've also done OS development where the same is true. I provided scripting as a counter example where maybe your argument is stronger: it's easier to run and debug scripts. I'd be curious if you have any realistic examples where people would prefer \"[making] the computer help with debugging\" over being able to \"[debug] in your head\" (I changed the gerunds in your quotes). I can't think of any. Seems like you always want to look at a program and know it works where possible and debugging only needs to come into the picture when that fails."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "faaf2df7-789d-4cd4-9d88-3ecf727ca6eb",
        "type": "message",
        "text": "Its interesting if you take each argument to its extreme. I don't claim you are making one of these arguments but they are interesting to think about:\n\u2022 A language which is easy to \"run in your head\" but has no debugger.\n\u2022 A language which is hard to \"run in your head\" but has a great debugger.\nI think its clear people would prefer the first bullet in most contexts. Though obviously a powerful debugger is an incredible tool for building better programs. I don't mean to degrade debuggers or claim they aren't useful. Rather, I think its worth aspiring to improving what can be done in the compiler/interpreter input before considering improvements provided by a debugger. Truthfully many of the tradeoffs may simply come out in difficulty of implementation. If it takes weeks to implement a complier feature vs days to implement a debugger feature that prevents a similar error, its probably better to focus on the debugger.\n\nAll else being equal though, I believe it is better to \"verify things by looking at them\" as I put it, even if human brains are lossy. The debugger comes in when the human brain fails... that doesn't mean the human brain should be replaced by it entirely though. The brain is what you are thinking with. Anything else, like a debugger, requires us using our much slower physical appendages to interact with.",
        "user": "U03US9D90HW",
        "ts": "1662150299.117169",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03US9D90HW",
            "ts": "1662150442.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ogdR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Its interesting if you take each argument to its extreme. I don't claim you are making one of these arguments but they are interesting to think about:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A language which is easy to \"run in your head\" but has no debugger."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A language which is hard to \"run in your head\" but has a great debugger."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think its clear people would prefer the first bullet in most contexts. Though obviously a powerful debugger is an incredible tool for building better programs. I don't mean to degrade debuggers or claim they aren't useful. Rather, I think its worth aspiring to improving what can be done in the compiler/interpreter input before considering improvements provided by a debugger. Truthfully many of the tradeoffs may simply come out in difficulty of implementation. If it takes weeks to implement a complier feature vs days to implement a debugger feature that prevents a similar error, its probably better to focus on the debugger.\n\nAll else being equal though, I believe it is better to \"verify things by looking at them\" as I put it, even if human brains are lossy. The debugger comes in when the human brain fails... that doesn't mean the human brain should be replaced by it entirely though. The brain is what you are thinking with. Anything else, like a debugger, requires us using our much slower physical appendages to interact with."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "de57fafe-29cc-4f28-84a7-37543dc3b0cd",
        "type": "message",
        "text": "Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down.",
        "user": "U02U0AS3J49",
        "ts": "1662151339.470759",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "piQ4f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "77b6c42c-44bf-4ac5-8dae-83b10ee9c03b",
        "type": "message",
        "text": "I agree that it would be better to be able to do it in your head but I think it's impossible. Even the simplest things are already way beyond un-aided human brain processing power.\n\nConsider the Mario example from Inventing on Principle <https://youtu.be/PUv66718DII|https://youtu.be/PUv66718DII> (from ~13 min, specifically the feature demoed from 13:55). It's basically just solving a quadratic equation but pretty much impossible (for me at least!) to do in your head.\n\n<@U02U0AS3J49>'s project is a \"debugger\" of sorts for Laws, something which are generally less complicated than computer programs.",
        "user": "UDQBTJ211",
        "ts": "1662151537.574679",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://youtu.be/PUv66718DII",
                "thumb_url": "https://i.ytimg.com/vi/PUv66718DII/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/PUv66718DII?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen title=\"Bret Victor - Inventing on Principle\"></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://youtu.be/PUv66718DII",
                "fallback": "YouTube Video: Bret Victor - Inventing on Principle",
                "title": "Bret Victor - Inventing on Principle",
                "title_link": "https://youtu.be/PUv66718DII",
                "author_name": "Rui Oliveira",
                "author_link": "https://www.youtube.com/c/ruif99",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dVi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that it would be better to be able to do it in your head but I think it's impossible. Even the simplest things are already way beyond un-aided human brain processing power.\n\nConsider the Mario example from Inventing on Principle "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/PUv66718DII",
                                "text": "https://youtu.be/PUv66718DII"
                            },
                            {
                                "type": "text",
                                "text": " (from ~13 min, specifically the feature demoed from 13:55). It's basically just solving a quadratic equation but pretty much impossible (for me at least!) to do in your head.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U02U0AS3J49"
                            },
                            {
                                "type": "text",
                                "text": "'s project is a \"debugger\" of sorts for Laws, something which are generally less complicated than computer programs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "8ccf65ad-459e-48b9-ae1c-1e5ca574b208",
        "type": "message",
        "text": "&gt; Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down.\nHow would even know how to write the program in the second bullet? A language could be so hard to use that its infeasible to get a program which is even debuggable. At least in the extreme case.\n\n&gt; I agree that it would be better to be able to do it in your head but I think it's impossible.\nI agree that its impossible in many situations. I even agree that small programs can be difficult to get right. You can't know its right until you run. But ideally you can get it as close to right as possible before running it so that debugging time is minimized.\n\nAgain, I'm not against debuggers and all code written should be run and tested so you can verify it is correct. Its just that the previous claim is too extreme for me to agree with. It certainly isn't \"fool's gold\" to construct better models that people can \"debug in [their] head\":\n&gt; It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, but this is fool's gold.",
        "user": "U03US9D90HW",
        "ts": "1662152126.166369",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03US9D90HW",
            "ts": "1662152175.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "85X",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How would even know how to write the program in the second bullet? A language could be so hard to use that its infeasible to get a program which is even debuggable. At least in the extreme case.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that it would be better to be able to do it in your head but I think it's impossible."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that its impossible in many situations. I even agree that small programs can be difficult to get right. You can't know its right until you run. But ideally you can get it as close to right as possible before running it so that debugging time is minimized.\n\nAgain, I'm not against debuggers and all code written should be run and tested so you can verify it is correct. Its just that the previous claim is too extreme for me to agree with. It certainly isn't \"fool's gold\" to construct better models that people can \"debug in [their] head\":\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It can be useful when you are debugging in your head (\"playing computer\") because it reduces the amount of possible factors affecting the program, but this is fool's gold."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "35a58c94-31b4-48c6-93dd-4a809c1b8239",
        "type": "message",
        "text": "There is no extreme case. People create languages that are harder to use, on purpose, for fun. Humans are weird like that.",
        "user": "U02U0AS3J49",
        "ts": "1662152393.448109",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t0A1B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is no extreme case. People create languages that are harder to use, on purpose, for fun. Humans are weird like that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "61f0f296-e0cf-4d22-9370-b55d4474c6b6",
        "type": "message",
        "text": "There is for sake of argument :stuck_out_tongue: but I agree its a weak argument. The reason its interesting to think about though is because it becomes clear that there _is_ some limit on program understandability that is important. It is impossible to ignore the brain. There is _not_ a limit on debuggers though. You don't need one. You could get by with printf and just running the whole program even if you don't want to.",
        "user": "U03US9D90HW",
        "ts": "1662152586.890349",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ShI3Q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is for sake of argument "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue",
                                "unicode": "1f61b"
                            },
                            {
                                "type": "text",
                                "text": " but I agree its a weak argument. The reason its interesting to think about though is because it becomes clear that there "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " some limit on program understandability that is important. It is impossible to ignore the brain. There is "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a limit on debuggers though. You don't need one. You could get by with printf and just running the whole program even if you don't want to."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "2e0d67c4-857a-47d9-80a1-d8299b2c8968",
        "type": "message",
        "text": "To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc.\n\nPerhaps there is a theoretical programming language possible that brings the power of the computer to 99% of people but I can't even conceive of what that would be like, whereas I can conceive of theoretical (but impossible-at-the-moment) tools which make programming more like building with your hands. Bret Victor's work has (faked) examples of these sort of tools",
        "user": "UDQBTJ211",
        "ts": "1662153117.224259",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NDQ0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc.\n\nPerhaps there is a theoretical programming language possible that brings the power of the computer to 99% of people but I can't even conceive of what that would be like, whereas I can conceive of theoretical (but impossible-at-the-moment) tools which make programming more like building with your hands. Bret Victor's work has (faked) examples of these sort of tools"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5ba8de99-5bf0-47fc-9b26-42aaa0d0ff18",
        "type": "message",
        "text": "I think we disagree about which of these two options is \"ignoring the brain\". Brains are very good at using language, and very bad at internally modelling the behaviour of complex systems they can't observe.",
        "user": "U02U0AS3J49",
        "ts": "1662153148.045989",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sIcmh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think we disagree about which of these two options is \"ignoring the brain\". Brains are very good at using language, and very bad at internally modelling the behaviour of complex systems they can't observe."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "3ddf66a2-3e63-4343-a772-99db246b90f5",
        "type": "message",
        "text": "&gt; To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc.\nI agree much more with this framing of the point. I really take issue with calling the effort \"fools gold\" though.\n\nSeparately, I'm not so sure folks have had \"little success\". In the context of \"a long time\". I think folks have had a lot of success at first, but it slowed down considerably over time. I made a previous point about a tradeoff between verifying with \"looking at a program\" vs verifying with \"debugging\" and I think there _is_ a valid argument that we've gotten all the low-hanging fruit from the first and underinvested in the second.",
        "user": "U03US9D90HW",
        "ts": "1662153268.628089",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03US9D90HW",
            "ts": "1662153297.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SIo",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree much more with this framing of the point. I really take issue with calling the effort \"fools gold\" though.\n\nSeparately, I'm not so sure folks have had \"little success\". In the context of \"a long time\". I think folks have had a lot of success at first, but it slowed down considerably over time. I made a previous point about a tradeoff between verifying with \"looking at a program\" vs verifying with \"debugging\" and I think there "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a valid argument that we've gotten all the low-hanging fruit from the first and underinvested in the second."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "7df9378c-3d81-4b12-b4c7-8f97f1b95079",
        "type": "message",
        "text": "As a specific example I think structured programming had pretty considerable impact on understandability in ways that are more significant than similar debugging improvements made at the time... Its been awhile since we've gotten anything as impactful as structured programming though.",
        "user": "U03US9D90HW",
        "ts": "1662153385.013169",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uJoB9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As a specific example I think structured programming had pretty considerable impact on understandability in ways that are more significant than similar debugging improvements made at the time... Its been awhile since we've gotten anything as impactful as structured programming though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dceff37b-3114-4545-a583-b63adb2e4e0b",
        "type": "message",
        "text": "In looking vs. debugging, which is type safety?",
        "user": "U02U0AS3J49",
        "ts": "1662153698.106909",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kv4aT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In looking vs. debugging, which is type safety?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "FDAD52C7-E403-49D8-91A0-F7856B33B128",
        "type": "message",
        "text": "Yeah, I was thinking that was missing from this discussion. It's interesting. Somewhere in between. There's almost three levels you want to consider things at:\n1. How easy is it to understand \u201cjust looking\u201d (human only)\n2. How easy is it to understand with automated verification (machine only)\n3. How easy is it to understand with a debugger (human and machine)",
        "user": "U03US9D90HW",
        "ts": "1662153974.388189",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yatW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I was thinking that was missing from this discussion. It's interesting. Somewhere in between. There's almost three levels you want to consider things at:"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How easy is it to understand \u201cjust looking\u201d (human only)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How easy is it to understand with automated verification (machine only)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How easy is it to understand with a debugger (human and machine)"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "offset": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "65FA3D79-E953-45A5-9F60-A3FE2177136E",
        "type": "message",
        "text": "I'd even argue that some of the verification methods impose complications in program text that makes 1 harder. Complicated type systems can sometimes place a burden on the programmer.",
        "user": "U03US9D90HW",
        "ts": "1662154033.528309",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03US9D90HW",
            "ts": "1662154043.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lxpRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd even argue that some of the verification methods impose complications in program text that makes 1 harder. Complicated type systems can sometimes place a burden on the programmer."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "87980600-e0ec-4a19-bb32-5133acd47ced",
        "type": "message",
        "text": "I divide it primarily between things that seek to make errors impossible, and things that seek to make errors easier to discover, and things that make errors easier to diagnose, and things that make them easier to repair.",
        "user": "U02U0AS3J49",
        "ts": "1662154339.671729",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZIg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I divide it primarily between things that seek to make errors impossible, and things that seek to make errors easier to discover, and things that make errors easier to diagnose, and things that make them easier to repair."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "4ab8597d-5aef-42c7-b356-87f7e7eb9f58",
        "type": "message",
        "text": "E.g. type safety, fuzzing, debugging, and clear syntax.",
        "user": "U02U0AS3J49",
        "ts": "1662154411.947479",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SO+e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "E.g. type safety, fuzzing, debugging, and clear syntax."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "4f134621-5921-4ae5-9a55-8a45a1bfc322",
        "type": "message",
        "text": "I find \"impossible\" and \"easy to repair\" to be usually mutually incompatible.",
        "user": "U02U0AS3J49",
        "ts": "1662154467.619199",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0exB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find \"impossible\" and \"easy to repair\" to be usually mutually incompatible."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "94903460-9632-4dc5-883a-8bb1c67927e4",
        "type": "message",
        "text": "Yeah, I feel like this is true in many contexts. There is definitely a balance between them.",
        "user": "U03US9D90HW",
        "ts": "1662154679.863649",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "plO3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I feel like this is true in many contexts. There is definitely a balance between them."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1661962300.475609",
        "parent_user_id": "UBN9AFS0N"
    }
]