[
    {
        "client_msg_id": "beb9016f-edbd-449b-afc6-dfbbeef14609",
        "type": "message",
        "text": "Was recently looking into \"annotations\" in Self and Java, as well as the related concepts of \"property wrappers\" and \"function builders\" in Swift. Are there other languages with similar features?\n\nAlso, what are the most interesting uses of annotations you've run across?",
        "user": "ULM3U6275",
        "ts": "1650051054.041089",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1650059326.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l+IvI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Was recently looking into \"annotations\" in Self and Java, as well as the related concepts of \"property wrappers\" and \"function builders\" in Swift. Are there other languages with similar features?\n\nAlso, what are the most interesting uses of annotations you've run across?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "reply_count": 13,
        "reply_users_count": 6,
        "latest_reply": "1650255215.281449",
        "reply_users": [
            "UBN9AFS0N",
            "U016VUZGUUQ",
            "UC2A2ARPT",
            "UJBAJNFLK",
            "ULM3U6275",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1650225472.567519"
    },
    {
        "client_msg_id": "7c8c1a1f-f539-4f30-be8a-46b7db2b13d6",
        "type": "message",
        "text": "decorators in python? <https://peps.python.org/pep-0318/>",
        "user": "UBN9AFS0N",
        "ts": "1650054658.635719",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://peps.python.org/pep-0318/",
                "service_icon": "https://peps.python.org/_static/py.png",
                "id": 1,
                "original_url": "https://peps.python.org/pep-0318/",
                "fallback": "PEP 318 \u2013 Decorators for Functions and Methods | peps.python.org",
                "text": "Python Enhancement Proposals (PEPs)",
                "title": "PEP 318 \u2013 Decorators for Functions and Methods | peps.python.org",
                "title_link": "https://peps.python.org/pep-0318/",
                "service_name": "peps.python.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v9P0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "decorators in python? "
                            },
                            {
                                "type": "link",
                                "url": "https://peps.python.org/pep-0318/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dcb3c226-2262-49c3-a92c-02f98fed6133",
        "type": "message",
        "text": "Python decorators. I think Rust calls them annotations as well. <https://elixir-lang.org/getting-started/module-attributes.html#as-annotations|Elixir via Erlang, apparently>. Nim. I'm less sure about C# but I'd bet 5$ they have something like that too. They're pretty common these days.",
        "user": "U016VUZGUUQ",
        "ts": "1650054667.567339",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://elixir-lang.org/getting-started/module-attributes.html#as-annotations",
                "service_icon": "https://elixir-lang.org/favicon.ico",
                "id": 1,
                "original_url": "https://elixir-lang.org/getting-started/module-attributes.html#as-annotations",
                "fallback": "elixir-lang.github.com: Module attributes",
                "text": "Website for Elixir",
                "title": "Module attributes",
                "title_link": "https://elixir-lang.org/getting-started/module-attributes.html#as-annotations",
                "service_name": "elixir-lang.github.com"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "95UE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Python decorators. I think Rust calls them annotations as well. "
                            },
                            {
                                "type": "link",
                                "url": "https://elixir-lang.org/getting-started/module-attributes.html#as-annotations",
                                "text": "Elixir via Erlang, apparently"
                            },
                            {
                                "type": "text",
                                "text": ". Nim. I'm less sure about C# but I'd bet 5$ they have something like that too. They're pretty common these days."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "741be024-63d0-432e-a9f5-d911ff514baf",
        "type": "message",
        "text": "Stage 2 proposal on js <https://github.com/tc39/proposal-decorators>",
        "user": "UBN9AFS0N",
        "ts": "1650054762.880859",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5Ji",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Stage 2 proposal on js "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/tc39/proposal-decorators"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7322a382-7928-469d-b4ce-16d45023e3f1",
        "type": "message",
        "text": "they already exist in typescript",
        "user": "UBN9AFS0N",
        "ts": "1650054771.271389",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a9f1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "they already exist in typescript"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "0F081EA8-EF54-406E-A92B-E886D8FBEC54",
        "type": "message",
        "text": "And now to torpedo this thread \u2014 can someone explain to me how these are meaningfully different from lisp macros?",
        "user": "UC2A2ARPT",
        "ts": "1650074117.432139",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mKC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And now to torpedo this thread \u2014 can someone explain to me how these are meaningfully different from lisp macros?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "7AD49FAE-262D-46AD-AF98-CDA5B100CB3F",
        "type": "message",
        "text": "Or, on the other hand, higher order functions? Are decorators just... sort of like a HOF or macro, but applied in a specific way, and thus it's useful to introduce a new term for them to help us talk about this particular usage? Or are they truly a new and different and fully general sort of thing?",
        "user": "UC2A2ARPT",
        "ts": "1650074453.472179",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J62E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Or, on the other hand, higher order functions? Are decorators just... sort of like a HOF or macro, but applied in a specific way, and thus it's useful to introduce a new term for them to help us talk about this particular usage? Or are they truly a new and different and fully general sort of thing?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "0a1088ee-a0f5-4def-a4fd-3bf0e3fc6850",
        "type": "message",
        "text": "Well, to the extent you can even consider them as a group, considering the very wide variety in semantics, they're pretty sharply limited (by design) relative to proper macros. The others seem to be more complicated, but Python decorators are literally sugar for wrapping the advisor annotated item in a function call. I think Rust annotations are just tags that can be processed by some other build-time code.",
        "user": "U016VUZGUUQ",
        "ts": "1650074458.718429",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "98t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well, to the extent you can even consider them as a group, considering the very wide variety in semantics, they're pretty sharply limited (by design) relative to proper macros. The others seem to be more complicated, but Python decorators are literally sugar for wrapping the advisor annotated item in a function call. I think Rust annotations are just tags that can be processed by some other build-time code."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "7abee91c-6e69-47d3-b58d-a4194eb96028",
        "type": "message",
        "text": "<@UC2A2ARPT> Python decorators are just syntactic sugar for a particular use case of higher-order function. But since readability is an important criterion for Python programmers, and since Python does not have anything like Lisp macros, syntactic sugar can make a big difference.",
        "user": "UJBAJNFLK",
        "ts": "1650101797.303849",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t+k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " Python decorators are just syntactic sugar for a particular use case of higher-order function. But since readability is an important criterion for Python programmers, and since Python does not have anything like Lisp macros, syntactic sugar can make a big difference."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UDQBTJ211"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0c4f651a-5f44-4d2b-b2b5-34ff8f3530ac",
        "type": "message",
        "text": "I'm more interested in the idea of an abstraction around slots (instance variable name and value) that manages meta data and computation related to it than a particular feature of this general area (such as decorators). Yes, we can implement decorators with macros etc, but that's just one small feature related to this area.",
        "user": "ULM3U6275",
        "ts": "1650218325.226179",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sny",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm more interested in the idea of an abstraction around slots (instance variable name and value) that manages meta data and computation related to it than a particular feature of this general area (such as decorators). Yes, we can implement decorators with macros etc, but that's just one small feature related to this area."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5cc8c709-88e7-4544-966e-416e2930354a",
        "type": "message",
        "text": "clojure supports metadata for any datastructure <https://clojuredocs.org/clojure.core/with-meta>",
        "user": "UBN9AFS0N",
        "ts": "1650220237.257529",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gsh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "clojure supports metadata for any datastructure "
                            },
                            {
                                "type": "link",
                                "url": "https://clojuredocs.org/clojure.core/with-meta"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "B80B76B1-0C12-4BEF-829A-78EF683461B2",
        "type": "message",
        "text": "<@ULM3U6275> Pharo Smalltalk has something like that, see <https://hal.inria.fr/hal-00641716/document|https://hal.inria.fr/hal-00641716/document>. Slots can be defined by classes, making them almost objects themselves. I have used this myself only once, to trace and record slot accesses. It\u2019s surprisingly straightforward to use.",
        "user": "UJBAJNFLK",
        "ts": "1650225472.567519",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ESYEE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " Pharo Smalltalk has something like that, see "
                            },
                            {
                                "type": "link",
                                "url": "https://hal.inria.fr/hal-00641716/document",
                                "text": "https://hal.inria.fr/hal-00641716/document"
                            },
                            {
                                "type": "text",
                                "text": ". Slots can be defined by classes, making them almost objects themselves. I have used this myself only once, to trace and record slot accesses. It\u2019s surprisingly straightforward to use."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "71e0d20f-e6cb-44c8-9bc6-f36f9b244daf",
        "type": "message",
        "text": "Rubyist checking in.  At some point (probably a decade or two ago), the method definition construct was made to return the method name so that you can easily write your own decorators.  This means that when you write `synchronize memoize def calculate(something); ...; end`, the interpreter:\n1. defines the `calculate` method,\n2. sends the symbol `:calculate` to the `memoize` class method, which will presumably define a new version of `calculate` and return `:calculate`, so that the interpreter\n3. again sends the symbol `:calculate` to the `synchronize` class method, which will presumably wrap `calculate` again.",
        "user": "UA14TGLTC",
        "ts": "1650255045.149519",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gSc7r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rubyist checking in.  At some point (probably a decade or two ago), the method definition construct was made to return the method name so that you can easily write your own decorators.  This means that when you write "
                            },
                            {
                                "type": "text",
                                "text": "synchronize memoize def calculate(something); ...; end",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", the interpreter:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "defines the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " method,"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "sends the symbol "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " to the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "memoize",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " class method, which will presumably define a new version of "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " and return "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ", so that the interpreter"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "again sends the symbol "
                                    },
                                    {
                                        "type": "text",
                                        "text": ":calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " to the "
                                    },
                                    {
                                        "type": "text",
                                        "text": "synchronize",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " class method, which will presumably wrap "
                                    },
                                    {
                                        "type": "text",
                                        "text": "calculate",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " again."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "0df3c0d5-bfa3-4afb-8aa8-98579e1d4b75",
        "type": "message",
        "text": "In Ruby, `public`, `protected`, and `private` annotations are all methods that one could (and should not) override.",
        "user": "UA14TGLTC",
        "ts": "1650255215.281449",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rY/8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Ruby, "
                            },
                            {
                                "type": "text",
                                "text": "public",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "protected",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and "
                            },
                            {
                                "type": "text",
                                "text": "private",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " annotations are all methods that one could (and should not) override."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650051054.041089",
        "parent_user_id": "ULM3U6275"
    }
]