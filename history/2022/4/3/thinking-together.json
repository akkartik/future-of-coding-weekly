[
    {
        "client_msg_id": "e625ed92-14f5-4cc1-b54b-9452a47e401a",
        "type": "message",
        "text": "I'm interested in using call graphs/control flow in a hierarchical way to understand programs better.  The problem is there seems to be two extremes - high level diagrams done manually and low level call graphs generated by tools.   A manual drawing with boxes and arrows is often used when describing a program at the highest level.  While it works, one question is how to move to the next level of detail?  Someone has to do that manually as well.  These diagrams aren't connected to the source and can get out of date.  The structure is going to change slowly at the highest level and so keeping up-to-date manually isn't that much trouble.  More detailed levels, though, can change more frequently and keeping them up-to-date is more work.   At the other extreme, tools to generate callgraphs give all the functions.  They can filter by time, number of calls or call stack depth, but those doesn't necessarily correlate to what's important conceptually.   I'm wondering if there's any work on anything between these two extremes?  Both in generating it and visualizing it. (Searching online for 'hierarchical call graph' gives research on automated and machine learning approaches to discovering a hierarchy - interesting as research, but not what I'm after here.  I would prefer something manual like adding program annotations or creating filtering terms - something that can be automated as part of a build or CI process.)",
        "user": "UNS7QDKFV",
        "ts": "1649010832.432969",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ooTl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm interested in using call graphs/control flow in a hierarchical way to understand programs better.  The problem is there seems to be two extremes - high level diagrams done manually and low level call graphs generated by tools.   A manual drawing with boxes and arrows is often used when describing a program at the highest level.  While it works, one question is how to move to the next level of detail?  Someone has to do that manually as well.  These diagrams aren't connected to the source and can get out of date.  The structure is going to change slowly at the highest level and so keeping up-to-date manually isn't that much trouble.  More detailed levels, though, can change more frequently and keeping them up-to-date is more work.   At the other extreme, tools to generate callgraphs give all the functions.  They can filter by time, number of calls or call stack depth, but those doesn't necessarily correlate to what's important conceptually.   I'm wondering if there's any work on anything between these two extremes?  Both in generating it and visualizing it. (Searching online for 'hierarchical call graph' gives research on automated and machine learning approaches to discovering a hierarchy - interesting as research, but not what I'm after here.  I would prefer something manual like adding program annotations or creating filtering terms - something that can be automated as part of a build or CI process.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649010832.432969",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1649025446.937819",
        "reply_users": [
            "UCUSW7WVD"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "2cd07a32-9a43-4bcc-9e82-a4de2fd1b67b",
        "type": "message",
        "text": "I spent some time thinking about this a few years ago, but eventually moved on for a couple of reasons:\n\n\u2022 I had lots of different questions about codebases that required many different visualizations. I wasn't able to come up with a single map that's useful in all situations. Code has far more dimensionality than regular space so the map metaphor is perhaps not as useful. (Though I think zoomable UIs are under-explored.)\n\u2022 I observed that good tools immediately cause people to create larger, more complex messes that outgrow them. So I started questioning why programs get so large and complex, and whether that's a good thing.\nFor example, I now sometimes build little text-mode programs that anyone can edit while using them, and they come with a simple big-picture view that's just a stratification of the call graph: <https://archive.org/details/akkartik-2021-11-14>",
        "user": "UCUSW7WVD",
        "ts": "1649025446.937819",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "m/9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I spent some time thinking about this a few years ago, but eventually moved on for a couple of reasons:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I had lots of different questions about codebases that required many different visualizations. I wasn't able to come up with a single map that's useful in all situations. Code has far more dimensionality than regular space so the map metaphor is perhaps not as useful. (Though I think zoomable UIs are under-explored.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I observed that good tools immediately cause people to create larger, more complex messes that outgrow them. So I started questioning why programs get so large and complex, and whether that's a good thing."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFor example, I now sometimes build little text-mode programs that anyone can edit while using them, and they come with a simple big-picture view that's just a stratification of the call graph: "
                            },
                            {
                                "type": "link",
                                "url": "https://archive.org/details/akkartik-2021-11-14"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649010832.432969",
        "parent_user_id": "UNS7QDKFV"
    }
]