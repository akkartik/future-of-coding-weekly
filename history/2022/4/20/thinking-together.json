[
    {
        "client_msg_id": "cd2248d8-8bff-4b0c-8857-519064fd70ed",
        "type": "message",
        "text": "Straw poll... As a rule, which is more challenging in the software systems you work on:\n\u2022 :exploding_head: Changing an algorithm.  (Example: Need to switch to recursion because nested loops aren't going to cut it anymore.)\n\u2022 :sob: Changing the data model.  (Example: A user should be able to register more than one email address.)\n\u2022 :open_mouth: Some other change is my main source of stress.  (Example: It always takes an unreasonable amount futzing to convince the linker to use the updated version of a library.)",
        "user": "UA14TGLTC",
        "ts": "1650424146.803409",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PUsDP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Straw poll... As a rule, which is more challenging in the software systems you work on:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "emoji",
                                        "name": "exploding_head"
                                    },
                                    {
                                        "type": "text",
                                        "text": " Changing an algorithm.  (Example: Need to switch to recursion because nested loops aren't going to cut it anymore.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "emoji",
                                        "name": "sob"
                                    },
                                    {
                                        "type": "text",
                                        "text": " Changing the data model.  (Example: A user should be able to register more than one email address.)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "emoji",
                                        "name": "open_mouth"
                                    },
                                    {
                                        "type": "text",
                                        "text": " Some other change is my main source of stress.  (Example: It always takes an unreasonable amount futzing to convince the linker to use the updated version of a library.)"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "reply_count": 6,
        "reply_users_count": 5,
        "latest_reply": "1650618902.385519",
        "reply_users": [
            "UC2A2ARPT",
            "U03CEGR3HSL",
            "UDQBTJ211",
            "UK3LH8CF5",
            "U0245E9RB2B"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "sob",
                "users": [
                    "UC2A2ARPT",
                    "U03CEGR3HSL",
                    "UEBG0NPDK",
                    "U01SUK9M8R2",
                    "U023V63MF6V",
                    "U013G7Z14TH",
                    "U02E4DAQGSZ",
                    "UCGAK10LS",
                    "UDQBTJ211",
                    "U02U0AS3J49"
                ],
                "count": 10
            },
            {
                "name": "open_mouth",
                "users": [
                    "UCGR73CAY",
                    "U03C0DRJB8B",
                    "U016VUZGUUQ",
                    "U0245E9RB2B"
                ],
                "count": 4
            },
            {
                "name": "yin_yang",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f326cc8a-7089-42d0-ac35-021ed4709115",
        "type": "message",
        "text": "But also \u2014 changing the UI? Because the UI is always the hardest part?\n\nBut also \u2014 changing user/stakeholder expectations?",
        "user": "UC2A2ARPT",
        "ts": "1650424701.247469",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t1p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But also \u2014 changing the UI? Because the UI is always the hardest part?\n\nBut also \u2014 changing user/stakeholder expectations?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC",
        "reactions": [
            {
                "name": "rolling_on_the_floor_laughing",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0756ed91-188f-466f-8d8a-9a57840198a9",
        "type": "message",
        "text": "I said data model, but I think the best way to make it hurt less that I know of so far is the Parnas approach. <https://dl.acm.org/doi/10.1145/361598.361623|https://dl.acm.org/doi/10.1145/361598.361623>",
        "user": "U03CEGR3HSL",
        "ts": "1650424780.321969",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uHD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I said data model, but I think the best way to make it hurt less that I know of so far is the Parnas approach. "
                            },
                            {
                                "type": "link",
                                "url": "https://dl.acm.org/doi/10.1145/361598.361623",
                                "text": "https://dl.acm.org/doi/10.1145/361598.361623"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "e0e0b34a-bf92-4cbf-ab50-8cf42ed046a2",
        "type": "message",
        "text": "[moved from top level, original post by <@U01HKV85Y1J>]\n\nchanging the data model is always more challenging, imho, since data comes first. for challenge 3, just use NixOS: problem solved :wink:",
        "user": "UC2A2ARPT",
        "ts": "1650425526.643989",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wxf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[moved from top level, original post by "
                            },
                            {
                                "type": "user",
                                "user_id": "U01HKV85Y1J"
                            },
                            {
                                "type": "text",
                                "text": "]\n\nchanging the data model is always more challenging, imho, since data comes first. for challenge 3, just use NixOS: problem solved "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC"
    },
    {
        "client_msg_id": "f17659ac-b812-44d0-8858-8f34c8bd5ede",
        "type": "message",
        "text": "I went :sob: . An algorithm is relatively self-contained. The implications of changing a data model can be impossible to even enumerate.",
        "user": "UDQBTJ211",
        "ts": "1650449186.498479",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3Xc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I went "
                            },
                            {
                                "type": "emoji",
                                "name": "sob"
                            },
                            {
                                "type": "text",
                                "text": " . An algorithm is relatively self-contained. The implications of changing a data model can be impossible to even enumerate."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2f4655de-eed1-4124-a5ed-3a1b5adf5d2c",
        "type": "message",
        "text": "I've been pondering how to define a metric for how programmable a user's overall environment is. One thought I've had is to add up, for each application used in an average day, the percent of time it is used times the percent of features that can be programmed. Call it something like Overall Average Programmability.\n\nI know this doesn't account for differences in how easy it is to use the programmability of a given app (mailx is much easier to automate than Gmail) or the importance of individual features that can or cannot be automated, or the ease of integrating applications with different built-in scripting languages, but I think this is a relatively well-defined metric that might still contain some meaning.\n\nDoes this sound like a meaningful and/or useful concept?\n\nWould you estimate, over the course of your career, that your environment's Overall Average Programmability has trended upwards or downwards?\n\nAny thoughts on the forces that may have impacted the trends?\n\nPersonally, I think mine has trended downwards, and I suspect it has something to do with the increasing roles played in my life by mobile apps, web apps, and services that make their money from advertising and want to maximize user engagement rather than productivity.\n\nThoughts?",
        "user": "U03CEGR3HSL",
        "ts": "1650464577.515109",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jm1j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been pondering how to define a metric for how programmable a user's overall environment is. One thought I've had is to add up, for each application used in an average day, the percent of time it is used times the percent of features that can be programmed. Call it something like Overall Average Programmability.\n\nI know this doesn't account for differences in how easy it is to use the programmability of a given app (mailx is much easier to automate than Gmail) or the importance of individual features that can or cannot be automated, or the ease of integrating applications with different built-in scripting languages, but I think this is a relatively well-defined metric that might still contain some meaning.\n\nDoes this sound like a meaningful and/or useful concept?\n\nWould you estimate, over the course of your career, that your environment's Overall Average Programmability has trended upwards or downwards?\n\nAny thoughts on the forces that may have impacted the trends?\n\nPersonally, I think mine has trended downwards, and I suspect it has something to do with the increasing roles played in my life by mobile apps, web apps, and services that make their money from advertising and want to maximize user engagement rather than productivity.\n\nThoughts?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "reply_count": 8,
        "reply_users_count": 3,
        "latest_reply": "1650781756.976969",
        "reply_users": [
            "UDQBTJ211",
            "UCUSW7WVD",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "afceddba-339c-4f21-bf69-242ac94cd044",
        "type": "message",
        "text": ":open_mouth: Understanding all the code, including code not in my codebase, to know if the change I want to make is okay. Actually making the changes to an algorithm or a data model is not too hard, in isolation.\n\nI think data models in practice are typically harder because other code depends on it in a way that I have to understand that other code too. That other code may not even be accessible to me. (A customers codebase for example). Algorithms can have that implication, but not as often.\n\nSince I\u2019m guessing this question is asked partially to motivate which problems to solve, I do think there are ways to tackle this.\n\nFirst, since others code in my scenario is a blackbox, we can\u2019t just make tools for actually understanding that code, it isn\u2019t accessible. But what we could do is make it easy to explore implications of changes.\n\nTake an algorithm change. Instead of sending a request for every one message, I aggregate every 10 messages and send them. What are the implications of this? What if I never get 10 messages? What if I overflow some bounds? What about retries? Would my accuracy decrees if my failure rate increased? Would this change be effective? Would it reduce my downstream costs?\n\nConsider a data model change. I have data structure A and I want to have data structure B. Is there a bidirectional mapping between them? What will the increase in my storage be? If I need to convert between the two, at what do I need to support? I know that I need X,Y, and Z access patterns. Are those efficient with the new data structure?\n\nAll of these things are questions we have to ask ourselves as we are making changes in systems. But we have no way to watch them play out. No way to tweak the parameters.\n\nReally there are two tools trying to help us 1) Whiteboards 2) Formal models.Surely there is a nicer middle ground here.",
        "user": "UK3LH8CF5",
        "ts": "1650481404.475269",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PCnN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "open_mouth"
                            },
                            {
                                "type": "text",
                                "text": " Understanding all the code, including code not in my codebase, to know if the change I want to make is okay. Actually making the changes to an algorithm or a data model is not too hard, in isolation.\n\nI think data models in practice are typically harder because other code depends on it in a way that I have to understand that other code too. That other code may not even be accessible to me. (A customers codebase for example). Algorithms can have that implication, but not as often.\n\nSince I\u2019m guessing this question is asked partially to motivate which problems to solve, I do think there are ways to tackle this.\n\nFirst, since others code in my scenario is a blackbox, we can\u2019t just make tools for actually understanding that code, it isn\u2019t accessible. But what we could do is make it easy to explore implications of changes.\n\nTake an algorithm change. Instead of sending a request for every one message, I aggregate every 10 messages and send them. What are the implications of this? What if I never get 10 messages? What if I overflow some bounds? What about retries? Would my accuracy decrees if my failure rate increased? Would this change be effective? Would it reduce my downstream costs?\n\nConsider a data model change. I have data structure A and I want to have data structure B. Is there a bidirectional mapping between them? What will the increase in my storage be? If I need to convert between the two, at what do I need to support? I know that I need X,Y, and Z access patterns. Are those efficient with the new data structure?\n\nAll of these things are questions we have to ask ourselves as we are making changes in systems. But we have no way to watch them play out. No way to tweak the parameters.\n\nReally there are two tools trying to help us 1) Whiteboards 2) Formal models.Surely there is a nicer middle ground here."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cd88fed1-be4c-48e1-8ba1-c4fd5da85c8e",
        "type": "message",
        "text": "I don't think it's a trend I've noticed. I would say the programmability of almost everything has stayed consistently low.",
        "user": "UDQBTJ211",
        "ts": "1650486717.190599",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UP/9p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think it's a trend I've noticed. I would say the programmability of almost everything has stayed consistently low."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "445b19c0-c7f9-48a1-a111-b58f599cdb55",
        "type": "message",
        "text": ":open_mouth: I spend inordinate amounts of time fighting with libraries and frameworks that I use without completely understanding. E.g., I recently migrated the backend of a web app from .NET Core to .NET Framework, because I needed a specific feature. It took a week to fix all the things that broke.",
        "user": "U0245E9RB2B",
        "ts": "1650618902.385519",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hWJF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "open_mouth"
                            },
                            {
                                "type": "text",
                                "text": " I spend inordinate amounts of time fighting with libraries and frameworks that I use without completely understanding. E.g., I recently migrated the backend of a web app from .NET Core to .NET Framework, because I needed a specific feature. It took a week to fix all the things that broke."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650424146.803409",
        "parent_user_id": "UA14TGLTC",
        "reactions": [
            {
                "name": "open_mouth",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d1218f6d-99ce-4d11-bace-d3b5e33ed88a",
        "type": "message",
        "text": "Things did feel more programmable 20 years ago. I spent more of my computer time on a Unix server that encouraged more scripting. Now I do more on devices (phones) that I can't program. I've made changes to my mail client when it used to be Pine. I can no longer do that now that it's a webmail client.\n\nEven on programmable devices the picture feels worse. Every single open source project has gotten larger and more complex and harder to build over the last 20 years. Pine is defunct, but observe:\n\nmutt mail client: 41kLoC in 1998 -&gt; 95kLoC now. required perl in 1998, now also requires python.\n\ntmux window manager: 24kLoC in 2009 -&gt; 64kLoC now. Required perl in 1998, now also requires awk and yacc.\n\nOne confounding factor: I wonder how much of things seeming worse has to do with me just burning out on this sort of hacking activity over the years.",
        "user": "UCUSW7WVD",
        "ts": "1650688301.617309",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c9T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Things did feel more programmable 20 years ago. I spent more of my computer time on a Unix server that encouraged more scripting. Now I do more on devices (phones) that I can't program. I've made changes to my mail client when it used to be Pine. I can no longer do that now that it's a webmail client.\n\nEven on programmable devices the picture feels worse. Every single open source project has gotten larger and more complex and harder to build over the last 20 years. Pine is defunct, but observe:\n\nmutt mail client: 41kLoC in 1998 -> 95kLoC now. required perl in 1998, now also requires python.\n\ntmux window manager: 24kLoC in 2009 -> 64kLoC now. Required perl in 1998, now also requires awk and yacc.\n\nOne confounding factor: I wonder how much of things seeming worse has to do with me just burning out on this sort of hacking activity over the years."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK",
                    "U03CEGR3HSL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0d581376-3920-4f61-94cc-968c37e7a90e",
        "type": "message",
        "text": "My experience is much the same as <@UCUSW7WVD>'s. The one environment that feels as programmable today as it did 15 years ago is Emacs. I suspect Emacs itself also grew bigger, if only for GUI improvements such as better rendering. But from the point of view of add-ons and customization, it's constant.",
        "user": "UJBAJNFLK",
        "ts": "1650702843.175699",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v0m2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My experience is much the same as "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "'s. The one environment that feels as programmable today as it did 15 years ago is Emacs. I suspect Emacs itself also grew bigger, if only for GUI improvements such as better rendering. But from the point of view of add-ons and customization, it's constant."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03CEGR3HSL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c764f519-dfae-4fc2-a0e1-1751ae5ebec4",
        "type": "message",
        "text": "That was tantalizing enough that I did some more digging.\n\nEmacs in 1997 (v20.1): 152kLoC C, 386kLoC lisp, 1010 lisp DEFUNs defined in C, 15k defuns defined in lisp\nEmacs in 2022: 405kLoC C, 1.25MLoC lisp, 1780 lisp DEFUNs defined in C, 42k defuns defined in lisp\n\nThis is pretty blunt, of course. I'm just counting `DEFUN` in the `src/` directory and `^(defun`  in the `lisp/` directory. Let me know if there's a more accurate approach. But my impression is that Emacs pays so much attention to backwards compatibility that you are able to ignore new affordances for add-ons and customization until you need to go find something.\n\nFor completeness:\n\nVim: 275kLoC in 2006 (v7.0) -&gt; 390kLoC now\nNeovim: 167kLoC in 2015 (v0.1.0) -&gt; 238kLoC now\n\nVery interesting that Neovim is smaller now than Vim was in 2006.\n\ntl;dr - `sloccount` is a useful tool!",
        "user": "UCUSW7WVD",
        "ts": "1650727820.667669",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rL9d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That was tantalizing enough that I did some more digging.\n\nEmacs in 1997 (v20.1): 152kLoC C, 386kLoC lisp, 1010 lisp DEFUNs defined in C, 15k defuns defined in lisp\nEmacs in 2022: 405kLoC C, 1.25MLoC lisp, 1780 lisp DEFUNs defined in C, 42k defuns defined in lisp\n\nThis is pretty blunt, of course. I'm just counting "
                            },
                            {
                                "type": "text",
                                "text": "DEFUN",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in the "
                            },
                            {
                                "type": "text",
                                "text": "src/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " directory and "
                            },
                            {
                                "type": "text",
                                "text": "^(defun ",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in the "
                            },
                            {
                                "type": "text",
                                "text": "lisp/",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " directory. Let me know if there's a more accurate approach. But my impression is that Emacs pays so much attention to backwards compatibility that you are able to ignore new affordances for add-ons and customization until you need to go find something.\n\nFor completeness:\n\nVim: 275kLoC in 2006 (v7.0) -> 390kLoC now\nNeovim: 167kLoC in 2015 (v0.1.0) -> 238kLoC now\n\nVery interesting that Neovim is smaller now than Vim was in 2006.\n\ntl;dr - "
                            },
                            {
                                "type": "text",
                                "text": "sloccount",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a useful tool!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03CEGR3HSL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e8500f36-296d-4f5a-8d11-448b34ccd696",
        "type": "message",
        "text": "Another potential metric that occurs to me here is \"build difficulty index\". Not really covered at all by my stats above.",
        "user": "UCUSW7WVD",
        "ts": "1650728125.332199",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1650728167.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6iaZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another potential metric that occurs to me here is \"build difficulty index\". Not really covered at all by my stats above."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03CEGR3HSL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "250db856-6137-4345-82c4-252f10055409",
        "type": "message",
        "text": "My point is that I don't really care about the size of Emacs. I do look at Emacs source code (the Lisp part) quite often, but I get there by navigating from my own code to layers below. As long as the number of layers I have to go through doesn't increase, the size of the Lisp code is irrelevant for me.\n\nAs you note, Emacs values backwards compatibility highly, which is something I do care about. Perhaps even more importantly, Emacs values programmability, and therefore offers good support for exploring its own source code.\n\nSo a good metric would perhaps be \"number of navigation steps until you hit a primitive\" (which for Emacs would be a function implemented in C)&gt;",
        "user": "UJBAJNFLK",
        "ts": "1650731586.091999",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jxj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My point is that I don't really care about the size of Emacs. I do look at Emacs source code (the Lisp part) quite often, but I get there by navigating from my own code to layers below. As long as the number of layers I have to go through doesn't increase, the size of the Lisp code is irrelevant for me.\n\nAs you note, Emacs values backwards compatibility highly, which is something I do care about. Perhaps even more importantly, Emacs values programmability, and therefore offers good support for exploring its own source code.\n\nSo a good metric would perhaps be \"number of navigation steps until you hit a primitive\" (which for Emacs would be a function implemented in C)>"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03CEGR3HSL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bc258270-6ffb-4c59-89e0-3ed2aaf139c7",
        "type": "message",
        "text": "I'm kinda handwaving that the amount of elisp growing at the same pace as C above suggests there's no difference between C and Lisp once you start poking at the internals of the elisp. But if you're just _using_ the elisp primitives, the surface area of names (which I'm estimating by counting `defun`s) does seem to grow a bit slower than the total volume of Emacs code.",
        "user": "UCUSW7WVD",
        "ts": "1650733506.325319",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JwG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm kinda handwaving that the amount of elisp growing at the same pace as C above suggests there's no difference between C and Lisp once you start poking at the internals of the elisp. But if you're just "
                            },
                            {
                                "type": "text",
                                "text": "using",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the elisp primitives, the surface area of names (which I'm estimating by counting "
                            },
                            {
                                "type": "text",
                                "text": "defun",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "s) does seem to grow a bit slower than the total volume of Emacs code."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "6e40a3cb-212c-484a-a1fa-8be052d99a2f",
        "type": "message",
        "text": "Surface matters more than volume, indeed, but any simple metric misses the importance of modularity. I suppose Emacs' size made a jump when org-mode was adopted into the core distribution, but this had no impact on people not using org-mode. They could (still can) simply ignore it.",
        "user": "UJBAJNFLK",
        "ts": "1650781756.976969",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZhJN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Surface matters more than volume, indeed, but any simple metric misses the importance of modularity. I suppose Emacs' size made a jump when org-mode was adopted into the core distribution, but this had no impact on people not using org-mode. They could (still can) simply ignore it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1650464577.515109",
        "parent_user_id": "U03CEGR3HSL"
    }
]