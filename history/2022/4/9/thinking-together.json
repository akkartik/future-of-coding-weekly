[
    {
        "client_msg_id": "520683c1-1f55-4fa4-8ed1-b637b57e6337",
        "type": "message",
        "text": "People admire Lisp's \"elegance\" in that it only has a single built-in datastructure - lists `(a b c)`. Clojure, on the other hand is generally admired for being more \"practical\". One of the main things Clojure introduced is vectors `[a b c]`, and maps `{:a b, :c d}` as first class syntax. I was reading <https://git.eta.st/eta/intertube/src/branch/master/trackernet.lisp#L93|some Lisp> this week and my brain kept grating/complaining because I was seeing what are conceptually hashmaps written as what I was interpreting as a lists of pairs, something which I \"know\" to be different.\n\nConversely, I have always thought it was annoying that C++ has three different operators (`::`, `.`, `-&gt;`) that all essentially mean \"member of\". Would C# be better if you had to say `System::Console.Print()` instead of `System.Console.Print()`? No, I think most people would rarely feel the need to conceptually distinguish between these things, the C++ syntax is just annoying noise to me.\n\n*What is it that distinguishes Clojure's brilliant decision to expand the syntax, from C# brilliant decision to compress the syntax?*\n\nIt implies to me that if there is a scale of simplicity-to-expressiveness, then humans just happen to sit at particular point on it. There's no particular \"reason\" for why these changes were right other than \"they'd gone too far that way, go back this way\". There's a local maximum somewhere in the middle.\n\nI have been thinking about this simplicity-to-expressiveness scale recently as it irrationally annoys me that on WikiData, \"instance of\" is \"just another relationship\" (it's <https://www.wikidata.org/wiki/Property:P31|P31> - <https://www.wikidata.org/wiki/Property:P27|\"citizen of\" is P27>!).\n\nI think that RDF is far too far towards the \"elegance\" end of the spectrum and would greatly benefit from a Clojure-style acknowledgement that some things are more different, and should be more differentiated. Yeah, it's mildly interesting that Node-Rel-Node triples is all you need to describe an ontology, but that's not actually how people think about the world...",
        "user": "UDQBTJ211",
        "ts": "1649508703.704979",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UDQBTJ211",
            "ts": "1649508782.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LSN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "People admire Lisp's \"elegance\" in that it only has a single built-in datastructure - lists "
                            },
                            {
                                "type": "text",
                                "text": "(a b c)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Clojure, on the other hand is generally admired for being more \"practical\". One of the main things Clojure introduced is vectors "
                            },
                            {
                                "type": "text",
                                "text": "[a b c]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and maps "
                            },
                            {
                                "type": "text",
                                "text": "{:a b, :c d}",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as first class syntax. I was reading "
                            },
                            {
                                "type": "link",
                                "url": "https://git.eta.st/eta/intertube/src/branch/master/trackernet.lisp#L93",
                                "text": "some Lisp"
                            },
                            {
                                "type": "text",
                                "text": " this week and my brain kept grating/complaining because I was seeing what are conceptually hashmaps written as what I was interpreting as a lists of pairs, something which I \"know\" to be different.\n\nConversely, I have always thought it was annoying that C++ has three different operators ("
                            },
                            {
                                "type": "text",
                                "text": "::",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": ".",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "->",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ") that all essentially mean \"member of\". Would C# be better if you had to say "
                            },
                            {
                                "type": "text",
                                "text": "System::Console.Print()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead of "
                            },
                            {
                                "type": "text",
                                "text": "System.Console.Print()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? No, I think most people would rarely feel the need to conceptually distinguish between these things, the C++ syntax is just annoying noise to me.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "What is it that distinguishes Clojure's brilliant decision to expand the syntax, from C# brilliant decision to compress the syntax?",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt implies to me that if there is a scale of simplicity-to-expressiveness, then humans just happen to sit at particular point on it. There's no particular \"reason\" for why these changes were right other than \"they'd gone too far that way, go back this way\". There's a local maximum somewhere in the middle.\n\nI have been thinking about this simplicity-to-expressiveness scale recently as it irrationally annoys me that on WikiData, \"instance of\" is \"just another relationship\" (it's "
                            },
                            {
                                "type": "link",
                                "url": "https://www.wikidata.org/wiki/Property:P31",
                                "text": "P31"
                            },
                            {
                                "type": "text",
                                "text": " - "
                            },
                            {
                                "type": "link",
                                "url": "https://www.wikidata.org/wiki/Property:P27",
                                "text": "\"citizen of\" is P27"
                            },
                            {
                                "type": "text",
                                "text": "!).\n\nI think that RDF is far too far towards the \"elegance\" end of the spectrum and would greatly benefit from a Clojure-style acknowledgement that some things are more different, and should be more differentiated. Yeah, it's mildly interesting that Node-Rel-Node triples is all you need to describe an ontology, but that's not actually how people think about the world..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "reply_count": 7,
        "reply_users_count": 5,
        "latest_reply": "1649562377.640379",
        "reply_users": [
            "UEBG0NPDK",
            "U02U0AS3J49",
            "UGWUJUZHT",
            "U016VUZGUUQ",
            "UBKNXPBAB"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "fireworks",
                "users": [
                    "U02M6PM725T"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "90353AA0-49CA-47F8-8612-5B4A8936FCBE",
        "type": "message",
        "text": "In the C++ case it's a distinction without a difference. In the lisp case it's a difference without a distinction.",
        "user": "UEBG0NPDK",
        "ts": "1649517032.800189",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M0P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the C++ case it's a distinction without a difference. In the lisp case it's a difference without a distinction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U016VUZGUUQ",
                    "UJBAJNFLK",
                    "U013ZLJARC7",
                    "UQ706GB9U",
                    "U0245E9RB2B"
                ],
                "count": 5
            }
        ]
    },
    {
        "client_msg_id": "7011B221-432D-44FF-BBC7-3D4C674C2C15",
        "type": "message",
        "text": "Differences and distinctions should match 1:1",
        "user": "UEBG0NPDK",
        "ts": "1649517079.681229",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eyC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Differences and distinctions should match 1:1"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "0E9344D8-94B0-465C-AA39-1BD49F3E4A05",
        "type": "message",
        "text": "Daniel Jackson's concept modeling work does a good job of giving a framework for why",
        "user": "UEBG0NPDK",
        "ts": "1649517126.837289",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Rg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Daniel Jackson's concept modeling work does a good job of giving a framework for why"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UHZUS56SV"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "146911ef-03b5-4767-8144-d6ca51d30e1e",
        "type": "message",
        "text": "Tools, tasks, and people are a triple. If you keep two the same you can find a local maximum for the third. But what you learn doing that isn't transferrable to different tasks, tools, and people. And maximizing only one would have to be justified by expecting the other two never to change. It's never just one spectrum, like \"elegance\". With Clojure and C#, it might be that they were opposite sides of the same local maximum, because the task and people are similar. Maybe not. RDF has a completely different triple, so the lessons aren't transferable, I would expect. I would also say that if a tool doesn't reflect how people think about the world that doesn't necessarily mean there is anything wrong with the tool. It might suggest the utility of another, different tool, aimed at different (or just more) people.",
        "user": "U02U0AS3J49",
        "ts": "1649518479.374759",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BO7I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Tools, tasks, and people are a triple. If you keep two the same you can find a local maximum for the third. But what you learn doing that isn't transferrable to different tasks, tools, and people. And maximizing only one would have to be justified by expecting the other two never to change. It's never just one spectrum, like \"elegance\". With Clojure and C#, it might be that they were opposite sides of the same local maximum, because the task and people are similar. Maybe not. RDF has a completely different triple, so the lessons aren't transferable, I would expect. I would also say that if a tool doesn't reflect how people think about the world that doesn't necessarily mean there is anything wrong with the tool. It might suggest the utility of another, different tool, aimed at different (or just more) people."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "566d63c5-2030-4513-9827-d829205c9721",
        "type": "message",
        "text": "IMO...\n\nThe beauty of assembler, lisp, lambda calculus, triples, etc. is that they have \u201cno syntax\u201d and *don\u2019t restrict* what you can do.\n\nThe beauty of C++, Smalltalk, Clojure, etc. is that they \u201chave syntax\u201d and *restrict* what you can do.\n\n\u201cLocal maximum\u201d is just that - local.  There are many local maxima.  Schmooing all possible notations into \u201cone language to rule them all\u201d results in complexity, poor UX, epicycles, watered-down unions of features, etc., etc.\n\nDisclaimer: I am a Lisper and a PEGer (Ohm-JS).  Syntax is cheap.  Deprecate programming languages.",
        "user": "UGWUJUZHT",
        "ts": "1649522470.505519",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TJ+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IMO...\n\nThe beauty of assembler, lisp, lambda calculus, triples, etc. is that they have \u201cno syntax\u201d and"
                            },
                            {
                                "type": "text",
                                "text": " don\u2019t restrict ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "what you can do.\n\nThe beauty of C++, Smalltalk, Clojure, etc. is that they \u201chave syntax\u201d and "
                            },
                            {
                                "type": "text",
                                "text": "restrict",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " what you can do.\n\n\u201cLocal maximum\u201d is just that - local.  There are many local maxima.  Schmooing all possible notations into \u201cone language to rule them all\u201d results in complexity, poor UX, epicycles, watered-down unions of features, etc., etc.\n\nDisclaimer: I am a Lisper and a PEGer (Ohm-JS).  Syntax is cheap.  Deprecate programming languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "116233d1-0403-4d3c-91b9-30d0b9ef8f2d",
        "type": "message",
        "text": "Expanding on <@UEBG0NPDK>'s point a bit, C++'s various member/scope operators all have basically the same signature of `(group, selector) -&gt; thing`. So it doesn't hide or obscure any semantics to use the same syntax. Lists and hash maps do not have the same signature; a list is flat, but there are internal relationships in the arguments to a hashmap. So it helps to have different syntax to remind you of that.",
        "user": "U016VUZGUUQ",
        "ts": "1649523349.579689",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rDg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Expanding on "
                            },
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": "'s point a bit, C++'s various member/scope operators all have basically the same signature of "
                            },
                            {
                                "type": "text",
                                "text": "(group, selector) -> thing",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". So it doesn't hide or obscure any semantics to use the same syntax. Lists and hash maps do not have the same signature; a list is flat, but there are internal relationships in the arguments to a hashmap. So it helps to have different syntax to remind you of that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "30159ddb-e49f-4702-a856-4cb53e186849",
        "type": "message",
        "text": "<@UEBG0NPDK>\u2019s take, absolutely. C++ adds complexity that doesn't provide any (useful) expressiveness. So it isn't even on the Pareto frontier of the simplicity/expressiveness tradeoff space.\n\nI personally take Lisp vs Clojure as a better example of a legitimate tradeoff close to the frontier.\n\nI also think it's bonkers that the smallest Wikidata property, P6, is \"head of government\". Shows you what Wikidata thinks is most important. :stuck_out_tongue:",
        "user": "UBKNXPBAB",
        "ts": "1649562377.640379",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ps1N2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": "\u2019s take, absolutely. C++ adds complexity that doesn't provide any (useful) expressiveness. So it isn't even on the Pareto frontier of the simplicity/expressiveness tradeoff space.\n\nI personally take Lisp vs Clojure as a better example of a legitimate tradeoff close to the frontier.\n\nI also think it's bonkers that the smallest Wikidata property, P6, is \"head of government\". Shows you what Wikidata thinks is most important. "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1649508703.704979",
        "parent_user_id": "UDQBTJ211"
    }
]