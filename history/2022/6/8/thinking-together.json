[
    {
        "client_msg_id": "6d1b937f-2b87-425f-8d2f-13fe316a3036",
        "type": "message",
        "text": "Is this a known result in PL theory? \"The set of stable minimum models returned in response to a query in a goal-directed stable model constraint answer set programming language entail, taken together, a stable model constraint answer set program for answering only that query.\"",
        "user": "U02U0AS3J49",
        "ts": "1654711669.779349",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pp5/D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is this a known result in PL theory? \"The set of stable minimum models returned in response to a query in a goal-directed stable model constraint answer set programming language entail, taken together, a stable model constraint answer set program for answering only that query.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "reply_count": 10,
        "reply_users_count": 5,
        "latest_reply": "1654854872.646929",
        "reply_users": [
            "U02U0AS3J49",
            "U03J1HP9C0G",
            "U03DNFDFYDA",
            "UA14TGLTC",
            "UDQBTJ211"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "52be46ae-6fd7-46ba-9e4d-dc2ec2dc79b4",
        "type": "message",
        "text": "I may be phrasing it wrong. Not a theorist. But this just occurred to me, and it seems intuitive. If true, it means I could let my users compile their encodings into lightning-fast code without sacrificing any reasoning capabilities for expert system applications. Which would be huge.",
        "user": "U02U0AS3J49",
        "ts": "1654712123.224909",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GFs9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I may be phrasing it wrong. Not a theorist. But this just occurred to me, and it seems intuitive. If true, it means I could let my users compile their encodings into lightning-fast code without sacrificing any reasoning capabilities for expert system applications. Which would be huge."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "ea34fba4-7e2d-4f16-907c-0088400b9296",
        "type": "message",
        "text": "For not being a theorist the question seems to be built successfully convoluted enough. Can you pose the proposition more clearly?",
        "user": "U03J1HP9C0G",
        "ts": "1654717390.843519",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cGCWY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For not being a theorist the question seems to be built successfully convoluted enough. Can you pose the proposition more clearly?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2da75c64-3bba-4a62-a173-03d75579d643",
        "type": "message",
        "text": "Sure. If you ask your software \"what are all the fact patterns (inputs) that could support this output\", and it tells you, can you use that list of possible valid fact patterns to do pattern matching between other inputs and the valid fact patterns, getting the same result as if you had asked the original program whether the inputs were valid.",
        "user": "U02U0AS3J49",
        "ts": "1654718056.964149",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KVVY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure. If you ask your software \"what are all the fact patterns (inputs) that could support this output\", and it tells you, can you use that list of possible valid fact patterns to do pattern matching between other inputs and the valid fact patterns, getting the same result as if you had asked the original program whether the inputs were valid."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "99aef540-19d1-416a-8cce-02271db461bf",
        "type": "message",
        "text": "Most systems cannot answer that first question, but the one I'm using can, and I'm wondering if that is effectively a means to compile a logic program and a query into more efficient code for answering only that specific query.",
        "user": "U02U0AS3J49",
        "ts": "1654718223.709239",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mjx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most systems cannot answer that first question, but the one I'm using can, and I'm wondering if that is effectively a means to compile a logic program and a query into more efficient code for answering only that specific query."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "79ad45c4-8569-4ae2-bdb8-281e650b492c",
        "type": "message",
        "text": "Stumbled on this, somewhat relevant <https://arxiv.org/pdf/2003.07438.pdf>",
        "user": "U03DNFDFYDA",
        "ts": "1654790807.626299",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kKN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Stumbled on this, somewhat relevant "
                            },
                            {
                                "type": "link",
                                "url": "https://arxiv.org/pdf/2003.07438.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "type": "message",
        "text": "",
        "files": [
            {
                "id": "F03JKK2T3BR",
                "created": 1654790844,
                "timestamp": 1654790844,
                "name": "Screen Shot 2022-06-09 at 09.07.12.png",
                "title": "Screen Shot 2022-06-09 at 09.07.12.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U03DNFDFYDA",
                "editable": false,
                "size": 53443,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F03JKK2T3BR/screen_shot_2022-06-09_at_09.07.12.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F03JKK2T3BR/download/screen_shot_2022-06-09_at_09.07.12.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F03JKK2T3BR-9c85242123/screen_shot_2022-06-09_at_09.07.12_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F03JKK2T3BR-9c85242123/screen_shot_2022-06-09_at_09.07.12_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F03JKK2T3BR-9c85242123/screen_shot_2022-06-09_at_09.07.12_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 191,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F03JKK2T3BR-9c85242123/screen_shot_2022-06-09_at_09.07.12_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 255,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F03JKK2T3BR-9c85242123/screen_shot_2022-06-09_at_09.07.12_160.png",
                "original_w": 490,
                "original_h": 260,
                "thumb_tiny": "AwAZADC+3IPJ4PZqbyf7/wD32KVvvH/P9KTv07f57UAOKqTne3/fVKoAOd5P1NMx/n/Io4/z/wDqoAmyPUUmR6ioh/n/ADigfeHH+fyoAUnkj3/z3pD7Ef5/Gl/5amjtQAgOPQf5+tHbt1/z3oP3qU/1oAQDPA/z+tOAO7kdP8+tCffNSUAf/9k=",
                "permalink": "https://futureofcoding.slack.com/files/U03DNFDFYDA/F03JKK2T3BR/screen_shot_2022-06-09_at_09.07.12.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F03JKK2T3BR-795a71f32d",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "user": "U03DNFDFYDA",
        "display_as_bot": false,
        "ts": "1654790846.396449",
        "client_msg_id": "41c59204-d2bd-41ce-8755-397c5bcc0f79",
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "3c32434d-2468-4f40-9673-680f53f12f06",
        "type": "message",
        "text": "My parser failed on your original question and on the rephrasing, but there's probably something interesting here.  So on the rephrasing, it's the second half.  How can there be \"other inputs\" not included in the list of \"all inputs\"?  (I mean there is more than one way to try to interpret \"other\" here.)  What follows doesn't \"the same result as if you had asked the original program whether the inputs were valid\" help.  Here \"the\" is ambiguous since we're talking about all the ones that led to a given output *and* other inputs too.",
        "user": "UA14TGLTC",
        "ts": "1654831932.698139",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BcCn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My parser failed on your original question and on the rephrasing, but there's probably something interesting here.  So on the rephrasing, it's the second half.  How can there be \"other inputs\" not included in the list of \"all inputs\"?  (I mean there is more than one way to try to interpret \"other\" here.)  What follows doesn't \"the same result as if you had asked the original program whether the inputs were valid\" help.  Here \"the\" is ambiguous since we're talking about all the ones that led to a given output "
                            },
                            {
                                "type": "text",
                                "text": "and",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " other inputs too."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "aee04b90-1572-41ef-947b-51cb39df7a8b",
        "type": "message",
        "text": "Fair. I neglected to mention that the answers from the first question are abstract, expressed as constraints. For example, if your code is the rules of Rock Paper Scissors, your first abstract query might be \"how can someone win a two player game\", and the abstract answers are in the form \" the first player throws rock, and the second player throws scissors, and the first player wins\". That would be one of the three possible abstract models that answer the hypothetical query. Now I know William and Jason played a game, and I know William threw rock. If what I want to know is who won a game, I have two options. I can run the same query again against the rules, with the concrete facts I have, and ask it to presume only that Jason threw something. Or, I can attempt to unify against the abstract models returned by the first query. Either way, the same two results will be returned. The one where Jason threw scissors, and the one where Jason threw paper. The complexity of the first query is exponential with regard to the complexity of the rules and the number of hypothetical inputs. The complexity of the second query is linear with the number of models I got from the first one, and exponential with the number of hypothesized inputs only. All the complexity that comes from the rules is avoided. I think. Maybe. :joy:",
        "user": "U02U0AS3J49",
        "ts": "1654833095.129749",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LEi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fair. I neglected to mention that the answers from the first question are abstract, expressed as constraints. For example, if your code is the rules of Rock Paper Scissors, your first abstract query might be \"how can someone win a two player game\", and the abstract answers are in the form \" the first player throws rock, and the second player throws scissors, and the first player wins\". That would be one of the three possible abstract models that answer the hypothetical query. Now I know William and Jason played a game, and I know William threw rock. If what I want to know is who won a game, I have two options. I can run the same query again against the rules, with the concrete facts I have, and ask it to presume only that Jason threw something. Or, I can attempt to unify against the abstract models returned by the first query. Either way, the same two results will be returned. The one where Jason threw scissors, and the one where Jason threw paper. The complexity of the first query is exponential with regard to the complexity of the rules and the number of hypothetical inputs. The complexity of the second query is linear with the number of models I got from the first one, and exponential with the number of hypothesized inputs only. All the complexity that comes from the rules is avoided. I think. Maybe. "
                            },
                            {
                                "type": "emoji",
                                "name": "joy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    },
    {
        "client_msg_id": "2fa2ba03-a8f1-49cc-8500-f051d402e036",
        "type": "message",
        "text": "I think the complexity is just pushed into the number of models, so while the second query is linear in respect of this, I think this is still exponential with regards to the original parameters (number of unknown inputs).",
        "user": "UDQBTJ211",
        "ts": "1654850145.675449",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o4v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the complexity is just pushed into the number of models, so while the second query is linear in respect of this, I think this is still exponential with regards to the original parameters (number of unknown inputs)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "D86B8ECD-8959-4FF6-9C44-82A432195770",
        "type": "message",
        "text": "In general there\u2019s no free lunch, but in general you aren\u2019t in the general case.\n\nThe advantage of talking about the \u201cmodels\u201d like you have here is that matching against a given one is easy.  The disadvantage is that most programs, even not very interesting programs, are associated with a large number.  So you\u2019re better off using a more compact formalism.  Probabilistic graphical models come to mind.\n\nOften there\u2019s a sweet spot where rules in the code are relatively simple and the data structures encode irregularity without being too big.  I shared a good example the other day.\n\nSuppose you have a grid of squares and each square can be part of a path.  So seven labels: \u2517,  \u2501, \u2513, \u251b, \u2503, \u250f, and blank.  You want to enumerate all closed loops.  You can simplify the problem by increasing the grid size to just represent horizontal edges, vertical edges, and intersections.\n\nLastly, the Yoneda Lemma formalizes the idea that you can characterize a thing by its relationships to similar things.  In practice you can use it to help figure out the right category of similar things or the right features to characterize or both simultaneously.",
        "user": "UA14TGLTC",
        "ts": "1654854872.646929",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UA14TGLTC",
            "ts": "1654854897.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wjhE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In general there\u2019s no free lunch, but in general you aren\u2019t in the general case.\n\nThe advantage of talking about the \u201cmodels\u201d like you have here is that matching against a given one is easy.  The disadvantage is that most programs, even not very interesting programs, are associated with a large number.  So you\u2019re better off using a more compact formalism.  Probabilistic graphical models come to mind.\n\nOften there\u2019s a sweet spot where rules in the code are relatively simple and the data structures encode irregularity without being too big.  I shared a good example the other day.\n\nSuppose you have a grid of squares and each square can be part of a path.  So seven labels: \u2517,  \u2501, \u2513, \u251b, \u2503, \u250f, and blank.  You want to enumerate all closed loops.  You can simplify the problem by increasing the grid size to just represent horizontal edges, vertical edges, and intersections.\n\nLastly, the Yoneda Lemma formalizes the idea that you can characterize a thing by its relationships to similar things.  In practice you can use it to help figure out the right category of similar things or the right features to characterize or both simultaneously."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1654711669.779349",
        "parent_user_id": "U02U0AS3J49"
    }
]