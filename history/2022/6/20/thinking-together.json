[
    {
        "client_msg_id": "77e5f006-5c58-499f-88a4-90bc0a3d6eb9",
        "type": "message",
        "text": "There\u2019s a recurring theme in my career, going back to my very first job, that goes under the mental headline of \u201cwide logic\u201d problems\u2026 That\u2019s where you have a somewhat narrow stream (conceptually, not necessarily streaming per se) of data, and you need to evaluate a large number of functions against each item--at least a handful, often dozens, sometimes hundreds! The functions are basically always provided by the user, although normally in a declarative, non-Turing-complete DSL. I\u2019m curious whether others have noticed this pattern, and whether you know of any more mainstream labels for it?\n\nThe closest I\u2019ve found is papers that reference publish/subscribe and indexing techniques for complex boolean expression trees, e.g.:\n\u2022 <https://dl.acm.org/doi/10.14778/2732296.2732298|An efficient publish/subscribe index for e-commerce databases> (VLDB \u201914)\n\u2022 <https://dl.acm.org/doi/10.1145/2487259.2487260|Analysis and optimization for boolean expression indexing [BE-Tree]> (ACM Trans. DB. Sys. \u201913)\n\u2022 <https://dl.acm.org/doi/10.1145/3448016.3457266|A-Tree: A Dynamic Data Structure for Efficiently Indexing Arbitrary Boolean Expressions> (SIGMOD/PODS \u201921 \u2026 actually this is a new one for me, I need to read it now\u2026 :slightly_smiling_face:)",
        "user": "U03DNFDFYDA",
        "ts": "1655747158.959289",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03DNFDFYDA",
            "ts": "1655747235.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2p9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There\u2019s a recurring theme in my career, going back to my very first job, that goes under the mental headline of \u201cwide logic\u201d problems\u2026 That\u2019s where you have a somewhat narrow stream (conceptually, not necessarily streaming per se) of data, and you need to evaluate a large number of functions against each item--at least a handful, often dozens, sometimes hundreds! The functions are basically always provided by the user, although normally in a declarative, non-Turing-complete DSL. I\u2019m curious whether others have noticed this pattern, and whether you know of any more mainstream labels for it?\n\nThe closest I\u2019ve found is papers that reference publish/subscribe and indexing techniques for complex boolean expression trees, e.g.:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https://dl.acm.org/doi/10.14778/2732296.2732298",
                                        "text": "An efficient publish/subscribe index for e-commerce databases"
                                    },
                                    {
                                        "type": "text",
                                        "text": " (VLDB \u201914)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https://dl.acm.org/doi/10.1145/2487259.2487260",
                                        "text": "Analysis and optimization for boolean expression indexing [BE-Tree]"
                                    },
                                    {
                                        "type": "text",
                                        "text": " (ACM Trans. DB. Sys. \u201913)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "link",
                                        "url": "https://dl.acm.org/doi/10.1145/3448016.3457266",
                                        "text": "A-Tree: A Dynamic Data Structure for Efficiently Indexing Arbitrary Boolean Expressions"
                                    },
                                    {
                                        "type": "text",
                                        "text": " (SIGMOD/PODS \u201921 \u2026 actually this is a new one for me, I need to read it now\u2026 "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "slightly_smiling_face",
                                        "unicode": "1f642"
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "reply_count": 15,
        "reply_users_count": 4,
        "latest_reply": "1655811575.243389",
        "reply_users": [
            "U03DNFDFYDA",
            "UEBG0NPDK",
            "U02E4DAQGSZ",
            "U013ZLJARC7"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "ba81b084-26b4-4bde-9288-7adbe63d73a0",
        "type": "message",
        "text": "Some stories\u2026",
        "user": "U03DNFDFYDA",
        "ts": "1655747304.186279",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hwu2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some stories\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "f8757bfe-2a20-46a5-834d-a1c4b8e24cb9",
        "type": "message",
        "text": "First job: a (snail mail) direct marketing agency. We would run dozens of queries/reports to analyze the performance of mailings/campaigns, breaking down response rates, average donation amounts, etc.\n\nThe functions were often \u201csymbolic\u201d (i.e. calculated) fields in the 4GL, they were in a Turing-complete language but often written by relatively unskilled programmers. I built a system that would traverse the analysis/mailing list once, eval all the expressions once per record, and aggregate them in memory over multiple group-bys",
        "user": "U03DNFDFYDA",
        "ts": "1655748114.837129",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6JE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "First job: a (snail mail) direct marketing agency. We would run dozens of queries/reports to analyze the performance of mailings/campaigns, breaking down response rates, average donation amounts, etc.\n\nThe functions were often \u201csymbolic\u201d (i.e. calculated) fields in the 4GL, they were in a Turing-complete language but often written by relatively unskilled programmers. I built a system that would traverse the analysis/mailing list once, eval all the expressions once per record, and aggregate them in memory over multiple group-bys"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "1ed38ade-ace0-499a-b256-406dc1f0dd8a",
        "type": "message",
        "text": "Is it possible that in our efforts to find alternatives to imperative programming, we have failed to promulgate knowledge about how to program imperatively?\n\nBack in the day, folks like Dijkstra, Hoare, Wirth, Knuth, and Naur did a lot of work on figuring out how to write imperative programs that did what they were intended to do.\n\nHowever, nowadays, I get the impression that much of the energy being spent on making programs better is focused on alternative ways to structure programs, like object oriented design, distributed and/or parallel and/or concurrent, event driven, reactive, etc. However, most of these design disciplines still involve executing chunks of imperative code, they just involve new and different ways of deciding which imperative code runs when.\n\nThis may be a dull and boring idea, but is it possible that part of what we need in order to improve software is wider distribution and study of the old ways of writing correct imperative programs, so that more of the little chunks of imperative code that get executed during an object oriented or event driven program will do what they are supposed to do?",
        "user": "U03CEGR3HSL",
        "ts": "1655748966.611579",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U03CEGR3HSL",
            "ts": "1655748995.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aSxXt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is it possible that in our efforts to find alternatives to imperative programming, we have failed to promulgate knowledge about how to program imperatively?\n\nBack in the day, folks like Dijkstra, Hoare, Wirth, Knuth, and Naur did a lot of work on figuring out how to write imperative programs that did what they were intended to do.\n\nHowever, nowadays, I get the impression that much of the energy being spent on making programs better is focused on alternative ways to structure programs, like object oriented design, distributed and/or parallel and/or concurrent, event driven, reactive, etc. However, most of these design disciplines still involve executing chunks of imperative code, they just involve new and different ways of deciding which imperative code runs when.\n\nThis may be a dull and boring idea, but is it possible that part of what we need in order to improve software is wider distribution and study of the old ways of writing correct imperative programs, so that more of the little chunks of imperative code that get executed during an object oriented or event driven program will do what they are supposed to do?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "reply_count": 7,
        "reply_users_count": 7,
        "latest_reply": "1655959279.484379",
        "reply_users": [
            "U03DNFDFYDA",
            "UCUSW7WVD",
            "U03CEGR3HSL",
            "U03E03MNL3V",
            "U02028JHX37",
            "U01SUK9M8R2",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "166baa6f-0c11-41ed-a059-951f6f334517",
        "type": "message",
        "text": "Second, third and fourth jobs didn\u2019t really have this feature\u2026",
        "user": "U03DNFDFYDA",
        "ts": "1655749029.213759",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AloH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Second, third and fourth jobs didn\u2019t really have this feature\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "9dba2e8b-02e3-413f-a64f-3a8c97a02bf0",
        "type": "message",
        "text": "Fifth job was <http://layer7.com|layer7.com> (an API gateway appliance), every message needed to be resolved to one of potentially hundreds of policies, but the resolution logic was pretty simple, and once resolved, the policy didn\u2019t tend to be too branchy",
        "user": "U03DNFDFYDA",
        "ts": "1655749242.929969",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JwR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fifth job was "
                            },
                            {
                                "type": "link",
                                "url": "http://layer7.com",
                                "text": "layer7.com"
                            },
                            {
                                "type": "text",
                                "text": " (an API gateway appliance), every message needed to be resolved to one of potentially hundreds of policies, but the resolution logic was pretty simple, and once resolved, the policy didn\u2019t tend to be too branchy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "ADA56DD7-AE81-474D-8B48-99C917B82E4E",
        "type": "message",
        "text": "Sounds like streaming analytics to me.",
        "user": "UEBG0NPDK",
        "ts": "1655749385.184329",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A3D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "like"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "streaming"
                            },
                            {
                                "type": "text",
                                "text": " analytics "
                            },
                            {
                                "type": "text",
                                "text": "to"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "me."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "17a90f07-3052-470a-98c0-fa8c8fc3c415",
        "type": "message",
        "text": "Sixth job was a SaaS app for monitoring compliance rules at brokerages\u2026 There were hundreds of handcrafted rules that needed to be evaluated against every Order, Trade and Account record after a nightly ETL job. Before I got involved, every rule was run one at a time, sequentially, and some customers\u2019 nightly jobs were starting to run up against the clock.",
        "user": "U03DNFDFYDA",
        "ts": "1655749416.780449",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uPI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sixth job was a SaaS app for monitoring compliance rules at brokerages\u2026 There were hundreds of handcrafted rules that needed to be evaluated against every Order, Trade and Account record after a nightly ETL job. Before I got involved, every rule was run one at a time, sequentially, and some customers\u2019 nightly jobs were starting to run up against the clock."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "11855547-6dba-4f6e-8238-2f385c249615",
        "type": "message",
        "text": "Definitely streaming analytics, but from what I\u2019ve seen so far the support for this pattern isn\u2019t great anywhere",
        "user": "U03DNFDFYDA",
        "ts": "1655749452.434219",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "COrij",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Definitely streaming analytics, but from what I\u2019ve seen so far the support for this pattern isn\u2019t great anywhere"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "74146895-4CC6-4F38-9927-4365C6DB5650",
        "type": "message",
        "text": "Differential dataflow should handle it well I would think. ",
        "user": "UEBG0NPDK",
        "ts": "1655749490.555159",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3DNxl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Differential"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "dataflow"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "should"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "handle"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "it"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "well"
                            },
                            {
                                "type": "text",
                                "text": " I "
                            },
                            {
                                "type": "text",
                                "text": "would"
                            },
                            {
                                "type": "text",
                                "text": " think"
                            },
                            {
                                "type": "text",
                                "text": ". "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "07e35e3a-9170-4070-b25f-ed80fbd7d23f",
        "type": "message",
        "text": "I\u2019ve definitely been keeping a close eye on <http://materialize.io|materialize.io> :slightly_smiling_face: \u2026 IIUC they don\u2019t do a great job with datasets that are significantly larger than main memory",
        "user": "U03DNFDFYDA",
        "ts": "1655749579.487879",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w/O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019ve definitely been keeping a close eye on "
                            },
                            {
                                "type": "link",
                                "url": "http://materialize.io",
                                "text": "materialize.io"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " \u2026 IIUC they don\u2019t do a great job with datasets that are significantly larger than main memory"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "30f9c133-69f0-44f6-acb6-eca8b397d7a6",
        "type": "message",
        "text": "At the brokerage monitoring thing, the hack I came up with was to stipulate that every rule needed to start with (in an AND position) a predicate that was constrained to be mechanically translatable to SQL, and all other predicates were MVEL, less constrained. All the rules that shared that primary predicate would be run as a single query as the first filter, and the MVEL expressions for the sub-rules would be run in-memory instead of pushed down",
        "user": "U03DNFDFYDA",
        "ts": "1655749801.216289",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/=h/D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At the brokerage monitoring thing, the hack I came up with was to stipulate that every rule needed to start with (in an AND position) a predicate that was constrained to be mechanically translatable to SQL, and all other predicates were MVEL, less constrained. All the rules that shared that primary predicate would be run as a single query as the first filter, and the MVEL expressions for the sub-rules would be run in-memory instead of pushed down"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "2de7451c-6ac3-46df-bc64-549e54fe761d",
        "type": "message",
        "text": "&gt; the old ways of writing correct imperative programs\nNot sure how well this ever worked :wink:",
        "user": "U03DNFDFYDA",
        "ts": "1655749902.653779",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yR3",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the old ways of writing correct imperative programs"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not sure how well this ever worked "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "cef6eabe-7fed-4c04-ae32-5214d5489e5a",
        "type": "message",
        "text": "ah yeah, if you need something out of core, I don't think DD (which is lower level than the materialize offering) will give you that, though it may be something you could add. <http://Relational.ai|Relational.ai> is probably almost exactly what you want (very powerful variant of datalog that can handle very large datasets and does incremental evaluation), but they're a bit early yet.",
        "user": "UEBG0NPDK",
        "ts": "1655750122.998189",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=y88e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "ah yeah, if you need something out of core, I don't think DD (which is lower level than the materialize offering) will give you that, though it may be something you could add. "
                            },
                            {
                                "type": "link",
                                "url": "http://Relational.ai",
                                "text": "Relational.ai"
                            },
                            {
                                "type": "text",
                                "text": " is probably almost exactly what you want (very powerful variant of datalog that can handle very large datasets and does incremental evaluation), but they're a bit early yet."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "78703ebc-165c-4d1f-97ec-4230e8ce3c14",
        "type": "message",
        "text": "Lately I\u2019ve been more focused on teasing out the 3-4 very different cost models for the sub-expressions that queries are composed of:\n\u2022 pure functions that don\u2019t even look at data or the environment; that can be evaluated whenever\n\u2022 functions that need to look at the record, or cheap environment stuff like the current time of day\n\u2022 stateful functions, usually aggregates but sometimes more complex\n\u2022 things that need to do IO: lookups, external service calls, etc. Caching becomes mission-critical",
        "user": "U03DNFDFYDA",
        "ts": "1655750232.745209",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BWO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Lately I\u2019ve been more focused on teasing out the 3-4 very different cost models for the sub-expressions that queries are composed of:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "pure functions that don\u2019t even look at data or the environment; that can be evaluated whenever"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "functions that need to look at the record, or cheap environment stuff like the current time of day"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "stateful functions, usually aggregates but sometimes more complex"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "things that need to do IO: lookups, external service calls, etc. Caching becomes mission-critical"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "2451aefc-b47a-46b1-9920-3092a93606a8",
        "type": "message",
        "text": "I notice you didn't mention functional in your list. Was that deliberate? :slightly_smiling_face: I don't think it involves chunks of imperative code, or orchestration of when each step runs.\n\nDijkstra's _A Discipline of Programming_ is one of the top 10 books on my bookshelf, and highly recommended no matter what paradigm you program in.",
        "user": "UCUSW7WVD",
        "ts": "1655760552.235979",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1655777123.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X4MJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I notice you didn't mention functional in your list. Was that deliberate? "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " I don't think it involves chunks of imperative code, or orchestration of when each step runs.\n\nDijkstra's "
                            },
                            {
                                "type": "text",
                                "text": "A Discipline of Programming",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is one of the top 10 books on my bookshelf, and highly recommended no matter what paradigm you program in."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "amiga-tick",
                "users": [
                    "U02M6PM725T"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dd0254b4-313c-42d7-b287-b08d69b5e07d",
        "type": "message",
        "text": "Yes, I left out purely functional programming and logic programming on purpose, both because they are not especially popular and because it requires some twisted thinking to fit them into the viewpoint I am taking.\n\nHowever, I would argue that mostly functional programming, like in Scheme, ML, or Clojure would still fit into this worldview of programs still containing small chunks of imperative code that need to be written correctly.",
        "user": "U03CEGR3HSL",
        "ts": "1655760872.401939",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SmxU/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I left out purely functional programming and logic programming on purpose, both because they are not especially popular and because it requires some twisted thinking to fit them into the viewpoint I am taking.\n\nHowever, I would argue that mostly functional programming, like in Scheme, ML, or Clojure would still fit into this worldview of programs still containing small chunks of imperative code that need to be written correctly."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "5fdeaedb-e9e3-4e19-8d05-444ff8a87e6e",
        "type": "message",
        "text": "yeah I have seen this a lot too, e.g. achievements on fitness trackers (tell me when I have done 10,000 steps over 10K customer base).\n\nThe specification is declarative but the data arrives incrementally. Due to the huge maintenance issues of trying to upgrade state on an incremental streaming solution, I tend to recommend just recomputing from scratch every X mins and throw horizontal compute at it (e.g. BigQuery). The system remains stateless then, plus you always need the from scratch computation anyway to recover from disaster, so it's the first thing to do anyway.",
        "user": "U02E4DAQGSZ",
        "ts": "1655761893.884199",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U02E4DAQGSZ",
            "ts": "1655762002.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "abk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah I have seen this a lot too, e.g. achievements on fitness trackers (tell me when I have done 10,000 steps over 10K customer base).\n\nThe specification is declarative but the data arrives incrementally. Due to the huge maintenance issues of trying to upgrade state on an incremental streaming solution, I tend to recommend just recomputing from scratch every X mins and throw horizontal compute at it (e.g. BigQuery). The system remains stateless then, plus you always need the from scratch computation anyway to recover from disaster, so it's the first thing to do anyway."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2283aa06-215e-46fe-8cf0-c4baa7010493",
        "type": "message",
        "text": "I see this as  a recurring theme of incremental computation, where I see analogues with differential equations.\n```declarative is to imperatives as y = f(x) is to dy/dx = f(x, y) ```",
        "user": "U02E4DAQGSZ",
        "ts": "1655762323.503099",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PIuv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see this as  a recurring theme of incremental computation, where I see analogues with differential equations.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "declarative is to imperatives as y = f(x) is to dy/dx = f(x, y) "
                            }
                        ],
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "88F3907F-ADAD-4AC3-839C-7790B1C606FC",
        "type": "message",
        "text": "Rust does the things. To write imperative programming correctly today, we will need Rust or better.",
        "user": "U03E03MNL3V",
        "ts": "1655772886.863429",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l9m",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Rust"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "does"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "the"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "things. To write imperative programming correctly today, we"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "will need Rust or better."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "f3524b16-900a-49b8-a74f-16e3adc31e63",
        "type": "message",
        "text": "I\u2019m not sure I agree with that bits of imperative code always get run (I mean: obviously it does; but is this a good viewpoint?).\n\nHowever, what certainly happens in all paradigms (even functional and logic) is that inbetween \u201ccybernetical parts\u201d (parts that do stuff: function applications, rules, statements, message sends, \u2026) you get to play with lexical variables containing state. These aren\u2019t easily analyzed, even when the state is \u201cimmutable\u201d (immutability doesn\u2019t imply discoverability or predictability).\n\nSo what is needed, in my view, is better handling of lexical variables (what they contain w.r.t. cybernetic elements of the program) and their evolution through control flow (imperative control flow, but also repeated message receives / function applications). One can imagine that a better understanding of imperative programs might lead to this handling of variables and control flow, since both are present in almost all paradigms in the form they had in imperative languages (an exception I can think of is constraint-solving).",
        "user": "U02028JHX37",
        "ts": "1655790781.802479",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "euu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m not sure I agree with that bits of imperative code always get run (I mean: obviously it does; but is this a good viewpoint?).\n\nHowever, what certainly happens in all paradigms (even functional and logic) is that inbetween \u201ccybernetical parts\u201d (parts that do stuff: function applications, rules, statements, message sends, \u2026) you get to play with lexical variables containing state. These aren\u2019t easily analyzed, even when the state is \u201cimmutable\u201d (immutability doesn\u2019t imply discoverability or predictability).\n\nSo what is needed, in my view, is better handling of lexical variables (what they contain w.r.t. cybernetic elements of the program) and their evolution through control flow (imperative control flow, but also repeated message receives / function applications). One can imagine that a better understanding of imperative programs might lead to this handling of variables and control flow, since both are present in almost all paradigms in the form they had in imperative languages (an exception I can think of is constraint-solving)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL"
    },
    {
        "client_msg_id": "66355c3d-f3af-456f-9052-0002f1beeeda",
        "type": "message",
        "text": "These are all <https://en.wikipedia.org/wiki/Complex_event_processing|Complex Event Processing> (CEP) use cases. We built a system at a startup called Aleri in the mid-00s that handled this sort of thing with continuous queries implemented over a dataflow engine. We sold the company to Sybase, which sold to SAP, which -- so far as I know -- still sells the product today.",
        "user": "U013ZLJARC7",
        "ts": "1655811575.243389",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XN/Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "These are all "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Complex_event_processing",
                                "text": "Complex Event Processing"
                            },
                            {
                                "type": "text",
                                "text": " (CEP) use cases. We built a system at a startup called Aleri in the mid-00s that handled this sort of thing with continuous queries implemented over a dataflow engine. We sold the company to Sybase, which sold to SAP, which -- so far as I know -- still sells the product today."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655747158.959289",
        "parent_user_id": "U03DNFDFYDA"
    },
    {
        "client_msg_id": "c27891ea-3590-4650-b5c0-81bec3da17e7",
        "type": "message",
        "text": "I don't think imperative style is necessarily inherent or ideal for computer programs. It was rather born out of the limitation of early computer architectures (single ALU, single memory bus, everything has to be synchronized, etc.) When multiple operations are happening in multiple places, imperative programming will no longer be suitable. Another thing to consider is that modern software needs to take care of thousands of different conditions (hardware configurations, user preferences, access controls, GUI events, network inputs and concurrency!). In a purely imperative style, it will blow up if-thens. We somehow needed to \"abstract away\" those conditionals. Programming styles don't evolve in vacuum. It's constantly reacting to ever changing needs from external forces like these.",
        "user": "U01SUK9M8R2",
        "ts": "1655852114.844389",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hUv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think imperative style is necessarily inherent or ideal for computer programs. It was rather born out of the limitation of early computer architectures (single ALU, single memory bus, everything has to be synchronized, etc.) When multiple operations are happening in multiple places, imperative programming will no longer be suitable. Another thing to consider is that modern software needs to take care of thousands of different conditions (hardware configurations, user preferences, access controls, GUI events, network inputs and concurrency!). In a purely imperative style, it will blow up if-thens. We somehow needed to \"abstract away\" those conditionals. Programming styles don't evolve in vacuum. It's constantly reacting to ever changing needs from external forces like these."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "heartpulse",
                "users": [
                    "U03E03MNL3V",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "64f04b6e-f0b1-4142-8dfb-c5c75620fc75",
        "type": "message",
        "text": "Think about it this way.  Though an imperative, interactive, step-by-step process may be the domain of a program, it doesn't mean a language with imperative semantics is going to be a good fit for the domain.  Often the process semantics and the imperative semantics have a big mismatch, take event driven UIs as an example.",
        "user": "UA14TGLTC",
        "ts": "1655959279.484379",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mlEc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Think about it this way.  Though an imperative, interactive, step-by-step process may be the domain of a program, it doesn't mean a language with imperative semantics is going to be a good fit for the domain.  Often the process semantics and the imperative semantics have a big mismatch, take event driven UIs as an example."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1655748966.611579",
        "parent_user_id": "U03CEGR3HSL",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]