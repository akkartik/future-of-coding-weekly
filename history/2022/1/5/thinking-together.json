[
    {
        "client_msg_id": "7b19335a-031d-42e0-b767-3c44deb76eee",
        "type": "message",
        "text": "I\u2019m struck by how rare it is for basic control systems knowledge to show up in our projects; my impression is that the common approaches to closed loop feedback are:\n\u2022 Ad hoc event handling and state management\n\u2022 An exercise left to the user\n\u2022 \u2018I\u2019m sorry dave, I\u2019m afraid I can\u2019t do that\u2019\nI think we tend this way because the underlying substrates (CPUs, peripherals, ISAs, PL grammars) are so well characterized as to allow formerly unthinkable consistency with open-loop methods.\n\nIt seems like there\u2019s a lot of low hanging fruit here, and it gets at the heart of what \u2018liveness\u2019 is about. I\u2019m curious if anyone here has experience working with controls/dynamical systems, or pointers to FoC type projects being approached in this way.\n\nPS if you\u2019re not familiar with controls, a wikipedia trip makes it seem like a lot of daunting math, but the basics are actually pretty simple. Basically you\u2019ve got your current system state, a function to compute the next state, and then whatever parameters you can actual directly control (\u201cdirect manipulation\u201d). If you\u2019ve ever used React or FRP, they get halfway there, then overcomplicate and oversimplify it at the same time. Here\u2019s a friendly intro if you\u2019re curious: <https://www.youtube.com/watch?v=O-OqgFE9SD4>.",
        "user": "U9C92716C",
        "ts": "1641389275.367500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U9C92716C",
            "ts": "1641404799.000000"
        },
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=O-OqgFE9SD4",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/O-OqgFE9SD4?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "thumb_url": "https://i.ytimg.com/vi/O-OqgFE9SD4/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=O-OqgFE9SD4",
                "fallback": "YouTube Video: Control Systems Lectures - Closed Loop Control",
                "title": "Control Systems Lectures - Closed Loop Control",
                "title_link": "https://www.youtube.com/watch?v=O-OqgFE9SD4",
                "author_name": "Brian Douglas",
                "author_link": "https://www.youtube.com/user/ControlLectures",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JxU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m struck by how rare it is for basic control systems knowledge to show up in our projects; my impression is that the common approaches to closed loop feedback are:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Ad hoc event handling and state management"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "An exercise left to the user"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u2018I\u2019m sorry dave, I\u2019m afraid I can\u2019t do that\u2019"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think we tend this way because the underlying substrates (CPUs, peripherals, ISAs, PL grammars) are so well characterized as to allow formerly unthinkable consistency with open-loop methods.\n\nIt seems like there\u2019s a lot of low hanging fruit here, and it gets at the heart of what \u2018liveness\u2019 is about. I\u2019m curious if anyone here has experience working with controls/dynamical systems, or pointers to FoC type projects being approached in this way.\n\nPS if you\u2019re not familiar with controls, a wikipedia trip makes it seem like a lot of daunting math, but the basics are actually pretty simple. Basically you\u2019ve got your current system state, a function to compute the next state, and then whatever parameters you can actual directly control (\u201cdirect manipulation\u201d). If you\u2019ve ever used React or FRP, they get halfway there, then overcomplicate and oversimplify it at the same time. Here\u2019s a friendly intro if you\u2019re curious: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=O-OqgFE9SD4"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "reply_count": 5,
        "reply_users_count": 3,
        "latest_reply": "1641414892.370500",
        "reply_users": [
            "UCGR73CAY",
            "U9C92716C",
            "U02E4DAQGSZ"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "star",
                "users": [
                    "USH01JEDQ",
                    "U02E4DAQGSZ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0a95b035-b536-4a72-a6ab-b88189dcbb89",
        "type": "message",
        "text": "Hi Dalton,\n\nYou may be interested in my project, the Mech programming language, which is designed specifically for these kinds of systems. I actually posted an update about it here just yesterday! <https://futureofcoding.slack.com/archives/CCL5VVBAN/p1641347451138200>\n\nMy background is in robotics, so I am designing Mech to be the ideal language to use on robotic systems, which of course make heavy use of control! You are right, there is a lot of low-hanging fruit here:\n\n\u2022 Units are a big one. Control systems operate in the real world, which has all kinds of dimensions. Adding units to type systems can be a big win, allowing you to verify correctness and improve reliability (<https://en.wikipedia.org/wiki/Mars_Climate_Orbiter|this> should never happen again).\n\u2022 Handling time explicitly is important for control systems. Having temporal operators (whenever, until, before, followed by, as soon as) can help programmers reason about control systems.\n\u2022 Asynchrony be default. The real world is asynchronous, so control systems must be as well. There's no blocking when it comes to reality.\n\u2022 Parallelism by default. A lot of algorithms for control systems are highly parallelizable. \n\u2022 Distributed programming by default. Control systems are all about coordinating disparate physical machinery to achieve a desired outcome. It's often the case that this system is composed of upwards of dozens of processing units. Think of all the computers that are in your car. A robot might have a dedicated computer per limb, networked with a CANN bus or ethernet. IOT control systems might have sensors that span a building or an entire town. \n\u2022 The same kind of math that GPUs do on games is done for control systems, so native GPGPU support is critical.\n\u2022 The real world is continuous but computerized control systems are discrete. It's important to take this into account as well. Consider a real-world control system that handles money. You don't want to use IEEE floating point for that.\n\u2022 Data is everything, so logging, searching, slicing, and visualizing data need to be first-class. Visualization is one of the most important debugging techniques for these kinds of systems. Logging must also be built-in and robust to failures. Typically the development cycle for a robot goes like this: 1. write some code 2. run the robot 3. watch the robot crash 4. look at the logs and figure out why the robot crashed 5. goto 1. So automatic logging and replay-ability of logs is also crucial. Once upon a time when I was in gradschool, I heard a tale from before my time of woe due to forgetting to set the logging flag to on. The goal was to make scans like <https://www.youtube.com/watch?v=n8YKShFlKvY|these> of the town using the remains of <https://vimeo.com/373043|Little Ben>, but parked cars obstructed the sidewalk view from the road. The solution then was to go out at 3 in the morning when all the cars were gone to take these scans. But one tired grad student forgot to set the logging flag to true, so they drove around all night collecting data, but it was all immediately lost. People were not happy with him.\nCurrent approaches rely on middleware to enable some of the above features. <https://ros.org|ROS> is one such middleware for robots. It's called an operating system but it runs on top of Linux. It provides a networking api to publish and subscribe to messages produced by control nodes. But the problem, aside from the fact that ROS is nigh unusable even for experts, is that the actual programming is still done in C++ or Python. I don't think I have to explain to this crowd how much of a letdown that is. C++ and Python and any other imperative language is the exact wrong kind of tool to use in this scenario.\n\nParallel, async, distributed code is way easier to write if the whole system is designed for it. Parallel/async code got a reputation for being a nightmare to write because it's a nightmare to write in C++. But that doesn't preclude other systems being better! I think you see a general recognition in the industry that things are going this way. But I don't think they have realized yet that it's better to use a system designed from first principles to support these features than to bolt them on to C++ or Python or Javascript.\n\nMech is still really early, so even it doesn't support all the features I laid out above. But that's one of the goals for the project: to be a better language for robot systems.\n\nAnyway, I'm happy you brought this topic up, because I love talking about it!",
        "user": "UCGR73CAY",
        "ts": "1641399650.368400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "moyM=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Dalton,\n\nYou may be interested in my project, the Mech programming language, which is designed specifically for these kinds of systems. I actually posted an update about it here just yesterday! "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/CCL5VVBAN/p1641347451138200"
                            },
                            {
                                "type": "text",
                                "text": "\n\nMy background is in robotics, so I am designing Mech to be the ideal language to use on robotic systems, which of course make heavy use of control! You are right, there is a lot of low-hanging fruit here:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Units are a big one. Control systems operate in the real world, which has all kinds of dimensions. Adding units to type systems can be a big win, allowing you to verify correctness and improve reliability ("
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://en.wikipedia.org/wiki/Mars_Climate_Orbiter",
                                        "text": "this"
                                    },
                                    {
                                        "type": "text",
                                        "text": " should never happen again)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Handling time explicitly is important for control systems. Having temporal operators (whenever, until, before, followed by, as soon as) can help programmers reason about control systems."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Asynchrony be default. The real world is asynchronous, so control systems must be as well. There's no blocking when it comes to reality."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Parallelism by default. A lot of algorithms for control systems are highly parallelizable. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Distributed programming by default. Control systems are all about coordinating disparate physical machinery to achieve a desired outcome. It's often the case that this system is composed of upwards of dozens of processing units. Think of all the computers that are in your car. A robot might have a dedicated computer per limb, networked with a CANN bus or ethernet. IOT control systems might have sensors that span a building or an entire town. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The same kind of math that GPUs do on games is done for control systems, so native GPGPU support is critical."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The real world is continuous but computerized control systems are discrete. It's important to take this into account as well. Consider a real-world control system that handles money. You don't want to use IEEE floating point for that."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Data is everything, so logging, searching, slicing, and visualizing data need to be first-class. Visualization is one of the most important debugging techniques for these kinds of systems. Logging must also be built-in and robust to failures. Typically the development cycle for a robot goes like this: 1. write some code 2. run the robot 3. watch the robot crash 4. look at the logs and figure out why the robot crashed 5. goto 1. So automatic logging and replay-ability of logs is also crucial. Once upon a time when I was in gradschool, I heard a tale from before my time of woe due to forgetting to set the logging flag to on. The goal was to make scans like "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://www.youtube.com/watch?v=n8YKShFlKvY",
                                        "text": "these"
                                    },
                                    {
                                        "type": "text",
                                        "text": " of the town using the remains of "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://vimeo.com/373043",
                                        "text": "Little Ben"
                                    },
                                    {
                                        "type": "text",
                                        "text": ", but parked cars obstructed the sidewalk view from the road. The solution then was to go out at 3 in the morning when all the cars were gone to take these scans. But one tired grad student forgot to set the logging flag to true, so they drove around all night collecting data, but it was all immediately lost. People were not happy with him."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCurrent approaches rely on middleware to enable some of the above features. "
                            },
                            {
                                "type": "link",
                                "url": "https://ros.org",
                                "text": "ROS"
                            },
                            {
                                "type": "text",
                                "text": " is one such middleware for robots. It's called an operating system but it runs on top of Linux. It provides a networking api to publish and subscribe to messages produced by control nodes. But the problem, aside from the fact that ROS is nigh unusable even for experts, is that the actual programming is still done in C++ or Python. I don't think I have to explain to this crowd how much of a letdown that is. C++ and Python and any other imperative language is the exact wrong kind of tool to use in this scenario.\n\nParallel, async, distributed code is way easier to write if the whole system is designed for it. Parallel/async code got a reputation for being a nightmare to write because it's a nightmare to write in C++. But that doesn't preclude other systems being better! I think you see a general recognition in the industry that things are going this way. But I don't think they have realized yet that it's better to use a system designed from first principles to support these features than to bolt them on to C++ or Python or Javascript.\n\nMech is still really early, so even it doesn't support all the features I laid out above. But that's one of the goals for the project: to be a better language for robot systems.\n\nAnyway, I'm happy you brought this topic up, because I love talking about it!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c8cb2f5a-2046-46e2-94a1-e09db417a1cc",
        "type": "message",
        "text": "Hey, that\u2019s awesome!! Thanks for sharing, you\u2019re in my neck of the woods too (Philly). Everything you laid out here is great. What I\u2019m most interested in is a layer down I think: reifying the _<https://www.youtube.com/watch?v=-FvrON0OmYc|dynamics>_ of the systems being programmed (which FRP is silent on). A corollary to this is being able to work easily with data-driven models, which is necessary when practically designing this systems but can also be easier than closed-form equations for beginners. Is this something you\u2019ve thought about incorporating into Mech?\n\nI have a hunch this approach could scale nicely from beginner games, robots, and websites all the way to some very cutting edge stuff based on <https://diffprogramming.mit.edu/|differentiable programming>.",
        "user": "U9C92716C",
        "ts": "1641404132.369000",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://www.youtube.com/watch?v=-FvrON0OmYc",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/-FvrON0OmYc?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "thumb_url": "https://i.ytimg.com/vi/-FvrON0OmYc/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=-FvrON0OmYc",
                "fallback": "YouTube Video: The Anatomy of a Dynamical System",
                "title": "The Anatomy of a Dynamical System",
                "title_link": "https://www.youtube.com/watch?v=-FvrON0OmYc",
                "author_name": "Steve Brunton",
                "author_link": "https://www.youtube.com/c/Eigensteve",
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pu9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey, that\u2019s awesome!! Thanks for sharing, you\u2019re in my neck of the woods too (Philly). Everything you laid out here is great. What I\u2019m most interested in is a layer down I think: reifying the "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=-FvrON0OmYc",
                                "text": "dynamics",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of the systems being programmed (which FRP is silent on). A corollary to this is being able to work easily with data-driven models, which is necessary when practically designing this systems but can also be easier than closed-form equations for beginners. Is this something you\u2019ve thought about incorporating into Mech?\n\nI have a hunch this approach could scale nicely from beginner games, robots, and websites all the way to some very cutting edge stuff based on "
                            },
                            {
                                "type": "link",
                                "url": "https://diffprogramming.mit.edu/",
                                "text": "differentiable programming"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C"
    },
    {
        "client_msg_id": "97265482-71b0-4cd1-9c39-598b5f9c3bf3",
        "type": "message",
        "text": "I kind of think the kubernetes control plane is a control theory esq.\n\n<https://kubernetes.io/docs/concepts/architecture/controller/>",
        "user": "U02E4DAQGSZ",
        "ts": "1641407309.369600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://kubernetes.io/docs/concepts/architecture/controller/",
                "thumb_url": "https://kubernetes.io/images/favicon.png",
                "thumb_width": 512,
                "thumb_height": 512,
                "service_icon": "https://kubernetes.io/favicons/apple-touch-icon-180x180.png",
                "id": 1,
                "original_url": "https://kubernetes.io/docs/concepts/architecture/controller/",
                "fallback": "Kubernetes: Controllers",
                "text": "In robotics and automation, a control loop is a non-terminating loop that regulates the state of a system. Here is one example of a control loop: a thermostat in a room. When you set the temperature, that's telling the thermostat about your desired state. The actual room temperature is the current state. The thermostat acts to bring the current state closer to the desired state, by turning equipment on or off.",
                "title": "Controllers",
                "title_link": "https://kubernetes.io/docs/concepts/architecture/controller/",
                "service_name": "Kubernetes"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "17Gr2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I kind of think the kubernetes control plane is a control theory esq.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://kubernetes.io/docs/concepts/architecture/controller/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d235b1f8-4d7a-4184-ae2b-7a3d87c1913d",
        "type": "message",
        "text": "I also have a patent in using kubernetes as an actual robot controller... <https://uspto.report/patent/app/20200344293>\n\nI think control theory is very applicable to distributed system because failures have to be considered, and not in PL research because a single computer is considered error free (or unrecoverable at least).",
        "user": "U02E4DAQGSZ",
        "ts": "1641407607.369900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3zs=X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also have a patent in using kubernetes as an actual robot controller... "
                            },
                            {
                                "type": "link",
                                "url": "https://uspto.report/patent/app/20200344293"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI think control theory is very applicable to distributed system because failures have to be considered, and not in PL research because a single computer is considered error free (or unrecoverable at least)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U9C92716C"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4ad21198-7b75-4635-8cc3-329cd90f9d6e",
        "type": "message",
        "text": "Nice! Yes, large industrial systems are where I see ideas from control systems being applied (by necessity). I\u2019d love to see more of that power accessible to end users and smaller communities. Kubernetes is a cool illustration because it\u2019s part of the \u201cabstract\u201d digital world where people forget that they\u2019re working with physical dynamical systems in the end\u2014not to mention the name itself. Alan Kay has recently been hammering on about how software systems should be designed more like the industrial \u201cCAD&lt;-&gt;SIM&lt;-&gt;FAB\u201d approach.\n<https://www.quora.com/Does-Alan-Kay-see-any-new-ideas-in-computing>\n<https://www.quora.com/What-would-software-CAD-SIM-look-like>",
        "user": "U9C92716C",
        "ts": "1641414892.370500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://www.quora.com/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "thumb_url": "https://qph.fs.quoracdn.net/main-custom-t-788-600x315-pitawsfglqjondnjfdmgqqsnbnracpcv.jpeg",
                "thumb_width": 600,
                "thumb_height": 315,
                "id": 1,
                "original_url": "https://www.quora.com/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "fallback": "Quora: Does Alan Kay see any new ideas in computing?",
                "text": "Answer: \u201cNew\u201d is not what I look for. \u201cIdeas that make a qualitative difference over past techniques\u201d are what I\u2019d like to see. Years ago, I\u2019m fairly sure I was aware of pretty much everything regarding computing that was going on in the world. Today, I\u2019m definitely not aware of everything, so i...",
                "title": "Does Alan Kay see any new ideas in computing?",
                "title_link": "https://www.quora.com/Does-Alan-Kay-see-any-new-ideas-in-computing",
                "service_name": "Quora"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5bt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nice! Yes, large industrial systems are where I see ideas from control systems being applied (by necessity). I\u2019d love to see more of that power accessible to end users and smaller communities. Kubernetes is a cool illustration because it\u2019s part of the \u201cabstract\u201d digital world where people forget that they\u2019re working with physical dynamical systems in the end\u2014not to mention the name itself. Alan Kay has recently been hammering on about how software systems should be designed more like the industrial \u201cCAD<->SIM<->FAB\u201d approach.\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.quora.com/Does-Alan-Kay-see-any-new-ideas-in-computing"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.quora.com/What-would-software-CAD-SIM-look-like"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1641389275.367500",
        "parent_user_id": "U9C92716C",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U02E4DAQGSZ"
                ],
                "count": 1
            }
        ]
    }
]