[
    {
        "client_msg_id": "857688c2-1885-41c7-be32-97178ab04024",
        "type": "message",
        "text": "Any opinions on should _the editors in which you edit a structure (AST) rather than text_ be called Structure Editors, Structured Editors, Structural Editors (just saw <@U03LMRE6MQE> use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?\n\nPersonally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology :slightly_smiling_face:.\n\nAny thoughts?",
        "user": "U0296ACR13M",
        "ts": "1671521797.378819",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2OHj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Any opinions on should "
                            },
                            {
                                "type": "text",
                                "text": "the editors in which you edit a structure (AST) rather than text",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be called Structure Editors, Structured Editors, Structural Editors (just saw "
                            },
                            {
                                "type": "user",
                                "user_id": "U03LMRE6MQE"
                            },
                            {
                                "type": "text",
                                "text": " use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?\n\nPersonally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nAny thoughts?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0296ACR13M",
            "ts": "1671522275.000000"
        },
        "thread_ts": "1671521797.378819",
        "reply_count": 18,
        "reply_users_count": 7,
        "latest_reply": "1671979233.520089",
        "reply_users": [
            "U03R0B9U1GD",
            "U0296ACR13M",
            "U013ZLJARC7",
            "U03J1HP9C0G",
            "UGWUJUZHT",
            "U03LMRE6MQE",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "aba8f0df-7d70-4708-93d2-dfa0cc1e5135",
        "type": "message",
        "text": "My vote is for Structure Editor :hand:\n\"With a text editor, you edit some text that represents your code. With a structure editor, you edit a structure that represents your code.\" ?",
        "user": "U03R0B9U1GD",
        "ts": "1671522340.337339",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Un7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My vote is for Structure Editor "
                            },
                            {
                                "type": "emoji",
                                "name": "hand",
                                "unicode": "270b"
                            },
                            {
                                "type": "text",
                                "text": "\n\"With a text editor, you edit some text that represents your code. With a structure editor, you edit a structure that represents your code.\" ?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U02028JHX37"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "89fbb837-aa02-409e-8bc7-87355aad22e4",
        "type": "message",
        "text": "on the other hand, it doesn't roll off the tongue so well, so scrap that",
        "user": "U03R0B9U1GD",
        "ts": "1671522542.584069",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KZV8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "on the other hand, it doesn't roll off the tongue so well, so scrap that"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "e4999557-9644-4171-bb65-19011cfa4b8b",
        "type": "message",
        "text": "Good choice! :slightly_smiling_face: Although I don't think the thing 'represented' needs to necessary be code.",
        "user": "U0296ACR13M",
        "ts": "1671522561.744529",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gb4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good choice! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": " Although I don't think the thing 'represented' needs to necessary be code."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "abfa3cc2-110f-45a5-b200-ceeb9f2160d0",
        "type": "message",
        "text": "roll off as opposed to Structured or Structural?",
        "user": "U0296ACR13M",
        "ts": "1671522599.037089",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8qm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "roll off as opposed to Structured or Structural?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "04ba1f08-e95f-4db3-87e0-acca1bdc098f",
        "type": "message",
        "text": "I guess swap out 'code' for 'X' depending on the context. \nAnd yes, but that's possibly just an accent thing. Not sure whether to put a glottal stop in between the two words or not :)",
        "user": "U03R0B9U1GD",
        "ts": "1671522787.099499",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fgub+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess swap out 'code' for 'X' depending on the context. \nAnd yes, but that's possibly just an accent thing. Not sure whether to put a glottal stop in between the two words or not :)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "7f281040-9a2d-48b5-954f-2b4c56b33a8c",
        "type": "message",
        "text": "I feel like for a finn Projectional would be easiest, but out of the other three Structure",
        "user": "U0296ACR13M",
        "ts": "1671522983.555769",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PSCv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I feel like for a finn Projectional would be easiest, but out of the other three Structure"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03R0B9U1GD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "23ef8510-c92c-4f47-92f0-e1bebd7aa815",
        "type": "message",
        "text": "all variations of structur* occur in the literature, but I also prefer \"Structure Editor\" :slightly_smiling_face:",
        "user": "U013ZLJARC7",
        "ts": "1671527182.877669",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FQ8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "all variations of structur* occur in the literature, but I also prefer \"Structure Editor\" "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1671527247.000000"
        },
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "arrow_up",
                "users": [
                    "U03R0B9U1GD",
                    "U02028JHX37"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "19914f6e-c22b-400f-976f-d3aaa13bd079",
        "type": "message",
        "text": "(\"Projectional editor\" means an editor that can project the same underlying structure in multiple ways, so it connotes a sort of meta structure editor.)",
        "user": "U013ZLJARC7",
        "ts": "1671527232.517079",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N10eg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(\"Projectional editor\" means an editor that can project the same underlying structure in multiple ways, so it connotes a sort of meta structure editor.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U03R0B9U1GD",
                    "U0296ACR13M"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0ed7016a-ae8f-4a21-9f50-ea1762e3fc55",
        "type": "message",
        "text": "'Structure editor' seems like a good general term, but a software that directly explores and edits AST may be called ... 'AST Editor'?",
        "user": "U03J1HP9C0G",
        "ts": "1671541383.577169",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w13Gx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "'Structure editor' seems like a good general term, but a software that directly explores and edits AST may be called ... 'AST Editor'?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U0296ACR13M",
                    "UN57U8V53"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "51dc1d7c-b405-48b0-8ecc-97cff354ed3e",
        "type": "message",
        "text": "I would call it \u201cLisp\u201d or a \u201ctree editor\u201d.\n\nFeatures of the underlying syntax:\nvery regular syntax, limited choices\nrecursive definition\nmachine-readable, machine-writable.\n\nThe different views (\u201cprojections\u201d) might be called \u201cskins\u201d.  They are micro-syntaxes that make the machine-readable stuff more palatable to humans, i.e. mappings from human-readable -&gt; machine-readable.",
        "user": "UGWUJUZHT",
        "ts": "1671556992.672599",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y6N82",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would call it \u201cLisp\u201d or a \u201ctree editor\u201d.\n\nFeatures of the underlying syntax:\nvery regular syntax, limited choices\nrecursive definition\nmachine-readable, machine-writable.\n\nThe different views (\u201cprojections\u201d) might be called \u201cskins\u201d.  They are micro-syntaxes that make the machine-readable stuff more palatable to humans, i.e. mappings from human-readable -> machine-readable."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "f276a17c-6ecb-49c5-a029-dffb2a86cbd6",
        "type": "message",
        "text": "<@UGWUJUZHT> why \"Lisp\" ?",
        "user": "U0296ACR13M",
        "ts": "1671641685.971529",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+O8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " why \"Lisp\" ?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "e12badc5-ae0a-4343-919b-2841e553008b",
        "type": "message",
        "text": "<@U0296ACR13M> Squinting:\nLisp source code is: hand-written ASTs\ne.g. in a ficticious high level language: `a := b + c`\nIn ficticious Lisp: `(assign a (plus b c))`\nIn real Common Lisp: `(setf a (+ b c))`\nLisp\u2019s main operations are tree manipulation operators - CAR, CDR, CONS.  The rest are nice-to-have noise operations that deal with with the contents of tree nodes and/or convenience functions.\nAny AST editor boils down to Lisp operations.",
        "user": "UGWUJUZHT",
        "ts": "1671650532.079039",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FwPg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0296ACR13M"
                            },
                            {
                                "type": "text",
                                "text": " Squinting:\nLisp source code is: hand-written ASTs\ne.g. in a ficticious high level language: "
                            },
                            {
                                "type": "text",
                                "text": "a := b + c",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nIn ficticious Lisp: "
                            },
                            {
                                "type": "text",
                                "text": "(assign a (plus b c))",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nIn real Common Lisp: "
                            },
                            {
                                "type": "text",
                                "text": "(setf a (+ b c))",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nLisp\u2019s main operations are tree manipulation operators - CAR, CDR, CONS.  The rest are nice-to-have noise operations that deal with with the contents of tree nodes and/or convenience functions.\nAny AST editor boils down to Lisp operations."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1671650797.000000"
        },
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK",
                    "UFWR21E4W"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "U0296ACR13M"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6a497669-804c-4949-a6a2-f7fa14cbad28",
        "type": "message",
        "text": "What are the list operations for dealing with tagged structures. i.e records and unions. I see how lisp matches to lambda reductions but I've been adding unions/records/effects all based of row types and am unsure what there native manipulations would be",
        "user": "U03LMRE6MQE",
        "ts": "1671700672.656719",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jsC0u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are the list operations for dealing with tagged structures. i.e records and unions. I see how lisp matches to lambda reductions but I've been adding unions/records/effects all based of row types and am unsure what there native manipulations would be"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "client_msg_id": "35582e4a-8e31-47e1-9ea3-15f9881f9332",
        "type": "message",
        "text": "short answer: functions\nx.y is really y(x) and is written in Lisp as (y x)\nmethod call self.y(z) is really y(self,z) and is written in Lisp as (y self z)\n\nlonger answer: all you get is ASTs (things and lists of things)\nYes, that is very low-level.\nMcCarthy decided to drape meaning over ASTs, i.e the root node of an AST is a always considered to be a function.\nIn the past, if you wanted to create more syntactic sugar draped over your ASTs, you would lock yourself away in a room for years and invent a \u201cnew language\u201d.\nOr, if you were a Lisper, you would create functions called \u201cmacros\u201d, but, the resulting syntax always looked like more ASTs (lists).\nCharacter-based syntax was reserved for compiler gurus who knew how to use parser tools.\nToday, though: Ohm-JS provides a way to drape character-based syntax over ASTs in an afternoon (it even comes with a REPL for helping you design/debug a syntax - \u201cOhm-Editor\u201d).  All you need is a toolbag of functionality plus Ohm-JS. (i.e. Common Lisp + Ohm-JS, or, JavaScript + Ohm-JS, or \u2026).  PEG-based parsers (like Ohm) can do things that CFG parsers can\u2019t.  As a result, quickie grammars can be incredibly short (i.e a couple of lines, slightly longer than a REGEX, but way shorter than most YACC-based parsers).\nBack to your question: If you want to see other people\u2019s ideas on how to structure data, or if you don\u2019t want to roll your own, see \u201cCLOS\u201d  and \u201cDEFCLASS\u201d and \u201cDEFSTRUCT\u201d.  CLOS method dispatch is different and better and more flexible than the usual OO stuff.\n\n[The learning curve is probably steep.  Lispers are usually glad to help.  There are &gt;1 Lispers here].",
        "user": "UGWUJUZHT",
        "ts": "1671713931.376959",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ln2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "short answer: functions\nx.y is really y(x) and is written in Lisp as (y x)\nmethod call self.y(z) is really y(self,z) and is written in Lisp as (y self z)\n\nlonger answer: all you get is ASTs (things and lists of things)\nYes, that is very low-level.\nMcCarthy decided to drape meaning over ASTs, i.e the root node of an AST is a always considered to be a function.\nIn the past, if you wanted to create more syntactic sugar draped over your ASTs, you would lock yourself away in a room for years and invent a \u201cnew language\u201d.\nOr, if you were a Lisper, you would create functions called \u201cmacros\u201d, but, the resulting syntax always looked like more ASTs (lists).\nCharacter-based syntax was reserved for compiler gurus who knew how to use parser tools.\nToday, though: Ohm-JS provides a way to drape character-based syntax over ASTs in an afternoon (it even comes with a REPL for helping you design/debug a syntax - \u201cOhm-Editor\u201d).  All you need is a toolbag of functionality plus Ohm-JS. (i.e. Common Lisp + Ohm-JS, or, JavaScript + Ohm-JS, or \u2026).  PEG-based parsers (like Ohm) can do things that CFG parsers can\u2019t.  As a result, quickie grammars can be incredibly short (i.e a couple of lines, slightly longer than a REGEX, but way shorter than most YACC-based parsers).\nBack to your question: If you want to see other people\u2019s ideas on how to structure data, or if you don\u2019t want to roll your own, see \u201cCLOS\u201d  and \u201cDEFCLASS\u201d and \u201cDEFSTRUCT\u201d.  CLOS method dispatch is different and better and more flexible than the usual OO stuff.\n\n[The learning curve is probably steep.  Lispers are usually glad to help.  There are >1 Lispers here]."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U03LMRE6MQE"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "613d6a25-2176-4907-a800-30bd6841c2cf",
        "type": "message",
        "text": "<@UGWUJUZHT> Your reference to \"Common Lisp + Ohm-JS\" suggests that parsers written in Ohm-JS can be used with languages outside of the JS ecosystem. That's not my impression from looking at the Ohm-JS Web site, which only mentions TypeScript as an alternative target to JavaScript. Is there something I overlooked?\nBackground: Ohm-JS looks very interesting for some ideas I'd like to play with, but I have investment into JS or Web programming in general.",
        "user": "UJBAJNFLK",
        "ts": "1671716960.985979",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dATju",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": " Your reference to \"Common Lisp + Ohm-JS\" suggests that parsers written in Ohm-JS can be used with languages outside of the JS ecosystem. That's not my impression from looking at the Ohm-JS Web site, which only mentions TypeScript as an alternative target to JavaScript. Is there something I overlooked?\nBackground: Ohm-JS looks very interesting for some ideas I'd like to play with, but I have investment into JS or Web programming in general."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "1b3174f0-d43f-4ec2-a618-7b76a359e190",
        "type": "message",
        "text": "[hmm long answer, I wish it were shorter...]\n\nCorrect, the parser technology is built in JavaScript and runs in a browser and in node.js.\n\nI was getting at something else. It\u2019s my fault that the idea wasn\u2019t made clear.  Let\u2019s try again:\n1) I generate compilers using Ohm-JS that transpile from syntax I invent to other languages like Common Lisp, Python and JS (I believe that I could do more languages, but I haven\u2019t needed to do so (FYI, I have a P.O.C. WASM generator, but more work is needed (this was my first encounter with WASM and more learning curve is needed))).\n2) Then, I run those generated compilers to compile code written in the new languages.\n3) Then, I run the generated code on the command line, and, sometimes, in the browser.\n\nOhm-JS, based on PEG, is the game changer in the way I now look at problems.  CFGs (LR(k), YACC, etc.), REGEX, and, hand-written recursive descent parsers are just too cumbersome to use in the same way that I use Ohm-JS.\n\nAs an aside, one of the first things I wrote was a compiler that produced code that could be bolted into an Ohm-JS project, with the result that, in many use-cases, I don\u2019t have to write any JavaScript code at all.  I can write the grammar in Ohm\u2019s grammar syntax and I can write the transform in my own FABrication syntax, which is more succinct than JS.\n\nFurther aside: the first thing I did with Ohm-JS was to write a Scheme-subset-to-JS transpiler and used it to convert Nils Holm\u2019s PROLOG in Scheme to JavaScript.\n\nExample: I am deeply interested in true concurrency.  My code uses messages that look like:\n\u27e8a b c d\u27e9\nand I use Ohm-JS to transpile this nano-syntax into something like:\n\u27e8Message a b c d\u27e9\nusing 2 specifications:\n1. \u201b\u27ea\u00abp\u00bb \u00abd\u00bb \u00abs\u00bb \u00abm\u00bb\u27eb\u2019\n2. \u201b\u27e8Message \u00abp\u00bb \u00abd\u00bb \u00abs\u00bb \u00abm\u00bb\u27e9\u2019\nN.B. the whole spec for the pattern matching is 1 line long, and, the whole spec for transforming is 1 line long.\nThis specific example could be done with a Python script (or sed with Unicode support), but there are other details that I\u2019m trying to skip over for this example, e.g. messages might contain other messages recursively, for which it helps to have a parser that can express matching brackets.\n\nThe input to Ohm-JS is a JS String.  The output of my FABricator compiler is a JS String.  All of the above steps can be done in one fell-swoop in a JavaScript program that feeds strings to Ohm-JS and calls Ohm-JS twice.  At one point, I need to compile a generated String to executable code.  JavaScript\u2019s \u201ceval()\u201d does this. (A \u201ccompiler\u201d is \u201ceval()\u201c)\n\nExample: here\u2019s a contrived example of something that I would never do with YACC, but would do with Ohm-JS:\nContrived Problem: scan this big JavaScript program and list every name of every top-level function.  Using YACC, you need to write a full spec (\u201cgrammar\u201d) for JavaScript, with PEG (Ohm-JS), you can say something more obvious and succint: a function is `function id (...) { ... }` where the \u2018...\u2019 stuff is anything including recursively bracketed bits.  The point here is not whether I wrote a correct pattern match, but, the difference between \u201comg, I have to write a grammar for every nook and cranny in JavaScript\u201d vs. writing a grammar with \u201cI don\u2019t care about this part\u201d.  This contrived example can probably be done with a REGEX, but if the problem is expanded to be something like \u201clist every function with the name of each parameter\u201d then REGEX works less-well than a parser.",
        "user": "UGWUJUZHT",
        "ts": "1671775304.698739",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "owrBc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "[hmm long answer, I wish it were shorter...]\n\nCorrect, the parser technology is built in JavaScript and runs in a browser and in node.js.\n\nI was getting at something else. It\u2019s my fault that the idea wasn\u2019t made clear.  Let\u2019s try again:\n1) I generate compilers using Ohm-JS that transpile from syntax I invent to other languages like Common Lisp, Python and JS (I believe that I could do more languages, but I haven\u2019t needed to do so (FYI, I have a P.O.C. WASM generator, but more work is needed (this was my first encounter with WASM and more learning curve is needed))).\n2) Then, I run those generated compilers to compile code written in the new languages.\n3) Then, I run the generated code on the command line, and, sometimes, in the browser.\n\nOhm-JS, based on PEG, is the game changer in the way I now look at problems.  CFGs (LR(k), YACC, etc.), REGEX, and, hand-written recursive descent parsers are just too cumbersome to use in the same way that I use Ohm-JS.\n\nAs an aside, one of the first things I wrote was a compiler that produced code that could be bolted into an Ohm-JS project, with the result that, in many use-cases, I don\u2019t have to write any JavaScript code at all.  I can write the grammar in Ohm\u2019s grammar syntax and I can write the transform in my own FABrication syntax, which is more succinct than JS.\n\nFurther aside: the first thing I did with Ohm-JS was to write a Scheme-subset-to-JS transpiler and used it to convert Nils Holm\u2019s PROLOG in Scheme to JavaScript.\n\nExample: I am deeply interested in true concurrency.  My code uses messages that look like:\n\u27e8a b c d\u27e9\nand I use Ohm-JS to transpile this nano-syntax into something like:\n\u27e8Message a b c d\u27e9\nusing 2 specifications:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201b\u27ea\u00abp\u00bb \u00abd\u00bb \u00abs\u00bb \u00abm\u00bb\u27eb\u2019"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201b\u27e8Message \u00abp\u00bb \u00abd\u00bb \u00abs\u00bb \u00abm\u00bb\u27e9\u2019"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "N.B. the whole spec for the pattern matching is 1 line long, and, the whole spec for transforming is 1 line long.\nThis specific example could be done with a Python script (or sed with Unicode support), but there are other details that I\u2019m trying to skip over for this example, e.g. messages might contain other messages recursively, for which it helps to have a parser that can express matching brackets.\n\nThe input to Ohm-JS is a JS String.  The output of my FABricator compiler is a JS String.  All of the above steps can be done in one fell-swoop in a JavaScript program that feeds strings to Ohm-JS and calls Ohm-JS twice.  At one point, I need to compile a generated String to executable code.  JavaScript\u2019s \u201ceval()\u201d does this. (A \u201ccompiler\u201d is \u201ceval()\u201c)\n\nExample: here\u2019s a contrived example of something that I would never do with YACC, but would do with Ohm-JS:\nContrived Problem: scan this big JavaScript program and list every name of every top-level function.  Using YACC, you need to write a full spec (\u201cgrammar\u201d) for JavaScript, with PEG (Ohm-JS), you can say something more obvious and succint: a function is "
                            },
                            {
                                "type": "text",
                                "text": "function id (...) { ... }",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " where the \u2018...\u2019 stuff is anything including recursively bracketed bits.  The point here is not whether I wrote a correct pattern match, but, the difference between \u201comg, I have to write a grammar for every nook and cranny in JavaScript\u201d vs. writing a grammar with \u201cI don\u2019t care about this part\u201d.  This contrived example can probably be done with a REGEX, but if the problem is expanded to be something like \u201clist every function with the name of each parameter\u201d then REGEX works less-well than a parser."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M"
    },
    {
        "type": "message",
        "subtype": "thread_broadcast",
        "text": "Thanks <@UGWUJUZHT>, that's a very good answer (better long than cryptic!). I was aware of the advantages of PEG, and of the exceptional tooling support in Ohm-JS for PEG. So my summary of your explanation is \"Rather than using a PEG library for language X, use Ohm-JS to generate something that you can process in/with language X.\" You gain better tooling, at the price of build system complexity if your ecosystem is not already JS.",
        "user": "UJBAJNFLK",
        "ts": "1671785800.274309",
        "thread_ts": "1671521797.378819",
        "root": {
            "client_msg_id": "857688c2-1885-41c7-be32-97178ab04024",
            "type": "message",
            "text": "Any opinions on should _the editors in which you edit a structure (AST) rather than text_ be called Structure Editors, Structured Editors, Structural Editors (just saw <@U03LMRE6MQE> use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?\n\nPersonally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology :slightly_smiling_face:.\n\nAny thoughts?",
            "user": "U0296ACR13M",
            "ts": "1671521797.378819",
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "2OHj",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Any opinions on should "
                                },
                                {
                                    "type": "text",
                                    "text": "the editors in which you edit a structure (AST) rather than text",
                                    "style": {
                                        "italic": true
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": " be called Structure Editors, Structured Editors, Structural Editors (just saw "
                                },
                                {
                                    "type": "user",
                                    "user_id": "U03LMRE6MQE"
                                },
                                {
                                    "type": "text",
                                    "text": " use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?\n\nPersonally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology "
                                },
                                {
                                    "type": "emoji",
                                    "name": "slightly_smiling_face",
                                    "unicode": "1f642"
                                },
                                {
                                    "type": "text",
                                    "text": ".\n\nAny thoughts?"
                                }
                            ]
                        }
                    ]
                }
            ],
            "team": "T5TCAFTA9",
            "edited": {
                "user": "U0296ACR13M",
                "ts": "1671522275.000000"
            },
            "thread_ts": "1671521797.378819",
            "reply_count": 18,
            "reply_users_count": 7,
            "latest_reply": "1671979233.520089",
            "reply_users": [
                "U03R0B9U1GD",
                "U0296ACR13M",
                "U013ZLJARC7",
                "U03J1HP9C0G",
                "UGWUJUZHT",
                "U03LMRE6MQE",
                "UJBAJNFLK"
            ],
            "is_locked": false,
            "subscribed": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "s4o1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UGWUJUZHT"
                            },
                            {
                                "type": "text",
                                "text": ", that's a very good answer (better long than cryptic!). I was aware of the advantages of PEG, and of the exceptional tooling support in Ohm-JS for PEG. So my summary of your explanation is \"Rather than using a PEG library for language X, use Ohm-JS to generate something that you can process in/with language X.\" You gain better tooling, at the price of build system complexity if your ecosystem is not already JS."
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "b4733156-114c-4a1a-b3a5-3ba5e942e06d",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "54446f76-1ba3-4e6a-b76a-e16e0b5aebf6",
        "type": "message",
        "text": "Addendum: There is \u201clightweight\u201d pattern matching and \u201cheavyweight\u201d pattern matching.\n\nREGEX falls into the lightweight category, while CFG-based parser generators fall into the heavyweight category.\n\nThe terms \u201clightweight\u201d and \u201cheavyweight\u201d refer to Economy of Expression.\n\nOhm-JS\u2019s big win is that it fills the gap between REGEX and CFG technologies, enabling a new niche for thought.\n\nOhm-JS falls into the lightweight category.  Ohm-JS can do things that REGEX can\u2019t do, like recursive matching and matching of balanced constructs.",
        "user": "UGWUJUZHT",
        "ts": "1671979233.520089",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pAnd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Addendum: There is \u201clightweight\u201d pattern matching and \u201cheavyweight\u201d pattern matching.\n\nREGEX falls into the lightweight category, while CFG-based parser generators fall into the heavyweight category.\n\nThe terms \u201clightweight\u201d and \u201cheavyweight\u201d refer to Economy of Expression.\n\nOhm-JS\u2019s big win is that it fills the gap between REGEX and CFG technologies, enabling a new niche for thought.\n\nOhm-JS falls into the lightweight category.  Ohm-JS can do things that REGEX can\u2019t do, like recursive matching and matching of balanced constructs."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1671521797.378819",
        "parent_user_id": "U0296ACR13M",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    }
]