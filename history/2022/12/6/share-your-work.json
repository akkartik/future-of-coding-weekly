[
    {
        "client_msg_id": "0ffeee90-9aed-41c1-bb92-e84cd0a81c00",
        "type": "message",
        "text": "An essay about the history of compiler-appeasement languages, meant for discussion.\n\n[meta: I would be glad to move this to another channel or to remove it completely.  One aspect of my \u201cwork\u201d is to observe.  FWIW, I share this...]\n\nType checkers are helpers for development.  Similar to parsing and syntax checkers.  Type checkers are - currently - more difficult to write than syntax checkers.  There was a time when syntax checking was not well understood and was difficult and was written in an ad-hoc manner.  Early FORTRAN had syntax that we would consider weird today.  Early FORTRAN did not treat spaces specially and went for the shortest match (I think).  For example `IF` and `IFX` were both parsed as the beginning of an `IF` statement.  Later, it was discovered that making spaces \u201cspecial\u201d would help in making parsers and would help in cleaning up silliness like `IF` and `IFX`.  At the time, the character set consisted of ASCII (well, there was EBCDIC, championed by IBM, but, IBM was hated even more than Microsoft and Apple are hated today, so EBCDIC was mostly avoided by non-IBMers).  The fact that ASCII only has 128 characters to choose from (some 32 \u201cunprintables\u201d must be subtracted from this count) made for silly decisions like denoting strings with the same beginning and ending quote (which makes parsing more difficult) and not-allowing spaces to be embedded in names.  With Unicode, we have many more choices, but, we remain stuck with decisions made to appease 1950s hardware.  Aside: in 2022, we have hardware that can handle vector graphics and overlapping graphical elements, e.g. windows and very-small windows (\u201cbuttons\u201d, \u201cwidgets\u201d), but, we are stuck with decisions made to appease 1950s hardware.  I argue that we should be building languages based on vector graphics instead of non-overlapping characters.  SVG is a simple example of something that might work on this front (rectangles, ellipses, lines, text, groups). Aside: \u201cdeclaration before use\u201d is a result of 1950s thinking (save CPU time by making compilers 1-pass), even though, in 2022, we could easily burn CPU cycles to figure out \u201cdeclaration after use\u201d. Aside: declaration-checking (before or after use) is only a helper for developers. The machine doesn\u2019t care if you make a typo.  \u201cDeclaration-checking\u201d is an app to help developers stamp out simple errors (like typos).  Demanding that programmers rearrange their code so that the declarations ALL come before the code is compiler-appeasement (based on 1950s hardware).\n\nThe best way to write a type checker is to use a Relational Language (like PROLOG, miniKanren, Datalog, etc., etc.).  Relational languages are shining examples of languages that don\u2019t appease compilers.  In a relational language, you write relations (\u201ctruth\u201d) and let the underlying system figure out how to implement the machinery for matching up the relations.  Other technologies that bark up this same tree: declarative languages and ML. (Aside: oh my, HTML is a declarative language.  But, HTML needs to lean on JavaScript to allow imperative break-outs).\n\nThere is no \u201cideal language\u201d.  The notation you use depends on the problem you are trying to solve.  A simple example would be the idea of Spreadsheets vs. Lambda Calculus.  Accountants and financial analysts like Spreadsheets.  Programming rigor analysts like Lambda Calculus.  Accountants would not want to use Lambda Calculus and rigor-ists would not want to use Spreadsheets.  Another example, closer to my heart, is the difference between using Language Theory to generate parsers and using PEG to generate parsers. Language Theory-based parsers cannot do what PEG-based parsers can do (for example, parse balanced parentheses).  Trying to force-fit language theory onto parsing has stagnated the field.  Most languages look the same, with minor differences. (Aside: PEG is Parser Theory, not Language Theory, despite the superficial similarities in syntax).  The fact that parsing is \u201cdifficult\u201d has restricted programmers to using only a small number of programming languages, instead of using a zillion nano-languages and defining their own nano-languages (I call these SCNs (Solution Centric Notations)).\n\n\u201cDynamic\u201d languages are \u201cgood\u201d for fast turnaround on ideas, but are \u201cbad\u201d for producing end-user apps which are cost-optimized.  \u201cStatic languages\u201d are \u201cgood\u201d for Production Engineering apps, but, are \u201cbad\u201d for inventing new products.  Trying to force-fit all use-cases into one language results in a watered-down notation which isn\u2019t particularly good for either use-case.  (Aside: at the moment, efforts to force-fit all use-cases into one language favour the Production Engineering side over the Design side of things, and, this is what I call \u201ccompiler appeasement\u201d.  When programmers have to stop and rearrange their inventions to help the compiler figure out how to optimize, they are appeasing the compiler). (Aside: if Physicists *ALL* engaged in worshipping functional notation, we wouldn\u2019t have Feynman Diagrams, nor Polyani\u2019s \u201cOrder Out of Chaos\u201d, etc.).\n\n_Barnacles_ might be invented for helping developers, e.g. type checkers and linters. Twisting a language design to appease *only* pre-compilation is *not OK* in my book. At the moment, most of our programming languages are compiler-appeasement languages and insist that developers waste time (and imagination) on dealing with compiler-appeasement and pre-compilation issues, long before the program works.\n\nBarnacle-like pre-compilation was researched in the mid-1900s with work like Fraser/Davidson peephole technologies. This was called RTL and formed the basis of _gcc_. Cordy\u2019s Orthogonal Code Generator is a generalization of this technique replete with declarative syntax for portability choice-trees (MISTs) and Data Descriptors and Condition Descriptors that improve on the virtual registers used by RTL.\n\n[This essay can be found in <https://github.com/guitarvydas/py0d/issues/2>]",
        "user": "UGWUJUZHT",
        "ts": "1670362232.776479",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ucj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An essay about the history of compiler-appeasement languages, meant for discussion.\n\n[meta: I would be glad to move this to another channel or to remove it completely.  One aspect of my \u201cwork\u201d is to observe.  FWIW, I share this...]\n\nType checkers are helpers for development.  Similar to parsing and syntax checkers.  Type checkers are - currently - more difficult to write than syntax checkers.  There was a time when syntax checking was not well understood and was difficult and was written in an ad-hoc manner.  Early FORTRAN had syntax that we would consider weird today.  Early FORTRAN did not treat spaces specially and went for the shortest match (I think).  For example "
                            },
                            {
                                "type": "text",
                                "text": "IF",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "IFX",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " were both parsed as the beginning of an "
                            },
                            {
                                "type": "text",
                                "text": "IF",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " statement.  Later, it was discovered that making spaces \u201cspecial\u201d would help in making parsers and would help in cleaning up silliness like "
                            },
                            {
                                "type": "text",
                                "text": "IF",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "IFX",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  At the time, the character set consisted of ASCII (well, there was EBCDIC, championed by IBM, but, IBM was hated even more than Microsoft and Apple are hated today, so EBCDIC was mostly avoided by non-IBMers).  The fact that ASCII only has 128 characters to choose from (some 32 \u201cunprintables\u201d must be subtracted from this count) made for silly decisions like denoting strings with the same beginning and ending quote (which makes parsing more difficult) and not-allowing spaces to be embedded in names.  With Unicode, we have many more choices, but, we remain stuck with decisions made to appease 1950s hardware.  Aside: in 2022, we have hardware that can handle vector graphics and overlapping graphical elements, e.g. windows and very-small windows (\u201cbuttons\u201d, \u201cwidgets\u201d), but, we are stuck with decisions made to appease 1950s hardware.  I argue that we should be building languages based on vector graphics instead of non-overlapping characters.  SVG is a simple example of something that might work on this front (rectangles, ellipses, lines, text, groups). Aside: \u201cdeclaration before use\u201d is a result of 1950s thinking (save CPU time by making compilers 1-pass), even though, in 2022, we could easily burn CPU cycles to figure out \u201cdeclaration after use\u201d. Aside: declaration-checking (before or after use) is only a helper for developers. The machine doesn\u2019t care if you make a typo.  \u201cDeclaration-checking\u201d is an app to help developers stamp out simple errors (like typos).  Demanding that programmers rearrange their code so that the declarations ALL come before the code is compiler-appeasement (based on 1950s hardware).\n\nThe best way to write a type checker is to use a Relational Language (like PROLOG, miniKanren, Datalog, etc., etc.).  Relational languages are shining examples of languages that don\u2019t appease compilers.  In a relational language, you write relations (\u201ctruth\u201d) and let the underlying system figure out how to implement the machinery for matching up the relations.  Other technologies that bark up this same tree: declarative languages and ML. (Aside: oh my, HTML is a declarative language.  But, HTML needs to lean on JavaScript to allow imperative break-outs).\n\nThere is no \u201cideal language\u201d.  The notation you use depends on the problem you are trying to solve.  A simple example would be the idea of Spreadsheets vs. Lambda Calculus.  Accountants and financial analysts like Spreadsheets.  Programming rigor analysts like Lambda Calculus.  Accountants would not want to use Lambda Calculus and rigor-ists would not want to use Spreadsheets.  Another example, closer to my heart, is the difference between using Language Theory to generate parsers and using PEG to generate parsers. Language Theory-based parsers cannot do what PEG-based parsers can do (for example, parse balanced parentheses).  Trying to force-fit language theory onto parsing has stagnated the field.  Most languages look the same, with minor differences. (Aside: PEG is Parser Theory, not Language Theory, despite the superficial similarities in syntax).  The fact that parsing is \u201cdifficult\u201d has restricted programmers to using only a small number of programming languages, instead of using a zillion nano-languages and defining their own nano-languages (I call these SCNs (Solution Centric Notations)).\n\n\u201cDynamic\u201d languages are \u201cgood\u201d for fast turnaround on ideas, but are \u201cbad\u201d for producing end-user apps which are cost-optimized.  \u201cStatic languages\u201d are \u201cgood\u201d for Production Engineering apps, but, are \u201cbad\u201d for inventing new products.  Trying to force-fit all use-cases into one language results in a watered-down notation which isn\u2019t particularly good for either use-case.  (Aside: at the moment, efforts to force-fit all use-cases into one language favour the Production Engineering side over the Design side of things, and, this is what I call \u201ccompiler appeasement\u201d.  When programmers have to stop and rearrange their inventions to help the compiler figure out how to optimize, they are appeasing the compiler). (Aside: if Physicists "
                            },
                            {
                                "type": "text",
                                "text": "ALL",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " engaged in worshipping functional notation, we wouldn\u2019t have Feynman Diagrams, nor Polyani\u2019s \u201cOrder Out of Chaos\u201d, etc.).\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Barnacles",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " might be invented for helping developers, e.g. type checkers and linters. Twisting a language design to appease "
                            },
                            {
                                "type": "text",
                                "text": "only",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " pre-compilation is "
                            },
                            {
                                "type": "text",
                                "text": "not OK",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in my book. At the moment, most of our programming languages are compiler-appeasement languages and insist that developers waste time (and imagination) on dealing with compiler-appeasement and pre-compilation issues, long before the program works.\n\nBarnacle-like pre-compilation was researched in the mid-1900s with work like Fraser/Davidson peephole technologies. This was called RTL and formed the basis of "
                            },
                            {
                                "type": "text",
                                "text": "gcc",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Cordy\u2019s Orthogonal Code Generator is a generalization of this technique replete with declarative syntax for portability choice-trees (MISTs) and Data Descriptors and Condition Descriptors that improve on the virtual registers used by RTL.\n\n[This essay can be found in "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/guitarvydas/py0d/issues/2"
                            },
                            {
                                "type": "text",
                                "text": "]"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1670362232.776479",
        "reply_count": 7,
        "reply_users_count": 4,
        "latest_reply": "1670847958.542229",
        "reply_users": [
            "UJBAJNFLK",
            "UCUSW7WVD",
            "U046LSVRN1H",
            "UGWUJUZHT"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "09d9f402-40ba-4642-93fe-6ee86228940b",
        "type": "message",
        "text": "I tend to agree with most of this, except that I am not sure I understand your ideas about SVG. In mainstream programming, the ground-truth representation of code is text (a linear stream of characters), and the UI is a slightly rendered version of that text (syntax coloring etc.). I see how SVG could yield better UIs, but it sounds as if you want SVG to become the ground-truth representation of code. If that's the case, I don't see why.",
        "user": "UJBAJNFLK",
        "ts": "1670397432.998059",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xYlX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I tend to agree with most of this, except that I am not sure I understand your ideas about SVG. In mainstream programming, the ground-truth representation of code is text (a linear stream of characters), and the UI is a slightly rendered version of that text (syntax coloring etc.). I see how SVG could yield better UIs, but it sounds as if you want SVG to become the ground-truth representation of code. If that's the case, I don't see why."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "180cb573-d71f-49a4-a11f-e316ce5306bc",
        "type": "message",
        "text": "On a different topic, your essay contains the eternal \"we are so stuck in the past, we need to move on\" thread that comes up frequently here (and elsewhere). What I have yet to see is a realistic proposition for \"moving on\". If it's \"start from scratch\", it just won't happen. We are not stuck with 1950s hardware, we have built up an enormous IT edifice _starting_ with 1950s hardware. We are still adding to it, and it has become infrastructure for other human endeavours. It won't go away (except maybe in a major civilization crash).\n\nA realistic scenario for moving on must either start from the present edifice and evolve it into something better, remaining functional along the way, or build a second, disconnected edifice to which the world can slowly migrate as it matures.",
        "user": "UJBAJNFLK",
        "ts": "1670397749.199189",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IUz94",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On a different topic, your essay contains the eternal \"we are so stuck in the past, we need to move on\" thread that comes up frequently here (and elsewhere). What I have yet to see is a realistic proposition for \"moving on\". If it's \"start from scratch\", it just won't happen. We are not stuck with 1950s hardware, we have built up an enormous IT edifice "
                            },
                            {
                                "type": "text",
                                "text": "starting",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with 1950s hardware. We are still adding to it, and it has become infrastructure for other human endeavours. It won't go away (except maybe in a major civilization crash).\n\nA realistic scenario for moving on must either start from the present edifice and evolve it into something better, remaining functional along the way, or build a second, disconnected edifice to which the world can slowly migrate as it matures."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "URKQXRCAC",
                    "U046LSVRN1H"
                ],
                "count": 2
            },
            {
                "name": "eyes",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8f3f84bc-a2a4-408a-80f7-71a3ade7b0cc",
        "type": "message",
        "text": "Your point regarding declarations reminds me of my <https://archive.org/details/akkartik-2min-2020-06-07|https://archive.org/details/akkartik-2min-2020-06-07>",
        "user": "UCUSW7WVD",
        "ts": "1670399906.320549",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3p0z3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your point regarding declarations reminds me of my "
                            },
                            {
                                "type": "link",
                                "url": "https://archive.org/details/akkartik-2min-2020-06-07",
                                "text": "https://archive.org/details/akkartik-2min-2020-06-07"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://archive.org/details/akkartik-2min-2020-06-07",
                "thumb_url": "https://archive.org/download/akkartik-2min-2020-06-07/akkartik-2min-2020-06-07.thumbs/akkartik-2min-2020-06-07_000005.jpg",
                "thumb_width": 720,
                "thumb_height": 422,
                "service_icon": "https://archive.org/favicon.ico",
                "id": 1,
                "original_url": "https://archive.org/details/akkartik-2min-2020-06-07",
                "fallback": "Internet Archive: 2020-06-07: Stop specifying modules : Kartik Agaram : Free Download, Borrow, and Streaming : Internet Archive",
                "text": "2-minute video of the Mu project for the Future of Coding forum",
                "title": "2020-06-07: Stop specifying modules : Kartik Agaram : Free Download, Borrow, and Streaming : Internet Archive",
                "title_link": "https://archive.org/details/akkartik-2min-2020-06-07",
                "service_name": "Internet Archive"
            }
        ],
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UGWUJUZHT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2f102a77-2037-4a7a-91cf-798012ce3ea7",
        "type": "message",
        "text": "<@UJBAJNFLK> I really agree with this sentiment on the \u201cwe are so stuck in the past\u201d thread. It\u2019s a little cliche almost to complain about how software development is such a mess. And not necessarily the most productive mindset.",
        "user": "U046LSVRN1H",
        "ts": "1670553263.601349",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NjI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I really agree with this sentiment on the \u201cwe are so stuck in the past\u201d thread. It\u2019s a little cliche almost to complain about how software development is such a mess. And not necessarily the most productive mindset."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT"
    },
    {
        "client_msg_id": "2f4cba94-952f-412e-9b79-df7c12feec7c",
        "type": "message",
        "text": "<@UCUSW7WVD>  Yes.\n\nThe machine does the work instead of asking programmers to rearrange their code.\n\nYour reminder reminds me of Holt\u2019s Data Descriptors, which reminds me of Cordy\u2019s Orthogonal Code Generator which reminds me of RTL (which is used in gcc).",
        "user": "UGWUJUZHT",
        "ts": "1670594473.668969",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nq35k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "  Yes.\n\nThe machine does the work instead of asking programmers to rearrange their code.\n\nYour reminder reminds me of Holt\u2019s Data Descriptors, which reminds me of Cordy\u2019s Orthogonal Code Generator which reminds me of RTL (which is used in gcc)."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT"
    },
    {
        "client_msg_id": "e6ec1ce8-6391-4553-9df5-a616483e6c1a",
        "type": "message",
        "text": "<https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png>",
        "user": "UGWUJUZHT",
        "ts": "1670847926.804909",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=5Ri",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png",
                "image_url": "https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png",
                "image_width": 715,
                "image_height": 416,
                "image_bytes": 73444,
                "id": 1,
                "original_url": "https://raw.githubusercontent.com/guitarvydas/drawware/dev/sourcecodehelloworld.png",
                "fallback": "715x416px image"
            }
        ],
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT"
    },
    {
        "client_msg_id": "3be9901d-054d-456f-9011-d19a0a9dca4f",
        "type": "message",
        "text": "Thank you all, for your comments!  I find the insightful criticism to be quite helpful.\n\nHoping to clarify some points:\n\n\u2022 IMO The Ground Truth is Programming, not Code.\n\u2022 IMO, change, even big change, is possible, especially in a young discipline like this.  We are witnessing big change right now - the conversion of gasoline-powered automobiles to electric-powered automobiles.  The enormous infrastructure for supplying gasoline is being replaced.  The figurehead for this huge change believes in \u201cFirst Principles Thinking\u201d [<https://fs.blog/first-principles/>].   Counter-arguments against big change might include: \n\u2022 The fact that electric cars still have 4 wheels and still have offset steering wheels (instead of centered steering sticks as in the first automobile) \n\u2022 The fact that the change-over from gas to electric is being facilitated by the existence of hybrid cars.  \n\u2022 Computer keyboards are still QWERTY.  \n\tIMO, change is driven by perceived orders-of-magnitude improvement (in process? ... in what?).  It remains incumbent on me to explain why I think that it is possible to improve on programming, noting that hardware has improved, and, noting that end-user apps have improved, while maintaining the assertion that programming languages have not improved proportionally.\n\u2022 PEG blurs the line between characters in a Scanner vs. tokens in a Parser.  IMO this is important and may lead to change.\n\u2022 IMO, snipping ALL dependencies is important and may lead to change.  Hence, this long response to an issue in an experimental code repo. To my eyes even simple`f(x)` causes several kinds of dependencies that are ripe for snipping.\n\u2022 SVG.  This is the simplest (albeit useless) example of SVG as a \u201cprogramming language\u201d that I could imagine.  There\u2019s more, and this is but a hint.  This useless example transpiles a diagram to running Python code. The live code is at <https://github.com/guitarvydas/drawware|drawware>.\n<https://github.com/guitarvydas/drawware/blob/dev/sourcecodehelloworld.png?raw=true>\n\t\n```&lt;html&gt;\n  &lt;body&gt;\n    \n    &lt;h1&gt;My first SVG&lt;/h1&gt;\n    \n    &lt;svg&gt;\n      &lt;g id='myfunc'&gt;\n        &lt;rect x=\"20\" y=\"0\" width=\"280\" height=\"130\" rx=\"19.5\" ry=\"19.5\" fill=\"none\" stroke=\"black\"/&gt;\n        &lt;text x=\"120\" y=\"19\"&gt;myfunc&lt;/text&gt;\n\n        &lt;g&gt;\n          &lt;rect x=\"60\" y=\"40\" width=\"200\" height=\"60\" fill=\"#f8cecc\" stroke=\"#b85450\"/&gt;\n          &lt;text x=\"70\" y=\"64\"&gt;print ('Hello ', end='')&lt;/text&gt;\n          &lt;text x=\"70\" y=\"84\"&gt;print ('World')&lt;/text&gt;\n        &lt;/g&gt;\n        \n      &lt;/g&gt;\n    &lt;/svg&gt;\n    \n  &lt;/body&gt;\n&lt;/html&gt;```\nthe Ohm-JS grammar that I used is:\n```CodeDrawing {\n  Main = \"&lt;html&gt;\" \"&lt;body&gt;\" H1 Drawing \"&lt;/body&gt;\" \"&lt;/html&gt;\"\n  H1 = \"&lt;h1&gt;\" stuff \"&lt;/h1&gt;\"\n\n  Drawing = \"&lt;svg\" stuff \"&gt;\" CodeContainer \"&lt;/svg&gt;\"\n  \n  CodeContainer = \"&lt;g\" FunctionName \"&gt;\" Boundary Title CodeBlock \"&lt;/g&gt;\"\n  \n  Boundary = \"&lt;rect\" stuff \"/&gt;\"\n  Title = \"&lt;text\" stuff \"&gt;\" name \"&lt;/text&gt;\"\n  CodeBlock = \"&lt;g&gt;\" RedRect Text+ \"&lt;/g&gt;\"\n  RedRect = \"&lt;rect\" (~AttrRed any)* AttrRed stuff \"/&gt;\"\n\n  FunctionName = \"id=\" sq name sq\n  Text = \"&lt;text\" stuff \"&gt;\" stuff \"&lt;/text&gt;\"\n  AttrRed = \"fill=\" dq \"#f8cecc\" dq\n\n  stuff = notElementChar+\n  notElementChar = ~\"&lt;\" ~\"&gt;\" ~\"/&gt;\" any\n  name = letter alnum*\n  sq = \"'\"\n  dq = \"\\\"\"\n}```\nAnd my personal notation (\u201cFab\u201d) that completes the transpiler is:\n```CodeDrawing {\n  Main [khtml kbody H1 Drawing kbodyend khtmlend] = \u201b\u00abDrawing\u00bb'\n  H1 [kh1 stuff kh1end] = \u201b\u00abkh1\u00bb\u00abstuff\u00bb\u00abkh1end\u00bb'\n\n  Drawing [ksvg CodeContainer ksvgend] = \u201b\u00abCodeContainer\u00bb'\n  \n  CodeContainer [kgroup FunctionName k Boundary Title CodeBlock kgroupend] = \u201bdef \u00abFunctionName\u00bb ():\u00abCodeBlock\u00bb\n\u00abFunctionName\u00bb ()'\n  \n  Boundary [krect stuff kend] = \u201b\u00abkrect\u00bb\u00abstuff\u00bb\u00abkend\u00bb'\n  Title [ktext stuff k name ktextend] = \u201b\u00abktext\u00bb\u00abstuff\u00bb\u00abk\u00bb\u00abname\u00bb\u00abktextend\u00bb'\n  CodeBlock [kgroup RedRect Texts+ kgroupend] = \u201b\\n(-\u00abTexts\u00bb-)'\n  RedRect [krect cs* AttrRed stuff kend] = \u201b\u00abkrect\u00bb\u00abcs\u00bb\u00abAttrRed\u00bb\u00abstuff\u00bb\u00abkend\u00bb'\n\n  FunctionName [kid sq1 name sq2] = \u201b\u00abname\u00bb'\n  Text [ktext stuff kend stuff2 ktextend] = \u201b\\n\u00abstuff2\u00bb'\n  AttrRed [kfill dq kred dq2] = \u201b\u00abkfill\u00bb\u00abdq\u00bb\u00abkred\u00bb\u00abdq2\u00bb'\n\n  stuff [cs+] = \u201b\u00abcs\u00bb'\n  notElementChar [c] = \u201b\u00abc\u00bb'\n  name [c1 cs*] = \u201b\u00abc1\u00bb\u00abcs\u00bb'\n  sq  [c] = \u201b\u00abc\u00bb'\n  dq  [c] = \u201b\u00abc\u00bb'\n}```\nThe generated Python code (from the diagram) is:\n```def myfunc ():\n\n  print ('Hello ', end='')\n  print ('World')\nmyfunc ()```\n\nFYI - Fab transpiles to JavaScript code that can be used in conjunction with Ohm-JS.  I got tired of writing JavaScript, so I built an SCN (nano-DSL) for myself.\n\nI\u2019ve chosen not to include the generated JavaScript code in this thread, but have pushed a working transpiler to the github listed above.\n\n[pardon the cave-man HTML, but I don\u2019t know enough about building web pages, and, clearly, need help]\n\n31:50~ \u201cIn a \u2018real\u2019 Computer Science, the best languages of an era should serve as \u2019assembly code\u201d for the next generation of expression.\n<https://www.youtube.com/watch?v=fhOHn9TClXY&amp;t=859s>\nAlan Kay",
        "user": "UGWUJUZHT",
        "ts": "1670847958.542229",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hy=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thank you all, for your comments!  I find the insightful criticism to be quite helpful.\n\nHoping to clarify some points:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "IMO The Ground Truth is Programming, not Code."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "IMO, change, even big change, is possible, especially in a young discipline like this.  We are witnessing big change right now - the conversion of gasoline-powered automobiles to electric-powered automobiles.  The enormous infrastructure for supplying gasoline is being replaced.  The figurehead for this huge change believes in \u201cFirst Principles Thinking\u201d ["
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://fs.blog/first-principles/"
                                    },
                                    {
                                        "type": "text",
                                        "text": "].   Counter-arguments against big change might include: "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The fact that electric cars still have 4 wheels and still have offset steering wheels (instead of centered steering sticks as in the first automobile) "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The fact that the change-over from gas to electric is being facilitated by the existence of hybrid cars.  "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Computer keyboards are still QWERTY.  "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\tIMO, change is driven by perceived orders-of-magnitude improvement (in process? ... in what?).  It remains incumbent on me to explain why I think that it is possible to improve on programming, noting that hardware has improved, and, noting that end-user apps have improved, while maintaining the assertion that programming languages have not improved proportionally.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "PEG blurs the line between characters in a Scanner vs. tokens in a Parser.  IMO this is important and may lead to change."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "IMO, snipping ALL dependencies is important and may lead to change.  Hence, this long response to an issue in an experimental code repo. To my eyes even simple`f(x)` causes several kinds of dependencies that are ripe for snipping."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "SVG.  This is the simplest (albeit useless) example of SVG as a \u201cprogramming language\u201d that I could imagine.  There\u2019s more, and this is but a hint.  This useless example transpiles a diagram to running Python code. The live code is at "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://github.com/guitarvydas/drawware",
                                        "text": "drawware"
                                    },
                                    {
                                        "type": "text",
                                        "text": "."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/guitarvydas/drawware/blob/dev/sourcecodehelloworld.png?raw=true"
                            },
                            {
                                "type": "text",
                                "text": "\n\t\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "<html>\n  <body>\n    \n    <h1>My first SVG</h1>\n    \n    <svg>\n      <g id='myfunc'>\n        <rect x=\"20\" y=\"0\" width=\"280\" height=\"130\" rx=\"19.5\" ry=\"19.5\" fill=\"none\" stroke=\"black\"/>\n        <text x=\"120\" y=\"19\">myfunc</text>\n\n        <g>\n          <rect x=\"60\" y=\"40\" width=\"200\" height=\"60\" fill=\"#f8cecc\" stroke=\"#b85450\"/>\n          <text x=\"70\" y=\"64\">print ('Hello ', end='')</text>\n          <text x=\"70\" y=\"84\">print ('World')</text>\n        </g>\n        \n      </g>\n    </svg>\n    \n  </body>\n</html>"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nthe Ohm-JS grammar that I used is:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "CodeDrawing {\n  Main = \"<html>\" \"<body>\" H1 Drawing \"</body>\" \"</html>\"\n  H1 = \"<h1>\" stuff \"</h1>\"\n\n  Drawing = \"<svg\" stuff \">\" CodeContainer \"</svg>\"\n  \n  CodeContainer = \"<g\" FunctionName \">\" Boundary Title CodeBlock \"</g>\"\n  \n  Boundary = \"<rect\" stuff \"/>\"\n  Title = \"<text\" stuff \">\" name \"</text>\"\n  CodeBlock = \"<g>\" RedRect Text+ \"</g>\"\n  RedRect = \"<rect\" (~AttrRed any)* AttrRed stuff \"/>\"\n\n  FunctionName = \"id=\" sq name sq\n  Text = \"<text\" stuff \">\" stuff \"</text>\"\n  AttrRed = \"fill=\" dq \"#f8cecc\" dq\n\n  stuff = notElementChar+\n  notElementChar = ~\"<\" ~\">\" ~\"/>\" any\n  name = letter alnum*\n  sq = \"'\"\n  dq = \"\\\"\"\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAnd my personal notation (\u201cFab\u201d) that completes the transpiler is:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "CodeDrawing {\n  Main [khtml kbody H1 Drawing kbodyend khtmlend] = \u201b\u00abDrawing\u00bb'\n  H1 [kh1 stuff kh1end] = \u201b\u00abkh1\u00bb\u00abstuff\u00bb\u00abkh1end\u00bb'\n\n  Drawing [ksvg CodeContainer ksvgend] = \u201b\u00abCodeContainer\u00bb'\n  \n  CodeContainer [kgroup FunctionName k Boundary Title CodeBlock kgroupend] = \u201bdef \u00abFunctionName\u00bb ():\u00abCodeBlock\u00bb\n\u00abFunctionName\u00bb ()'\n  \n  Boundary [krect stuff kend] = \u201b\u00abkrect\u00bb\u00abstuff\u00bb\u00abkend\u00bb'\n  Title [ktext stuff k name ktextend] = \u201b\u00abktext\u00bb\u00abstuff\u00bb\u00abk\u00bb\u00abname\u00bb\u00abktextend\u00bb'\n  CodeBlock [kgroup RedRect Texts+ kgroupend] = \u201b\\n(-\u00abTexts\u00bb-)'\n  RedRect [krect cs* AttrRed stuff kend] = \u201b\u00abkrect\u00bb\u00abcs\u00bb\u00abAttrRed\u00bb\u00abstuff\u00bb\u00abkend\u00bb'\n\n  FunctionName [kid sq1 name sq2] = \u201b\u00abname\u00bb'\n  Text [ktext stuff kend stuff2 ktextend] = \u201b\\n\u00abstuff2\u00bb'\n  AttrRed [kfill dq kred dq2] = \u201b\u00abkfill\u00bb\u00abdq\u00bb\u00abkred\u00bb\u00abdq2\u00bb'\n\n  stuff [cs+] = \u201b\u00abcs\u00bb'\n  notElementChar [c] = \u201b\u00abc\u00bb'\n  name [c1 cs*] = \u201b\u00abc1\u00bb\u00abcs\u00bb'\n  sq  [c] = \u201b\u00abc\u00bb'\n  dq  [c] = \u201b\u00abc\u00bb'\n}"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe generated Python code (from the diagram) is:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "def myfunc ():\n\n  print ('Hello ', end='')\n  print ('World')\nmyfunc ()"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\nFYI - Fab transpiles to JavaScript code that can be used in conjunction with Ohm-JS.  I got tired of writing JavaScript, so I built an SCN (nano-DSL) for myself.\n\nI\u2019ve chosen not to include the generated JavaScript code in this thread, but have pushed a working transpiler to the github listed above.\n\n[pardon the cave-man HTML, but I don\u2019t know enough about building web pages, and, clearly, need help]\n\n31:50~ \u201cIn a \u2018real\u2019 Computer Science, the best languages of an era should serve as \u2019assembly code\u201d for the next generation of expression.\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=fhOHn9TClXY&t=859s"
                            },
                            {
                                "type": "text",
                                "text": "\nAlan Kay"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UGWUJUZHT",
            "ts": "1670851444.000000"
        },
        "attachments": [
            {
                "from_url": "https://fs.blog/first-principles/",
                "ts": 1523280399,
                "image_url": "https://149664534.v2.pressablecdn.com/wp-content/uploads/2018/04/First-principles.png",
                "image_width": 250,
                "image_height": 250,
                "image_bytes": 47664,
                "service_icon": "https://149664534.v2.pressablecdn.com/wp-content/uploads/2015/06/cropped-farnamstreet-300x300.png",
                "id": 1,
                "original_url": "https://fs.blog/first-principles/",
                "fallback": "Farnam Street: First Principles: The Building Blocks of True Knowledge - Farnam Street",
                "text": "First Principles tinking breaks down true understanding into building blocks we can reassemble. It turns out most of us don\u2019t know as much as we think we do.",
                "title": "First Principles: The Building Blocks of True Knowledge - Farnam Street",
                "title_link": "https://fs.blog/first-principles/",
                "service_name": "Farnam Street",
                "fields": [
                    {
                        "value": "Farnam Street",
                        "title": "Written by",
                        "short": true
                    },
                    {
                        "value": "21 minutes",
                        "title": "Est. reading time",
                        "short": true
                    }
                ]
            }
        ],
        "thread_ts": "1670362232.776479",
        "parent_user_id": "UGWUJUZHT"
    }
]