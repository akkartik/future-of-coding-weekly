[
    {
        "client_msg_id": "c4116a70-a5ba-4dc8-8215-96d7876d30ec",
        "type": "message",
        "text": "Traditional models of communication between devices, processes, and threads include message-passing, remote procedure calls, and shared memory. Here's a model I haven't seen before: _shared game-playing_.\n\nHow it would work:\n\u2022 The rules for a \"game\" of some kind are expressed as a code library... or whatever representation works best.\n\u2022 A set of \"players\" (processes or threads) express interest in playing the game with each other. (somehow...)\n\u2022 The players communicate with each other by interacting with the game (in accordance with its rules), and receive information about each other's actions by observing how the game state has changed.\nThe \"game\" could be an _actual_ game like chess or Factorio (implemented via peer-to-peer communication), or it could be a standardized protocol like HTTP, FTP, or (most commonly) it could be an application-specific protocol that would normally be implemented via message-passing or RPC.\n\nImagine if this were the only model of communication that a programming language exposes. What if it were the \"building block\" of communication \u2014 the only way to build concurrent systems? I think it's an intriguing thought :thinking_face:. I'm surprised I haven't heard this model proposed before.\n\n(This post was inspired by <https://syndicate-lang.org/|Syndicate>, which is an actor-based PL that eschews message-passing and RPC for the idea of a \"data-space\" that actors use to exchange information. But unlike my proposal above, Syndicate's data-spaces don't contain _rules_, and thus cannot be used to model video games or communication protocols.)",
        "user": "UCGAK10LS",
        "ts": "1672471217.151219",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4WKX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Traditional models of communication between devices, processes, and threads include message-passing, remote procedure calls, and shared memory. Here's a model I haven't seen before: "
                            },
                            {
                                "type": "text",
                                "text": "shared game-playing",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nHow it would work:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The rules for a \"game\" of some kind are expressed as a code library... or whatever representation works best."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A set of \"players\" (processes or threads) express interest in playing the game with each other. (somehow...)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The players communicate with each other by interacting with the game (in accordance with its rules), and receive information about each other's actions by observing how the game state has changed."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe \"game\" could be an "
                            },
                            {
                                "type": "text",
                                "text": "actual",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " game like chess or Factorio (implemented via peer-to-peer communication), or it could be a standardized protocol like HTTP, FTP, or (most commonly) it could be an application-specific protocol that would normally be implemented via message-passing or RPC.\n\nImagine if this were the only model of communication that a programming language exposes. What if it were the \"building block\" of communication \u2014 the only way to build concurrent systems? I think it's an intriguing thought "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face",
                                "unicode": "1f914"
                            },
                            {
                                "type": "text",
                                "text": ". I'm surprised I haven't heard this model proposed before.\n\n(This post was inspired by "
                            },
                            {
                                "type": "link",
                                "url": "https://syndicate-lang.org/",
                                "text": "Syndicate"
                            },
                            {
                                "type": "text",
                                "text": ", which is an actor-based PL that eschews message-passing and RPC for the idea of a \"data-space\" that actors use to exchange information. But unlike my proposal above, Syndicate's data-spaces don't contain "
                            },
                            {
                                "type": "text",
                                "text": "rules",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and thus cannot be used to model video games or communication protocols.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672471565.000000"
        },
        "thread_ts": "1672471217.151219",
        "reply_count": 36,
        "reply_users_count": 6,
        "latest_reply": "1672612206.844169",
        "reply_users": [
            "UBN9AFS0N",
            "UCGAK10LS",
            "UEBG0NPDK",
            "UE1JQM9HQ",
            "U016VUZGUUQ",
            "UE6EFEPTQ"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1672492198.593029"
    },
    {
        "client_msg_id": "dd9475ca-cdf0-45b5-a50f-53ee6ffcc480",
        "type": "message",
        "text": "if you replace game for server, players for client and game rules for protocol or API, how is it different to client/server?",
        "user": "UBN9AFS0N",
        "ts": "1672482469.842989",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BfNV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "if you replace game for server, players for client and game rules for protocol or API, how is it different to client/server?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "68187315-8A97-4ECE-8234-DF4CBF73A6C5",
        "type": "message",
        "text": "The difference is that the \u201cgame\u201d isn\u2019t a device. It\u2019s just code that runs on each of the players\u2019 machines such that each player can keep track of what has happened and what can be done next. It\u2019s <https://en.m.wikipedia.org/wiki/Peer-to-peer|peer-to-peer communication>.",
        "user": "UCGAK10LS",
        "ts": "1672482638.391559",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uJJ5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The difference is that the \u201cgame\u201d isn\u2019t a device. It\u2019s just code that runs on each of the players\u2019 machines such that each player can keep track of what has happened and what can be done next. It\u2019s "
                            },
                            {
                                "type": "link",
                                "url": "https://en.m.wikipedia.org/wiki/Peer-to-peer",
                                "text": "peer-to-peer communication"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672483168.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "AE292D1E-DE9E-4459-9677-09C023906A13",
        "type": "message",
        "text": "(Peer-to-peer communication is more general than client-server. The former can be used to model the latter, but the converse isn\u2019t true. Or put another way: a \u201cpeer\u201d can act as a server if it wants/needs to, but it\u2019s entirely optional.)",
        "user": "UCGAK10LS",
        "ts": "1672482730.031719",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OPpu+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Peer-to-peer communication is more general than client-server. The former can be used to model the latter, but the converse isn\u2019t true. Or put another way: a \u201cpeer\u201d can act as a server if it wants/needs to, but it\u2019s entirely optional.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672482930.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "27714083-5554-45cc-b714-81dcb467d119",
        "type": "message",
        "text": "The network topology isn't the interesting thing here though. The interesting thing is the proposal that in order to engage in communication with someone, you have to specify a \"game\" that you are going to play with them.\n\u2022 Nobody can communicate without first specifying the rules of the game.\n\u2022 There is no ability to send unstructured \"messages\". There is only the ability to make \"game moves\". :hushed:\nAnd ideally, your programming language has a type system capable of verifying that your program only makes _valid_ game moves. But that's a whole different discussion.",
        "user": "UCGAK10LS",
        "ts": "1672483492.291539",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8k+HW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The network topology isn't the interesting thing here though. The interesting thing is the proposal that in order to engage in communication with someone, you have to specify a \"game\" that you are going to play with them.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Nobody can communicate without first specifying the rules of the game."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "There is no ability to send unstructured \"messages\". There is only the ability to make \"game moves\". "
                                    },
                                    {
                                        "type": "emoji",
                                        "name": "hushed",
                                        "unicode": "1f62f"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And ideally, your programming language has a type system capable of verifying that your program only makes "
                            },
                            {
                                "type": "text",
                                "text": "valid",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " game moves. But that's a whole different discussion."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672484018.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "8358487F-CCED-415E-9E2B-16BCE00DD343",
        "type": "message",
        "text": "Sounds like statemachine replication. ",
        "user": "UEBG0NPDK",
        "ts": "1672492198.593029",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cdy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds like statemachine replication"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "D52D090D-4030-4308-9955-1D1477B68855",
        "type": "message",
        "text": "I think you might want to take a look at <http://croquet.io|croquet.io> . <@UMWF81HTP> is a core developer and is sometimes active here.",
        "user": "UE1JQM9HQ",
        "ts": "1672496658.754979",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "i/2FB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you might want to take a look at "
                            },
                            {
                                "type": "link",
                                "url": "http://croquet.io",
                                "text": "croquet.io"
                            },
                            {
                                "type": "text",
                                "text": " . "
                            },
                            {
                                "type": "user",
                                "user_id": "UMWF81HTP"
                            },
                            {
                                "type": "text",
                                "text": " is a core developer and is sometimes active here."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cfebe82d-7f6b-4f46-be07-c701972b0773",
        "type": "message",
        "text": "Kind of sounds like a mix of session typing and tuple spaces. I like the idea, and I think it would be fun as an available option, but I'm not sure I'd try to make it a primitive. <https://en.wikipedia.org/wiki/Session_type|https://en.wikipedia.org/wiki/Session_type> I guess Syndicate already references tuple spaces, but I'll toss that link here for completeness. <https://en.wikipedia.org/wiki/Tuple_space|https://en.wikipedia.org/wiki/Tuple_space>",
        "user": "U016VUZGUUQ",
        "ts": "1672524583.949789",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Idl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Kind of sounds like a mix of session typing and tuple spaces. I like the idea, and I think it would be fun as an available option, but I'm not sure I'd try to make it a primitive. "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Session_type",
                                "text": "https://en.wikipedia.org/wiki/Session_type"
                            },
                            {
                                "type": "text",
                                "text": " I guess Syndicate already references tuple spaces, but I'll toss that link here for completeness. "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Tuple_space",
                                "text": "https://en.wikipedia.org/wiki/Tuple_space"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5a6a619c-6c12-414b-9dd7-0ab6eebcee7c",
        "type": "message",
        "text": "<@UEBG0NPDK> This communication model definitely involves replication, though when I google \"state machine replication\" it turns up unrelated stuff about fault-tolerant servers. Nothing about a communication model.\n\n<@UE1JQM9HQ> Oh that's interesting! Croquet OS seems to be built upon replicated virtual machines (the things I'm calling \"games\") as well. But I suppose that's not surprising \u2014 Croquet is quite literally a platform for games (and other virtual worlds). I'll suss it out :slightly_smiling_face:.\n\n<@U016VUZGUUQ> Yes, this model is definitely somewhat reminiscent of session types and tuple spaces. The motivation for making it a primitive is the same as the motivation for putting session types into a programming language \u2014 to allow users to write programs against a known interface, and to allow the computer to check that the interface is being used correctly. RPC (in a statically-typed language) is an ultra-simplistic example of this \u2014 it models one action, followed by one response.",
        "user": "UCGAK10LS",
        "ts": "1672543825.966709",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7GAni",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": " This communication model definitely involves replication, though when I google \"state machine replication\" it turns up unrelated stuff about fault-tolerant servers. Nothing about a communication model.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UE1JQM9HQ"
                            },
                            {
                                "type": "text",
                                "text": " Oh that's interesting! Croquet OS seems to be built upon replicated virtual machines (the things I'm calling \"games\") as well. But I suppose that's not surprising \u2014 Croquet is quite literally a platform for games (and other virtual worlds). I'll suss it out "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": ".\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " Yes, this model is definitely somewhat reminiscent of session types and tuple spaces. The motivation for making it a primitive is the same as the motivation for putting session types into a programming language \u2014 to allow users to write programs against a known interface, and to allow the computer to check that the interface is being used correctly. RPC (in a statically-typed language) is an ultra-simplistic example of this \u2014 it models one action, followed by one response."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672543931.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "39069497-ae1f-427f-850b-9e9454468934",
        "type": "message",
        "text": "I just feel it ought to be possible to do it as a library given an adequately expressive type system, but I haven't thought about it that deeply. :)\n\nAlso, re state machine replication: yeah, I'm guessing the fault tolerant server stuff is what Chris was referring to. Communication is a big part of fault tolerance. From the perspective of designing abstractions, it probably looks more like a potential implementation detail, but it will constrain what kinds of \"games\" can run over an unreliable (i.e. real) network.",
        "user": "U016VUZGUUQ",
        "ts": "1672544642.820549",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Lpp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just feel it ought to be possible to do it as a library given an adequately expressive type system, but I haven't thought about it that deeply. :)\n\nAlso, re state machine replication: yeah, I'm guessing the fault tolerant server stuff is what Chris was referring to. Communication is a big part of fault tolerance. From the perspective of designing abstractions, it probably looks more like a potential implementation detail, but it will constrain what kinds of \"games\" can run over an unreliable (i.e. real) network."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "49d66405-f12e-4796-b364-9ca6d39554c4",
        "type": "message",
        "text": "Definitely any mechanism for fault-tolerance should be a library. I doubt it is possible to find \"the ultimate answer\" to fault-tolerance, and thus bake it into a PL. :innocent:\n\nType checking, on the other hand, is definitely the job of a PL!\n\nTo make a \"game\" fault-tolerant, you'd just have to add corresponding rules to the game \u2014 e.g. allow clients to vote an unresponsive client out of the game.",
        "user": "UCGAK10LS",
        "ts": "1672545147.902239",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "C4l=i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Definitely any mechanism for fault-tolerance should be a library. I doubt it is possible to find \"the ultimate answer\" to fault-tolerance, and thus bake it into a PL. "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent",
                                "unicode": "1f607"
                            },
                            {
                                "type": "text",
                                "text": "\n\nType checking, on the other hand, is definitely the job of a PL!\n\nTo make a \"game\" fault-tolerant, you'd just have to add corresponding rules to the game \u2014 e.g. allow clients to vote an unresponsive client out of the game."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672545267.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "type": "message",
        "text": "yep, I did indeed mean that, though not for the fault tolerance, but because it almost exactly describes the model you mentioned. From the wikipedia article:",
        "files": [
            {
                "id": "F04H3UQPLDR",
                "created": 1672545239,
                "timestamp": 1672545239,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UEBG0NPDK",
                "user_team": "T5TCAFTA9",
                "editable": false,
                "size": 352402,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F04H3UQPLDR/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F04H3UQPLDR/download/image.png",
                "media_display_type": "unknown",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 90,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 120,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 180,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 200,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 240,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F04H3UQPLDR-36be0a5cfc/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 256,
                "original_w": 1778,
                "original_h": 444,
                "thumb_tiny": "AwALADC+Rg0Dr/8AXpW60lADhu7UuD60igc06gBMH1pfxoooA//Z",
                "permalink": "https://futureofcoding.slack.com/files/UEBG0NPDK/F04H3UQPLDR/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F04H3UQPLDR-434228dc44",
                "is_starred": false,
                "has_rich_preview": false,
                "file_access": "visible"
            }
        ],
        "upload": false,
        "user": "UEBG0NPDK",
        "display_as_bot": false,
        "ts": "1672545241.691389",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vJD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yep, I did indeed mean that, though not for the fault tolerance, but because it almost exactly describes the model you mentioned. From the wikipedia article:"
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "c2c37ee7-e75a-4727-809e-50a530d9080c",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a56dadba-c48c-4474-ab40-ad157770047a",
        "type": "message",
        "text": "your \u201cgame\u201d is a state machine which defines the only valid inputs and transitions that any peer in the system can take",
        "user": "UEBG0NPDK",
        "ts": "1672545280.867449",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TaHc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "your \u201cgame\u201d is a state machine which defines the only valid inputs and transitions that any peer in the system can take"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEBG0NPDK",
            "ts": "1672545324.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c08a5b86-1f5a-4dec-91d3-d0892e305a3a",
        "type": "message",
        "text": "the crux is #3. Choosing an order is very hard. Croquet solves that by using relays as timestamp providers.",
        "user": "UEBG0NPDK",
        "ts": "1672545311.510979",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7+pWo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the crux is #3. Choosing an order is very hard. Croquet solves that by using relays as timestamp providers."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c18baf19-eb39-4f85-884a-e8f0eac0c693",
        "type": "message",
        "text": "Ah, but the trick is that you _don't_ have to choose an order :wink:. Not in general. There exist data models that allow for much more loosely structured interaction. In fact, you're the one who introduced me to those data models Chris! My research project over the last few years has been based on Datalog, extended with a declarative model of time.",
        "user": "UCGAK10LS",
        "ts": "1672545425.369189",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rxh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah, but the trick is that you "
                            },
                            {
                                "type": "text",
                                "text": "don't ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "have to choose an order "
                            },
                            {
                                "type": "emoji",
                                "name": "wink",
                                "unicode": "1f609"
                            },
                            {
                                "type": "text",
                                "text": ". Not in general. There exist data models that allow for much more loosely structured interaction. In fact, you're the one who introduced me to those data models Chris! My research project over the last few years has been based on Datalog, extended with a declarative model of time."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ef630b5a-9171-4406-b068-89ef6e4956c4",
        "type": "message",
        "text": "unless you\u2019re only allowing monotone programs, you\u2019ll need an ordering once there\u2019s communication",
        "user": "UEBG0NPDK",
        "ts": "1672545498.103459",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qvM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "unless you\u2019re only allowing monotone programs, you\u2019ll need an ordering once there\u2019s communication"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "515314b4-c540-4a35-a87b-80f9f97ccf70",
        "type": "message",
        "text": "e.g. I don\u2019t think it\u2019s possible to guarantee a limited number of turns in one of your games without it",
        "user": "UEBG0NPDK",
        "ts": "1672545636.918759",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VB7m",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "e.g. I don\u2019t think it\u2019s possible to guarantee a limited number of turns in one of your games without it"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEBG0NPDK",
            "ts": "1672545644.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2354f100-5fd5-4b4c-94bb-8bf9974c9b89",
        "type": "message",
        "text": "Yes, a partial ordering. Real-time video games often do this by stratifying a game into \"frames\", and allowing players to simultaneously submit their actions for that frame. You'd do something similar.\n\nThe key idea is that the rules for how inputs affect each other are specified as part of the game rules. This is a good alternative to forcing a global order upon all inputs, as Croquet seems to do!",
        "user": "UCGAK10LS",
        "ts": "1672545660.879649",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Lv=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, a partial ordering. Real-time video games often do this by stratifying a game into \"frames\", and allowing players to simultaneously submit their actions for that frame. You'd do something similar.\n\nThe key idea is that the rules for how inputs affect each other are specified as part of the game rules. This is a good alternative to forcing a global order upon all inputs, as Croquet seems to do!"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672545678.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "594639f2-bdd0-40b1-aa0c-87b2f27c47f4",
        "type": "message",
        "text": "That's pretty much the Datalog philosophy: order emerges from the structure of rules. There is no total order imposed upon everything.\n\n(This is also the philosophy required to develop distributed systems. If you want your distributed system to be scalable and responsive, it's often _not possible_ to impose a total order on all events.)",
        "user": "UCGAK10LS",
        "ts": "1672545742.608069",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VRo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That's pretty much the Datalog philosophy: order emerges from the structure of rules. There is no total order imposed upon everything.\n\n(This is also the philosophy required to develop distributed systems. If you want your distributed system to be scalable and responsive, it's often "
                            },
                            {
                                "type": "text",
                                "text": "not possible",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to impose a total order on all events.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672545898.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d39f364d-26f0-4699-b815-5d70f7540ff4",
        "type": "message",
        "text": "Yep, that\u2019ll work for some programs :slightly_smiling_face:",
        "user": "UEBG0NPDK",
        "ts": "1672545885.328309",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pqhrR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yep, that\u2019ll work for some programs "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "995b8ac1-6287-4bab-bcf4-c6e69ac6aa81",
        "type": "message",
        "text": "Peter Bailis\u2019s IConfluence work explains exactly which ones",
        "user": "UEBG0NPDK",
        "ts": "1672545905.299169",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FT8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Peter Bailis\u2019s IConfluence work explains exactly which ones"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "529011eb-c8b7-4b6e-8689-a587bee5c30e",
        "type": "message",
        "text": "I mean, it can work for _all_ programs, because a total order is just a special case of a partial order :unicorn_face:. If your program needs a total order, you can always impose one. But it can happen at the \"game\" level, not the programming language level. For example, if you think your game needs the \"relay\" architecture that Croquet uses, you can implement that at the game level. Instead of writing a game that clients play with each other directly, you write a game that the clients play with the relay.",
        "user": "UCGAK10LS",
        "ts": "1672546046.165909",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Yk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mean, it can work for "
                            },
                            {
                                "type": "text",
                                "text": "all ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "programs, because a total order is just a special case of a partial order "
                            },
                            {
                                "type": "emoji",
                                "name": "unicorn_face",
                                "unicode": "1f984"
                            },
                            {
                                "type": "text",
                                "text": ". If your program needs a total order, you can always impose one. But it can happen at the \"game\" level, not the programming language level. For example, if you think your game needs the \"relay\" architecture that Croquet uses, you can implement that at the game level. Instead of writing a game that clients play with each other directly, you write a game that the clients play with the relay."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672547437.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "dbdcd448-21f2-4a89-94b8-11423d321898",
        "type": "message",
        "text": "Sure, but at that point you\u2019re right back at \u201cpresent day.\u201d",
        "user": "UEBG0NPDK",
        "ts": "1672546365.303359",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f3bdc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure, but at that point you\u2019re right back at \u201cpresent day.\u201d"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6cc84351-262f-4d27-bb79-45cc40102f42",
        "type": "message",
        "text": "In some sense, we\u2019re saying you could relax #3 from the description of state machine replication and still have something useful, which is definitely true depending on the shape of the state machine",
        "user": "UEBG0NPDK",
        "ts": "1672546491.273339",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nfZmE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In some sense, we\u2019re saying you could relax #3 from the description of state machine replication and still have something useful, which is definitely true depending on the shape of the state machine"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9343eb48-1e05-4254-bb1d-09f237884e14",
        "type": "message",
        "text": "if the state machine happened to be IConfluent, then it\u2019s guaranteed to be safely eventually consistent and we can just broadcast inputs everywhere and be good to go",
        "user": "UEBG0NPDK",
        "ts": "1672546535.171139",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k1ZDZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "if the state machine happened to be IConfluent, then it\u2019s guaranteed to be safely eventually consistent and we can just broadcast inputs everywhere and be good to go"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2657a3ca-e76c-4e0b-b2d7-c6740c3bde1b",
        "type": "message",
        "text": "an interesting take on all of this, is rather than just leaving this \u201cup to the game\u201d why couldn\u2019t the programming system determine where this type of coordination is necessary and have it handle these topological concerns for me?",
        "user": "UEBG0NPDK",
        "ts": "1672546637.627089",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pye3S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "an interesting take on all of this, is rather than just leaving this \u201cup to the game\u201d why couldn\u2019t the programming system determine where this type of coordination is necessary and have it handle these topological concerns for me?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d593b0a3-8d53-450c-b3c9-da4ccc9cf83f",
        "type": "message",
        "text": "we know programmers are pretty terrible at this stuff, so pushing it into the application layer is likely going to end up in something analogous to today",
        "user": "UEBG0NPDK",
        "ts": "1672546679.924809",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qc9l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "we know programmers are pretty terrible at this stuff, so pushing it into the application layer is likely going to end up in something analogous to today"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEBG0NPDK",
            "ts": "1672546681.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b0dd7a7b-7de7-4fba-a9b4-f6d05b226766",
        "type": "message",
        "text": "I think we're on the same page here \u2014 that's the solution I'm envisaging (and working on). I'm envisaging a programming language wherein you write these \"games\" using Datalog-style rules, which are partially ordered. Tuples would be stratified by timestamps similar to how it's done with Dedalus (I've been working on a generalization). Then, much of the explicit coordination logic is handled by the language runtime \u2014 e.g. the actual exchanging of messages between game-players. But there is always going to be _some_ logic \u2014 such as fault-tolerance \u2014 which must be written into the game itself, because there is no blessed solution that will work for all games. For example, how to handle unresponsive players should be up to the game. Maybe the game waits indefinitely, maybe there's a timeout, or maybe the other players have to vote the unresponsive player out. (Standard mechanisms could be offered as _libraries_, but not as language-level constructs.)",
        "user": "UCGAK10LS",
        "ts": "1672546942.230589",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DQoH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think we're on the same page here \u2014 that's the solution I'm envisaging (and working on). I'm envisaging a programming language wherein you write these \"games\" using Datalog-style rules, which are partially ordered. Tuples would be stratified by timestamps similar to how it's done with Dedalus (I've been working on a generalization). Then, much of the explicit coordination logic is handled by the language runtime \u2014 e.g. the actual exchanging of messages between game-players. But there is always going to be "
                            },
                            {
                                "type": "text",
                                "text": "some",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " logic \u2014 such as fault-tolerance \u2014 which must be written into the game itself, because there is no blessed solution that will work for all games. For example, how to handle unresponsive players should be up to the game. Maybe the game waits indefinitely, maybe there's a timeout, or maybe the other players have to vote the unresponsive player out. (Standard mechanisms could be offered as "
                            },
                            {
                                "type": "text",
                                "text": "libraries",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but not as language-level constructs.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672547109.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "1a5469d5-dea8-4d8a-89f5-8d0e32afd589",
        "type": "message",
        "text": "I\u2019ll be curious to see what it\u2019s like programming with the time stratification. It led to a lot of unfortunate weirdness in Eve. It\u2019d be awesome if you found something more natural :smile:",
        "user": "UEBG0NPDK",
        "ts": "1672547094.785329",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z+PAo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019ll be curious to see what it\u2019s like programming with the time stratification. It led to a lot of unfortunate weirdness in Eve. It\u2019d be awesome if you found something more natural "
                            },
                            {
                                "type": "emoji",
                                "name": "smile",
                                "unicode": "1f604"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0f30724d-c1be-49ec-8822-4fe2e61a3b24",
        "type": "message",
        "text": "I believe I have! I'm working towards a shareable prototype as we speak. The hardest part has actually been figuring out a good syntax for it. I've had to invent a wholly different syntax to standard Datalog \u2014 something that is easier for us humans to read. I should have something to share in February. At least, that's when I'll have the time to work on it. Stay tuned :slightly_smiling_face:.",
        "user": "UCGAK10LS",
        "ts": "1672547315.068039",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QlR0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I believe I have! I'm working towards a shareable prototype as we speak. The hardest part has actually been figuring out a good syntax for it. I've had to invent a wholly different syntax to standard Datalog \u2014 something that is easier for us humans to read. I should have something to share in February. At least, that's when I'll have the time to work on it. Stay tuned "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face",
                                "unicode": "1f642"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672547391.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2e637efb-b5a4-456d-af6e-caff08d3cbf3",
        "type": "message",
        "text": "Hi Chris - can you elaborate on the \"unfortunate weirdness\"?",
        "user": "UE6EFEPTQ",
        "ts": "1672579347.339879",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lCm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi Chris - can you elaborate on the \"unfortunate weirdness\"?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9d4c8952-e5ba-4133-b689-283af46bee17",
        "type": "message",
        "text": "We found that people struggled dealing with the implications of stratified time so we tried to hide it to some degree. We made it so that `commit` which permanently added a fact into the world and `bind` which only adds a fact for as long as it was supported represented T+1 and T respectively. For many things that worked well, but it can be very hard in multi-step processes to understand why something may not behave correctly.",
        "user": "UEBG0NPDK",
        "ts": "1672581794.183839",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Avl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We found that people struggled dealing with the implications of stratified time so we tried to hide it to some degree. We made it so that "
                            },
                            {
                                "type": "text",
                                "text": "commit",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " which permanently added a fact into the world and "
                            },
                            {
                                "type": "text",
                                "text": "bind",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " which only adds a fact for as long as it was supported represented T+1 and T respectively. For many things that worked well, but it can be very hard in multi-step processes to understand why something may not behave correctly."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "1cb2605e-9977-4f1a-ae39-9b54bca5e002",
        "type": "message",
        "text": "More generally stratified time adds another dimension to the call graph, which is already a difficult thing to piece together",
        "user": "UEBG0NPDK",
        "ts": "1672581822.773259",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7O=r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "More generally stratified time adds another dimension to the call graph, which is already a difficult thing to piece together"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "570f1439-85f1-46f9-ab78-61d4fe70a584",
        "type": "message",
        "text": "unlike in imperative programs, there\u2019s no \u201cstarting\u201d place so now not only do you have to consider the dependency graph of all the assertions in your program you now have to model an invisible timeline that indicates \u201cwhen\u201d those assertions happen",
        "user": "UEBG0NPDK",
        "ts": "1672581900.505899",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kEpar",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "unlike in imperative programs, there\u2019s no \u201cstarting\u201d place so now not only do you have to consider the dependency graph of all the assertions in your program you now have to model an invisible timeline that indicates \u201cwhen\u201d those assertions happen"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "073fe969-05e1-42dc-a237-6da75e246f36",
        "type": "message",
        "text": "you _might_ be able to paper over that with tooling, but it\u2019s going to be complex either way",
        "user": "UEBG0NPDK",
        "ts": "1672581916.166729",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xLI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you "
                            },
                            {
                                "type": "text",
                                "text": "might",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be able to paper over that with tooling, but it\u2019s going to be complex either way"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "4ed352bb-c612-450c-a422-8b52f92d9041",
        "type": "message",
        "text": "I'm leaning towards thinking that time is another domain or application level thing that the user or programmer deals with, but that they should be given engine support in that data should be both spatial /and/ temporal in its presentation to them. In other words, don't build in strict synchronisation because often best effort is good enough, but let them sew things together precisely temporally if their application needs it. Don't have always-reliable messaging, have best efforts and make it easy to define timeouts for important application protocols or interactions.",
        "user": "UE6EFEPTQ",
        "ts": "1672609772.280589",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vX2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm leaning towards thinking that time is another domain or application level thing that the user or programmer deals with, but that they should be given engine support in that data should be both spatial /and/ temporal in its presentation to them. In other words, don't build in strict synchronisation because often best effort is good enough, but let them sew things together precisely temporally if their application needs it. Don't have always-reliable messaging, have best efforts and make it easy to define timeouts for important application protocols or interactions."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "CD150029-D5CB-4E46-9E8D-5DA7DCCADDE3",
        "type": "message",
        "text": "In the language semantics I\u2019m working on, time is application-level as you suggest. What\u2019s built-in is the notion of stratification by inductive types (think Haskell ADTs), of which the natural numbers are a special case. Stratifying by natural numbers allows you to model linear time, but you can also stratify by other structures, which allows you to model bottom-up (memoized) recursion, a.k.a. \u201cdynamic programming\u201d. So my proposed semantics for time is also a semantics for provably terminating (or productive) non-monotonic recursion \u2014 something Datalog is sorely missing :innocent:. Concretely: this means you can model any iterative or recursive computation that you\u2019d perform in an imperative language, by defining a (possibly non-linear) \u201cvirtual machine\u201d that executes it. The state of the machine can be observed by supplying \u201ctimestamps\u201d for the steps you want to observe. (For a dynamic programming algorithm, these steps are the cells of the table.) The end result is a _de facto_ Turing-complete programming language built upon Datalog semantics. _De facto_ because it\u2018s impossible to crash or hang your program \u2014 unless you invoke a computation that takes a long-but-finite time to resolve. For any Haskellers reading this: the semantics is a generalization of \u201crecursion schemes\u201d.\n\nThis may or may not make sense to anyone. I\u2019ll be able to explain it properly once I\u2019ve finished putting together the prototype. It might sound _complicated_, but I\u2019ve been working on a syntax that (I hope) makes it feel simple. (And debuggers that _visualize_ these dynamic processes are going to be important too.)\n\nThis stratification scheme would be a very general way to drive the \u201cgames\u201d I\u2019ve been talking about :innocent:. It\u2019s a means of specifying partially-ordered _non-monotonic_ computations.\n\n(Apologies to readers who don't know what \"monotonic\" or \"stratified\" means. These are terms from the logic programming community. You'll encounter them in most Datalog tutorials.)",
        "user": "UCGAK10LS",
        "ts": "1672612206.844169",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nri",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the language semantics I\u2019m working on, time is application-level as you suggest. What\u2019s built-in is the notion of stratification by inductive types (think Haskell ADTs), of which the natural numbers are a special case. Stratifying by natural numbers allows you to model linear time, but you can also stratify by other structures, which allows you to model bottom-up (memoized) recursion, a.k.a. \u201cdynamic programming\u201d. So my proposed semantics for time is also a semantics for provably terminating (or productive) non-monotonic recursion \u2014 something Datalog is sorely missing "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent",
                                "unicode": "1f607"
                            },
                            {
                                "type": "text",
                                "text": ". Concretely: this means you can model any iterative or recursive computation that you\u2019d perform in an imperative language, by defining a (possibly non-linear) \u201cvirtual machine\u201d that executes it. The state of the machine can be observed by supplying \u201ctimestamps\u201d for the steps you want to observe. (For a dynamic programming algorithm, these steps are the cells of the table.) The end result is a "
                            },
                            {
                                "type": "text",
                                "text": "de facto",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " Turing-complete programming language built upon Datalog semantics. "
                            },
                            {
                                "type": "text",
                                "text": "De facto",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " because it\u2018s impossible to crash or hang your program \u2014 unless you invoke a computation that takes a long-but-finite time to resolve. For any Haskellers reading this: the semantics is a generalization of \u201crecursion schemes\u201d.\n\nThis may or may not make sense to anyone. I\u2019ll be able to explain it properly once I\u2019ve finished putting together the prototype. It might sound "
                            },
                            {
                                "type": "text",
                                "text": "complicated",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but I\u2019ve been working on a syntax that (I hope) makes it feel simple. (And debuggers that "
                            },
                            {
                                "type": "text",
                                "text": "visualize ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "these dynamic processes are going to be important too.)\n\nThis stratification scheme would be a very general way to drive the \u201cgames\u201d I\u2019ve been talking about "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent",
                                "unicode": "1f607"
                            },
                            {
                                "type": "text",
                                "text": ". It\u2019s a means of specifying partially-ordered "
                            },
                            {
                                "type": "text",
                                "text": "non-monotonic",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " computations.\n\n(Apologies to readers who don't know what \"monotonic\" or \"stratified\" means. These are terms from the logic programming community. You'll encounter them in most Datalog tutorials.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1672614990.000000"
        },
        "thread_ts": "1672471217.151219",
        "parent_user_id": "UCGAK10LS"
    }
]