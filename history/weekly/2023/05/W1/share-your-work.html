
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2023-04-26T14:40:36.159Z" class="post"><span class="user">Sam Arbesman</span> <a href="./?fromDate=2023-04-23&amp;toDate=2023-04-29&amp;channel=share-your-work&amp;filter=#2023-04-26T14:40:36.159Z" class="date">2023-04-26 14:40:36</a> <div class="message"><p>This might be of interest to folks here: I'm working on a new book project all about computation from many different angles. Working title is "The Magic of Code" and I would welcome everyone following along and providing advice and feedback: <a href="https://arbesman.substack.com/p/the-magic-of-code">arbesman.substack.com/p/the-magic-of-code</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://arbesman.substack.com/p/the-magic-of-code">‚òû The Magic of Code</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2023-04-27T00:18:02.478Z" class="reply"><span class="user">Denny Vrandeƒçiƒá</span> <a href="./?fromDate=2023-04-24&amp;toDate=2023-04-30&amp;channel=share-your-work&amp;filter=#2023-04-27T00:18:02.478Z" class="date">2023-04-27 00:18:02</a> <div class="message"><p>oh no, that's the title of a book I wanted to write üòÑ</p>
<p>Ah well, good luck! I didn't get very far with it yet, and will find another title. Had a neat intro playing with that title though üòÑ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2023-04-27T02:03:50.286Z" class="reply"><span class="user">Sam Arbesman</span> <a href="./?fromDate=2023-04-24&amp;toDate=2023-04-30&amp;channel=share-your-work&amp;filter=#2023-04-27T02:03:50.286Z" class="date">2023-04-27 02:03:50</a> <div class="message"><p>Thanks</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2023-04-27T21:47:04.577Z" class="post"><span class="user">Stian H√•klev</span> <a href="./?fromDate=2023-04-24&amp;toDate=2023-04-30&amp;channel=share-your-work&amp;filter=#2023-04-27T21:47:04.577Z" class="date">2023-04-27 21:47:04</a> <div class="message"><p>We just launched a new concept of command nodes in Tana, which together with AI enables some pretty powerful workflows. <a href="https://help.tana.inc/tana-for-builders.html">help.tana.inc/tana-for-builders.html</a>. See some building walkthroughs in this thread <a href="https://twitter.com/houshuang/status/1651687719033077760">twitter.com/houshuang/status/1651687719033077760</a></p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://help.tana.inc/tana-for-builders.html">Tana for Builders - Tana Help Center</a></p>
<p>üìù <a href="https://twitter.com/houshuang/status/1651687719033077760">Stian H√•klev on Twitter</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div><div id="2023-04-01T17:39:15.360Z" class="post"><span class="user"></span> <a href="./?fromDate=2023-03-29&amp;toDate=2023-04-04&amp;channel=share-your-work&amp;filter=#2023-04-01T17:39:15.360Z" class="date">üï∞Ô∏è 2023-04-01 17:39:15</a> <div class="message"><p>...</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2023-04-28T20:10:00.334Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2023-04-25&amp;toDate=2023-05-01&amp;channel=share-your-work&amp;filter=#2023-04-28T20:10:00.334Z" class="date">2023-04-28 20:10:00</a> <div class="message"><p>Thank you for responding to my feedback last episode. I was a little worried that my response was so long nobody would read it. </p>
<p>I'm not sure how to respond when you ask me to give you the same kind of respect that I extend, and encourage others to extend, to people like Licklider, Engelbart, Naur, or Brooks, especially when you are asking me to respect your decision to disrespect them. It is possible that I am mistaken or ignorant here, but I am unaware of any reason to believe that either of you have had a hand in crafting the fundamental nature of modern computing or the way that our entire industry views it. </p>
<p>I do not mean this as an insult, since it also applies to almost every other person who has ever lived as well. I do think it's important to remember, and be sensitive to, the level of genius one is reading when deciding whether and how to criticize.</p>
<p>I have no idea how popular your podcast is. I'm thrilled that you are bringing additional attention to these papers, no matter the size of your audience, but I worry that your casual disrespect during prior episodes could cause your listeners to discount the importance of the papers or their authors.</p>
<p>That said, I have no reason to believe that the authors of Out of the Tar Pit deserve any special consideration, so I don't particularly care about how you treated this one.</p>
<p>I think you are joking about making an episode about Intercal, but now that I heard you say it I have a strange desire to listen to it.</p>
<p>Although the structured programming movement ultimately degenerated into "don't use goto," for what it's worth, papers by Peter Naur (Proof of Algorithms by General Snapshots, Programming by Action Clusters), Tony Hoare (An Axiomatic Basis for Computer Programming), and Edsger Dijkstra (Notes on Structured Programming) were pushing the idea of making programs easier to reason about a long time ago.</p>
<p>A big downside of purely functional programming is that it can interfere with modularity. See The Art of the Interpreter or, The Modularity Complex by Guy Steele and Gerald Sussman.</p>
<p>With respect to trying to reduce complexity, but only measuring some of the dimensions, while I intensely dislike C++, I have a great deal of respect for Bjarne Stroustrup. He has done an amazing job of achieving his design goals, and I really appreciate his observation that "complexity has to go somewhere." I believe he is implicitly referring to essential complexity here.</p>
<p><a href="https://m.slashdot.org/story/10028">m.slashdot.org/story/10028</a></p>
<p>With respect to the challenge of creating a type of programming that informal reasoning cannot help with, Peter Naur pointed out in Formalization in Program Development that all formal reasoning is ultimately defined in terms of informal reasoning, so while I cannot prove it formally, I don't think it's possible to create a system that is not dependent on any informal reasoning.</p>
<p>Hiding state is the basis of encapsulation in the Parnas sense (On the Criteria To Be Used in Decomposing Systems into Modules) and modularity in the Sussman/Steele sense above. Trying to make all state visible might make it easier to design and play with small systems, but I'm not sure how it can coexist with encapsulation and modularity.</p>
<p>For a differing view on the "power corrupts" thesis, in Why Software Jewels are Rare, Parnas notes "Moreover, languages that prevent programming errors, a goal advanced by some inveterate language designers, are as feasible as knives that can cut meat but not hands. We need sharp tools to do good work."</p>
<p><a href="https://www.researchgate.net/publication/2954521_Why_software_jewels_are_rare">researchgate.net/publication/2954521_Why_software_jewels_are_rare</a></p>
<p>Also, "Unix was not designed to stop you from doing stupid things, because that would also stop you from doing clever things." -- Doug Gwyn</p>
<p>With respect to creating programs that retain their conceptual integrity when the problem they are solving changes, I am fond of both Dijkstra's string of beads / hierarchy of virtual machines (Notes on Structured Programming) and the Structure and Interpretation of Computer Programs (SICP) model of bottom up design, where you essentially design a language for solving the kind of problem you are facing, and then solve your particular problem in that language. Of course, there's always the possibility that your problem changes in the future to be of a sufficiently different kind that you end up needing to adjust more than just the top layer.</p>
<p>Overall, although I haven't read this paper and am going purely by what you said in the podcast, my sense is that the authors didn't have much new to say. I'm not clear on how this became such a popular paper in recent times.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
