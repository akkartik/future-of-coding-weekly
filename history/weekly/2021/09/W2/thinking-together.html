
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2021-09-06T05:01:04.100Z" class="post"><span class="user">Florian Schulz</span> <a href="#2021-09-06T05:01:04.100Z" class="date">2021-09-06 05:01:04</a> <div class="message"><p>When <a href="https://twitter.com/spiralganglion">Ivan Reese</a> talks about the data model in Hest (<a href="https://pod.link/1559446316/episode/488217b61f1f644d58a4219f9d0545f1">Hest Podcast, Episode 25</a>), he mentions things like:</p>
<ul><li>AOS: Array of Structs</li><li>SOA: Struct of Arrays</li></ul><p>He also mentions a way to organise data where each property (name, color, position, ‚Ä¶) is stored in its own Array ‚Äì in contrast to an Array of Objects of Properties.</p>
<p>This reminded me of a talk I had seen at Unite (Unity Conference) about ‚Äú<a href="https://unity.com/dots">Data-Oriented Design</a>‚Äù. While it makes a lot of sense in terms of memory usage, caching and lookup performance, I barely see data-oriented design today.</p>
<p>What are examples of programming languages or software that are using/promote data-oriented design outside of game development?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-09-06T07:31:24.101Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-09-06T07:31:24.101Z" class="date">2021-09-06 07:31:24</a> <div class="message"><p>Scientific computing has much of the same issues as games: large but simply structured datasets, and dealing with hardware limitations in memory and performance. But explicit support in programming languages is rare. One reason why there was a lot of enthusiasm for C++ for scientific computing in the 1990s was the hope for managing the AOS vs. SOA tradeoff better than in Fortran. Not sure it was a success.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-06T09:38:10.108Z" class="reply"><span class="user">Alexander Chichigin</span> <a href="#2021-09-06T09:38:10.108Z" class="date">2021-09-06 09:38:10</a> <div class="message"><p>Probably, "the languages promoting data-oriented design" are exactly "array programming languages", which are kinda popular again later with the spread of GPGPU, but mostly around scientific computing, DSP and alike. üôÇ</p>
<p>Besides, just SoA isn't efficient enough on modern hardware considering all levels of caching, NUMA and vectorization. Thus in practice for maximum performance people use combined layouts like SoAoS. But for that you have to know the sizes and layouts of your base structures, where and how they are used, and adapt algorithms for that. So no "one size fits all" solution here, it's all careful conscious and methodical manual optimisation.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-06T13:46:40.115Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2021-09-06T13:46:40.115Z" class="date">2021-09-06 13:46:40</a> <div class="message"><p>I know Andrew Kelly just applied some data oriented techniques to zig for compiler performance improvements. <a href="https://vimeo.com/507318005"></a><a href="https://vimeo.com/507318005">https://vimeo.com/507318005</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://vimeo.com/507318005">Zig Live Coding: Applying Data Oriented Design to Tokenization and Parsing</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-09-06T14:49:57.116Z" class="reply"><span class="user">Vijay Chakravarthy</span> <a href="#2021-09-06T14:49:57.116Z" class="date">2021-09-06 14:49:57</a> <div class="message"><p>I‚Äôd recommend looking at <a href="https://www.youtube.com/watch?v=Oj_xgO2uKJM&amp;t=1s"></a><a href="https://www.youtube.com/watch?v=Oj_xgO2uKJM&amp;t=1s">https://www.youtube.com/watch?v=Oj_xgO2uKJM&amp;t=1s</a>. And also Aarons Hsu‚Äôs thesis.</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=Oj_xgO2uKJM&amp;amp;t=1s">Aaron Hsu- Program Obesity: A Code Health Epidemic- ŒªC 2019 Unconference</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-09-07T05:05:08.119Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-09-07T05:05:08.119Z" class="date">2021-09-07 05:05:08</a> <div class="message"><p>Jonathan Blow's work-in-progress programming language Jai has <a href="https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md#data-oriented-structures">language-level support</a> for AOS and SOA:</p>
<blockquote><p>However, as programs get larger, it becomes much more difficult to reorganize the data. Testing whether a single, simple change has any effect on performance can take the developer a long time, because once the data structures must change, all of the code that acts on that data structure breaks. So Jai provides mechanisms for automatically transitioning between SoA and AoS without breaking the supporting code.</p>
</blockquote>
<p>Which makes me wonder if this sort of generality of data access is similar to the approach Clojure takes to its data structures ‚Äî and if so, whether they're directly aligned or lie along slightly different axes.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-07T14:23:07.120Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2021-09-07T14:23:07.120Z" class="date">2021-09-07 14:23:07</a> <div class="message"><p>For what it is worth I am fairly sure that Jonathan Blow got rid of those abilities. Instead you have macros and arbitrary compile time code execution that would let you reimplement something like that yourself.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-07T16:24:24.121Z" class="reply"><span class="user">Chris Granger</span> <a href="#2021-09-07T16:24:24.121Z" class="date">2021-09-07 16:24:24</a> <div class="message"><p>Anytime someone talks about a column store vs a row store, they‚Äôre effectively talking about SoA vs AoS</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-09-08T23:12:43.129Z" class="post"><span class="user">Nick Smith</span> <a href="#2021-09-08T23:12:43.129Z" class="date">2021-09-08 23:12:43</a> <div class="message"><p>Calling all software engineers who know basic category theory: some applied category theorists in the US are organizing a hackathon to explore how <a href="https://topos.site/poly-course/">the theory of polynomial functors</a> can be applied to software development (new programming libraries and/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. üôÇ This would be an in-person event in the US, taking place ~March next year.</p>
<p>There is <a href="https://topos.site/poly-course/">a short course and book draft</a> on the category of polynomial functors, outlining its applicability to interactive systems and databases. I expect these applications will be the focus of the hackathon.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-09-11T13:02:23.173Z" class="reply"><span class="user">Don Abrams</span> <a href="#2021-09-11T13:02:23.173Z" class="date">2021-09-11 13:02:23</a> <div class="message"><p>I‚Äôm interested in this, but I am only familiar with the basics of CT.</p>
<p>FYI: I‚Äôve been learning what I can about generating code from laymen-defined models+properties where the generated code ‚Äúsmartly‚Äù chooses between both runtime (based on collected metrics) and static (based on machine model) strategies (such as sort algorithm, data layouts, GPU vs. CPU targeting, batch/row sizes, etc). There‚Äôs also a very difficult problem on providing feedback or even choices when ‚Äúthings‚Äù are over-constrained/non-feasible.</p>
<p>Any thoughts on if Poly could be a helpful way to model this problem? In the Poly book, they restrict the lens structure in a way I don‚Äôt understand, so I don‚Äôt know if it can model more complex optics like monadic lenses (which is one way to model+execute RT strategy decisions). I also really don‚Äôt understand the implications of things like ‚Äúpreserving op-cartesian arrows.‚Äù</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-11T23:59:32.174Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-09-11T23:59:32.174Z" class="date">2021-09-11 23:59:32</a> <div class="message">
<blockquote><p>I‚Äôve been learning what I can about generating code from laymen-defined models+properties</p>
</blockquote>
<p>It sounds like you're interested in compilers for high-level languages? Your description reminds me of MLIR, which aims to be a good framework for compiling programs from (vastly different) high-level domains, such as neural networks and hardware circuits. It definitely does all those static optimizations you describe.</p>
<p>As for whether Poly can help with this: my hunch is no, not right now. (Disclaimer though: I'm not a category theorist, I'm just a software engineer who's been in contact with the book authors.) Poly is being investigated as a modelling language, but not as a compiler. The main challenge right now is connecting Poly back to everyday programming constructs. We've got an understanding of how it connects to type systems, I/O, and databases, but other important stuff like recursion is missing. It's unclear how deep the Poly rabbit hole goes; it's still very early days. That's why there's a hackathon being planned: to support further exploration!</p>
<blockquote><p>I don‚Äôt know if it can model more complex optics like monadic lenses</p>
</blockquote>
<p>Nor do I. I don't even know what a monadic lens is üôÇ</p>
<blockquote><p>I also really don‚Äôt understand the implications of things like ‚Äúpreserving op-cartesian arrows.‚Äù</p>
</blockquote>
<p>The book is mainly targeted at category theorists right now, and so its style is to list out a bunch of theorems on every aspect of Poly. Some of them have clear implications, some of them don't. My personal strategy has been to focus on the theorems that seem interesting to me as a software engineer üòá.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-12T10:47:38.000Z" class="reply"><span class="user">Don Abrams</span> <a href="#2021-09-12T10:47:38.000Z" class="date">2021-09-12 10:47:38</a> <div class="message"><p>Hah, well my current hope is that the compiler input isn‚Äôt a high level language, but a model (think more like minecraft or sketch)</p>
<p>I‚Äôm looking for the right model(s) to slowly increase power/complexity, basically adding a dimension at a time (and trying to keep people thinking about the ‚Äúwhat‚Äù rather than the ‚Äúhow‚Äù when manipulating the model)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-12T23:51:15.001Z" class="reply"><span class="user">Nick Smith</span> <a href="#2021-09-12T23:51:15.001Z" class="date">2021-09-12 23:51:15</a> <div class="message"><p>What do you mean by "model" here? That word has a lot of meanings!</p>
<p>For example, how do you wish me to perceive Minecraft as a model? I see it as a fully-fledged interactive application! But if I were to think of Minecraft as a tool for making models, I can recall how people use Minecraft blocks to build physical models of locations and buildings. But those aren't models of interactive systems. You can also use Minecraft's redstone system to build circuits, but that's equivalent to a low-level programming language, so I don't see it as something special. And of course you can write mods for Minecraft, but that's just conventional programming.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-09-09T03:06:00.159Z" class="post"><span class="user">Ivan Reese</span> <a href="#2021-09-09T03:06:00.159Z" class="date">2021-09-09 03:06:00</a> <div class="message"><p>I'm thinking more about the sensation of time, as it pertains to the execution of code. (Yeah, back on my bullshit.) I see a spectrum here ‚Äî&nbsp;a spectrum of different sensations of time for different ways we interact with computation.</p>
<p>On one end of the spectrum, we have raw math. There's not supposed to be any sensation of time in the evaluation of math. A variable always has a specific value; relationships either exist or they don't. It might take you (or a computer) some time to crunch values and arrive at a result, but that's absolutely not supposed to be part of the aesthetic. Conal Elliot's Denotational Design is an application of this sort of thinking to software design. Lambda calculus, Curry-Howard, and some of the more hardcore FP languages all exist ‚Äî infinitely, suspended frozen in midair ‚Äî over here. Of course, no computer language is actually timeless (that violated physics, and this is addressed in Church-Turing and related work, and we all agree never to try that again), but the desired sensation ‚Äî the aesthetic ‚Äî is one in which time is not a constraint or concern.</p>
<p>On the other end of the spectrum, we have mechanical computers. There's no avoiding the sensation of time when operating these clockwork beasts. You're required to think about the passage of time as you plan an execution, or else the result will be nonsense, or malfunction. Nothing is instant, nothing exists until you build it. Here we find the CAP theorem, Turing machines, and Rich Hickey's The Language of the System, all of them toiling, sweating, grinding, churning.</p>
<p>[Aside: note that Functional Programming is orthogonal to this spectrum ‚Äî it is not bound to the math side. On either extreme and anywhere in between, you can have programming that's about immutable values (or not), static vs dynamic binding, data &amp; behaviour co-located (or not), for-each vs map, place-oriented vs value-oriented, and so forth.]</p>
<p>I've spent all my time over in the mechanical labour camp ‚Äî&nbsp;this is where Hest lives. So I don't have much insight at all into the crystal tower of pure evaluation. So beyond just suggesting "Hey, talk about this spectrum" (which, granted, I am suggesting), I'd also like to know what examples you can point to that obviously violate this common alignment of aesthetics. For example: what's the most I feel the passage of time in execution you can get to when working with something like Coq, or Haskell, or APL? Is there some step debugger for SML that really lets you feel the iterative progress through execution? Or on the other side, what's out there that takes a process rooted in time ‚Äî like CAP ‚Äî and makes it shake that feeling of temporality? Look at something like Erlang/OTP ‚Äî they take Prolog (timeless) and reify the sensation of process ("let it fail"). Who else is doing that? Is anyone doing it in the other direction?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-09-09T11:19:00.163Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2021-09-09T11:19:00.163Z" class="date">2021-09-09 11:19:00</a> <div class="message"><p>Potentially in this direction could be something like <a href="http://temporal.io">temporal.io</a> , which is a workflow language that makes keeping value in the stack for weeks at a time, a comfortable endeavor. (The contrast is usually we put values into a database so they can survive an upgrade over the course of the weeks)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-09T11:22:17.163Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2021-09-09T11:22:17.163Z" class="date">2021-09-09 11:22:17</a> <div class="message"><p>Also, on another side of this that may or may not bear any fruit, is <a href="https://www.liquidsoap.info/"></a><a href="https://www.liquidsoap.info/">https://www.liquidsoap.info/</a> , a language for programming media streams.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-09T13:12:42.164Z" class="reply"><span class="user">Chris Knott</span> <a href="#2021-09-09T13:12:42.164Z" class="date">2021-09-09 13:12:42</a> <div class="message"><p>I don't really know enough about the Haskell end of this spectrum but my sense is that the units for it are probably something like "percent of the code that has some kind of invariance guarantee".</p>
<p>If you take something multi paradigm like Java or C++ it is possible to write very mathsy code by leaning in heavily on const, interfaces, classes etc. and earn yourself very strong guarantees about invariance over time. Different languages force or encourage you to bake more guarantees into your code but it's something that is possible in any language. Even something like Python, in the real world, will probably come with a stack of Organisational Practices and socially enforced norms that allow to in practice make similar assumptions, even though you could in theory overwrite the + operator at runtime.</p>
<p>Accepting these kinds of restrictions limits your expressivity but can superpower your understanding of a codebase because it lets you make massively compressing abstractions and draw very clean lines ("Ok... this can't&nbsp;possibly&nbsp;affect this... It must have come from A, B or C...").</p>
<p>Time invariance is an affordance that lets you better "play computer in your head", as Bret Victor would say.</p>
<p>So basically I think the reason that Haskell programmers play down the actual execution of their code is they are backing themselves to have already run it accurately in their head beforehand.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-09T13:18:46.164Z" class="reply"><span class="user">Chris Knott</span> <a href="#2021-09-09T13:18:46.164Z" class="date">2021-09-09 13:18:46</a> <div class="message"><p>I basically believe you should start from the opposite end.</p>
<p>Computers are physical machines that literally, actually, move and change with the forward arrow of time as part of the physical universe. Because they change in very small ways and very quickly, they kind of fly below our intuition radar. They are also highly deterministic compared to naturally occurring phenomena.</p>
<p>Still, they actually do perform an irreversible action just like a computer built out of metal ball bearings falling through chutes (<a href="https://www.turingtumble.com/"></a><a href="https://www.turingtumble.com/">https://www.turingtumble.com/</a>).</p>
<p>If you want to understand what happened, you should just record what happened and then interrogate that recording with a powerful suite of thinking tools.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-09T13:21:00.164Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-09-09T13:21:00.164Z" class="date">2021-09-09 13:21:00</a> <div class="message"><p>Temporal Logic of Actions sounds like an in between in your spectrum:</p>
<blockquote><p>This paper introduces TLA, which I now believe is the best general formalism for describing and reasoning about concurrent systems. The new idea in TLA is that one can use actions‚Äìformulas with primed and unprimed variables‚Äìin temporal formulas. An action describes a state-transition relation. For example, the action x‚Äô=x+1 means approximately the same thing as the programming-language statement x := x+1.</p>
</blockquote>
<p><a href="https://www.microsoft.com/en-us/research/publication/the-temporal-logic-of-actions/"></a><a href="https://www.microsoft.com/en-us/research/publication/the-temporal-logic-of-actions/">https://www.microsoft.com/en-us/research/publication/the-temporal-logic-of-actions/</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-09T18:21:15.166Z" class="reply"><span class="user">Andreas S.</span> <a href="#2021-09-09T18:21:15.166Z" class="date">2021-09-09 18:21:15</a> <div class="message"><p>This virtual time approach? <a href="https://twitter.com/codefrau/status/1430715818115883008?s=20"></a><a href="https://twitter.com/codefrau/status/1430715818115883008?s=20">https://twitter.com/codefrau/status/1430715818115883008?s=20</a></p>
</div> <div class="attachments">
<blockquote><p>üê¶ <a href="https://twitter.com/@codefrau">Vanessa wrote a thing</a>: What is <a href="https://twitter.com/croquetio">@croquetio</a> anyways?</p>
<p>A thread üßµ</p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-09-10T00:18:29.167Z" class="reply"><span class="user">Luke Persola</span> <a href="#2021-09-10T00:18:29.167Z" class="date">2021-09-10 00:18:29</a> <div class="message"><p><a href="https://twitter.com/spiralganglion">Ivan Reese</a></p>
<blockquote><p>Functional Programming is orthogonal to this spectrum</p>
</blockquote>
<p>I don‚Äôt get this. While I would normally think of functional programming as being on the timeless end of the spectrum, you make a good point that it can also be on other end. But isn‚Äôt it the case that programming styles that contrast with FP often do have to be structured in time? To pick from your examples, how would you have mutable values without modeling time? Or with <code>forEach</code>  don‚Äôt you need to have time to have side effects work?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-10T01:34:22.168Z" class="reply"><span class="user">Luke Persola</span> <a href="#2021-09-10T01:34:22.168Z" class="date">2021-09-10 01:34:22</a> <div class="message"><p><a href="https://github.com/ChrisKnott">Chris Knott</a></p>
<p>Are you taking an anti-abstraction stance that programmers should be be aware of time as it exists in the internals of the language/environment they‚Äôre using (because they‚Äôll have to deal with it eventually anyway)? Or are you just saying it‚Äôs good for them to think about/deal with time in their code, but it‚Äôs OK if it‚Äôs abstracted into a different (likely more limited) form?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-10T17:14:10.170Z" class="reply"><span class="user">Chris Granger</span> <a href="#2021-09-10T17:14:10.170Z" class="date">2021-09-10 17:14:10</a> <div class="message"><p>synchronous languages (Lucid, Esterel, Lustre) have a pretty qualitatively different experience of time</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-10T17:35:22.171Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-09-10T17:35:22.171Z" class="date">2021-09-10 17:35:22</a> <div class="message"><p>Great references and exploration of the topic ‚Äî thanks everyone.</p>
<p><a href="https://github.com/colelawrence">Cole Lawrence</a></p>
<blockquote><p>keeping value in the stack for weeks at a time</p>
</blockquote>
<p>I love this idea. I'm so accustomed to non-live programming that I forget about the completely different sensation of time that you get from a live environment, where state is can be thought of as non-volatile by default.</p>
<p><a href="https://github.com/ChrisKnott">Chris Knott</a> ‚Äî&nbsp;I like that your two comments are "here's why [existing thing] is what it is" and "here's what I want to exist". Both make sense to me!</p>
<p><a href="https://twitter.com/warianoguerra">Mariano Guerra</a> ‚Äî Queued! Though unlike Lamport's earlier work (you know, the hits), this one looks like it might fly over my head a bit :$</p>
<p><a href="https://twitter.com/curious_reader">Andreas S</a> ‚Äî&nbsp;Croquet sure is interesting, hey? Though I'm not sure how it relates here ‚Äî I can imagine ways, but if you had something specific about it you wanted to highlight that'd be appreciated.</p>
<p><strong>@Luke Persola</strong> ‚Äî You're right, I under-considered what I was saying there. I was focused on pointing out that you can have all that conventionally "functional" stuff within a programming system that does feel very mechanical / process-oriented. I didn't consider enough whether it's possible to have the non-FP stuff within a system that feels timeless. Good point, will have to think about this some more.</p>
<p><a href="https://twitter.com/ibdknox">Chris Granger</a> ‚Äî Nice pulls! I suppose the same applies to RT OSes, CAN Bus (etc), and perhaps even programming within a high-end game engine (eg: frame cadence, Carmack's preference for algorithms that are slower average-case with less variability, etc). Would love to just be able to just... order a study on this.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-11T00:16:36.172Z" class="reply"><span class="user">Shalabh</span> <a href="#2021-09-11T00:16:36.172Z" class="date">2021-09-11 00:16:36</a> <div class="message"><p>ok, stream of conciousness incoming...</p>
<p>On the concept of math vs mechanics, I perceive math as this vast graph that always exists, but in imagination. Mechanics is about materializing parts of this graph in some physical form. The machine manifests a subset of this graph, and traverses to other nodes, pulling in more and more of this graph, from the imaginary to the physical, as physical time progresses. If you type <code>2 + 3</code> in a system, you've got a graph with three nodes (2, 3, +, connected in a nice tree) and after some time, you've got a 4th node (5, connected to the [2,3+] bundle of nodes), but in mathland all 4 nodes (and the edges and more) pre-existed.</p>
<p>On the intersection of these ideas, CRDTs come to mind. You have the semi-lattice, which is very mathematical and static. However you have the actual values at different nodes, which correspond to one node in the lattice at any point in time, but they change over time and eventually walk up the math lattice to meet at the top.</p>
<p>Croquet came to my mind as well when reading the prompt. On the surface it is full-mechanical. The machines moves, step by step, and is implemented in that style. However look between steps - each step is functional, it <em>must</em> be deterministic - that's what keeps all the different systems in sync. There is no logical time within a step (e.g. can be considered instantaneous.. the next input cannot interrupt a step).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-11T09:32:36.173Z" class="reply"><span class="user">Chris Knott</span> <a href="#2021-09-11T09:32:36.173Z" class="date">2021-09-11 09:32:36</a> <div class="message"><p><strong>@Luke Persola</strong> Basically the first. You should at least be aware of which end of this spectrum is the actual bedrock, and which is the potentially leaky abstraction.</p>
<p>I've used this example before but CPython and Pypy implement <code>list.pop(0)</code> (popping first item from a list) differently. CPython bumps a pointer, Pypy moves the list. So it's O(1) vs O(n). There is literally no way to discover this "in system". This is the sort of thing that comes up in end-user programming like data science and will actually confuse users. It can make the difference between a visualisation being interactive or not.</p>
<p>The weakness in my position is that in a lot of cases, you truly don't ever need to worry about how the abstraction is actually realised/implemented. Most actual use cases are just IFTTT style plumbing or CRUD apps with N in the hundreds.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-09-10T15:19:41.168Z" class="post"><span class="user">Jimmy Miller</span> <a href="#2021-09-10T15:19:41.168Z" class="date">2021-09-10 15:19:41</a> <div class="message"><p>I know a lot of us here have been influenced by talks like Bret Victor‚Äôs ‚ÄúInventing on Principle‚Äù. But I‚Äôm curious about your favorite papers that are somehow related to the future of coding. I‚Äôll start with mine.</p>
<p>PILOT: A Step Toward Man-Computer Symbiosis - Warren Teitelman</p>
<p>This is actually a thesis, so it is a bit long, though much of that length is taken up with a transcript. I will admit there is a lot in this paper that isn‚Äôt great. The resulting system is almost certainly something no one would want to use today. But yet in it are such interesting ideas. </p>
<p>It is often considered to be the paper that introduced aspect oriented programming, but I believe that sells it a bit short. PILOT is an integrated, live, editing and computational system. It‚Äôs goal is to allow programmers to 1) customize their interface and syntax, 2) edit programs they are unfamiliar with 3) make changes not just to current functions in the program, but future ones as well 4) control how the program itself executes and so much more. It is a bit of a historical trip, but includes so many fascinating ideas.</p>
<p>Programming as Theory Building - Peter Naur</p>
<p>Naur lays out a view of the activity of programming that is both radical and yet highly attractive. A key consequence on his theory is that the real end product of programming is not the source code, not the build artifact, not the running system, but the knowledge that a programmer builds. So much follows from this. It is a fascinating paper that I highly recommend reading.</p>
<p>The Structure of a Programming Language Revolution - Richard P Gabriel</p>
<p>A beautiful paper about the changes to programming language research that Gabriel has seen over his career. I will just leave you with this quote that sets the mood for the paper.</p>
<blockquote><p>That night I pulled the paper down from the ACM server and read it while outside enormous puffed clouds dwelled overhead, lit from beneath by the town of Porto de Galinhas on the Brazilian coast; the smell of burning sugarcane and bitter ocean pushed into my room.</p>
</blockquote>
<p>What are your favorites? What papers have really pushed you in a particular direction? What papers do you think people should read, even if you disagree with them? Whatever the criteria for the paper being good, I want to know about it.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-09-10T18:47:07.172Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-09-10T18:47:07.172Z" class="date">2021-09-10 18:47:07</a> <div class="message"><p>Beyond Programming Languages - Terry Winograd (1979)</p>
<p>Discusses higher-level programming which is less about algorithms and data structures and more about different views on a complex software system that can be manipulated by programmers.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-12T20:01:53.000Z" class="reply"><span class="user">Chris Rabl</span> <a href="#2021-09-12T20:01:53.000Z" class="date">2021-09-12 20:01:53</a> <div class="message"><p>I'll second the Winograd paper! A few that have influenced my thoughts around programming tools are:</p>
<ul><li>Beyond Being There - This one is mostly about communication media, but given that communication is necessary for coordination, and that coordination is necessary for delivering and maintaining complex systems, having solid communication media is (I believe), a principal factor in the success of any group that wishes to build software:&nbsp;<a href="http://worrydream.com/refs/Hollan%20-%20Beyond%20Being%20There.pdf"></a><a href="http://worrydream.com/refs/Hollan%20-%20Beyond%20Being%20There.pdf">http://worrydream.com/refs/Hollan%20-%20Beyond%20Being%20There.pdf</a></li><li>Convivial Design Heuristics for Software Systems - Stephen Kell talks about how language and environment designers can afford individuals agency and freedom, while limiting their ability to trample the freedoms of others: he gives many great (and counterintuitive) recommendations such as introducing friction when it comes to defining abstractions:&nbsp;<a href="https://dl.acm.org/doi/abs/10.1145/3397537.3397543"></a><a href="https://dl.acm.org/doi/abs/10.1145/3397537.3397543">https://dl.acm.org/doi/abs/10.1145/3397537.3397543</a></li><li>WhyLine - "A debugging tool that allows programmers to ask 'Why did' and 'Why didn't' questions about their program's output". This is interesting to me because it inverts the relationship between programmer and computer. Normally the programmer is the one tasked with coming up with the "why/why not" questions: in the case of Whyline, the system generates these questions automatically based on static and dynamic analyses of the running system:&nbsp;<a href="https://www.cs.cmu.edu/~NatProg/whyline.html"></a><a href="https://www.cs.cmu.edu/~NatProg/whyline.html">https://www.cs.cmu.edu/~NatProg/whyline.html</a></li><li>A Programmable Programming Language - Matthias Felleisen has some great talks on building DSLs in Racket (<a href="https://www.youtube.com/watch?v=z8Pz4bJV3Tk"></a><a href="https://www.youtube.com/watch?v=z8Pz4bJV3Tk">https://www.youtube.com/watch?v=z8Pz4bJV3Tk</a>) but I think his paper does the best job of explaining why language-oriented programming is so powerful (the "Thoughts" section of his website is also full of gems:&nbsp;<a href="https://felleisen.org/matthias/Thoughts/index.html"></a><a href="https://felleisen.org/matthias/Thoughts/index.html">https://felleisen.org/matthias/Thoughts/index.html</a>):&nbsp;<a href="https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/paper.pdf"></a><a href="https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/paper.pdf">https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/paper.pdf</a></li><li>Revisiting and Broadening the Meta-Design Framework for End-User Development - This paper builds on the authors' earlier work (<a href="https://www.researchgate.net/publication/220427813_Meta-Design_A_manifesto_for_End-User_Development"></a><a href="https://www.researchgate.net/publication/220427813_Meta-Design_A_manifesto_for_End-User_Development">https://www.researchgate.net/publication/220427813_Meta-Design_A_manifesto_for_End-User_Development</a>) and advocates for open, extensible systems, and for the designers of those systems to engage end-users as co-designers of these kinds of systems, as opposed to building "walled gardens" that attempt to anticipate every future need or possible use of the system:&nbsp;<a href="https://www.researchgate.net/publication/316734680_Revisiting_and_Broadening_the_Meta-Design_Framework_for_End-User_Development"></a><a href="https://www.researchgate.net/publication/316734680_Revisiting_and_Broadening_the_Meta-Design_Framework_for_End-User_Development">https://www.researchgate.net/publication/316734680_Revisiting_and_Broadening_the_Meta-Design_Framework_for_End-User_Development</a></li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-09-13T00:04:33.004Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2021-09-13T00:04:33.004Z" class="date">2021-09-13 00:04:33</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> </p>
<p>Just finished the Winograd Paper. Thank you so much for that recommendation!|</p>
<p><a href="https://twitter.com/crabl">Chris Rabl</a> </p>
<p>Love beyond being there. The other‚Äôs I have not read, (though I am familiar with racket). Thanks for the recommendations :) Look forward to diving in.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
