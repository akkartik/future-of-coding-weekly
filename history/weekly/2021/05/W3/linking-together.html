
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2021-05-10T14:13:11.162Z" class="post"><span class="user">Mariano Guerra</span> <a href="#2021-05-10T14:13:11.162Z" class="date">2021-05-10 14:13:11</a> <div class="message"><p>The plot thickens: Why OpenDoc failed, and then failed 3 more times?</p>
<p>Summary of reasons found around the web and comparing them with other implementations of the same concept:</p>
<ul><li><p>ActiveX</p>
</li><li><p>KParts</p>
</li><li><p>Bonobo</p>
</li></ul><p>And a short mention of Web Components</p>
<p><a href="https://instadeq.com/blog/posts/why-opendoc-failed-and-then-failed-3-more-times/"></a><a href="https://instadeq.com/blog/posts/why-opendoc-failed-and-then-failed-3-more-times/">https://instadeq.com/blog/posts/why-opendoc-failed-and-then-failed-3-more-times/</a></p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://instadeq.com/blog/posts/why-opendoc-failed-and-then-failed-3-more-times/">Why OpenDoc failed, and then failed 3 more times?</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2021-05-10T14:53:20.162Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-05-10T14:53:20.162Z" class="date">2021-05-10 14:53:20</a> <div class="message"><p>HN Thread here: <a href="https://news.ycombinator.com/item?id=27106195"></a><a href="https://news.ycombinator.com/item?id=27106195">https://news.ycombinator.com/item?id=27106195</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-05-11T07:46:23.163Z" class="post"><span class="user">Mariano Guerra</span> <a href="#2021-05-11T07:46:23.163Z" class="date">2021-05-11 07:46:23</a> <div class="message"><p>LinkBack is an open source framework for Mac OS X that helps developers integrate content from other applications into their own. A user can paste content from any LinkBack-enabled application into another and reopen that content later for editing with just a double-click. Changes will automatically appear in the original document again when you save.</p>
<p><a href="http://linkbackproject.org/"></a><a href="http://linkbackproject.org/">http://linkbackproject.org/</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-05-11T08:21:47.163Z" class="reply"><span class="user">Yousef El-Dardiry</span> <a href="#2021-05-11T08:21:47.163Z" class="date">2021-05-11 08:21:47</a> <div class="message"><p>Not exactly the same, but had to think of Ray Ozzie’s Live clipboard ideas (sort of shared schema for web copy/paste). Perhaps you’ll find it interesting (<a href="https://scripting.wordpress.com/2006/03/07/ray-ozzies-clipboard-for-the-web/"></a><a href="https://scripting.wordpress.com/2006/03/07/ray-ozzies-clipboard-for-the-web/">https://scripting.wordpress.com/2006/03/07/ray-ozzies-clipboard-for-the-web/</a>)</p>
<p><a href="https://channel9.msdn.com/Blogs/Charles/Live-Clipboard-What-How-Why"></a><a href="https://channel9.msdn.com/Blogs/Charles/Live-Clipboard-What-How-Why">https://channel9.msdn.com/Blogs/Charles/Live-Clipboard-What-How-Why</a> -&gt; the mid quality WMV is still working.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-12T15:59:13.165Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-05-12T15:59:13.165Z" class="date">2021-05-12 15:59:13</a> <div class="message"><p>Oh wow, from Nisus. That's a name I've not heard for a long time.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-12T16:01:00.165Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-05-12T16:01:00.165Z" class="date">2021-05-12 16:01:00</a> <div class="message"><p>Aside from the design of the site, here's a clue that this is quite an old project (sadly) — at the bottom of the <a href="http://linkbackproject.org/about/"></a><a href="http://linkbackproject.org/about/">http://linkbackproject.org/about/</a>:</p>
<blockquote><p>Last Revised:&nbsp;&gt; 28 Jun 2004</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-12T16:01:51.165Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-05-12T16:01:51.165Z" class="date">2021-05-12 16:01:51</a> <div class="message"><p>I say sadly because that Nelsonian dream of transclusion is still a dang dream. Here's hoping the bidirectional link hype bubble inches us a little closer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-05-12T07:43:10.164Z" class="post"><span class="user">Mariano Guerra</span> <a href="#2021-05-12T07:43:10.164Z" class="date">2021-05-12 07:43:10</a> <div class="message"><p>Philosophy of Programming, Simulating the Commodore 64, and More with Tomas Petricek</p>
<p><a href="https://www.twitch.tv/videos/1014761652"></a><a href="https://www.twitch.tv/videos/1014761652">https://www.twitch.tv/videos/1014761652</a></p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://www.twitch.tv/videos/1014761652">#PLTalk: Philosophy of Programming, Simulating the Commodore 64, and More - jeanqasaur on Twitch</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div><div id="2021-05-13T00:56:52.166Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2021-05-13T00:56:52.166Z" class="date">2021-05-13 00:56:52</a> <div class="message">
<blockquote><p>I posit that a truly comprehensible programming environment - one forever and by design devoid of dark corners and mysterious, voodoo-encouraging subtle malfunctions - must obey this rule:&nbsp;the programmer is expected to inhabit the bedrock abstraction level. And thus, the latter must be &gt; <a href="http://akkartik.name/post/habitability"></a><a href="http://akkartik.name/post/habitability">http://akkartik.name/post/habitability</a>&gt; .<a href="http://www.loper-os.org/?p=55"></a><a href="http://www.loper-os.org/?p=55">http://www.loper-os.org/?p=55</a> (inline link mine)</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-05-13T04:52:44.167Z" class="reply"><span class="user">Andrew F</span> <a href="#2021-05-13T04:52:44.167Z" class="date">2021-05-13 04:52:44</a> <div class="message"><p>I predict that if you actually try to build a machine with an instruction set isomorphic to a high level language, it will never reach the reliability we demand from hardware. Most likely, it will be implemented in something like microcode and we'll immediately land right back where we started. I'd rather see a focus on formal verification, probably of higher-level virtual machines built on simple and therefore easy-to-model hardware.</p>
<p>I think the reference to "atomic operations" is quite deep. A layer of abstraction that provides truly atomic operations is indistinguishable from a bedrock layer to anything built on it. A lot of my thinking on how to layer things is built on this idea...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-13T05:09:54.167Z" class="reply"><span class="user">Robert Butler</span> <a href="#2021-05-13T05:09:54.167Z" class="date">2021-05-13 05:09:54</a> <div class="message"><p>I'm curious what reliability you are referring to. An instruction set isomorphic language can be made reliable in the sense of 1) consistent execution 2) predictable execution every bit as much as we count on the hardware in those two ways. It probably won't look exactly like what we think of as a high level language today. In fact, it may be quite different. You can only allow certain "clearly understandable" abstractions and maintain the isomorphism. I think this is what <a href="https://github.com/akkartik/mu">Kartik Agaram</a> is attempting to explore with Mu and why there is so much focus on the hardware, the general 1:1 relationship between language statements and translation into hardware instructions and other design constraints.</p>
<p>My question is can such a isomorphic language be made in such a way that it would be high level enough and useful enough to be commonly used within a well understood domain?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-13T09:35:59.167Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2021-05-13T09:35:59.167Z" class="date">2021-05-13 09:35:59</a> <div class="message"><p><a href="https://tumbleweed.nu/r/lm-3/uv/cadr.html"></a><a href="https://tumbleweed.nu/r/lm-3/uv/cadr.html">https://tumbleweed.nu/r/lm-3/uv/cadr.html</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-13T13:39:39.168Z" class="reply"><span class="user">Doug Moen</span> <a href="#2021-05-13T13:39:39.168Z" class="date">2021-05-13 13:39:39</a> <div class="message">
<blockquote><p>A&nbsp;&gt; bedrock abstraction&gt;  level is found in every man-made system.&nbsp;&nbsp;No&nbsp;recoverable&nbsp;failure, no matter how catastrophic, will ever demand intelligent intervention below it.My experience with programming early 8-bit microprocessors is that, when programming in assembly language, you did indeed have access to a bedrock abstraction level, as defined above.</p>
</blockquote>
<p>There is no accessible bedrock abstraction level in modern computers. Machine code programming on a modern Intel based motherboard happens at an abstraction level far above the bedrock, and below you are many dark corners and mysterious voodoo-encouraging subtle malfunctions. The UEFI is stealing cycles from the OS to do who knows what, the firmware for the microcode and the mysterious intel management engine are encrypted, and security flaws like Spectre and Meltdown require intelligent intervention at a level that is inaccessible to the owner of the computer. I think the author agrees with this.</p>
<p>I don't agree that the invention of compilers in the 1950's was a mistake. Twenty years later, in the 1970's, CPU instruction set architectures were still being designed with the needs of assembly language programmers in mind. A key design goal was "orthogonality" <a href="[https://en.wikipedia.org/wiki/Orthogonal_instruction_set](https://en.wikipedia.org/wiki/Orthogonal_instruction_set)">[https://en.wikipedia.org/wiki/Orthogonal_instruction_set](https://en.wikipedia.org/wiki/Orthogonal_instruction_set)</a>. The existence of compilers didn't prevent architectures like the PDP-11 from being designed. I think the author agrees, since they mention RISC as the beginning of "braindead architectures".</p>
<p>But RISC wasn't primarily about compilers, it was primarily about making CPUs faster and more efficient, and prioritizing that goal above the goal of making the ISA comfortable for assembly programmers.</p>
<p>So here's my question. Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-13T13:58:43.169Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-13T13:58:43.169Z" class="date">2021-05-13 13:58:43</a> <div class="message"><p><a href="http://curv3d.org/">Doug Moen</a>:</p>
<blockquote><p>Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?</p>
</blockquote>
<p>Probably. For me the inescapable implication is: think about habitability (and safety), and don't focus on performance to the exclusion of all else.</p>
<p>I don't understand why people get so excited about performance and forget Wirth's Law:</p>
<blockquote><p>software&gt;  is getting slower more rapidly than &gt; hardware&gt;  is becoming faster.</p>
</blockquote>
<p>You think the M1 is fast? Just wait a couple of years!</p>
<p>A substrate that will run so fast that you don't have to think about what you run on it is the very definition of an externality. Exponential curves consume all slack. No matter how large the supply of Buffalo is, it's finite. Thinking of a resource as infinite makes no sense. That way lies religion and the Singularity.</p>
<p>Has Apple said anything about how they've tried to mitigate side-channel attacks on hardware optimizations? If they've just focused on making everything faster like everyone else, they're likely open to similar attacks?</p>
<p>"Reality is that which, when you stop believing in it, doesn't go away." -- Philip K Dick</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-16T07:11:15.173Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-05-16T07:11:15.173Z" class="date">2021-05-16 07:11:15</a> <div class="message"><p>Wondering if the notion of "bedrock" still makes sense in a world where most computers are virtual to some degree. From the exchanges above, I'd conclude that the bedrock level is the first programmable level of abstraction just above non-programmable hardware. In some contexts (e.g. cybersecurity), that's relevant. For many others, it isn't.</p>
<p>I'd be perfectly happy to fully inhabit a higher level of abstraction, and leave the lower programmable levels to other species of inhabitants. I see the main problem with today's platforms in the unclear borderlines between levels and in the intentional obfuscation of lower levels.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-16T19:29:30.174Z" class="reply"><span class="user">Doug Moen</span> <a href="#2021-05-16T19:29:30.174Z" class="date">2021-05-16 19:29:30</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> I'm thinking about a version of my language that runs in WASM, using (some subset of) WASI to interface to the hardware and OS. In that context, WASM and WASI are the "bedrock" abstraction level, since you can't go any lower.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-05-15T00:31:44.170Z" class="post"><span class="user">Srini Kadamati</span> <a href="#2021-05-15T00:31:44.170Z" class="date">2021-05-15 00:31:44</a> <div class="message"><p>Stumbled into this open source personal CRM tool called Monica: <a href="https://github.com/monicahq/monica"></a><a href="https://github.com/monicahq/monica">https://github.com/monicahq/monica</a> few people in the DevRel community I’m in mentioned it. I always enjoy seeing end-user applications open sourced (I’m often also equally as confused, b/c most users won’t be able to self-host it 😕 ).</p>
<p>I’m very keen to figure out how to do open source that isn’t code / github oriented, for end-user applications</p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://github.com/monicahq/monica">monicahq/monica</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div><div id="2021-05-15T02:39:00.171Z" class="post"><span class="user">Ivan Reese</span> <a href="#2021-05-15T02:39:00.171Z" class="date">2021-05-15 02:39:00</a> <div class="message"><p>Charming little <a href="https://macwright.com/2021/03/16/return-of-fancy-tools.html"></a><a href="https://macwright.com/2021/03/16/return-of-fancy-tools.html">https://macwright.com/2021/03/16/return-of-fancy-tools.html</a> on complexity and simplicity.</p>
<blockquote><p>The friction of having to write, to structure thoughts in plain text, to remember the name of the person I need to reference on this page: that is the point. Frictionless note-taking produces notes, but it doesn’t - for me - produce memory.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-05-15T13:26:40.172Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2021-05-15T13:26:40.172Z" class="date">2021-05-15 13:26:40</a> <div class="message"><p>There is some utility to having the computer figure out what you've referenced and built the interlinks for you, but it doesn't seem like the note tool people have much overlap with the NLP + semantics crowd...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-15T21:15:12.173Z" class="reply"><span class="user">Chris Rabl</span> <a href="#2021-05-15T21:15:12.173Z" class="date">2021-05-15 21:15:12</a> <div class="message">
<blockquote><p>There’s no “directory listing” in my editor. I hit ctrl-p and fzf&nbsp;helps me find the file by name. This is obviously&nbsp;&gt; not the future of codingFunny, this is strikingly similar to the approach Unison takes (and even carries out a few decimal places): an append-only collection of syntax trees identified by hashes, all stored inside of a single directory 😉</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2021-05-15T09:39:16.172Z" class="post"><span class="user">Mariano Guerra</span> <a href="#2021-05-15T09:39:16.172Z" class="date">2021-05-15 09:39:16</a> <div class="message"><p>Dark Lang with Paul Biggar</p>
<p><a href="https://www.twitch.tv/videos/1022779382"></a><a href="https://www.twitch.tv/videos/1022779382">https://www.twitch.tv/videos/1022779382</a></p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://www.twitch.tv/videos/1022779382">#PLTalk: Dark Lang with Paul Biggar - jeanqasaur on Twitch</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div>
    </div>
  </body>
</html>
