
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2021-05-26T17:06:15.021Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2021-05-26T17:06:15.021Z" class="date">2021-05-26 17:06:15</a> <div class="message"><p>SAD theorem</p>
<p>As programs grow complex, you will be repeatedly forced to either:</p>
<p>maintain some State,</p>
<p>perform some computations Again,</p>
<p>or Duplicate some code.</p>
<p>Has anyone encountered a formulation like this in the literature?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2021-05-26T18:03:55.022Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-05-26T18:03:55.022Z" class="date">2021-05-26 18:03:55</a> <div class="message"><p>S and A seem to relate to caching, the D talks about code, but if it talked about data it would definitely be about cache invalidation ðŸ˜›</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-26T18:21:51.022Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-26T18:21:51.022Z" class="date">2021-05-26 18:21:51</a> <div class="message"><p>I'm only concerned about the code architecture. S and A are about caching only to the extent that all data structures are caches (a reasonable view)</p>
<p>I'm going to flesh out a concrete case study. But if y'all think of any papers that may be relevant please throw them here.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-26T18:48:12.022Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-05-26T18:48:12.022Z" class="date">2021-05-26 18:48:12</a> <div class="message"><p>right now I can only think of "On the criteria to be used in decomposing systems into modules" by parnas</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-26T18:53:01.023Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2021-05-26T18:53:01.023Z" class="date">2021-05-26 18:53:01</a> <div class="message"><p><a href="https://www.semanticscholar.org/paper/N-degrees-of-separation%3A-multi-dimensional-of-Tarr-Ossher/2618f43d7ada40c94e91d9abbba4456799a7e927"></a><a href="https://www.semanticscholar.org/paper/N-degrees-of-separation%3A-multi-dimensional-of-Tarr-Ossher/2618f43d7ada40c94e91d9abbba4456799a7e927">https://www.semanticscholar.org/paper/N-degrees-of-separation%3A-multi-dimensional-of-Tarr-Ossher/2618f43d7ada40c94e91d9abbba4456799a7e927</a></p>
</div> <div class="attachments"><blockquote><p>ðŸ”— <a href="https://www.semanticscholar.org/paper/N-degrees-of-separation%3A-multi-dimensional-of-Tarr-Ossher/2618f43d7ada40c94e91d9abbba4456799a7e927">[PDF] N degrees of separation: multi-dimensional separation of concerns | Semantic Scholar</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2021-05-26T19:32:06.024Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="#2021-05-26T19:32:06.024Z" class="date">2021-05-26 19:32:06</a> <div class="message"><p>Maybe of interest:</p>
<p>NiCad Clone Detector <a href="https://www.researchgate.net/publication/221219568_The_NiCad_clone_detector"></a><a href="https://www.researchgate.net/publication/221219568_The_NiCad_clone_detector">https://www.researchgate.net/publication/221219568_The_NiCad_clone_detector</a></p>
<p>Framing Software Reuse <a href="https://www.amazon.ca/Framing-Software-Reuse-Lessons-World/dp/013327859X"></a><a href="https://www.amazon.ca/Framing-Software-Reuse-Lessons-World/dp/013327859X">https://www.amazon.ca/Framing-Software-Reuse-Lessons-World/dp/013327859X</a>)</p>
<p>My thoughts on RY as a Programming Primitive</p>
<p><a href="https://guitarvydas.github.io/2021/05/24/RY-Repeat-Yourself-as-a-PL-Primitive.html"></a><a href="https://guitarvydas.github.io/2021/05/24/RY-Repeat-Yourself-as-a-PL-Primitive.html">https://guitarvydas.github.io/2021/05/24/RY-Repeat-Yourself-as-a-PL-Primitive.html</a></p>
<p>StateCharts</p>
<p><a href="https://guitarvydas.github.io/2020/12/09/StateCharts.html"></a><a href="https://guitarvydas.github.io/2020/12/09/StateCharts.html">https://guitarvydas.github.io/2020/12/09/StateCharts.html</a>)</p>
<p>StateCharts II</p>
<p><a href="https://guitarvydas.github.io/2021/02/25/statecharts-(again).html"></a><a href="https://guitarvydas.github.io/2021/02/25/statecharts-(again).html">https://guitarvydas.github.io/2021/02/25/statecharts-(again).html</a>)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T00:56:45.026Z" class="reply"><span class="user">taowen</span> <a href="#2021-05-27T00:56:45.026Z" class="date">2021-05-27 00:56:45</a> <div class="message"><p>we might say, there is no such thing called "state" once upon a time. "state" is a illusion invented to decouple computation.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T01:14:43.026Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-27T01:14:43.026Z" class="date">2021-05-27 01:14:43</a> <div class="message"><p><strong>@taowen</strong> Spotted just now:</p>
<blockquote><p>a filesystem is a kind of network protocol that allows for communicating across time</p>
</blockquote>
<p><a href="https://tiny.tilde.website/@astrid/103554056156344583"></a><a href="https://tiny.tilde.website/@astrid/103554056156344583">https://tiny.tilde.website/@astrid/103554056156344583</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T01:19:30.026Z" class="reply"><span class="user">taowen</span> <a href="#2021-05-27T01:19:30.026Z" class="date">2021-05-27 01:19:30</a> <div class="message"><p>or a abstraction to generalize the past, no matter how many events happened in what order, we can always generalize it as "same state", to simplify the integration</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T04:41:42.027Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2021-05-27T04:41:42.027Z" class="date">2021-05-27 04:41:42</a> <div class="message"><p>Seen from a purely computational perspective, yes. But state is also a feature of our physical universe, and can thus be an important aspect of models of the physical world. Much of the OO vs. FP debate could be eliminated if both sides made a clear distinction between state as part of the model and computational state as an optimization technique.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T14:09:41.027Z" class="reply"><span class="user">Jared Windover</span> <a href="#2021-05-27T14:09:41.027Z" class="date">2021-05-27 14:09:41</a> <div class="message"><p>S and A do seem like things that can be traded against each other, but I'm having a hard time seeing how D comes in. How does duplicated code trade against State? Is the idea that the branch of code you find yourself in implicitly encodes the state?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T14:22:23.027Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-27T14:22:23.027Z" class="date">2021-05-27 14:22:23</a> <div class="message"><p>Say you perform some complex function (rendering some structured data to screen) and then need the result of a sub-computation (where did ___ get drawn?) You could either save some state during the computation (render) or redo a slice of it (a pretend-render function that duplicates some of the logic in render).</p>
<p>Perhaps higher-order functions will help here? I have a tendency to forget them after 2 years of programming in machine code.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T14:30:53.028Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-27T14:30:53.028Z" class="date">2021-05-27 14:30:53</a> <div class="message"><p>Oh, reusing a HOF would correspond to doing some potentially complex computation again for the complex traversal logic. This reminds me of the Scrap Your Boilerplate papers from the Haskell world.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-27T17:13:16.028Z" class="reply"><span class="user">Chris Granger</span> <a href="#2021-05-27T17:13:16.028Z" class="date">2021-05-27 17:13:16</a> <div class="message"><p>This feels very related to the primary thesis of Out of the Tar Pit</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-29T16:05:07.031Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-29T16:05:07.031Z" class="date">2021-05-29 16:05:07</a> <div class="message"><p><a href="https://twitter.com/ibdknox">Chris Granger</a> Thank you for bringing up Out of the Tar Pit! I've tried several times to appreciate it, and mostly failed to do so in the past[1]. Your nudge in this context got me to do so one more time, and I got a lot further. This time I went past the preliminaries in chapters 1-7 which had given me a lot of trouble before, and focused on their solution outline in chapters 8-10.</p>
<p>I don't think I'd ever noticed before that their FRP is not Conal Elliott's FRP! Functional Relational Programming, not Functional Reactive Programming. Did everybody else know this? This is the kind of stuff that reminds me that my brain is just a jumble of wires, and all my seeming insights are illusory. I'll call it a Moseley-Marks or MM system, just to get past the camouflage.</p>
<p>Have there been any attempts to build an MM system? Pretty much every FRP mention out there seems to be reactive rather than relational. The closest I got was systems inspired directly by Codd rather than MM: <a href="https://wiki.c2.com/?TutorialDee"></a><a href="https://wiki.c2.com/?TutorialDee">https://wiki.c2.com/?TutorialDee</a></p>
<p>Anyways, once I pruned away the stuff I was distracted by in the past, I see now a kernel of ideas that seem very useful. It's not essential vs accidental complexity that an MM system manages, because I'm skeptical of our ability to separate those categories, but rather functional invariants vs cross-cutting concerns:</p>
<ul><li>Base state consisting of immutable value types and relations between them (subsets of points in tuple space).</li><li>Functions over value types.</li><li>Derived relations that aren't needed to describe the problem, but useful to a specific implementation.</li><li>Integrity constraints for base and derived relations.</li><li>Hints on what to store, what order to store it, indexes, etc. A Prolog-like search strategy would fit in here, I think.</li></ul><p>The critical new insight for me: this doesn't have to be an all-encompassing framework. Calling it Functional makes it hard to see that I can actually use the framework even in an imperative setting. Set up a phase of a program where it goes through deriving relations from the input, then query the relation store in various ways to create the desired output. Unlike properties like referential transparency, a little impurity here doesn't actually make it impossible to assess the remainder. I can imagine a fairly conventional language toolchain that adds a <code>relvar</code> type, along with operations to insert into, query and clear relational variables. Use them in the "lumpy" parts of your program, where you're tempted to duplicate code or no obvious new abstractions present themselves. The toolchain could even give feedback in a complexity score every time it rebuilds a program. The only new domain-independent constraint: you can't mutate a value in the relation store.</p>
<p>This framework feels enormously useful once I stop expecting it to be a silver bullet, and start thinking of it instead as a stepping stone to the right architecture. A dynamically typed store of global state that is easy to query. The problem with mutable global state is really just one of UX: it's too easy to get into situations where mutations get squirreled away where they're easy to forget. Creating immutable copies and local variables can lead to the same pathologies; they just tend to do so less often. Given the gradual nature of the benefits, requiring 100% purity to get any benefits feels like a bad trade. The MM system permits more graceful trade-offs.</p>
<p>[1] My opinion of it as of last week, mostly honed in the course of discussions here: <a href="https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9"></a><a href="https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9">https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-29T19:56:30.031Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2021-05-29T19:56:30.031Z" class="date">2021-05-29 19:56:30</a> <div class="message">
<blockquote><p>I don't think I'd ever noticed before that their FRP is not Conal Elliott's FRP! Functional&nbsp;&gt; Relational&gt; &nbsp;Programming, not Functional Reactive Programming. Did everybody else know this?</p>
</blockquote>
<p><em>nod</em></p>
<blockquote><p>Have there been any attempts to build an MM system?</p>
</blockquote>
<p>Last time I asked / researched this, I only heard/saw "no" beyond the example in the paper. I think a lot of folks (myself included) have made feints in that direction, before diverting off elsewhere for whatever reason.</p>
<blockquote><p>It's not essential vs accidental complexity that an MM system manages, &gt; because I'm skeptical of our ability to separate those categories</p>
</blockquote>
<p>Need one of those room-scale "ðŸ’¯" buttons I can jump up and down on.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-30T02:02:54.032Z" class="reply"><span class="user">Doug Moen</span> <a href="#2021-05-30T02:02:54.032Z" class="date">2021-05-30 02:02:54</a> <div class="message"><p>I think that the Cell language is MM inspired. I'd guess heavily inspired, except that the author doesn't cite the tarpit paper. <a href="http://cell-lang.net/"></a><a href="http://cell-lang.net/">http://cell-lang.net/</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-30T04:32:29.035Z" class="reply"><span class="user">Chris Granger</span> <a href="#2021-05-30T04:32:29.035Z" class="date">2021-05-30 04:32:29</a> <div class="message"><p>Many versions of Eve were essentially MM systems that tried out different points in the implementation space. From pure log + view to various forms of mutable. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-30T11:20:59.035Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-30T11:20:59.035Z" class="date">2021-05-30 11:20:59</a> <div class="message"><p><a href="http://curv3d.org/">Doug Moen</a> <a href="http://cell-lang.net/relations.html"></a><a href="http://cell-lang.net/relations.html">http://cell-lang.net/relations.html</a> cites the paper!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2021-05-29T16:05:07.031Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2021-05-29T16:05:07.031Z" class="date">2021-05-29 16:05:07</a> <div class="message"><p><a href="https://twitter.com/ibdknox">Chris Granger</a> Thank you for bringing up Out of the Tar Pit! I've tried several times to appreciate it, and mostly failed to do so in the past[1]. Your nudge in this context got me to do so one more time, and I got a lot further. This time I went past the preliminaries in chapters 1-7 which had given me a lot of trouble before, and focused on their solution outline in chapters 8-10.</p>
<p>I don't think I'd ever noticed before that their FRP is not Conal Elliott's FRP! Functional Relational Programming, not Functional Reactive Programming. Did everybody else know this? This is the kind of stuff that reminds me that my brain is just a jumble of wires, and all my seeming insights are illusory. I'll call it a Moseley-Marks or MM system, just to get past the camouflage.</p>
<p>Have there been any attempts to build an MM system? Pretty much every FRP mention out there seems to be reactive rather than relational. The closest I got was systems inspired directly by Codd rather than MM: <a href="https://wiki.c2.com/?TutorialDee"></a><a href="https://wiki.c2.com/?TutorialDee">https://wiki.c2.com/?TutorialDee</a></p>
<p>Anyways, once I pruned away the stuff I was distracted by in the past, I see now a kernel of ideas that seem very useful. It's not essential vs accidental complexity that an MM system manages, because I'm skeptical of our ability to separate those categories, but rather functional invariants vs cross-cutting concerns:</p>
<ul><li>Base state consisting of immutable value types and relations between them (subsets of points in tuple space).</li><li>Functions over value types.</li><li>Derived relations that aren't needed to describe the problem, but useful to a specific implementation.</li><li>Integrity constraints for base and derived relations.</li><li>Hints on what to store, what order to store it, indexes, etc. A Prolog-like search strategy would fit in here, I think.</li></ul><p>The critical new insight for me: this doesn't have to be an all-encompassing framework. Calling it Functional makes it hard to see that I can actually use the framework even in an imperative setting. Set up a phase of a program where it goes through deriving relations from the input, then query the relation store in various ways to create the desired output. Unlike properties like referential transparency, a little impurity here doesn't actually make it impossible to assess the remainder. I can imagine a fairly conventional language toolchain that adds a <code>relvar</code> type, along with operations to insert into, query and clear relational variables. Use them in the "lumpy" parts of your program, where you're tempted to duplicate code or no obvious new abstractions present themselves. The toolchain could even give feedback in a complexity score every time it rebuilds a program. The only new domain-independent constraint: you can't mutate a value in the relation store.</p>
<p>This framework feels enormously useful once I stop expecting it to be a silver bullet, and start thinking of it instead as a stepping stone to the right architecture. A dynamically typed store of global state that is easy to query. The problem with mutable global state is really just one of UX: it's too easy to get into situations where mutations get squirreled away where they're easy to forget. Creating immutable copies and local variables can lead to the same pathologies; they just tend to do so less often. Given the gradual nature of the benefits, requiring 100% purity to get any benefits feels like a bad trade. The MM system permits more graceful trade-offs.</p>
<p>[1] My opinion of it as of last week, mostly honed in the course of discussions here: <a href="https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9"></a><a href="https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9">https://lobste.rs/s/1yfrup/into_tar_pit#c_3ikuv9</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
