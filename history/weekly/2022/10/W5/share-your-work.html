
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-10-30T02:02:35.922Z" class="post"><span class="user">Ivan Reese</span> <a href="./?fromDate=2022-10-27&amp;toDate=2022-11-02&amp;channel=share-your-work&amp;filter=#2022-10-30T02:02:35.922Z" class="date">2022-10-30 02:02:35</a> <div class="message"><p>Future of Coding â€¢ Episode 59</p>
<p>Richard P. Gabriel â€¢ Worse is Better</p>
<p>ðŸ”— <a href="https://futureofcoding.org/episodes/059">futureofcoding.org/episodes/059</a></p>
<p>Following our <a href="https://futureofcoding.org/episodes/058">previous episode</a> on Richard P. Gabriel's  <em>Incommensurability</em>  paper, we're back for round two with an analysis of what we've dubbed the  <em>Worse is Better family of thought products:</em> </p>
<ul><li><a href="https://dreamsongs.com/RiseOfWorseIsBetter.html">The Rise of Worse Is Better</a> by Richard P. Gabriel</li><li><a href="https://www.dreamsongs.com/Files/worse-is-worse.pdf">Worse is Better is Worse</a> by Nickieben Bourbaki</li><li><a href="https://www.dreamsongs.com/Files/IsWorseReallyBetter.pdf">Is Worse Really Better?</a> by Richard P. Gabriel</li></ul><p>Next episode, we've got a recent work by a real up-and-comer in the field. While you may not have heard of him yet, he's a promising young lad who's sure to become a household name.</p>
<ul><li><a href="http://worrydream.com/MagicInk/">Magic Ink</a> by Bret Victor</li></ul><p>I am usually really thorough in my editing of the show, but this one I sort of had to rush out the door because the month is rapidly drawing to a close. If anyone spots any weird edits, or anything that sounds out of place, let me know. In particular, the sponsors (which now come at the end of the episode) might be a little rough. Oh well â€” pays the bills, amirite?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-10-30T04:44:35.864Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-10-27&amp;toDate=2022-11-02&amp;channel=share-your-work&amp;filter=#2022-10-30T04:44:35.864Z" class="date">2022-10-30 04:44:35</a> <div class="message"><p> <em>i</em> Land ðŸ˜‚</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-10-30T05:09:15.058Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-10-27&amp;toDate=2022-11-02&amp;channel=share-your-work&amp;filter=#2022-10-30T05:09:15.058Z" class="date">2022-10-30 05:09:15</a> <div class="message"><p>Thank you, this was a fun listen. I also really appreciate that you have dropped the disrespectful nicknames. Thank you.</p>
<p>When comparing the priorities of the authors of Unix versus the authors of ITS, I think it's worth remembering some of the technical differences between the hardware.</p>
<p>Unix grew up on a mini computer, the PDP-11 (Yes, it started life on a PDP-7, but the real growth into the operating system we would recognize today occurred on the PDP 11.), where the kernel had to fit in 64K, and each program had to fit in its own 64K (later models let you use 64K for code and a separate 64K for data). This environment will naturally encourage one to prioritize performance and simplicity of implementation.</p>
<p>On the other hand, ITS grew up on a mainframe, the PDP-6 (later PDP-10), which had a 36-bit word and 18-bit addressing, making it possible for a single address space to contain substantially more memory. It's much easier to put more complexity into your kernel in this environment.</p>
<p>As a result, I'm not convinced that the differences in prioritization were fundamentally the results of the two cultures in question. I suspect the different priorities may have arisen partly from the technologies in question.</p>
<p>With respect to the question of how well the Unix interface hides complexity, I would argue that many Unix tools provide a good, simple interface for utilizing some pretty deep complexity. In fact, I think the relevant comparison is not Lisp versus C, but Lisp versus sh. The ubiquitous data type in Lisp is the list, while the ubiquitous data type in sh is the file full of variable length one line records. Pipelines in sh fill the role of function composition in Lisp. The equivalent of C in ITS was the MIDAS assembler, which WAS really nice for an assembler. See <a href="https://wiki.c2.com/?SymbioticLanguages">wiki.c2.com/?SymbioticLanguages</a> for some elaboration on where I'm coming from with this comparison.</p>
<p>For example, make provides a relatively easy way to make use of a topological sort, without having to understand the implementation details or even what a topological sort is.</p>
<p>The sort command allows you to sort files substantially larger than RAM, handling all issues of breaking files into chunks that can be sorted within RAM, merging those chunks into larger chunks, storing intermediate results on disc, etc.</p>
<p>The diff command provides a simple interface for finding the longest common substring between two sets of lines.</p>
<p>lex and yacc pack a lot of powerful computer science into a relatively straightforward interface for specifying tokens and grammars.</p>
<p>join, comm, awk, dc, bc, and many other tools that were already available in v7 Unix also present simple interfaces for making use of powerful code.</p>
<p>Speaking as a huge Smalltalk and Lisp fan, as well as a huge Unix fan, I think the question of how Unix won extends far beyond Gabriel's analysis, though I appreciate the factors that he identified.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-10-31T06:22:06.494Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-10-28&amp;toDate=2022-11-03&amp;channel=share-your-work&amp;filter=#2022-10-31T06:22:06.494Z" class="date">2022-10-31 06:22:06</a> <div class="message"><p>Interesting episode, once more! I had read these papers many years ago, with mixed feelings about the relevance of the "worse is better" idea. Your discussion framing it as "where does the complexity go" is illuminating here. But I agree with <strong>@Personal Dynamic Media</strong> that it's not so much "developer vs. user" but "where on the many layers of a real-life software system does the complexity go?" Unix at the shell programming level is indeed free from the low-level considerations that PG mentions. Which explains why I found the topic only moderately relevant since my own focus as a power user (rather than software developer) is on levels clearly above the Linux kernel APIs. For me,  Lisp machine vs. Unix is about Lisp vs. shell as the layer that defines the coherence and accessability of system features. With Lisp clearly "winning" here, but at the cost of much higher resource usage.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-10-31T07:00:57.995Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2022-10-28&amp;toDate=2022-11-03&amp;channel=share-your-work&amp;filter=#2022-10-31T07:00:57.995Z" class="date">2022-10-31 07:00:57</a> <div class="message"><p>On Ruby, Matz put it this way, "Actually, I'm trying to make Ruby natural, not simple."</p>
<p>Concrete example.  The keyword  <code>alias</code>  is a for giving multiple names to the same method so that you can call the synonym that feels the most natural.  Examples from the often used  <code>Enumerable</code>  module:</p>
<ul><li><code>include?</code>  and  <code>member?</code></li><li><code>to_a</code>  and  <code>entries</code></li><li><code>detect</code>  and  <code>find</code></li><li><code>select</code>  and  <code>filter</code>  and  <code>find_all</code></li><li><code>map</code>  and  <code>collect</code></li><li><code>flat_map</code>  and  <code>collect_concat</code></li><li><code>reduce</code>  and  <code>inject</code></li></ul><p>The -ect names ( <code>select</code> ,  <code>reject</code> ,  <code>detect</code> ,  <code>inject</code> ) come from Smalltalk.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-10-31T14:06:21.392Z" class="reply"><span class="user">Ivan Reese</span> <a href="./?fromDate=2022-10-28&amp;toDate=2022-11-03&amp;channel=share-your-work&amp;filter=#2022-10-31T14:06:21.392Z" class="date">2022-10-31 14:06:21</a> <div class="message"><p><strong>@William Taysom</strong> I'm not sure what you're responding to. Something from a previous comment? Something from the episode? (Perhaps Jimmy's mention that Ruby is difficult to parse?)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-11-01T02:15:20.667Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2022-10-29&amp;toDate=2022-11-04&amp;channel=share-your-work&amp;filter=#2022-11-01T02:15:20.667Z" class="date">2022-11-01 02:15:20</a> <div class="message"><p>Yes, Jimmy's comment from the episode that Ruby is complex in implementation and complex in API.  Yet somehow using it often feels good.  How?  Comes from the complexity being in service of a kind of naturalness.  The syntax, for example, if enough people interested people think something should work eventually it does.</p>
<p>Now does anyone actually know the syntax of the language?  Not me!  And I've been writing this language for twenty years.  I was today days old when I learned you can use  <code>::</code>  for method calls, as in  <code>Object.new::is_a?(Object)</code> .</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
