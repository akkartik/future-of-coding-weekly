
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-04-10T07:36:09.153Z" class="post"><span class="user">Christopher Shank</span> <a href="./?fromDate=2022-04-07&amp;toDate=2022-04-13&amp;channel=reading-together&amp;filter=#2022-04-10T07:36:09.153Z" class="date">2022-04-10 07:36:09</a> <div class="message"><p>A book called ‚ÄúDiagramming Techniques for Analysts and Programmers‚Äù (1985). Found it through a paper by David Harel. He descibed it as: </p>
<blockquote><p>The state of the art on diagrammatic languages at the time can be gleaned from the book by Martin and McClure titled &gt; Diagramming Techniques for Analysts and Programmers&gt; . This book discussed many visual techniques, but little attention was given to the need for solid semantics and/or executability. Curiously, this book could have helped convince people that visual languages should not be taken seriously as means to actually program a system the way a standard programming language can.</p>
</blockquote>
<p><a href="https://archive.org/details/diagrammingtechn00mart/page/310/mode/2up"></a><a href="https://archive.org/details/diagrammingtechn00mart/page/310/mode/2up">https://archive.org/details/diagrammingtechn00mart/page/310/mode/2up</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://archive.org/details/diagrammingtechn00mart/page/310/mode/2up">Diagramming techniques for analysts and programmers : Martin, James, 1933- : Free Download, Borrow, and Streaming : Internet Archive</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"></div></div><div id="2022-04-10T20:47:20.570Z" class="post"><span class="user">Christopher Shank</span> <a href="./?fromDate=2022-04-07&amp;toDate=2022-04-13&amp;channel=reading-together&amp;filter=#2022-04-10T20:47:20.570Z" class="date">2022-04-10 20:47:20</a> <div class="message"><p>Also started reading through ‚ÄúUsability Analysis of Visual Programming Environments: a ‚Äòcognitive dimensions‚Äô framework‚Äù by Green and Petre (1996).</p>
<blockquote><p>The dimensions in outline: The list of dimensions that we shall use in this paper follows. For each dimension we supply a thumb-nail description. A lengthier account of the dimension and its relation to the underlying evidence will be found in the appropriate section below.</p>
</blockquote>
<ul><li>Abstraction Gradient: What are the minimum and maximum levels of abstraction? Can fragments be encapsulated?</li><li>Closeness of mapping: What ‚Äòprogramming games‚Äô need to be learned?</li><li>Consistency: When some of the language has been learnt, how much of the rest can be inferred?</li><li>Diffuseness: How many symbols or graphic entities are required to express a meaning?</li><li>Error-proneness: Does the design of the notation induce ‚Äòcareless mistakes‚Äô?</li><li>Hard mental operations: Are there places where the user needs to resort to fingers or pen- cilled annotation to keep track of what‚Äôs happening?</li><li>Hidden dependencies: Is every dependency overtly indicated in both directions? Is the indi- cation perceptual or only symbolic?</li><li>Premature commitment: Do programmers have to make decisions before they have the information they need?</li><li>Progressive evaluation: Can a partially-complete program be executed to obtain feedback on ‚ÄúHow am I doing‚Äù?</li><li>Role-expressiveness: Can the reader see how each component of a program relates to the whole?</li><li>Secondary notation: Can programmers use layout, colour, or other cues to convey extra meaning, above and beyond the ‚Äòofficial‚Äô semantics of the language?</li><li>Viscosity: How much effort is required to perform a single change?</li><li>Visibility: Is every part of the code simultaneously visible (assuming a large enough display), or is it at least possible to juxtapose any two parts side-by-side at will? If the code is dispersed, is it at least possible to know in what order to read it?</li></ul><p><a href="https://web.engr.oregonstate.edu/~burnett/CS589and584/CS589-papers/CogDimsPaper.pdf"></a><a href="https://web.engr.oregonstate.edu/~burnett/CS589and584/CS589-papers/CogDimsPaper.pdf">https://web.engr.oregonstate.edu/~burnett/CS589and584/CS589-papers/CogDimsPaper.pdf</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div>
    </div>
  </body>
</html>
