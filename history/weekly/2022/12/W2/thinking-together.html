
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-12-05T11:34:36.951Z" class="post"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:34:36.951Z" class="date">2022-12-05 11:34:36</a> <div class="message"><p>Provenance of content will be a huge challenge due to recent advancements in AI/ML. My immediate thought was "but code is in Git etc. and we know the author", but that's all void if the actual author of the code was a tool like ChatGPT/Co-Pilot and the dev was just the one that pushed it.</p>
<p>Maybe AI will be what brings about next-gen versioning systems where content provenance is managed at the AST node level during code authoring, and not just by whoever pushed the code after the fact.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-12-05T11:36:52.422Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:36:52.422Z" class="date">2022-12-05 11:36:52</a> <div class="message"><p>Why does provenance matter? If it's good enough to pass a human review, then it's good enough. So quality/accuracy will matter more than provenance.</p>
<p>Or did you have copyright liability in mind?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:42:32.221Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:42:32.221Z" class="date">2022-12-05 11:42:32</a> <div class="message"><p>I think the review aspect is that weak part of the link. More people, with less programming knowledge will be adding code that was written by AI, and even developers are busy and will accept code that looks correct. All that code is then fed into the training set of the next round, and you've got a positive feedback loop.</p>
<p>It's the same as self-driving cars. Humans learn to trust the system, relax, and then it's all fine until it's not. I do think we'll eventually get to a good place, but right now we're in the gap between two worlds, and that's when the damage happens.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:43:24.404Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:43:24.404Z" class="date">2022-12-05 11:43:24</a> <div class="message"><p>The thread that inspired this: <a href="https://twitter.com/v21/status/1599571365556006915">twitter.com/v21/status/1599571365556006915</a></p>
</div> <div class="attachments">
<blockquote><p>üê¶ <a href="https://twitter.com/@v21">v buckenham</a>: it seems very possible that we are now exiting the brief window where a good fraction of all of human knowledge was searchable &amp;amp; instantly available. a window that starts with the invention of the search engine &amp;amp; ends with the invention of large language models.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-12-05T11:46:15.411Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:46:15.411Z" class="date">2022-12-05 11:46:15</a> <div class="message"><p>Speaking only as a developer, we  <em>cannot</em>  accept code that just looks correct because we have quality review infra in place. Any code needs to pass the test cases. Can it pass test cases while being incorrect? May be, but then that's equally likely with a human.</p>
<p>So, generated code is fine. But  <em>generated prose</em>  is a different matter. We will need accuracy-checker, bullshit-checker etc kind of systems.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:47:48.058Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:47:48.058Z" class="date">2022-12-05 11:47:48</a> <div class="message"><p>How will the AI know the difference between well-tested code and code that's not during its training?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:49:44.234Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:49:44.234Z" class="date">2022-12-05 11:49:44</a> <div class="message"><p>Not the AI, but the AI training team will very likely put quality filters for the training set. Instead of training on entire github or stackoverflow, you only train on the highly-rated repos or answers.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:52:04.331Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:52:04.331Z" class="date">2022-12-05 11:52:04</a> <div class="message"><p>I see your point, but highly-rated is a simple metric, that might be more related to popularity/hype than code-quality/correctness. It's a super difficult problem.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:54:12.681Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:54:12.681Z" class="date">2022-12-05 11:54:12</a> <div class="message"><p>My point is, when it comes to code, the vicious cycle of bad quality content -&gt; bad model -&gt; bad quality content is just not there. Because our quality/rating systems work.</p>
<p>For prose, yes, this is absolutely true.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:55:04.171Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:55:04.171Z" class="date">2022-12-05 11:55:04</a> <div class="message"><p>Interesting. I think code and prose are the same in that regard üòÑ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T11:59:18.697Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T11:59:18.697Z" class="date">2022-12-05 11:59:18</a> <div class="message"><p>Not really. Spam on the web is mostly prose. There are both incentives as well as lack of quality filter tools. Nobody is spamming github with incorrect code.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T12:08:15.570Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T12:08:15.570Z" class="date">2022-12-05 12:08:15</a> <div class="message"><p>Ah, yep, agreed. they're different in terms of scale and incentives.</p>
<p>I was thinking from a more fundamental level: Quality assurance of language content at scale (both code and prose are symbolic, and use/construct abstractions). They're similar problems in that regard, but we might be lucky that the incentives make training on code a less complicated practical problem.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T12:09:25.099Z" class="reply"><span class="user">Nilesh Trivedi</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T12:09:25.099Z" class="date">2022-12-05 12:09:25</a> <div class="message"><p>Meanwhile, StackOverflow has temporarily banned answers by ChatGPT because they're too inaccurate: <a href="https://meta.stackoverflow.com/questions/421831/temporary-policy-chatgpt-is-banned">meta.stackoverflow.com/questions/421831/temporary-policy-chatgpt-is-banned</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T12:09:46.521Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T12:09:46.521Z" class="date">2022-12-05 12:09:46</a> <div class="message"><p>Haha, yep it sure is confident, even while wrong üòÑ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T12:23:05.762Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T12:23:05.762Z" class="date">2022-12-05 12:23:05</a> <div class="message"><p>This actually feeds back to my initial worry. Code alone is not enough to train systems like ChatGTP. It won't know how to map natural language onto code. That comes from training on sources like StackOverflow. See how this spam makes prose and code not so different? The social systems and incentives do appear to have some overlap. This policy change is needed, but difficult to enforce at scale. Same as QA'ing spam/prose because it requires a lot of effort to know whether something is a good answer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T12:24:44.896Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T12:24:44.896Z" class="date">2022-12-05 12:24:44</a> <div class="message"><p>Humans talking about code -&gt; Social systems/incentives -&gt; Humans gaming the systems with AI</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-05T16:33:34.203Z" class="reply"><span class="user">Mark Dewing</span> <a href="./?fromDate=2022-12-02&amp;toDate=2022-12-08&amp;channel=thinking-together&amp;filter=#2022-12-05T16:33:34.203Z" class="date">2022-12-05 16:33:34</a> <div class="message"><p>AI systems based on large language models are prone to human-like errors, both in solving logic puzzles and in writing program code.  Which gives me less confidence in code review as a quality check on AI-written code - both the AI and the human are okay with code that "looks good".   The advances in the scientific method come from developing techniques to work around limitations and drawbacks in human reasoning.  We'll need to apply these (and new ones) to AI systems.   In my view, the test suite is going to be the most important part of the code base, since an AI will write the code. (Until the AI's can write the test suite as well üôÇ ).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-07T02:32:22.208Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2022-12-04&amp;toDate=2022-12-10&amp;channel=thinking-together&amp;filter=#2022-12-07T02:32:22.208Z" class="date">2022-12-07 02:32:22</a> <div class="message"><p>Things to keep in mind:</p>
<ul><li>Part of what makes ChatGTP and improvement over plain GPT-3 comes from training for relevance rather than the first thing you would think of.  So adjusting the training criteria should then feed into...</li><li>If an AI is writing code, it should iterate with itself running the code before coming back with an answer.  Basically, mix in some of what's done to play games.  In fact...</li><li>We could potentially see quick improvement with these chat systems if well engineered prompts can go back into the training of the system.  For example, one reason why "in the style of" prompts get more pleasant output from ChatGTP is that they steer the system away from its default middling BS mode.</li></ul><p>Curiously, one good use of ChatGTP is to help discover likely misconceptions that students learning technical subjects are likely to have.  In conversations so far, I've seen ChatGTP be fuzzy on the distinctions between:</p>
<ul><li>Continuity and uncountability in math, and</li><li>block and procs in Ruby.</li></ul><p>To the credit of incorporating so much training data, ChatGTP is conversant on so many topics.  It's kind of interesting how OpenAI has put a filter on this so as to avoid avoid answering questions where ChatGTP's knowledge might be limited.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-12-10T22:28:18.043Z" class="post"><span class="user">Jan Ruzicka</span> <a href="./?fromDate=2022-12-07&amp;toDate=2022-12-13&amp;channel=thinking-together&amp;filter=#2022-12-10T22:28:18.043Z" class="date">2022-12-10 22:28:18</a> <div class="message"><p>Do computers make a qualitative difference compared to paper and a concentrated human mind?</p>
<p>They certainly improve the speed at which we can perform certain mechanical tasks by automating them (e.g. calculations, simulations and rendering of their results, even some basic logical inference can be done automatically). So even though this all can be in principle performed manually, ain‚Äôt nobody got time for that :)) This is similar to how paper dramatically expands the working and long-term memory, hence augmenting mental capabilities.</p>
<p>However, paper also expands qualitatively over mere speech by adding a second dimension for expression. This allows for not only planar, but also spatial objects to be represented trivially (they‚Äôre sometimes easier to represent than text). Also, it makes possible the use of maps and graphs, which are just impossible to imitate using just speech.</p>
<p>Computers add a dimension for expression, namely time. One can create objects that change in time, and also dynamically change them while they‚Äôre changing. But this is where I‚Äôm not sure if it makes that much of a difference. In my opinion, there‚Äôs always a certain limit beyond which changing a dynamic object gets unbelievably difficult (the ‚Äúwalled-garden‚Äù or ‚Äúprogrammer-didn‚Äôt-think-of-that‚Äù phenomenon). On paper, you might need to work with a static representation of a process, but you can manipulate it without restraints. Also from the same phenomenon, we get a limited compositionality/mobility of dynamic objects. This is not a problem with paper, where the mind is free to consider different mental and symbolic objects to interact.</p>
<p>The last point might have something to do with the fact that whereas we know some threshold for literacy (at least limited to using paper and writing for personal thinking), and that is:</p>
<ul><li>learn to read and write letters</li><li>learn to organize thoughts on paper</li><li>done (there‚Äôs always room for improvement, but this baseline still covers the qualitative advantages of paper)</li></ul><p>Compare that with ‚Äúcomputing literacy‚Äù which not only doesn‚Äôt exist, but if it did, would be something like:</p>
<ul><li>learn to use some basic programs and how programs work in general</li><li>learn to write basic procedural programs in some ‚Äúnice‚Äù programming environment (= not complex systems, not parallel, but not necessarily in a procedural language; what the environment should look like is of concern to e.g. Jonathan Edwards)</li></ul><p>‚Ä¶ so far so good, but when you hit the limit ‚Ä¶</p>
<ol start="3"><li><p>either wait for some programmer/company to expand the stuff you‚Äôre using, or ‚Ä¶</p>
</li><li><p>learn to program in universal languages, on general-purpose platforms</p>
</li><li><p>rewrite the stuff you‚Äôre using, but somewhat better</p>
</li><li><p>done? (not really - your program is buggy / your program can‚Äôt interoperate with all the other stuff that‚Äôs out there which the old program could interoperate with / ‚Ä¶)</p>
</li></ol><p>We know how unreal of a threshold numbers 4 and 5 are for the general public. If we instead restrict the threshold to 1 and 2, we don‚Äôt get the qualitative advantage of the computer.</p>
<p>So the question is: If viewed as means to augment human intellect, do computers provide qualitative (not just quantitative) advantages over pen, paper and the human mind?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-12-10T22:57:06.527Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-12-07&amp;toDate=2022-12-13&amp;channel=thinking-together&amp;filter=#2022-12-10T22:57:06.527Z" class="date">2022-12-10 22:57:06</a> <div class="message"><p>You may find this article from the original wiki interesting. <a href="https://wiki.c2.com/?IsAnythingBetterThanPaper">wiki.c2.com/?IsAnythingBetterThanPaper</a></p>
<p>One of the things Richard stallman discusses in the original Emacs paper is the gradual progression that a good programmable program can provide for users. At first they can just use the program. Then they can alter settings. Then they can add tiny one-line hooks to customize specific behaviors. Then they can move on to actually implementing larger pieces of functionality. At some point a user may realize that they are now programming, but it is difficult to identify the moment when they transitioned from being a user to being a programmer.</p>
<p><a href="https://dspace.mit.edu/handle/1721.1/5736">dspace.mit.edu/handle/1721.1/5736</a></p>
<p>A similar progression can happen in many command line-based systems, such as with Unix. At first the user simply uses the commands the system provides. Then they create a few aliases for convenience. Then they create some very simple shell scripts that just run a couple commands. Then they create slightly more sophisticated shell scripts that process multiple files or contain a conditional. Then those scripts get longer, and at some point they are obviously programming, but again it is difficult to spot the moment when they shifted from just using the software to programming, because the on ramp is so gradual.</p>
<p>For many things, such as calculations or database management, computers "just" allow us to perform the same actions at a greater scale, but at some point, when one is looking at multiple orders of magnitude difference in a quantitative measurement, it creates a qualitative difference in the types of activities that are possible.</p>
<p>From a communications perspective, the amazing thing a computer can do that paper cannot is respond to the reader. If I create a spreadsheet modeling my projections for income and expenses next year and email it to you, you can then adjust the spreadsheet numbers and watch what happens within my model. With just paper, you need to understand my model well enough to perform the calculations yourself before you can experiment with alternative inputs.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-11T00:54:31.031Z" class="reply"><span class="user">Andrew F</span> <a href="./?fromDate=2022-12-08&amp;toDate=2022-12-14&amp;channel=thinking-together&amp;filter=#2022-12-11T00:54:31.031Z" class="date">2022-12-11 00:54:31</a> <div class="message"><p>"Augment human intellect" is rather specific compared to the space of things you might compare to "paper and a concentrated human mind", but still not specific enough IMO to support a definite answer. It will depend on the problem to be solved. And the problem-solving style of the person involved.</p>
<p>There are some problems where being able to rapidly run variations on a model (I'm thinking of my budget expressed, honestly, currently expressed as a Python program), without context switching between arithmetic and conceptual thought, is handy. But doing the arithmetic by hand can also be helpful. Similar for the general case of solving program-shaped problems, there are insights to be had both in writing the program/model, running it and examining the results, and doing the work manually.</p>
<p>Practically IMO, the most useful thing about computers for what you might call "augmentation" is their memory, not so much computation per se. Hence all the myriad notes/personal database apps, digital whiteboards, etc.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-11T10:10:02.132Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-08&amp;toDate=2022-12-14&amp;channel=thinking-together&amp;filter=#2022-12-11T10:10:02.132Z" class="date">2022-12-11 10:10:02</a> <div class="message"><p>I re-invented calculus from scratch when I was eight years old so that things would "fall right" in the games/simulations I was writing on an 8-bit microcomputer. If a computer can allow a child to do something that required a lifetime's work from Newton, it's probably safe to say they are able to augment human intellect.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-11T14:36:54.765Z" class="reply"><span class="user">Jan Ruzicka</span> <a href="./?fromDate=2022-12-08&amp;toDate=2022-12-14&amp;channel=thinking-together&amp;filter=#2022-12-11T14:36:54.765Z" class="date">2022-12-11 14:36:54</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> How modest‚Ä¶ What exactly did you discover?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T01:02:02.277Z" class="reply"><span class="user">Riley Stewart</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T01:02:02.277Z" class="date">2022-12-12 01:02:02</a> <div class="message"><p>Alan Kay wrote a great essay precisely about this somewhat recently (<a href="http://www.vpri.org/pdf/future_of_reading.pdf">vpri.org/pdf/future_of_reading.pdf</a>). It's especially relevant, I feel, with the arrival of LLMs - his example of "Socrates in a computer" seems much closer. Hopefully they can be put to use to make computer literacy more attainable, much as phonetic alphabets did for traditional literacy. That's not to say that AI will solve all of our problems, or even most of them. End-user programming still requires a basic model of computation even if just to direct an agent. The fragmented ecosystem is tiresome to navigate and plumb together even for professionals. Actually running applications in the era of Web software requires too much effort, especially when security is taken into account. Yet it provides an invaluable tool to help solve all of these issues, especially if its cost falls dramatically.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T01:06:17.187Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T01:06:17.187Z" class="date">2022-12-12 01:06:17</a> <div class="message"><p><a href="https://github.com/ruza-net">Jan Ruzicka</a> I'm guessing he discovered the concepts of constant acceleration, linear velocity, and quadratic position. In the video Squeakers, Alan Kay comments on students experimenting with these concepts with virtual cars and falling objects, saying something to the effect of "your students understand second order differential equations."</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T05:35:45.850Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T05:35:45.850Z" class="date">2022-12-12 05:35:45</a> <div class="message"><p>And I imagine students come to understand the importance of some kind of dampening pretty quick, which you aren't going to get from an introductory mechanics class.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T08:39:28.735Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T08:39:28.735Z" class="date">2022-12-12 08:39:28</a> <div class="message"><p>Indeed, it was the same set of things Kay writes about and <strong>@Personal Dynamic Media</strong> enumerated. The feedback loop from experiment to observation to understanding is so much faster in a computational medium that you can learn (and thus do) things that would otherwise be extremely difficult/impossible. One of the reasons I champion interactive programming to anyone who will listen is that I've found this to be true throughout my life in a wide variety of situations.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T09:13:16.935Z" class="reply"><span class="user">Jan Ruzicka</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T09:13:16.935Z" class="date">2022-12-12 09:13:16</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a>  <strong>@Personal Dynamic Media</strong> I suspected that, too, but was curious to see if this was indeed the perfect example of Dunning-Kruger. A second-order difference equation is nowhere near "re-invented calculus from scratch". (Worth noting that calculus didn't take Newton a lifetime, maybe read up on it?)</p>
<p>Also, simulating free fall in homogeneous field does not make you "understand differential equations".</p>
<p><strong>@William Taysom</strong>  Actually, you do learn about dampening in an intro class (even in an intro class for pure mathematicians).</p>
<p>You also learn about resonance (damped and driven oscillator), which I don't imagine you can discover by playing around, due to it being dependent on a critical value of a combination of the input parameters (a certain multiple of the driving frequency, dampening rate and intrinsic frequency). Despite what e.g. Bret Victor says, I'm not convinced that much understanding can come from simulations alone, without actually studying the models (equations, which are much nicer to study than computer code).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T11:18:29.427Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T11:18:29.427Z" class="date">2022-12-12 11:18:29</a> <div class="message"><p>Well, we at least agree that there's some Dunning-Kruger going on in this conversation üòâ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-12T12:34:46.238Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-09&amp;toDate=2022-12-15&amp;channel=thinking-together&amp;filter=#2022-12-12T12:34:46.238Z" class="date">2022-12-12 12:34:46</a> <div class="message"><p>Computers can be bicycles for the mind, but, this is currently discouraged by programming notation.</p>
<p>Notation and language affects the way you allow yourself to think.</p>
<p>I would say that computers are a new medium for expression in 4 dimensions x/y/z/t.</p>
<p>IMO, this medium has yet to be explored in depth.</p>
<p>Text-based functional notation, e.g.  <code>f(x)</code>  or  <code>f(x,y,z)</code>  addresses only one use-case for computers - computers as sophisticated calculators - but cannot easily express other uses of computers, e.g. sequencers (time, history), IoT, robotics, internet, blockchain, gaming, animation, etc.</p>
<p>Obviously, we CAN express these other concepts in the current notation, but, programmers are encouraged - by exclusive use of this single notation - to think in 2D and to create calculators.</p>
<p>When all you‚Äôve got is a single notation for describing calculators, everything looks like a calculator.</p>
<p>A calculator takes one input (which might look like several inputs, thanks to the miracle of destructuring) and produces one output.  The calculator model is so insufficient for expressing programs, that a bag has been added onto the side of the model, called ‚Äòexceptions‚Äô.</p>
<p>If you want to build YAC (Yet Another Calculator), the current notation is appropriate.  If you want to build a sequencer, switch to another notation(s).  When starting a new project, it is unnecessary to jump to the premature conclusion that the project is YAC until you‚Äôve savoured all of the project‚Äôs details.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
