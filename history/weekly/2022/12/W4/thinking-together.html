
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-12-20T07:36:37.378Z" class="post"><span class="user">Jarno Montonen</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:36:37.378Z" class="date">2022-12-20 07:36:37</a> <div class="message"><p>Any opinions on should  <em>the editors in which you edit a structure (AST) rather than text</em>  be called Structure Editors, Structured Editors, Structural Editors (just saw <a href="https://twitter.com/CrowdHailer">Peter Saxton</a> use this term in his post), or Projectional Editors? Are all of these synonyms or are they just related in specific ways?</p>
<p>Personally I like Structure Editor the best, as opposed to Text Editor. Although Structured and Structural sound correct, I feel like they refer to the editor UI. Similar to how the terms graphical and visual are used. But a Structure editor could be either visual or textual, so having Structure Editor as the 'base term' would allow being more specific by saying Graphical Structure Editor or Textual Structure Editor. Also, even if technically a structure editor would always use a projection of the structure, I feel like it would be best to reserve the term Projectional Editor to editors that explicitly support multiple projections of the said structure.  However, Projection(al) might be a bit foreign term to people not familiar with the topic, so I would rather just use Structure Editor 99% of the time. I feel like one of the barriers for more widespread usage of structure editors is that you have to explain people what they even are and it would certainly be easier to change this if the developer field could agree on the terminology üôÇ.</p>
<p>Any thoughts?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-12-20T07:45:40.337Z" class="reply"><span class="user">Lu Wilson</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:45:40.337Z" class="date">2022-12-20 07:45:40</a> <div class="message"><p>My vote is for Structure Editor ‚úã</p>
<p>"With a text editor, you edit some text that represents your code. With a structure editor, you edit a structure that represents your code." ?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T07:49:02.584Z" class="reply"><span class="user">Lu Wilson</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:49:02.584Z" class="date">2022-12-20 07:49:02</a> <div class="message"><p>on the other hand, it doesn't roll off the tongue so well, so scrap that</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T07:49:21.744Z" class="reply"><span class="user">Jarno Montonen</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:49:21.744Z" class="date">2022-12-20 07:49:21</a> <div class="message"><p>Good choice! üôÇ Although I don't think the thing 'represented' needs to necessary be code.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T07:49:59.037Z" class="reply"><span class="user">Jarno Montonen</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:49:59.037Z" class="date">2022-12-20 07:49:59</a> <div class="message"><p>roll off as opposed to Structured or Structural?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T07:53:07.099Z" class="reply"><span class="user">Lu Wilson</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:53:07.099Z" class="date">2022-12-20 07:53:07</a> <div class="message"><p>I guess swap out 'code' for 'X' depending on the context. </p>
<p>And yes, but that's possibly just an accent thing. Not sure whether to put a glottal stop in between the two words or not :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T07:56:23.555Z" class="reply"><span class="user">Jarno Montonen</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T07:56:23.555Z" class="date">2022-12-20 07:56:23</a> <div class="message"><p>I feel like for a finn Projectional would be easiest, but out of the other three Structure</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T09:06:22.877Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T09:06:22.877Z" class="date">2022-12-20 09:06:22</a> <div class="message"><p>all variations of structur* occur in the literature, but I also prefer "Structure Editor" üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T09:07:12.517Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T09:07:12.517Z" class="date">2022-12-20 09:07:12</a> <div class="message"><p>("Projectional editor" means an editor that can project the same underlying structure in multiple ways, so it connotes a sort of meta structure editor.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T13:03:03.577Z" class="reply"><span class="user">V√°clav Bla≈æej</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T13:03:03.577Z" class="date">2022-12-20 13:03:03</a> <div class="message"><p>'Structure editor' seems like a good general term, but a software that directly explores and edits AST may be called ... 'AST Editor'?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-20T17:23:12.672Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-17&amp;toDate=2022-12-23&amp;channel=thinking-together&amp;filter=#2022-12-20T17:23:12.672Z" class="date">2022-12-20 17:23:12</a> <div class="message"><p>I would call it ‚ÄúLisp‚Äù or a ‚Äútree editor‚Äù.</p>
<p>Features of the underlying syntax:</p>
<p>very regular syntax, limited choices</p>
<p>recursive definition</p>
<p>machine-readable, machine-writable.</p>
<p>The different views (‚Äúprojections‚Äù) might be called ‚Äúskins‚Äù.  They are micro-syntaxes that make the machine-readable stuff more palatable to humans, i.e. mappings from human-readable -&gt; machine-readable.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-21T16:54:45.971Z" class="reply"><span class="user">Jarno Montonen</span> <a href="./?fromDate=2022-12-18&amp;toDate=2022-12-24&amp;channel=thinking-together&amp;filter=#2022-12-21T16:54:45.971Z" class="date">2022-12-21 16:54:45</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> why "Lisp" ?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-21T19:22:12.079Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-18&amp;toDate=2022-12-24&amp;channel=thinking-together&amp;filter=#2022-12-21T19:22:12.079Z" class="date">2022-12-21 19:22:12</a> <div class="message"><p><strong>@Jarno Montonen</strong> Squinting:</p>
<p>Lisp source code is: hand-written ASTs</p>
<p>e.g. in a ficticious high level language:  <code>a := b + c</code> </p>
<p>In ficticious Lisp:  <code>(assign a (plus b c))</code> </p>
<p>In real Common Lisp:  <code>(setf a (+ b c))</code> </p>
<p>Lisp‚Äôs main operations are tree manipulation operators - CAR, CDR, CONS.  The rest are nice-to-have noise operations that deal with with the contents of tree nodes and/or convenience functions.</p>
<p>Any AST editor boils down to Lisp operations.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-22T09:17:52.656Z" class="reply"><span class="user">Peter Saxton</span> <a href="./?fromDate=2022-12-19&amp;toDate=2022-12-25&amp;channel=thinking-together&amp;filter=#2022-12-22T09:17:52.656Z" class="date">2022-12-22 09:17:52</a> <div class="message"><p>What are the list operations for dealing with tagged structures. i.e records and unions. I see how lisp matches to lambda reductions but I've been adding unions/records/effects all based of row types and am unsure what there native manipulations would be</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-22T12:58:51.376Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-19&amp;toDate=2022-12-25&amp;channel=thinking-together&amp;filter=#2022-12-22T12:58:51.376Z" class="date">2022-12-22 12:58:51</a> <div class="message"><p>short answer: functions</p>
<p>x.y is really y(x) and is written in Lisp as (y x)</p>
<p>method call self.y(z) is really y(self,z) and is written in Lisp as (y self z)</p>
<p>longer answer: all you get is ASTs (things and lists of things)</p>
<p>Yes, that is very low-level.</p>
<p>McCarthy decided to drape meaning over ASTs, i.e the root node of an AST is a always considered to be a function.</p>
<p>In the past, if you wanted to create more syntactic sugar draped over your ASTs, you would lock yourself away in a room for years and invent a ‚Äúnew language‚Äù.</p>
<p>Or, if you were a Lisper, you would create functions called ‚Äúmacros‚Äù, but, the resulting syntax always looked like more ASTs (lists).</p>
<p>Character-based syntax was reserved for compiler gurus who knew how to use parser tools.</p>
<p>Today, though: Ohm-JS provides a way to drape character-based syntax over ASTs in an afternoon (it even comes with a REPL for helping you design/debug a syntax - ‚ÄúOhm-Editor‚Äù).  All you need is a toolbag of functionality plus Ohm-JS. (i.e. Common Lisp + Ohm-JS, or, JavaScript + Ohm-JS, or ‚Ä¶).  PEG-based parsers (like Ohm) can do things that CFG parsers can‚Äôt.  As a result, quickie grammars can be incredibly short (i.e a couple of lines, slightly longer than a REGEX, but way shorter than most YACC-based parsers).</p>
<p>Back to your question: If you want to see other people‚Äôs ideas on how to structure data, or if you don‚Äôt want to roll your own, see ‚ÄúCLOS‚Äù  and ‚ÄúDEFCLASS‚Äù and ‚ÄúDEFSTRUCT‚Äù.  CLOS method dispatch is different and better and more flexible than the usual OO stuff.</p>
<p>[The learning curve is probably steep.  Lispers are usually glad to help.  There are &gt;1 Lispers here].</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-22T13:49:20.985Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-12-19&amp;toDate=2022-12-25&amp;channel=thinking-together&amp;filter=#2022-12-22T13:49:20.985Z" class="date">2022-12-22 13:49:20</a> <div class="message"><p><a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a> Your reference to "Common Lisp + Ohm-JS" suggests that parsers written in Ohm-JS can be used with languages outside of the JS ecosystem. That's not my impression from looking at the Ohm-JS Web site, which only mentions TypeScript as an alternative target to JavaScript. Is there something I overlooked?</p>
<p>Background: Ohm-JS looks very interesting for some ideas I'd like to play with, but I have investment into JS or Web programming in general.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T06:01:44.698Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T06:01:44.698Z" class="date">2022-12-23 06:01:44</a> <div class="message"><p>[hmm long answer, I wish it were shorter...]</p>
<p>Correct, the parser technology is built in JavaScript and runs in a browser and in node.js.</p>
<p>I was getting at something else. It‚Äôs my fault that the idea wasn‚Äôt made clear.  Let‚Äôs try again:</p>
<p>1) I generate compilers using Ohm-JS that transpile from syntax I invent to other languages like Common Lisp, Python and JS (I believe that I could do more languages, but I haven‚Äôt needed to do so (FYI, I have a P.O.C. WASM generator, but more work is needed (this was my first encounter with WASM and more learning curve is needed))).</p>
<p>2) Then, I run those generated compilers to compile code written in the new languages.</p>
<p>3) Then, I run the generated code on the command line, and, sometimes, in the browser.</p>
<p>Ohm-JS, based on PEG, is the game changer in the way I now look at problems.  CFGs (LR(k), YACC, etc.), REGEX, and, hand-written recursive descent parsers are just too cumbersome to use in the same way that I use Ohm-JS.</p>
<p>As an aside, one of the first things I wrote was a compiler that produced code that could be bolted into an Ohm-JS project, with the result that, in many use-cases, I don‚Äôt have to write any JavaScript code at all.  I can write the grammar in Ohm‚Äôs grammar syntax and I can write the transform in my own FABrication syntax, which is more succinct than JS.</p>
<p>Further aside: the first thing I did with Ohm-JS was to write a Scheme-subset-to-JS transpiler and used it to convert Nils Holm‚Äôs PROLOG in Scheme to JavaScript.</p>
<p>Example: I am deeply interested in true concurrency.  My code uses messages that look like:</p>
<p>‚ü®a b c d‚ü©</p>
<p>and I use Ohm-JS to transpile this nano-syntax into something like:</p>
<p>‚ü®Message a b c d‚ü©</p>
<p>using 2 specifications:</p>
<ul><li>‚Äõ‚ü™¬´p¬ª ¬´d¬ª ¬´s¬ª ¬´m¬ª‚ü´‚Äô</li><li>‚Äõ‚ü®Message ¬´p¬ª ¬´d¬ª ¬´s¬ª ¬´m¬ª‚ü©‚Äô</li></ul><p>N.B. the whole spec for the pattern matching is 1 line long, and, the whole spec for transforming is 1 line long.</p>
<p>This specific example could be done with a Python script (or sed with Unicode support), but there are other details that I‚Äôm trying to skip over for this example, e.g. messages might contain other messages recursively, for which it helps to have a parser that can express matching brackets.</p>
<p>The input to Ohm-JS is a JS String.  The output of my FABricator compiler is a JS String.  All of the above steps can be done in one fell-swoop in a JavaScript program that feeds strings to Ohm-JS and calls Ohm-JS twice.  At one point, I need to compile a generated String to executable code.  JavaScript‚Äôs ‚Äúeval()‚Äù does this. (A ‚Äúcompiler‚Äù is ‚Äúeval()‚Äú)</p>
<p>Example: here‚Äôs a contrived example of something that I would never do with YACC, but would do with Ohm-JS:</p>
<p>Contrived Problem: scan this big JavaScript program and list every name of every top-level function.  Using YACC, you need to write a full spec (‚Äúgrammar‚Äù) for JavaScript, with PEG (Ohm-JS), you can say something more obvious and succint: a function is  <code>function id (...) { ... }</code>  where the ‚Äò...‚Äô stuff is anything including recursively bracketed bits.  The point here is not whether I wrote a correct pattern match, but, the difference between ‚Äúomg, I have to write a grammar for every nook and cranny in JavaScript‚Äù vs. writing a grammar with ‚ÄúI don‚Äôt care about this part‚Äù.  This contrived example can probably be done with a REGEX, but if the problem is expanded to be something like ‚Äúlist every function with the name of each parameter‚Äù then REGEX works less-well than a parser.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T08:56:40.274Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T08:56:40.274Z" class="date">2022-12-23 08:56:40</a> <div class="message"><p>Thanks <a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a>, that's a very good answer (better long than cryptic!). I was aware of the advantages of PEG, and of the exceptional tooling support in Ohm-JS for PEG. So my summary of your explanation is "Rather than using a PEG library for language X, use Ohm-JS to generate something that you can process in/with language X." You gain better tooling, at the price of build system complexity if your ecosystem is not already JS.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-25T14:40:33.520Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-22&amp;toDate=2022-12-28&amp;channel=thinking-together&amp;filter=#2022-12-25T14:40:33.520Z" class="date">2022-12-25 14:40:33</a> <div class="message"><p>Addendum: There is ‚Äúlightweight‚Äù pattern matching and ‚Äúheavyweight‚Äù pattern matching.</p>
<p>REGEX falls into the lightweight category, while CFG-based parser generators fall into the heavyweight category.</p>
<p>The terms ‚Äúlightweight‚Äù and ‚Äúheavyweight‚Äù refer to Economy of Expression.</p>
<p>Ohm-JS‚Äôs big win is that it fills the gap between REGEX and CFG technologies, enabling a new niche for thought.</p>
<p>Ohm-JS falls into the lightweight category.  Ohm-JS can do things that REGEX can‚Äôt do, like recursive matching and matching of balanced constructs.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T08:56:40.274Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T08:56:40.274Z" class="date">2022-12-23 08:56:40</a> <div class="message"><p>Thanks <a href="https://guitarvydas.github.io/2021/09/23/Manifesto.html">Paul Tarvydas</a>, that's a very good answer (better long than cryptic!). I was aware of the advantages of PEG, and of the exceptional tooling support in Ohm-JS for PEG. So my summary of your explanation is "Rather than using a PEG library for language X, use Ohm-JS to generate something that you can process in/with language X." You gain better tooling, at the price of build system complexity if your ecosystem is not already JS.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-12-23T12:20:42.383Z" class="post"><span class="user">Alex Bender</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T12:20:42.383Z" class="date">2022-12-23 12:20:42</a> <div class="message"><p>Hello all! Once I saw a great tool in here, to test react components and build a state tree or something like that. Looks like it was here but I can not recall the name so would be really pleased if someone could point me to that tool. Thanks</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-12-23T14:11:33.294Z" class="reply"><span class="user">Tak Tran</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T14:11:33.294Z" class="date">2022-12-23 14:11:33</a> <div class="message"><p><a href="https://xstate.js.org/docs/">xstate.js.org/docs</a> ?</p>
</div> <div class="attachments"><blockquote><p>üìù <a href="https://xstate.js.org/docs/">XState Docs</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-12-23T14:58:57.790Z" class="reply"><span class="user">Alex Bender</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T14:58:57.790Z" class="date">2022-12-23 14:58:57</a> <div class="message"><p>it‚Äôs an interesting one, but not that tool. I‚Äôm looking for one where user can put some component and press button Explore or whatever it reads, whcih will then click all possible controls and collect all possible states of the component</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T20:35:30.398Z" class="reply"><span class="user">Mariano Guerra</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T20:35:30.398Z" class="date">2022-12-23 20:35:30</a> <div class="message"><p>try some terms like react or test here: <a href="http://history.futureofcoding.org/history/links/">history.futureofcoding.org/history/links</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T20:35:40.501Z" class="reply"><span class="user">Mariano Guerra</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T20:35:40.501Z" class="date">2022-12-23 20:35:40</a> <div class="message"><p>(takes a while to load or filter üòÑ)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T21:07:02.285Z" class="reply"><span class="user">Alex Bender</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T21:07:02.285Z" class="date">2022-12-23 21:07:02</a> <div class="message"><p>tried before contacting you in the first place haha. didn‚Äôt work out</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-12-23T14:51:16.914Z" class="post"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T14:51:16.914Z" class="date">2022-12-23 14:51:16</a> <div class="message"><p>Question:</p>
<p>How did REGEX jaibreak from Compiler Technology and become popular with non-compilerists?</p>
<p>First guess: (1) grep, sed, awk, etc. broke the ice, and, (2) perl brought REGEX into the mainstream.</p>
<p>I guess that perl solved a latent problem, which made it very popular.  What was that problem?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-12-23T14:56:03.703Z" class="reply"><span class="user">Orion Reed</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T14:56:03.703Z" class="date">2022-12-23 14:56:03</a> <div class="message"><p>I think part of the answer is that is that it‚Äôs representation as strings meant that it was supported by a near-ubiquitous infrastructure of plaintext which made it much easier to share, store, and use in everyday systems.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T15:01:33.989Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T15:01:33.989Z" class="date">2022-12-23 15:01:33</a> <div class="message"><p>The real question for me is why isn‚Äôt grep/regex search more commonly used by non-programmers? </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T15:05:22.905Z" class="reply"><span class="user">Duncan Cragg</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T15:05:22.905Z" class="date">2022-12-23 15:05:22</a> <div class="message"><p>It's funny how all declarative syntaxes (syntaxii?) acquire a reputation for fiendishness! Take CSS - coulda been a non-programmer language but it's notoriously hard to do simple things like line stuff up; take SQL - a team at my work had the "SQL expert" who everyone went to cos it was so bloody hard, and of course, the most notorious of all: regexes - if only there were a non-brain-twisting way of doing them!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T17:54:04.751Z" class="reply"><span class="user">Jack Rusher</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T17:54:04.751Z" class="date">2022-12-23 17:54:04</a> <div class="message"><p><a href="https://twitter.com/duncancragg">Duncan Cragg</a> There are better ways of writing them that date back to the 1960s. This rant from Sussman captures the problems, and the implementation that follows shows one way of improving matters:</p>
<p><a href="https://github.com/bzinberg/regex-combinator/blob/c49d6aba03d2a42c33b1bdafc7d5e5ded9d60eb8/ps.txt#L33">github.com/bzinberg/regex-combinator/blob/c49d6aba03d2a42c33b1bdafc7d5e5ded9d60eb8/ps.txt#L33</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T18:00:30.929Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T18:00:30.929Z" class="date">2022-12-23 18:00:30</a> <div class="message"><p>One part of that seems a bit off. The nice formalism is for regular expressions, which don‚Äôt support backreferences (one of the ways that modern ‚Äúregexes‚Äù drifted from the original concept‚Äîtowards more power, but more obscurity).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T18:04:46.360Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T18:04:46.360Z" class="date">2022-12-23 18:04:46</a> <div class="message"><p>Combinators are neat, and I wish they were better integrated as an option that plays nicely with existing libraries. The downside is that they give up the very powerful idea of regular expressions as a language, instead of just another API for doing string processing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T18:05:55.247Z" class="reply"><span class="user">Justin Blank</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T18:05:55.247Z" class="date">2022-12-23 18:05:55</a> <div class="message"><p>As a result, they‚Äôre most powerful for programmers who rarely use regular expressions, and programmers who want to do certain more abstract manipulations of regular expressions, but weak for non-programmer end users, and programmers who routinely use regular expressions.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-12-23T23:45:34.709Z" class="reply"><span class="user">Andrew F</span> <a href="./?fromDate=2022-12-20&amp;toDate=2022-12-26&amp;channel=thinking-together&amp;filter=#2022-12-23T23:45:34.709Z" class="date">2022-12-23 23:45:34</a> <div class="message"><p>Parsing is an essential part of any IO more complicated than accepting and echoing byte strings. Regex solves or helps solve parsing across a wide variety of problems.  I think that answers why it "jailbroke" from "compilerists": it was never just a compiler thing, everyone needs parsing. Once someone figured out the math, something like regex was inevitable.</p>
<p>The question of Perl's adoption, and by extension PCRE, is IMO a separate one, more historical than theoretical. I assume it's the usual right-place-right-time/path-dependent/worse-is-better type of story. Certainly Perl is more than PCRE, and was responsive to more problems than just parsing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
