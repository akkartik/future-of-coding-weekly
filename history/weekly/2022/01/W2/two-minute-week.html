
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-01-04T21:06:34.111Z" class="post"><span class="user">Matthew Linkous</span> <a href="#2022-01-04T21:06:34.111Z" class="date">2022-01-04 21:06:34</a> <div class="message"><p>Hey everyone! Here is a very brief overview of what we’ve been building to enable us developers to create and share full-stack web apps without storing each other’s data. We’ll be providing more details each week! Don’t hesitate to drop any questions below  <a href="https://share.descript.com/view/LW69H0AkbuM?transcript=false"></a><a href="https://share.descript.com/view/LW69H0AkbuM?transcript=false">https://share.descript.com/view/LW69H0AkbuM?transcript=false</a></p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://share.descript.com/view/LW69H0AkbuM?transcript=false">Screen Recording</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2022-01-05T07:26:17.111Z" class="reply"><span class="user">Andy Jakubowski</span> <a href="#2022-01-05T07:26:17.111Z" class="date">2022-01-05 07:26:17</a> <div class="message"><p>Cool! Do you have some kind of protocol to ensure the web apps can access and use the personal cloud data in a reliable way?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-05T09:46:03.111Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2022-01-05T09:46:03.111Z" class="date">2022-01-05 09:46:03</a> <div class="message"><p>Do you have a longer writeup somewhere?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-05T14:48:51.112Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-05T14:48:51.112Z" class="date">2022-01-05 14:48:51</a> <div class="message"><p><strong>@Andy Jakubowski</strong> yep! Currently it’s pretty simple but each web app is served on its own subdomain with strict <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">CSP rules</a> to prevent sending data to external servers. To actually persist data an app can connect to any number of “agents” (which are hosted isolated backends) but it must declare which ones it connects to in its manifest so the user can see. Each agent will have access to a separate, isolated part of the users database and are decoupled from the frontend app. So, for example, that means the “calendar agent” can be used by multiple apps so that you can have a canonical place for all your events. And in your frontend app, you don’t have to do any authentication, authorization, or API-key management. You just declare in your config/manifest which agents your app interacts with and then you can use those API’s directly. Does that makes sense?</p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy (CSP) - HTTP | MDN</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-01-05T14:52:41.112Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-05T14:52:41.112Z" class="date">2022-01-05 14:52:41</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> ^ my response above might shed some light but we are working on a written overview as well as some preliminary documentation. We’ve also begun pulling out and open-sourcing our Agent runtime (effectively serverless, isolated JS functions) if you’re interested in following that: <a href="https://github.com/aspen-cloud/runtime"></a><a href="https://github.com/aspen-cloud/runtime">https://github.com/aspen-cloud/runtime</a></p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://github.com/aspen-cloud/runtime">GitHub - aspen-cloud/runtime</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-01-05T16:03:54.112Z" class="reply"><span class="user">Andy Jakubowski</span> <a href="#2022-01-05T16:03:54.112Z" class="date">2022-01-05 16:03:54</a> <div class="message"><p><a href="https://twitter.com/aspen_cloud">Matthew Linkous</a> It does make sense—thanks! I like the idea of owning my data and letting third parties access it in a controllable way.</p>
<p>Two thoughts come to mind.</p>
<p>One, it seems similar to how Apple and Google let apps access location, photos, health etc. data. Would you want people to clone this data somehow, or start from scratch?</p>
<p>Two, why don’t we have something like that already? The idea seems good for the user in principle, so I wonder what may be the reasons it hasn’t really materialized in the past, and what may be different now.</p>
<p>I think what you’re working on could be really awesome!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-05T17:38:34.112Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-05T17:38:34.112Z" class="date">2022-01-05 17:38:34</a> <div class="message"><p><strong>@Andy Jakubowski</strong> Great observation! We model a lot of ideas around permissions on the patterns used in mobile app ecosystems, and even take it step further by limiting networking.</p>
<ul><li>Re: cloning existing data vs starting anew, we decided to build from scratch so a user will have a clean, single source of truth while still having the ability to write some code (and potentially publish it for others to install with a click!) that can import data from other sources with an API.  We would happily assist someone in making an agent that pulled, for example, Google calendar data into your Aspen calendar.</li><li>It’s a great question. I think previous attempts at creating personal servers with one-click installable apps have started with existing open-source projects and used ordinary linux VM’s; this however, is fairly costly to the user (paying when not using), still fairly technical to manage, and the existing apps tend to be either low quality or aimed towards developers. Our platform is effectively “serverless” so it is much less expensive to run, has a uniform application model so you can much more easily work with the underlying data and API’s, and should be much easier for non-technical users to use.</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-05T17:40:40.113Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-05T17:40:40.113Z" class="date">2022-01-05 17:40:40</a> <div class="message"><p>The other problem is existing apps tend to roll their own authentication and data storage so making them work with an existing platform is very difficult. What ends up happening is, you log into the “platform” and then have to again log into each app which likely has it’s own Postgres process running, etc. Overall, the existing solutions are very clunky and inefficient.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T07:26:45.000Z" class="reply"><span class="user">Andy Jakubowski</span> <a href="#2022-01-06T07:26:45.000Z" class="date">2022-01-06 07:26:45</a> <div class="message"><p>Great follow-up, thanks <a href="https://twitter.com/aspen_cloud">Matthew Linkous</a>.</p>
<p>This makes sense to me. It may be indeed the case that nobody’s come up with a working, easy to use solution to this.</p>
<p>Your mention of your platform being serverless stood out to me, because I assume data can be both written and read in my personal cloud. I saw your GitHub repo mentioned an append-only log, I wonder if that has something to do with it? You write by appending, and reading is a matter of reading a “static file”?</p>
<p>I’m interested in your approach because I was thinking of making a similar thing for UI on the web. Many UI elements reuse the same logic, and only differ in styling. So you could define the logic once with statecharts, for example, and then let people style those elements with styles from their “personal style cloud”.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T09:06:23.000Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2022-01-06T09:06:23.000Z" class="date">2022-01-06 09:06:23</a> <div class="message"><p>I built a prototype of a thing like this in 2010. The main problems with adoption were: app devs aren't interested in building for a platform without users, and users aren't interested in signing up for a service unless it has a killer app. Do you have any plans to overcome this trap?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T14:20:03.000Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-06T14:20:03.000Z" class="date">2022-01-06 14:20:03</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> yeah that’s exactly right and easily the biggest risk in building something like this. I think it’s going to be very difficult to overcome no matter what. But we’re trying a couple things:</p>
<p>First, we’re prioritizing getting Aspen in to the hands of people that are both devs and users (like the lovely folks in this community!) so we can all build apps for ourselves and each other.</p>
<p>Second, while we probably won’t directly come up with the killer app on our own, we’re working really hard to provide the right tools and complementary API’s for the developer or designer who does have the brilliant idea. For example, we’ve noticed a lot of really cool productivity apps like Superhuman or Cron, are primarily innovating on the frontend. So we’re trying to provide robust, canonical agent (i.e. backend) implementations of common API’s like calendar, messaging, documents, etc. This way if someone has a great idea for an app, they can skip all the of the tedious authentication, authorization, db management, token management, etc and just build the frontend of their dreams. Same goes for backend devs who don’t want to bother with a frontend: they can just build and upload an agent for others to use from the terminal or connect to their own frontend.</p>
<p>It’s going to be a challenge but we’re very committed to our mission and will spend whatever time and effort it takes to polish the UI, refine the API,  and support the developers.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T14:31:26.001Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-06T14:31:26.001Z" class="date">2022-01-06 14:31:26</a> <div class="message"><p><strong>@Andy Jakubowski</strong> yeah that’s pretty much it. We’re working on a more detailed overview with explainer graphics to fully illustrate how persistence works. But the main way to persist data is to store events on an append-only log. It’s not a static file but we inject a runtime object into the agents code so they can call methods like <code>pushEvent</code> and create projections of the data through aggregations. If you’ve used Redux, it’s a very similar pattern except in Aspen it runs on the server and is automatically persisted.</p>
<p>Here is an example of a task manager agent I made: <a href="https://github.com/matlin/todos-backend/blob/main/src/index.ts"></a><a href="https://github.com/matlin/todos-backend/blob/main/src/index.ts">https://github.com/matlin/todos-backend/blob/main/src/index.ts</a></p>
<p>Disclaimer: some of these API’s will very likely change</p>
</div> <div class="attachments"><blockquote><p>🔗 <a href="https://github.com/matlin/todos-backend/blob/main/src/index.ts">todos-backend/index.ts at main · matlin/todos-backend</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-01-06T14:33:24.001Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-06T14:33:24.001Z" class="date">2022-01-06 14:33:24</a> <div class="message"><p>The main thing to note with that example agent is that it’s a complete backend for multi-tenant, multi-list task manager all in ~100 lines of Typescript</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T15:57:45.001Z" class="reply"><span class="user">Andy Jakubowski</span> <a href="#2022-01-06T15:57:45.001Z" class="date">2022-01-06 15:57:45</a> <div class="message"><p>Nice! I haven’t worked with Redux, but I have worked with XState, which also combines all logic in one massive object.</p>
<p>Will be interested to read that overview of your persistence implementation details. In particular, timing and syncing events. Martin Kleppmann’s Designing Data-Intensive Applications had some interesting discussion of this, but I’m sure you know that one already!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-06T22:31:57.001Z" class="reply"><span class="user">Matthew Linkous</span> <a href="#2022-01-06T22:31:57.001Z" class="date">2022-01-06 22:31:57</a> <div class="message"><p>Martin’s work is definitely a big influence. Currently everything is serialized on the server but this obviously doesn’t scale in terms of latency from the client so we have an implementation that acts mostly like a CRDT that we’ll share more details on in the future!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-07T12:30:49.002Z" class="reply"><span class="user">Andy Jakubowski</span> <a href="#2022-01-07T12:30:49.002Z" class="date">2022-01-07 12:30:49</a> <div class="message"><p>Good luck and keep us posted 🙂</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-01-05T22:45:54.115Z" class="post"><span class="user">Tom Larkworthy</span> <a href="#2022-01-05T22:45:54.115Z" class="date">2022-01-05 22:45:54</a> <div class="message"><p>I wrote a generative listicle using a browser based programmable notebook which went a little viral. I thought it be good to see what's coming out of that FoC environment. <a href="https://observablehq.com/@tomlarkworthy/notebooks2021"></a><a href="https://observablehq.com/@tomlarkworthy/notebooks2021">https://observablehq.com/@tomlarkworthy/notebooks2021</a></p>
<p>edit: the code to scrape Observable's own internal API to get the content is right at the bottom of that very long notebook! I use an inline CORS proxy and cache the scraping results in FileAttachments. So it's both a piece of content, and a program to self construct itself. The CORS proxy is implemented using (my) webcode.run</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2022-01-07T17:39:52.003Z" class="post"><span class="user">Pawel Ceranka</span> <a href="#2022-01-07T17:39:52.003Z" class="date">2022-01-07 17:39:52</a> <div class="message"><p><a href="https://www.nette.io/">Nette: A Research OS for the Web</a>, feature spotlight 🔦</p>
<p>De-construct&nbsp;| “semantic” drag and drop |&nbsp;<a href="https://nette.io/"></a><a href="https://nette.io/">https://nette.io/</a></p>
<p>===========================================</p>
<p>Goal:&nbsp;Whenever I see anything that carries meaning I can take it out of the original context and drop it on canvas.</p>
<p>Outcome:&nbsp;It becomes a block (like an “object”)</p>
<p>Constraints:</p>
<ul><li>a universal gesture in the system</li><li>grows the system—indexing and keeping back references (blocks know their sources)</li><li>intuitive—aligns with what we consider meaningful</li><li>idea of being first class—wide class of media have a first class representation—can be acted upon and re-combined in a consistent way</li></ul><p> Have a wonderful weekend! 😎</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>📷 <a href="http://history.futureofcoding.org/history/msg_files/F02/F02THMLSRRP.gif">deconstruct.gif</a></p>
</blockquote>
</div> <div class="replies"><div id="2022-01-07T23:03:29.003Z" class="reply"><span class="user">yeT</span> <a href="#2022-01-07T23:03:29.003Z" class="date">2022-01-07 23:03:29</a> <div class="message"><p>what a brilliant concept! the idea of dragging information out of a specific context, and allowing for it to then build new context is something that I feel like if much more intuitive than creating multiple tabs/stack in a modern research architecture, it makes sense mentally and visually. Kind of reminds me of the system in intellij that lets you jump from a function call to the function def, something I don’t think I could live without. Have a wonderful weekend as well and good luck with the feature.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-01-09T12:32:45.004Z" class="reply"><span class="user">Pawel Ceranka</span> <a href="#2022-01-09T12:32:45.004Z" class="date">2022-01-09 12:32:45</a> <div class="message"><p>Thank you <strong>@yeT</strong>!</p>
<blockquote><p>makes sense mentally and visually</p>
</blockquote>
<p>And also manually 😄</p>
<p>It’s a gesture, it’s an expression of agency—thinking with hands kind of thing—I want to take it apart and put it back together to understand—kind of mentality.</p>
<p>For that you need well (-ish) defined domain and affordances—something more granular, not a rendered document as a unit of meaning.</p>
<p>Here is an example in the context of a “readable” version of a webpage—pulling out links and images etc.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>📷 <a href="http://history.futureofcoding.org/history/msg_files/F02/F02T5L5U9BP.gif">radableDragLinksImagesHeadlines.gif</a></p>
</blockquote>
</div></div></div></div>
    </div>
  </body>
</html>
