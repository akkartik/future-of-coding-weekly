
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2022-08-29T04:40:33.254Z" class="post"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T04:40:33.254Z" class="date">2022-08-29 04:40:33</a> <div class="message"><p>üßµ on the first 25 minutes of <a href="https://futureofcoding.org/episodes/057">futureofcoding.org/episodes/057</a></p>
<p>Summary:</p>
<ul><li>It would be cool to create a visualizer for low level software. Assembly language in particular would benefit from visualization to catch errors in register allocation, manual memory management.</li><li>A retro game console may be a simple test bed for trying out various FoC ideas. You could literally save snapshots of all 64KB of RAM for some machines every single frame, and then perform further analysis on them, diffs and so on.</li><li>A similar idea: GPU Maker 2000 like <a href="https://en.wikipedia.org/wiki/RPG_Maker">RPG Maker 2000</a> but for GPU programming.</li><li>The Gameboy has a particularly ideal form factor for a convivial tool for thought. In particular, it has a camera, something I wasn't aware of.</li></ul><p>Does anyone have a good sense of the space of Assemblers out there? Surely there exist debuggers for Assembly? Maybe reverse engineering is a space to look at? Are there any debuggers or reverse-engineering tools with command languages? Ghidra does seem to have something: <a href="https://resolute-tech.com/an-introduction-to-ghidra-scripting">resolute-tech.com/an-introduction-to-ghidra-scripting</a>. Does anyone here have experience with it?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-08-29T04:42:27.872Z" class="reply"><span class="user">Kartik Agaram</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T04:42:27.872Z" class="date">2022-08-29 04:42:27</a> <div class="message"><p>One reaction I had listening to the podcast: do we  <em>really</em>  need a visualizer? Mu would check register allocations and raise errors when you got them wrong. Ditto memory allocation errors. A visualizer would add a lot of complexity to it. Is it really worthwhile?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-29T06:45:58.793Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T06:45:58.793Z" class="date">2022-08-29 06:45:58</a> <div class="message"><p>I am converging on the idea that the FoC is not replacement of text with no-code, but augmentation of text with dataviz, i.e. dataviz assisted development. This seems to be what you want here (I can't help with the specifics of assembly). Yo do not need the same set of dataviz for all problems, so I think complexity is not an issue, as you only pick the tools that make sense.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-29T11:09:15.018Z" class="reply"><span class="user">Jan Ruzicka</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T11:09:15.018Z" class="date">2022-08-29 11:09:15</a> <div class="message"><p>Re the idea that retro consoles might be a good testbed, since we can handle the whole systems with our current tools: Alan Kay would argue that we ought to do this with our current platforms, with the aid of supercomputers, and that we're limiting the scope of our ideas by not doing it. I agree with him, since on a retro console you won't typically need to deal with concurrency, and certainly not with parallelism.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-29T15:32:44.655Z" class="reply"><span class="user">Andreas S.</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T15:32:44.655Z" class="date">2022-08-29 15:32:44</a> <div class="message"><p>I actually remember RPG Maker 2000 there was a forum around the 2000‚Äôs where I spend a lot of time back then where it had a sub forum.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-29T16:20:59.113Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-26&amp;toDate=2022-09-01&amp;channel=thinking-together&amp;filter=#2022-08-29T16:20:59.113Z" class="date">2022-08-29 16:20:59</a> <div class="message"><p>Re: retro consoles. Yes, I would love to make a Gameboy emulator that included all the visualisations from this talk <a href="https://youtu.be/HyzD8pNlpwI">youtu.be/HyzD8pNlpwI</a> (particularly the pixel data related ones from ~29mins on)</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://youtu.be/HyzD8pNlpwI">The Ultimate Game Boy Talk (33c3)</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-08-30T05:36:04.866Z" class="reply"><span class="user">William Taysom</span> <a href="./?fromDate=2022-08-27&amp;toDate=2022-09-02&amp;channel=thinking-together&amp;filter=#2022-08-30T05:36:04.866Z" class="date">2022-08-30 05:36:04</a> <div class="message"><p>For many years now, I've wanted to make an easy to use card game builder.  Would be less time sensitive than a console.  Complexity comes in managing state well: phases of a turn, turns combining into rounds, phases, matches.  Some combinatorial trickiness: sets and runs.  And I'd feel good about the result if the system can automatically generate AI players of different skill level and disposition based off the rules.  I mean given this set of rules, you could have an "aggressive" player who tries to do this and this.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-30T09:05:13.524Z" class="reply"><span class="user">Paul Tarvydas</span> <a href="./?fromDate=2022-08-27&amp;toDate=2022-09-02&amp;channel=thinking-together&amp;filter=#2022-08-30T09:05:13.524Z" class="date">2022-08-30 09:05:13</a> <div class="message">
<blockquote><p>do we  <em>really</em>  need a visualizer?</p>
</blockquote>
<p>IMO, the question about ‚Äúvisualization‚Äù might be rhetorical - visualization of  <em>what</em> ?</p>
<p>Debugging belongs to the realm of creativity, not of clockwork engineering.</p>
<p>Debugging is iteration.  Debugging is notation-specific.  Debugging is paradigm-specific.  For example, if you Design a system using, say, the OO paradigm, you want a debugger that shows you the OO-iness of your code, not, say, machine-level single-stepping from a completely different paradigm.</p>
<p><a href="https://github.com/akkartik/mu">Kartik Agaram</a>‚Äôs Handmade-network video reminds me of a long-standing  <em>je ne sais quoi</em>  I‚Äôve had about <a href="https://equis.cs.queensu.ca/~equis/pubs/1992/cordy-jvlc-92.pdf">GVL</a> . Kind of a projectional editing REPL (based on simplistic-SVG?).</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-08-31T16:11:40.475Z" class="post"><span class="user">Mariano Guerra</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T16:11:40.475Z" class="date">2022-08-31 16:11:40</a> <div class="message"><p>What are alternative solutions to variables and scopes? Is there a proven abstraction that end users easily understand?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-08-31T16:36:55.079Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T16:36:55.079Z" class="date">2022-08-31 16:36:55</a> <div class="message"><p>Brian Harvey used to say that dynamic scope is what you get if you don't think about scope, so that's why it is easier for beginners to understand. But it still involves variables and a type of scoping.</p>
<p>Maybe I'm suffering from a lack of imagination here, but I'm not sure how to easily perform abstraction without giving things names. Names are what help us humans remember the meaning and usage of a thing or a behavior. If one tried to create some form of graphical language where things were displayed but could not be named, I feel like the first thing people would ask for is the ability to use names so they're not stuck thinking about this thing and that thing and the other thing.</p>
<p>It did not take long for early programmers to invent so-called floating labels, allowing them to name pieces of code and data in memory. Even in spreadsheets, the ability to name cells and ranges makes formulas substantially easier to read.</p>
<p><a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED">cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED</a></p>
<p>Outside of computers, imagine trying to tell someone how to make a sandwich without using any names.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/the-use-of-a-floating-address-system-for-orders-in-an-automatic-digital-computer/66DB2A4ACA578BB871B1B4A75352A6ED">The use of a ‚Äòfloating address‚Äô system for orders in an automatic digital computer | Mathematical Proceedings of the Cambridge Philosophical Society | Cambridge Core</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-08-31T16:45:48.255Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T16:45:48.255Z" class="date">2022-08-31 16:45:48</a> <div class="message"><p>I think we're bounded by human biology in what kind of scopes we can reason about. We're spatial creatures (2D/3D plus time).</p>
<p>I'm not aware of alternative solutions, but there are variations with important differences in their relationship to end users.</p>
<p>All scopes are essentially a set of nested spatial containers, but the spatial borders in traditional programming are functions and classes which is where the problems start for non-coders.</p>
<p>The best example of spatial scopes that make sense for end users are spreadsheet rows and columns, which are much more natural. The variables "need a place to hang on the wall" in the end user's mind, and a function doesn't tick that box (it's a position in a text file, but essentially non-spatial).</p>
<p>From here I guess the remaining directions are 3D scopes or Graph scopes which is essentially the input/output model seen with node/flow-based programming.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-31T16:59:28.600Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T16:59:28.600Z" class="date">2022-08-31 16:59:28</a> <div class="message"><p>The alternative I am trying out myself in my Leibniz project (<a href="https://github.com/khinsen/leibniz-pharo">github.com/khinsen/leibniz-pharo</a>) is no scopes, or if you prefer a single scope. To make this practical, code units must be kept very small, which actually helps to keep them understandable. That means: no "standard libraries" with tons of definitions that might one day be useful. Small bits of functionality must be explicitly included.</p>
<p>The inspiration for this is mathematical notation in textbooks and research articles. They don't have scopes. Every bit of notation, once introduced, is valid for the whole text.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-31T17:31:34.055Z" class="reply"><span class="user">Jonathan Arnett</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T17:31:34.055Z" class="date">2022-08-31 17:31:34</a> <div class="message"><p>I've thought about creating a single-scope logic/"relational" language where "functions" are sets of rules about how the variables relate to one another. I guess it's not too terribly different from a database, per se, where variables are rows and rules are constraints.  Moreso inspired by Prolog, only Prolog rules take explicit arguments.</p>
<p>I honestly have no idea if this is a  <em>good</em>  idea, and in all probability it's probably a bad one.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-08-31T19:10:16.755Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-28&amp;toDate=2022-09-03&amp;channel=thinking-together&amp;filter=#2022-08-31T19:10:16.755Z" class="date">2022-08-31 19:10:16</a> <div class="message"><p>Wikipedia titles are globally unique, they just put the scope in brackets afterwards e.g. "Franz Ferdinand (band)".</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T02:58:31.432Z" class="reply"><span class="user">Nick Smith</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T02:58:31.432Z" class="date">2022-09-01 02:58:31</a> <div class="message"><p>The PL I‚Äôm designing doesn‚Äôt have nested scopes. It‚Äôs a relational programming language (Datalog-inspired) ‚Äî it‚Äôs the only paradigm I know of where such a thing is possible (with some hard work!).</p>
<p>As a program gets large, the absence of a syntactic boundary (e.g. a file, or a code block) for limiting the places a definition can be accessed from becomes a problem. But I think it‚Äôs an easily solvable one.</p>
<p>Variables, on the other hand, will remain essential for as long as humans use natural language.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T06:40:46.658Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T06:40:46.658Z" class="date">2022-09-01 06:40:46</a> <div class="message"><p><a href="https://github.com/ChrisKnott">Chris Knott</a> That looks more like an ad-hoc namespace than a scope to me.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T07:27:42.141Z" class="reply"><span class="user">Tom Larkworthy</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T07:27:42.141Z" class="date">2022-09-01 07:27:42</a> <div class="message"><p>the old programs were declare all your variable in advance and/or only have a single global scope which is extremely easy to understand with the negative drawback of not scaling to large programs or not handling temporary internal control flow variables very well (internal loop variables have to go to the top). Still, pretty good IMHO if you want fast understanding of a snippet of code.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T08:10:42.339Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T08:10:42.339Z" class="date">2022-09-01 08:10:42</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> yeah you are right.</p>
<p>I think scope in the sense of actively restricting the ability to talk about something from another context is not user friendly. Chris Granger talks about this in one of his talks where he demoed Eve at a local event (at Dynamicland I think). There were lots of non-programmers there. They couldn't understand why you could point to a deeply nested variable on the screen, but not just pull that value out and use it where you want.</p>
<p>I think the lack of scope in Excel (and autonaming of variables) is one of the reasons it is user friendly. It still has namespaces but you can refer to anything you can see (even across different files if you use a fully qualified path reference).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T10:27:41.125Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T10:27:41.125Z" class="date">2022-09-01 10:27:41</a> <div class="message"><p>Smalltalk doesn't have scopes either. Namespaces, yes: a global one (class names etc.), one per class for instance variables, and one per method for local variables, which are not allowed to shadow instance variables. I can't remember anyone complaining about the lack of scopes in Smalltalk.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-01T16:38:00.817Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-29&amp;toDate=2022-09-04&amp;channel=thinking-together&amp;filter=#2022-09-01T16:38:00.817Z" class="date">2022-09-01 16:38:00</a> <div class="message"><p>I find scopes to be a useful abstraction. Not necessarily for the initial creation of a program. I believe they resolve two issues:</p>
<ul><li>Single-user error on text entry: You may not intend to use a particular variable in certain contexts. Scopes are a useful way to make sure that a typo doesn't result in unintentional usage.</li><li>Multi-user idea communication: When designing large systems it is useful to hide certain details of the system, especially if a particular use would largely result in errors. For example, if the use of a variable  <code>i</code>  is used multiple times in a single method to iterate through multiple lists it is useful that different  <code>i</code> s in different scopes are associated with different lists. It communicates an idea to other developers that the "mental load" introduced by the variable need only relate to the matter at hand and can be ignored outside of that context.</li></ul><p>In a similar way to dynamic vs typed languages you can get away  <em>without</em>  scopes with a little bit of discipline. Encoding the restrictions seems a useful way to communicate intentions of the code though. In traditional implementations it really doesn't put much burden on the author as types can in some cases.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T16:10:11.308Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T16:10:11.308Z" class="date">2022-09-02 16:10:11</a> <div class="message"><p>By default, definitions are unbounded, or bounded only by document. Redefinitions are bounded, and only explicitly. Redefinitions can be referred to outside the boundary of the definition but only explicitly. "1. Minister means the Minister of Health." "2. In this section, Minister means the Minister of Revenue." "3. The Minister, as that term is defined in section 2." Is that "scope" or "namespace"? I'm thinking namespace?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T16:13:12.427Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T16:13:12.427Z" class="date">2022-09-02 16:13:12</a> <div class="message"><p>I would say that approach is proven.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T16:13:40.188Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T16:13:40.188Z" class="date">2022-09-02 16:13:40</a> <div class="message"><p>The distinction to me is that something  <em>does not exist at all</em>  outside of its scope, whereas outside of its namespace it just goes by a different name.</p>
<p>Scope is inherently confusing from an author who has an omniscient view of the program.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T16:16:56.798Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T16:16:56.798Z" class="date">2022-09-02 16:16:56</a> <div class="message"><p>It can be useful when you are debugging in your head ("playing computer") because it reduces the amount of possible factors affecting the program, but this is fool's gold, the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T16:32:06.448Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T16:32:06.448Z" class="date">2022-09-02 16:32:06</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> local variables and arguments in Smalltalk blocks are lexically scooped. That's what makes it possible to implement conditionals and iteration by passing a block to a method.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T17:48:44.539Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T17:48:44.539Z" class="date">2022-09-02 17:48:44</a> <div class="message">
<blockquote><p>It can be useful when you are debugging in your head ("playing computer") because it reduces the amount of possible factors affecting the program,  <em>but this is fool's gold</em> , the actual solution is to make the computer help with debugging, so people don't have to play computer in their head at all</p>
</blockquote>
<p>I disagree with this, specifically the bold part. In almost every scenario the goal should be to get feedback as early as possible. Ideally you can look at a program and know what it does just like you can look at text in a book and know what it says. In many large programs it is difficult to run all of the code through a debugger, sometimes taking double digit numbers of minutes. For example, major games take minutes to compile, run, and load into maps.</p>
<p>There are certainly use cases where you can lean more on a debugger, like scripting. Even in these scenarios most developers prefer to be able to look at code and know what it does rather than have to run it through a debugger.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T18:16:21.221Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T18:16:21.221Z" class="date">2022-09-02 18:16:21</a> <div class="message"><p>I think your concerns are about the current-of-programming, aren't they?</p>
<p>Yeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done  <em>overnight</em> . This is bad. I would be wary of basing philosophical positions on that though.</p>
<p>"If we adopt this language feature, compile times will be faster" is exactly the sort of tradeoff I'd classify as fool's gold.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T18:56:09.810Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T18:56:09.810Z" class="date">2022-09-02 18:56:09</a> <div class="message"><p><strong>@Personal Dynamic Media</strong> In Pharo (the only Smalltalk I have experience with), there are no lexical scopes. Re-declaring an argument or a local variable in a nested block is forbidden (see screenshots).</p>
<p>Blocks passed into a method are a different story. Their local variables are invisible from the method that uses them, so I wouldn't call that lexical scopes either, but that's certainly debatable.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>üì∑ <a href="http://history.futureofcoding.org/history/msg_files/F04/F0419FZQAF3.png">Screenshot 2022-09-02 at 20.49.43.png</a></p>
<p>üì∑ <a href="http://history.futureofcoding.org/history/msg_files/F04/F040WT4K7T4.png">Screenshot 2022-09-02 at 20.51.34.png</a></p>
<p>üì∑ <a href="http://history.futureofcoding.org/history/msg_files/F04/F0419G0LYG1.png">Screenshot 2022-09-02 at 20.52.44.png</a></p>
</blockquote>
</div></div><div id="2022-09-02T19:01:22.127Z" class="reply"><span class="user">Personal Dynamic Media</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T19:01:22.127Z" class="date">2022-09-02 19:01:22</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> thank you, I was unaware of that limitation/feature. I think I see your point now about how if you just forbid variables from ever being shadowed, programmers don't need to think about scope.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T20:16:04.267Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:16:04.267Z" class="date">2022-09-02 20:16:04</a> <div class="message">
<blockquote><p>I think your concerns are about the current-of-programming, aren't they?</p>
</blockquote>
<p>Yeah, I mean forget minutes - when I last worked in the games industry a full compile had to be done  <em>overnight</em> . This is bad. I would be wary of basing philosophical positions on that though.</p>
<p>"If we adopt this language feature, compile times will be faster" is exactly the sort of tradeoff I'd classify as fool's gold.</p>
<p>I feel like this is putting words in my mouth. I'm making this argument for past, present and future: it was true, it is true, and it will continue to be true.  <em>Looking at something and knowing it works is better than having to take extra steps to find out if it works</em> .</p>
<p>Games are only used as an example. I've also done OS development where the same is true. I provided scripting as a counter example where maybe your argument is stronger: it's easier to run and debug scripts. I'd be curious if you have any realistic examples where people would prefer "[making] the computer help with debugging" over being able to "[debug] in your head" (I changed the gerunds in your quotes). I can't think of any. Seems like you always want to look at a program and know it works where possible and debugging only needs to come into the picture when that fails.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T20:24:59.117Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:24:59.117Z" class="date">2022-09-02 20:24:59</a> <div class="message"><p>Its interesting if you take each argument to its extreme. I don't claim you are making one of these arguments but they are interesting to think about:</p>
<ul><li>A language which is easy to "run in your head" but has no debugger.</li><li>A language which is hard to "run in your head" but has a great debugger.</li></ul><p>I think its clear people would prefer the first bullet in most contexts. Though obviously a powerful debugger is an incredible tool for building better programs. I don't mean to degrade debuggers or claim they aren't useful. Rather, I think its worth aspiring to improving what can be done in the compiler/interpreter input before considering improvements provided by a debugger. Truthfully many of the tradeoffs may simply come out in difficulty of implementation. If it takes weeks to implement a complier feature vs days to implement a debugger feature that prevents a similar error, its probably better to focus on the debugger.</p>
<p>All else being equal though, I believe it is better to "verify things by looking at them" as I put it, even if human brains are lossy. The debugger comes in when the human brain fails... that doesn't mean the human brain should be replaced by it entirely though. The brain is what you are thinking with. Anything else, like a debugger, requires us using our much slower physical appendages to interact with.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T20:42:19.470Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:42:19.470Z" class="date">2022-09-02 20:42:19</a> <div class="message"><p>Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T20:45:37.574Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:45:37.574Z" class="date">2022-09-02 20:45:37</a> <div class="message"><p>I agree that it would be better to be able to do it in your head but I think it's impossible. Even the simplest things are already way beyond un-aided human brain processing power.</p>
<p>Consider the Mario example from Inventing on Principle <a href="https://youtu.be/PUv66718DII">youtu.be/PUv66718DII</a> (from ~13 min, specifically the feature demoed from 13:55). It's basically just solving a quadratic equation but pretty much impossible (for me at least!) to do in your head.</p>
<p><a href="https://twitter.com/RoundTableLaw">Jason Morris</a>'s project is a "debugger" of sorts for Laws, something which are generally less complicated than computer programs.</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://youtu.be/PUv66718DII">Bret Victor - Inventing on Principle</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-09-02T20:55:26.166Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:55:26.166Z" class="date">2022-09-02 20:55:26</a> <div class="message">
<blockquote><p>Hard disagree. Programs are complicated. Even if you can understand small parts well by looking at them, you have no possibility of seeing the implications of how they interact once they are beyond toy size. I'll take your second option hands down.</p>
</blockquote>
<p>How would even know how to write the program in the second bullet? A language could be so hard to use that its infeasible to get a program which is even debuggable. At least in the extreme case.</p>
<blockquote><p>I agree that it would be better to be able to do it in your head but I think it's impossible.</p>
</blockquote>
<p>I agree that its impossible in many situations. I even agree that small programs can be difficult to get right. You can't know its right until you run. But ideally you can get it as close to right as possible before running it so that debugging time is minimized.</p>
<p>Again, I'm not against debuggers and all code written should be run and tested so you can verify it is correct. Its just that the previous claim is too extreme for me to agree with. It certainly isn't "fool's gold" to construct better models that people can "debug in [their] head":</p>
<blockquote><p>It can be useful when you are debugging in your head ("playing computer") because it reduces the amount of possible factors affecting the program, but this is fool's gold.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T20:59:53.448Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T20:59:53.448Z" class="date">2022-09-02 20:59:53</a> <div class="message"><p>There is no extreme case. People create languages that are harder to use, on purpose, for fun. Humans are weird like that.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:03:06.890Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:03:06.890Z" class="date">2022-09-02 21:03:06</a> <div class="message"><p>There is for sake of argument üòõ but I agree its a weak argument. The reason its interesting to think about though is because it becomes clear that there  <em>is</em>  some limit on program understandability that is important. It is impossible to ignore the brain. There is  <em>not</em>  a limit on debuggers though. You don't need one. You could get by with printf and just running the whole program even if you don't want to.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:11:57.224Z" class="reply"><span class="user">Chris Knott</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:11:57.224Z" class="date">2022-09-02 21:11:57</a> <div class="message"><p>To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc.</p>
<p>Perhaps there is a theoretical programming language possible that brings the power of the computer to 99% of people but I can't even conceive of what that would be like, whereas I can conceive of theoretical (but impossible-at-the-moment) tools which make programming more like building with your hands. Bret Victor's work has (faked) examples of these sort of tools</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:12:28.045Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:12:28.045Z" class="date">2022-09-02 21:12:28</a> <div class="message"><p>I think we disagree about which of these two options is "ignoring the brain". Brains are very good at using language, and very bad at internally modelling the behaviour of complex systems they can't observe.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:14:28.628Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:14:28.628Z" class="date">2022-09-02 21:14:28</a> <div class="message">
<blockquote><p>To restate my point; people have been trying to create languages that are easier to write correctly for a long time, with comparatively little success, whereas less effort has been put into omniscient/time travel debugging/program visualisations etc.</p>
</blockquote>
<p>I agree much more with this framing of the point. I really take issue with calling the effort "fools gold" though.</p>
<p>Separately, I'm not so sure folks have had "little success". In the context of "a long time". I think folks have had a lot of success at first, but it slowed down considerably over time. I made a previous point about a tradeoff between verifying with "looking at a program" vs verifying with "debugging" and I think there  <em>is</em>  a valid argument that we've gotten all the low-hanging fruit from the first and underinvested in the second.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:16:25.013Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:16:25.013Z" class="date">2022-09-02 21:16:25</a> <div class="message"><p>As a specific example I think structured programming had pretty considerable impact on understandability in ways that are more significant than similar debugging improvements made at the time... Its been awhile since we've gotten anything as impactful as structured programming though.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:21:38.106Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:21:38.106Z" class="date">2022-09-02 21:21:38</a> <div class="message"><p>In looking vs. debugging, which is type safety?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:26:14.388Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:26:14.388Z" class="date">2022-09-02 21:26:14</a> <div class="message"><p>Yeah, I was thinking that was missing from this discussion. It's interesting. Somewhere in between. There's almost three levels you want to consider things at:</p>
<ul><li>How easy is it to understand ‚Äújust looking‚Äù (human only)</li><li>How easy is it to understand with automated verification (machine only)</li><li>How easy is it to understand with a debugger (human and machine)</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:27:13.528Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:27:13.528Z" class="date">2022-09-02 21:27:13</a> <div class="message"><p>I'd even argue that some of the verification methods impose complications in program text that makes 1 harder. Complicated type systems can sometimes place a burden on the programmer.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:32:19.671Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:32:19.671Z" class="date">2022-09-02 21:32:19</a> <div class="message"><p>I divide it primarily between things that seek to make errors impossible, and things that seek to make errors easier to discover, and things that make errors easier to diagnose, and things that make them easier to repair.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:33:31.947Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:33:31.947Z" class="date">2022-09-02 21:33:31</a> <div class="message"><p>E.g. type safety, fuzzing, debugging, and clear syntax.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:34:27.619Z" class="reply"><span class="user">Jason Morris</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:34:27.619Z" class="date">2022-09-02 21:34:27</a> <div class="message"><p>I find "impossible" and "easy to repair" to be usually mutually incompatible.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-02T21:37:59.863Z" class="reply"><span class="user">Tyler Leonhardt</span> <a href="./?fromDate=2022-08-30&amp;toDate=2022-09-05&amp;channel=thinking-together&amp;filter=#2022-09-02T21:37:59.863Z" class="date">2022-09-02 21:37:59</a> <div class="message"><p>Yeah, I feel like this is true in many contexts. There is definitely a balance between them.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2022-09-03T06:27:12.980Z" class="post"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-08-31&amp;toDate=2022-09-06&amp;channel=thinking-together&amp;filter=#2022-09-03T06:27:12.980Z" class="date">2022-09-03 06:27:12</a> <div class="message"><p>A UX design tool has one job: Materialize the designer's intent as working code.</p>
<p>Everything the tool does is in service of refining that intent (ideation, exploration, validation).</p>
<p>A programing tool has one job: Materialize the user's intent as working code.</p>
<p>UX design tools are programming tools.</p>
<p>UX tools today care very little for code. But they should, and it needs to be at their core.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2022-09-03T16:37:27.661Z" class="reply"><span class="user">Garth Goldwater</span> <a href="./?fromDate=2022-08-31&amp;toDate=2022-09-06&amp;channel=thinking-together&amp;filter=#2022-09-03T16:37:27.661Z" class="date">2022-09-03 16:37:27</a> <div class="message"><p>id also make the argument that programming tools do very little in the opposite direction‚Äîthey're much worse at communicating intent. and they're obviously visually weak</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2022-09-03T17:00:47.199Z" class="reply"><span class="user">Jim Meyer</span> <a href="./?fromDate=2022-08-31&amp;toDate=2022-09-06&amp;channel=thinking-together&amp;filter=#2022-09-03T17:00:47.199Z" class="date">2022-09-03 17:00:47</a> <div class="message"><p><a href="https://twitter.com/no_defects">Garth Goldwater</a> Trying to fix that üòä See <a href="./?fromDate=2022-07-25&amp;toDate=2022-07-31&amp;channel=share-your-work&amp;filter=#2022-07-28T11:20:10.210Z">üí¨ #share-your-work@2022-07-28T11:20:10.210Z</a> on how we're able to let designers communicate their intent by visually editing code. Working UI code, that uses real production components, is a much more precise way for designers to communicate their intent than compared to having their developer counterparts inspect their Figma/Sketch/XD vector-graphics files.</p>
</div> <div class="attachments"><blockquote><p>[July 28th, 2022 4:20 AM] jimkyndemeyer: UI code was always meant to be edited visually at 60 FPS on a canvas in a code-native design tool.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2022-09-03T18:08:03.369Z" class="reply"><span class="user">Garth Goldwater</span> <a href="./?fromDate=2022-08-31&amp;toDate=2022-09-06&amp;channel=thinking-together&amp;filter=#2022-09-03T18:08:03.369Z" class="date">2022-09-03 18:08:03</a> <div class="message"><p>oh yeah‚Äîi think i saved that gif lol</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
