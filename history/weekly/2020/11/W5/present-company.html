
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2020-11-22T19:13:25.090Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2020-11-22T19:13:25.090Z" class="date">üï∞Ô∏è 2020-11-22 19:13:25</a> <div class="message"><p>Anybody here using an ARM desktop? It occurs to me that I've only owned laptops all my life, and the pandemic is a great opportunity for me to switch to more hackable desktops. And switching to ARM may reduce the energy barrier for later forking Mu to it.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-11-23T09:18:03.092Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-11-23T09:18:03.092Z" class="date">2020-11-23 09:18:03</a> <div class="message"><p>Another interesting choice: <a href="https://www.sifive.com/boards/hifive-unmatched"></a><a href="https://www.sifive.com/boards/hifive-unmatched">https://www.sifive.com/boards/hifive-unmatched</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.sifive.com/boards/hifive-unmatched">SiFive</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-11-23T12:21:34.092Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2020-11-23T12:21:34.092Z" class="date">2020-11-23 12:21:34</a> <div class="message"><p>If you want hackability at every level of the stack, the rpi is probably not what you want, afaik it requires blobs for quite a lot of its hardware</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T12:25:02.092Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2020-11-23T12:25:02.092Z" class="date">2020-11-23 12:25:02</a> <div class="message"><p>pine64 also sells SBCs, using the same SoC as their computer line, which are more hackable on that front‚Äîno blobs to my knowledge</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T16:14:21.092Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-23T16:14:21.092Z" class="date">2020-11-23 16:14:21</a> <div class="message"><p>My bar for hackability is quite low. Just something that matches Wintel for hardware  (say you can add RAM after purchase) or Apple circa 2008 for software (install gdb). Mostly I'm trying to think about what replaces x86. But the market doesn't seem to have a clear answer yet. Pine has supply issues (i.e. I can't find one available anywhere)</p>
<p>RISC V is definitely on my radar, but my impression was that it's not quite ready to be used. The way my motivation system works, I need to be able to switch to the browser and browse the internet when I get stuck. Can HIFIVE run a browser yet?</p>
<p>I think I might have to just stick with Qemu for now.. all in all this feels like my attempts to find a decent browser in 2004.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T16:43:02.093Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-11-23T16:43:02.093Z" class="date">2020-11-23 16:43:02</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> The one to which I linked comes with a memory stick containing a Linux build that includes a web browser, but it definitely wouldn't offer all the creature comforts of your current workstation. üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T16:48:02.093Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-23T16:48:02.093Z" class="date">2020-11-23 16:48:02</a> <div class="message"><p>Whoa! Definitely taking a look. I'm willing to put up with some inconvenience. Some of my most productive period came during a vacation when I had just a 2nd generation Kindle ePaper device. Refresh times were abysmal. But it had signal on Lakshadweep when my phone didn't.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T18:16:18.093Z" class="reply"><span class="user">Ray Imber</span> <a href="#2020-11-23T18:16:18.093Z" class="date">2020-11-23 18:16:18</a> <div class="message"><p>I love the ethos behind Pine, but their supply chain issues are terrible üò¢</p>
<p>That SiFive board does look damn cool though!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-23T23:08:14.093Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2020-11-23T23:08:14.093Z" class="date">2020-11-23 23:08:14</a> <div class="message"><p>Yeah, my pinephone was close to two months late... due to covid locking the borders, but what can you do; at least they are transparent about it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-11-23T23:50:54.094Z" class="post"><span class="user">Emmanuel Oga</span> <a href="#2020-11-23T23:50:54.094Z" class="date">2020-11-23 23:50:54</a> <div class="message"><p>A pattern I'm using to simplify my HTTP APIs: <a href="https://gist.github.com/EmmanuelOga/8458a500645da511f10ad32fe8084367"></a><a href="https://gist.github.com/EmmanuelOga/8458a500645da511f10ad32fe8084367">https://gist.github.com/EmmanuelOga/8458a500645da511f10ad32fe8084367</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"></div></div><div id="2020-11-24T00:36:01.100Z" class="post"><span class="user">Jarrett Atkinson</span> <a href="#2020-11-24T00:36:01.100Z" class="date">2020-11-24 00:36:01</a> <div class="message"><p>I'm not a hardware designer, but I've had classes on HW design and I've done quite a bit of research on it. In general, does it make sense to design hardware that supports functional languages? Correct me if I'm wrong here, but it seems to me that the most expensive operation for languages like clojure are around their <a href="https://en.wikipedia.org/wiki/Persistent_data_structure"></a><a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a> (even though they are really fast). Could fixed function hardware be designed to make persistant data structures a winning choice? e.g. could be stuff like improving cache synchronization. I don't know where this would fit best though - would this type of FF HW be best placed within the cpu core, or perhaps alongside the ram? Just spit balling here, hopefully someone here knows enough to say weather this is dumb or a possible idea.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-11-24T00:48:55.100Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2020-11-24T00:48:55.100Z" class="date">2020-11-24 00:48:55</a> <div class="message"><p>I'm reminded of this recent <a href="https://twitter.com/Catfish_Man/status/1326238434235568128"></a><a href="https://twitter.com/Catfish_Man/status/1326238434235568128">https://twitter.com/Catfish_Man/status/1326238434235568128</a> from Apple engineer Dave Smith about the perf of the M1 chip:</p>
<blockquote><p>fun fact: retaining and releasing an NSObject takes ~30 nanoseconds on current gen Intel, and ~6.5 nanoseconds on an M1</p>
</blockquote>
<p>‚Ä¶and ~14 nanoseconds on an M1 emulating an Intel &gt; üòá&gt;  </p>
<p>They designed the M1 chip to do really well at object retain/release because Swift &amp; Obj-C use reference counting extensively (rather than, say, some sort of full-blown GC).</p>
<p>Would be interesting to know what work they did to the hardware to accelerate that particular pattern. Like you said ‚Äî&nbsp;is it just in the CPU, or is it affected by memory latency, or..?</p>
<p>Would also be interesting to know whether other languages could be pulled along in the slipstream of that particular HW optimization.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T01:42:32.101Z" class="reply"><span class="user">Emmanuel Oga</span> <a href="#2020-11-24T01:42:32.101Z" class="date">2020-11-24 01:42:32</a> <div class="message"><p>I think it is a rabbit hole. Hardware is inherently stateful, state machines are a good model to think about it. There were whole teams trying to come up with Lisp machines and the effort is well documented elsewhere but they ultimately failed to get traction (there's also a distinction to be made between "functional" and "immutable"). I feel like stateful hardware with an immutable layer on top is the correct way to model something like Clojure.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T02:13:37.101Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-24T02:13:37.101Z" class="date">2020-11-24 02:13:37</a> <div class="message"><p>Yeah, this has been explored a whole lot. I'd have more citations to provide 10+ years ago when I did my PhD in computer architecture. One thing to note here is that the whole CISC thing that RISC was in response to was a trend of adding special instructions for common patterns in software.</p>
<p>Which is not to say there's nothing to explore here. It's gotten quite unfashionable for 30+ years now. That seems like enough time for another turn of the wheel.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T04:35:16.101Z" class="reply"><span class="user">Ivan Reese</span> <a href="#2020-11-24T04:35:16.101Z" class="date">2020-11-24 04:35:16</a> <div class="message"><p>On the one hand: yeah, RISC has definitely had a good run for the past 30 years.</p>
<p>On the other hand: chips are extremely wide now wherever the software is able to make use of that (eg: SIMD, GPU units); SoCs have dedicated image signal processors, ML accelerators, crypto accelerators, video decoding (and sometimes encoding); mobile chips (or, at least, Apple's chips) have heterogeneous cores, some for high-perf and some for low-power.</p>
<p>So there seems to be a move away from simple, undifferentiated compute and a return to specialized hardware aplenty ‚Äî but this time it's physical specialization, rather than instruction specialization.</p>
<p>Curiously, it seems the opposite might be happening in memory. RAM and VRAM are frequently merged (ie. by M1, modern game consoles, mobile devices), there's the thought that we might see NVRAM combine RAM and storage, I wouldn't be surprised if L3 cache fell out of favour.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T07:25:11.106Z" class="reply"><span class="user">Jarrett Atkinson</span> <a href="#2020-11-24T07:25:11.106Z" class="date">2020-11-24 07:25:11</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> my only disagreement with your post is that, yes, lisp machine have been tried. However, afaik most lisps before clojure used more out less standard mutable data structures. My theory (could still be wrong) is that the data structures provide the biggest possible ROI for hardware. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T07:30:55.106Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-24T07:30:55.106Z" class="date">2020-11-24 07:30:55</a> <div class="message"><p>Perhaps you're responding to Emanuel's comment? I didn't really mention Lisp machines.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T14:02:50.107Z" class="reply"><span class="user">Jarrett Atkinson</span> <a href="#2020-11-24T14:02:50.107Z" class="date">2020-11-24 14:02:50</a> <div class="message"><p>Oops, mobile is hard to read :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T14:05:03.108Z" class="reply"><span class="user">Jarrett Atkinson</span> <a href="#2020-11-24T14:05:03.108Z" class="date">2020-11-24 14:05:03</a> <div class="message"><p>I thought you had made both comments, but with each of you making one my comment applies less</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-24T14:59:13.108Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-11-24T14:59:13.108Z" class="date">2020-11-24 14:59:13</a> <div class="message"><p><strong>@Jarrett Atkinson</strong> While most Lisps allow one to tinker with the inner workings of cons cells, it's probably worth noting that the standard list building process of <code>(cons elem the-list)</code>  (construct a new list with <code>elem</code> as the head and <code>the-list</code> as the tail) does not modify <code>the-list </code>in any way, allowing other reference holders to continue as if nothing has happened. It's a form of "unenforced immutability," if you will.</p>
<p>You can read about how this works in the context of Common Lisp here:</p>
<p><a href="http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html"></a><a href="http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html">http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html">Immutable Persistent Data Structures in Common Lisp - the zero bit stream</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-11-24T16:21:24.109Z" class="reply"><span class="user">Jarrett Atkinson</span> <a href="#2020-11-24T16:21:24.109Z" class="date">2020-11-24 16:21:24</a> <div class="message"><p>Ah, interesting. I've come across this before, but I didn't think about it w.r.t. this topic</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-11-27T03:42:58.111Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2020-11-27T03:42:58.111Z" class="date">2020-11-27 03:42:58</a> <div class="message"><p><strong>@William Taysom</strong> <a href="https://emmanueloga.com/">Emmanuel Oga</a> Following up on the shell sub-thread of <a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1606359276136400"></a><a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1606359276136400">https://futureofcoding.slack.com/archives/C5T9GPWFL/p1606359276136400</a>, Oil is a principled language that is also a compatible superset of most of bourne-descended shell.</p>
<p><a href="http://www.oilshell.org"></a><a href="http://www.oilshell.org">http://www.oilshell.org</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-11-27T08:22:38.111Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-11-27T08:22:38.111Z" class="date">2020-11-27 08:22:38</a> <div class="message"><p>I wonder if the author spent much time studying prior attempts, like <a href="http://doc.cat-v.org/plan_9/4th_edition/papers/rc"></a><a href="http://doc.cat-v.org/plan_9/4th_edition/papers/rc">http://doc.cat-v.org/plan_9/4th_edition/papers/rc</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-27T08:32:34.111Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-27T08:32:34.111Z" class="date">2020-11-27 08:32:34</a> <div class="message"><p>The claim is that it's as principled as rc, but still compatible with bourne derivatives:</p>
<p><a href="https://lobste.rs/s/7bpgbl/rc_plan_9_shell#c_mokqrn"></a><a href="https://lobste.rs/s/7bpgbl/rc_plan_9_shell#c_mokqrn">https://lobste.rs/s/7bpgbl/rc_plan_9_shell#c_mokqrn</a></p>
<p>All in all, seems like fairly substantial work.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-27T13:52:29.112Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-11-27T13:52:29.112Z" class="date">2020-11-27 13:52:29</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> I didn't mean to be dismissive of the work. I was legitimately interested in how much time he spent with <code>rc</code> , so thanks for digging up this comment üôÇ Amusingly, this comment from user dpk:</p>
<blockquote><p>I love&nbsp;&gt; <code>rc</code>&gt; &nbsp;for shell programming, but as an interactive shell (even in the various currently-existing forks) it‚Äôs long been overtaken in features. I‚Äôve long wished for a shell I‚Äôve informally called&nbsp;&gt; <code>zrc</code>&gt; : the syntax and programming features of&nbsp;&gt; <code>rc</code>&gt; &nbsp;with the interactive usability of&nbsp;&gt; <code>zsh</code>Echoes what everyone was saying about <code>csh</code> (good for scripting, bad for use) vs <code>bash</code> (the inverse) circa 1989.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-27T17:00:43.112Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-11-27T17:00:43.112Z" class="date">2020-11-27 17:00:43</a> <div class="message"><p>Thanks <a href="https://github.com/akkartik/mu">Kartik Agaram</a>.  Oil appears promising enough that I'm going to look into this.  Even the website is sufficiently nonsense that I viewed source as a double-take.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-28T14:20:00.112Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-11-28T14:20:00.112Z" class="date">2020-11-28 14:20:00</a> <div class="message"><p>I reasd that Oil is not really intended for interactive use ‚Äî manual line by line entering of commands as opposed to running scripts.  Is that correct?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-11-28T16:30:54.113Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-11-28T16:30:54.113Z" class="date">2020-11-28 16:30:54</a> <div class="message"><p>It's a statement of priorities, I believe. Scripting first. Though he has a tendency to add whole new kitchen sinks to it, IMO. So who knows how long it will take to even get scripting done.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
