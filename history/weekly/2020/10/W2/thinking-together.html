
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2020-10-04T19:10:27.149Z" class="post"><span class="user">Alexey Shmalko</span> <a href="#2020-10-04T19:10:27.149Z" class="date">üï∞Ô∏è 2020-10-04 19:10:27</a> <div class="message"><p>I'm experiencing a minor burnout at work, so I've decided to work less and spend more time on my side projects, hang out with people, and do more fun in general.</p>
<p>My question: what motivates, excites, and inspires you? (thoughts, personal stories, or specific links are much appreciated)</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-04T22:16:40.152Z" class="reply"><span class="user">Nick Smith</span> <a href="#2020-10-04T22:16:40.152Z" class="date">2020-10-04 22:16:40</a> <div class="message"><p>Increasing the range of things that the human mind can build and accomplish! That‚Äôs why I‚Äôm spending my time in PL research. I‚Äôve come to realise that there are huge strides that can be made; we just need more people working on the problem, and more variance in approach!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-04T23:11:07.153Z" class="reply"><span class="user">Chris Rabl</span> <a href="#2020-10-04T23:11:07.153Z" class="date">2020-10-04 23:11:07</a> <div class="message"><p>Nearly every day I take a three to five mile walk outdoors (alone, which really helps me clear my mind and forces me to focus on myself and what I feel: thankfully my wife accommodates me in this regard!). I find that it helps me center myself in the world and forces me to walk away from any issues I happen to be experiencing in that moment (work-related or otherwise). Music and podcasts also help me get away from my own thoughts, as do books and side-projects (although I tend to avoid immersing myself too far in the latter because it can lead me to obsess over them). Doing a variety of activities and tasks that challenge me in different ways is my key to feeling energized and motivated, but it all starts with my walks :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T07:15:23.154Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-10-05T07:15:23.154Z" class="date">2020-10-05 07:15:23</a> <div class="message"><p>To follow up Chris on the zen stuff that help me freeing my mind from issues, etc.: I like cooking (and then eating what I have cooked of course) it helps me focused on manual things with a good balance between simple repetitive tasks with a bit of creativity. I find it relaxing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T07:24:36.154Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-10-05T07:24:36.154Z" class="date">2020-10-05 07:24:36</a> <div class="message"><p>And about my prog-futurism work, what motivates me the more is when I see that something that were complicated to do becomes really simple. It is when programming feels like magic.</p>
<p>And what also motivates me is when someone else suddenly feels the magic also. For example during workshop, where you see a kid with sparkles in her eyes when she discover what she can create. Something, she didn't believe she can do a few minutes before.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T07:28:50.154Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-10-05T07:28:50.154Z" class="date">2020-10-05 07:28:50</a> <div class="message"><p>Also, a classic here, someone that motivates me, inspires me and makes me think a lot is Bret Victor. Another important inspiration: Seymour Papert.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T07:50:52.155Z" class="reply"><span class="user">Chris Knott</span> <a href="#2020-10-05T07:50:52.155Z" class="date">2020-10-05 07:50:52</a> <div class="message"><p>This is an odd one, but this video inspires me. Imagine trying to convince a farm worker 200 years ago that this level of efficiency would be possible. Imagine the equivalent manual work.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>üé• <a href="https://files.slack.com/files-pri/T5TCAFTA9-F01BHKX3W8P/y4jdsvl.mp4">y4JdSvL.mp4</a></p>
</blockquote>
</div></div><div id="2020-10-05T07:53:02.155Z" class="reply"><span class="user">Chris Knott</span> <a href="#2020-10-05T07:53:02.155Z" class="date">2020-10-05 07:53:02</a> <div class="message"><p>In terms of actual projects, it's bringing the real power of computers to frontline practitioners in fields that are currently underserved by computers.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T19:43:14.157Z" class="reply"><span class="user">Jason Hobbs</span> <a href="#2020-10-05T19:43:14.157Z" class="date">2020-10-05 19:43:14</a> <div class="message"><p>A couple months ago I started a nightly routine of asking "what was life-giving today?". It's really helped me to identify the activities that really light me up, or provide me fuel. Those things that leave me with more energy then when I started them.  The biggest surprise I had here was doing physical activities while listening to an audiobook as a daily practice is highly rewarding for me. I'm talking about things like cleaning the garage, yardwork, etc.  On the coding side of things, I'm really lit up by the idea of giving developers freedom of notation where we can read/write any function using whatever notation best serves our ability to think about that problem.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-10-01T00:04:09.105Z" class="post"><span class="user">Will Crichton</span> <a href="#2020-10-01T00:04:09.105Z" class="date">üï∞Ô∏è 2020-10-01 00:04:09</a> <div class="message"><p>I was reading Fred Kjolstad‚Äôs thesis (<a href="http://fredrikbk.com/publications/kjolstad-thesis.pdf"></a><a href="http://fredrikbk.com/publications/kjolstad-thesis.pdf">http://fredrikbk.com/publications/kjolstad-thesis.pdf</a>) about compilers for sparse linear algebra. He says:</p>
<blockquote><p>The issue with libraries of hand-optimized functions boils down to our inability to easily build composable building blocks that perform well. Current sparse linear algebra libraries do not let us compose expressions, data structures, optimization strategies, and architectures without sacrificing performance. The first performance loss is from lost temporal locality‚Äîa deficiency that is also present with dense operations. Second, sparse operations may operate on many different data structures, which are each designed to work well on one type of sparsity pattern. If two composed functions do not support the same data structure, then it becomes necessary to perform an expensive conversion between irregular data structures. But the most serious issue is that composing two sparse linear or tensor algebra functions may perform asymptotically worse than a fused function written to compute the entire expression at once.</p>
</blockquote>
<p>This made me think more generally about the composability vs. performance trade-off.  Being able to compose black box abstractions at a high level is at the very foundation of software engineering, enabling programmers to eliminate boilerplate and more easily use others‚Äô work. Yet composition is the enemy of performance: a careful implementation that fuses two operations is often more efficient than a sequenced invocation of the two. However, most compilers today only offer <code>#[inline]</code> pragmas or other extremely shallow means of reducing abstraction/composition costs. Even the most advanced C++ template magic can‚Äôt do the necessary code-reordering to achieve the optimal composition that Fred describes.</p>
<p>Several programming systems have good ideas in this direction:</p>
<ul><li>Zero-cost abstractions in programming languages (eg Rust <a href="https://blog.rust-lang.org/2015/05/11/traits.html"></a><a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>)</li><li>Separating algorithm from schedule (eg Halide <a href="http://halide-lang.org/"></a><a href="http://halide-lang.org/">http://halide-lang.org/</a>)</li><li>Using higher-order functions to express data parallelism (eg Spark <a href="https://spark.apache.org/"></a><a href="https://spark.apache.org/">https://spark.apache.org/</a>)</li></ul><p>Curious to hear others‚Äô thoughts (how will we manage this trade-off in future langs/compilers?) and pointers to relevant work.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-05T09:18:27.156Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-10-05T09:18:27.156Z" class="date">2020-10-05 09:18:27</a> <div class="message"><p>Partial evaluation to remove abstraction overhead?</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-28T21:58:39.057Z" class="post"><span class="user">Denny Vrandeƒçiƒá</span> <a href="#2020-09-28T21:58:39.057Z" class="date">üï∞Ô∏è 2020-09-28 21:58:39</a> <div class="message"><p>Hi all! I am working for the Wikimedia Foundation where we are starting to work on a new project [1]: a wiki of functions (name is currently being discussed by the community) [2]. Imagine that for every function, you have on wiki page, where the wiki page describes what the functions does, it's formal parameters (input types, output types), etc. Each function can have several implementations associated with it (which can be built either from other functions in the wiki or be natively written in a programming language, and we plan to support many of those) and also tests. Maybe the best way to understand the project is to take a look at some of the early mockups. [3]</p>
<p>The functions are meant to be functional, i.e. not to rely on state (well, not too much - they are able to call out to the Web, e.g. to look up information in Wikidata, etc., so in some way, the Web does provide state. We will need to figure that part out. There's a lot of open questions around that).</p>
<p>The type system is also in the wiki, so that it is extensible by the community.</p>
<p>We are in very early development (and, in fact, hiring!) [4] I am happy to answer any questions, but I would love to invite folks to join us, either for discussing the  project, help working on it, or ask as hard questions and think about how to solve it. [5]</p>
<p>A preprint paper with background can be found on Arxiv. [6] The paper has been accepted, but not published yet.</p>
<p>Happy to answer any questions here, and to have discussions about what we are doing. In the future I expect us to have many questions like "what is a good exception system", "do we need a type hierarchy", "what should the UX for the project do", etc., so would love to have a place for that.</p>
<p>[1] <a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia"></a><a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia">https://meta.wikimedia.org/wiki/Abstract_Wikipedia</a></p>
<p>[2] <a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Wiki_of_functions_naming_contest"></a><a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Wiki_of_functions_naming_contest">https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Wiki_of_functions_naming_contest</a></p>
<p>[3} <a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Early_mockups"></a><a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Early_mockups">https://meta.wikimedia.org/wiki/Abstract_Wikipedia/Early_mockups</a></p>
<p>[4] <a href="https://boards.greenhouse.io/wikimedia/jobs/2338515"></a><a href="https://boards.greenhouse.io/wikimedia/jobs/2338515">https://boards.greenhouse.io/wikimedia/jobs/2338515</a></p>
<p>[5] <a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia#Participate"></a><a href="https://meta.wikimedia.org/wiki/Abstract_Wikipedia#Participate">https://meta.wikimedia.org/wiki/Abstract_Wikipedia#Participate</a> - links to mailing list, chat, etc.</p>
<p>[6] <a href="https://arxiv.org/abs/2004.04733"></a><a href="https://arxiv.org/abs/2004.04733">https://arxiv.org/abs/2004.04733</a></p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-05T22:14:38.157Z" class="reply"><span class="user">Leonard Pauli</span> <a href="#2020-10-05T22:14:38.157Z" class="date">2020-10-05 22:14:38</a> <div class="message"><p><strong>@Denny Vrandeƒçiƒá</strong> Very cool! Working on something similar (interactive graph of knowledge and logic). An interesting aspect is converters/lenses/mappers between types of values. A simple one being unit conversion, a more complex one being eg. a rephrasing of a concept with the terminology of one field, to another (where the mapping isn't 1:1).</p>
<p>Would be cool to have the ability to associate function with functions (edge(origin function, target function, relation type/concept article)); for instance. "inverse" of a multiplication with b is a division with b (I would prefer to have the multiplicative inverse of a real number, and the rest derived, but doesn't seem to fit as well with wikilambdas current structure).</p>
<ul><li>indexes of all functions applicable to a specific type (allowing fancy auto-complete).</li></ul><p>Will it support higher order functions? Thoughts regarding program termination? (I believe it can be solved for most cases in practise)</p>
<p>Of course, a nice integration with wikidata.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-05T22:56:54.158Z" class="reply"><span class="user">Leonard Pauli</span> <a href="#2020-10-05T22:56:54.158Z" class="date">2020-10-05 22:56:54</a> <div class="message"><p>Oh! oh! Allow different output than text, eg. plots. Would then be great to update datasets/tables in wikipedia to be type-annotated, both to make it accessible structurally, but also to allow <code>population_pyramid(country.sweden.population_history)</code> instead of the current images, that quickly go out of date with the underlying data (eg. <a href="https://en.wikipedia.org/wiki/Demographics_of_Sweden"></a><a href="https://en.wikipedia.org/wiki/Demographics_of_Sweden">https://en.wikipedia.org/wiki/Demographics_of_Sweden</a>). (I suppose you've seen the likes of <a href="https://observablehq.com/explore"></a><a href="https://observablehq.com/explore">https://observablehq.com/explore</a>) Also, show function on article pages; eg. molar mass calc for a chemical compound. Wait, it is currently manually entered?? (eg. <a href="https://en.wikipedia.org/wiki/Adenosine_triphosphate"></a><a href="https://en.wikipedia.org/wiki/Adenosine_triphosphate">https://en.wikipedia.org/wiki/Adenosine_triphosphate</a>). Also, all values inline text to be type-annotated, with the ability to apply relevant single-argument functions; eg. unit conversion. In math example, ability to "link" the values, resulting in the ability to provide your own. Endless possibilities. Much excitement. Looking forward to interop with my system; both using and adding functions/data (also, when this becomes a reality, and an api gets used extensively, it would be cool with at least some sort of "estimated infrastructure cost" calculator, or a wikilambda-specific donation flag, if nothing else).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-06T00:54:48.158Z" class="reply"><span class="user">Denny Vrandeƒçiƒá</span> <a href="#2020-10-06T00:54:48.158Z" class="date">2020-10-06 00:54:48</a> <div class="message"><p><strong>@Leonard Pauli</strong> plenty of good ideas! come and join us on our mailing list! üôÇ Yes plenty of these ideas should become realizable when we get there</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-30T22:08:44.095Z" class="post"><span class="user">Andrew Carr</span> <a href="#2020-09-30T22:08:44.095Z" class="date">üï∞Ô∏è 2020-09-30 22:08:44</a> <div class="message"><p>I'm not sure how to phrase this question. I've been thinking a lot about "bit rot" recently. For example, will we reach a point where there are no DVD players that can decode the disks?</p>
<p>Or where there is no existing program to read PowerPoint presentations? </p>
<p>Is this a likely eventuality for systems? Should everything be txt files to avoid this? </p>
<p>Are we going to have our period of history with large gaps from this bit rot problem? </p>
<p>Can we as programmers do anything to avoid this?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-05T23:43:25.158Z" class="reply"><span class="user">Leonard Pauli</span> <a href="#2020-10-05T23:43:25.158Z" class="date">2020-10-05 23:43:25</a> <div class="message"><p>Disregarding mass destruction events, it's a question of preservation through data portability + software portability. Docker is pretty cool in that regard that as long as docker itself is maintained, all images will work for long. If not, just put the old docker in a medium old os in the next docker, and the gap is bridged. Seen windows95 in the browser? <a href="https://copy.sh/v86/?profile=windows95"></a><a href="https://copy.sh/v86/?profile=windows95">https://copy.sh/v86/?profile=windows95</a> As long as we get a steady stream of bridges, and keep the data store fresh, we should be good. (though possibly a big ask for orgs like the internet archive).</p>
<p>It's tricky to enforce when the access-interval is longer than the rot-interval, but otherwise, the increasing decoupling of data from storage medium + logic from computational substrate is a good sign. Cloud platforms that die, and take both data and logic to the grave, is a less good trend. Don't do that. Observablehq is a little nice by including an open runtime with the source when you download your projects.</p>
<p>In my language, I strive for more high-level, separating logic from computational substrate, allowing re-export to multiple different mediums. By keeping it append-only, with unique refs to versioned logic, and including them in any potential exported data, in addition to somewhat automatic migration transformations between logic versions, I hope that a piece of data/logic should both be runnable as is + "migratable" to a far future version, seamlessly.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-06T20:36:42.160Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-10-06T20:36:42.160Z" class="date">2020-10-06 20:36:42</a> <div class="message"><p>Makes me wonder: are there programs that today can only be run with 2nd-order emulation, so you need an emulator for the emulator to run the program?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:04:38.169Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-10-08T19:04:38.169Z" class="date">2020-10-08 19:04:38</a> <div class="message"><p>Define emulator! Is a JVM implementation an emulator? Or a JavaScript engine? There are emulators written in Java and JavaScript.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-10-07T13:58:46.163Z" class="post"><span class="user">Harry Brundage</span> <a href="#2020-10-07T13:58:46.163Z" class="date">2020-10-07 13:58:46</a> <div class="message"><p>Has anyone seen any paradigms they really like for keyboard-navigating big, abstract mediums that aren't text? i really like how text can be keyboard navigated easily. Where your cursor + attention is about to go is always clear and we've invented lots of ways to accelerate getting your cursor to where you want it to go. How does that play out in things that aren't text though, like all the flow based languages we're seeing, or tools like Webflow that are trying to make it fast to create trees of stuff? Are we destined for slower mouse based interfaces that don't leverage muscle memory as much?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-07T14:00:03.164Z" class="reply"><span class="user">Harry Brundage</span> <a href="#2020-10-07T14:00:03.164Z" class="date">2020-10-07 14:00:03</a> <div class="message"><p>i think part of why code feels nice to navigate is that it matches the paper metaphor that we're all very used to, things don't jump around or appear or stack on top of each other when you're working in a (normal) text editor, it's 2D, which monitors and the arrow keys are also</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-07T14:03:21.164Z" class="reply"><span class="user">Harry Brundage</span> <a href="#2020-10-07T14:03:21.164Z" class="date">2020-10-07 14:03:21</a> <div class="message"><p>one thing i've been exploring is TV-remote style navigation of interfaces where the interface knows what all the selectable targets are and the arrow keys move a cursor in space between all the targets, like the Apple TV or Roku UI, but it suffers from some issues where it's unclear where your cursor might go to next, and that compounds as you jump farther so it's hard to make accelerated key commands like jump all the way to left or right or something of that nature.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-07T14:06:30.165Z" class="reply"><span class="user">Harry Brundage</span> <a href="#2020-10-07T14:06:30.165Z" class="date">2020-10-07 14:06:30</a> <div class="message"><p>text files also don't have inner hidden bits that you have to open by clicking something or buried menus, the only way you can change which part of a text file you are seeing is by scrolling, which again matches the paper metaphor really closely. we've invented all sorts of fun ways to jump around the different text files to allow developers to go in and out of abstractions and levels of detail, but the artifacts that express that detail don't really compress themselves or expand or change shape, unless you're using code folding, which i always found cumbersome</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T02:27:07.165Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-10-08T02:27:07.165Z" class="date">2020-10-08 02:27:07</a> <div class="message"><p>I find folding cumbersome due to a lack of mapped, memorized, and practiced keys for performing the higher level navigation actions I would want to execute.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T15:19:42.167Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-10-08T15:19:42.167Z" class="date">2020-10-08 15:19:42</a> <div class="message"><p>Check out Grant‚Äôs work: <a href="https://constraint.systems"></a><a href="https://constraint.systems">https://constraint.systems</a> He does experimental design tools with a Vim vibe to it.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://constraint.systems/">Constraint Systems</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-10-09T01:30:25.174Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-10-09T01:30:25.174Z" class="date">2020-10-09 01:30:25</a> <div class="message"><p>I‚Äôve been investigating this a bit. I made a prototype of a keyboard-oriented html/css editor a while ago, haven‚Äôt revisited it since but you might find it interesting as a non-text example of keyboard UI. Also seconding <a href="https://twitter.com/prabros">Prathyush</a>, check out grant‚Äôs work! <a href="https://twitter.com/yoshikischmitz/status/1185189779521953798?s=21"></a><a href="https://twitter.com/yoshikischmitz/status/1185189779521953798?s=21">https://twitter.com/yoshikischmitz/status/1185189779521953798?s=21</a></p>
</div> <div class="attachments"><blockquote><p>üê¶ <a href="https://twitter.com/@yoshikischmitz">yoshiki</a>: I've been investigating ideas for rapidly developing frontends. One angle I've been interested in is making a highly keyboard-driven design tool, something like a "vim for marking up UI". First experiment is this concise syntax for specifying style props using styled-system.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-10-09T01:32:42.176Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-10-09T01:32:42.176Z" class="date">2020-10-09 01:32:42</a> <div class="message"><p>Also iirc WorkFlowy is pretty keyboard friendly. You might find stuff like vim-wiki or org mode interesting, as those deal with trees and are primarily keyboard-driven as well.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T01:35:42.179Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-10-09T01:35:42.179Z" class="date">2020-10-09 01:35:42</a> <div class="message"><p>Finally, if we extend this idea to non-pointer interfaces(i.e not mouse or touch), you can investigate video games that use d-pads and buttons as their input method and observe that buttons are pretty good at controlling embodied agents. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T01:40:01.181Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-10-09T01:40:01.181Z" class="date">2020-10-09 01:40:01</a> <div class="message"><p>Oh! Also many structured code editors support keyboard navigation. Related, TiledText by <strong>@westoncb</strong> lets you do AST navigation using a game pad(w/ no pointers, as far as I‚Äôm aware): <a href="http://westoncb.com/projects/tiledtext"></a><a href="http://westoncb.com/projects/tiledtext">http://westoncb.com/projects/tiledtext</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T03:43:37.181Z" class="reply"><span class="user">westoncb</span> <a href="#2020-10-09T03:43:37.181Z" class="date">2020-10-09 03:43:37</a> <div class="message"><p>Yoshiki I see it's been about a year since those tweets‚Äîmaybe time to resume that project? üòõ (really cool though‚Äîdon't think I'd seen that before)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T03:51:02.182Z" class="reply"><span class="user">westoncb</span> <a href="#2020-10-09T03:51:02.182Z" class="date">2020-10-09 03:51:02</a> <div class="message"><p>I do think the Tiled Text input scheme did a couple things that would be useful for non-text UIs, but probably not for using keyboard control.</p>
<p>It is "pointerless" though: it's a 1d input scheme, no moving a pointer in 2d space. The navigation scheme has two parts, one of which is less visible in the video: expansion/collapsing to change which level of the tree you're at, and 'cycling'.</p>
<p>Cycling is what makes it possible to not use pointers. Two things needed to make cycling effective: 1. being able to move to higher tree levels, allowing you to skip over large sections 2. disconnecting the amount of space you have to swipe the input from the visual representation: whether a node is tiny or huge in the UI, you 'travel' the same distance with your input device.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-24T01:06:02.010Z" class="post"><span class="user">Will Crichton</span> <a href="#2020-09-24T01:06:02.010Z" class="date">üï∞Ô∏è 2020-09-24 01:06:02</a> <div class="message"><p>A big issue in programming is that a program is an extremely lossy record of history. Even with good comments, it‚Äôs hard to look at a program and know:</p>
<ul><li>What are the alternatives that were considered, but ignored? Tried, but later discarded?</li><li>What order was this program written in? Is a particular line or function the focal point of this code?</li><li>What is the set of resources the author used to write this code?</li><li>How weathered is this code? How many bugs have happened in this code? How scared should I be to change it?</li></ul><p>What are some ways in which programming environments could help us record this info / answer these questions without requiring additional effort from the author?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-10-08T18:46:49.167Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-08T18:46:49.167Z" class="date">2020-10-08 18:46:49</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a></p>
<p>Really interesting to hear more about the limitations with slicing. Not 100% sure I followed why data transformation causes an issue. But definitely agree that slices don't solve the whole problem.</p>
<p>As for the test suite idea, I definitely agree that it has some issues. I do think trying to take an existing test suite and applying this wouldn't be super useful. But you can imagine making your own test suite, specifically designed to exercise various parts of the system. You can imagine taking some lisp interpreter, feeding it simple expressions, getting the trace, and the moving on to more and more complex ones. Giving you in the end something that you can follow.</p>
<p>I think your work on wart is really interesting and actually really aligns with what I was aiming at talking about. What we need is not a factual, uninterpreted history of how the program changed. We do in fact have the facts. They are recorded in source control. What we need is an interpretive, idealized history. You are providing exactly that in wart. Though I will say, I'm not sure it goes far enough, but that is mostly related to this:</p>
<blockquote><p>There's no way to understand programs efficiently when the author didn't design for it from the start. If a program had multiple authors, it's as easy to read as the author least interested in comprehensibility made it. Programs have to be designed for comprehensibility. So toss out the modern social organization and its incentives for creating programs primarily as black boxes for people to use.</p>
</blockquote>
<p>I'm tempted to agree. But I think the key word here is efficiently. I have worked in codebases that were clearly not meant to be understood (one was decompiled source). Where the code was absolutely insane. Understanding them was very very difficult and took a ton of work. But what I found in the end was that the tools I really needed to capture this information weren't there. I could of course write docs, and I did. But that wasn't enough.</p>
<p>Nor was my coming to an understanding of the code aided (much) by tools. Of course, a slice wouldn't have told me everything, but it would have helped me start with a simplified case. Being able to ask counterfactual questions of my program would have aided me in understanding. In general, I can think of a number of things that computers are fully capable of that would have made my journey of understanding condensed. And then, once understood, I could convey some of that to people, but helping them get into the right states where they too could repeat my learnings.</p>
<p>Designing programs with comprehensibility from the start is definitely a goal. But I just don't think it can be our end state.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T18:50:08.168Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-08T18:50:08.168Z" class="date">2020-10-08 18:50:08</a> <div class="message"><p>This post resonates so much with me on how I feel working on a codebases. Thought others might enjoy.  (good despite it being on medium) <a href="https://medium.com/@wm/the-generation-ship-model-of-software-development-5ef89a74854b"></a><a href="https://medium.com/@wm/the-generation-ship-model-of-software-development-5ef89a74854b">https://medium.com/@wm/the-generation-ship-model-of-software-development-5ef89a74854b</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T18:53:28.168Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-10-08T18:53:28.168Z" class="date">2020-10-08 18:53:28</a> <div class="message"><p>I realize you can put either side in the foreground, like a Necker cube:</p>
<ul><li><p>Designing ahead of time for comprehensibility is definitely a start, but it can't be our end state.</p>
</li><li><p>Tooling for comprehension is definitely a start, but it can't be our end state.</p>
</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T18:55:41.169Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-10-08T18:55:41.169Z" class="date">2020-10-08 18:55:41</a> <div class="message"><p>Also worth observing: we have no idea what program comprehension is or how it works. A theory of comprehension would likely be an essential component of designing for comprehension at the tool or program level.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:01:44.169Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-10-08T19:01:44.169Z" class="date">2020-10-08 19:01:44</a> <div class="message"><p>This is probably a subjective opinion, but I think we tend to do things first, and theories catch up over time as lots of people try out lots of things, and definitions converge last of all. Given that "ready, fire, aim" worldview, I try above all to focus on rewritability. If rewriting seems risky, that feels like the first problem to try to fix. That way the things you build can benefit from future theories, and you can be disrupted by yourself rather than external Johnny-come-latelies.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:44:09.169Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-08T19:44:09.169Z" class="date">2020-10-08 19:44:09</a> <div class="message"><p>Personally I think Naur's "Programming as Theory Building" and "Intuition in Software Development" are good starting points. In general, I think we have a lot that we could gain from including insights in philosophy into software development (I have a talk at splash this year advocating for exactly that). Something I think Naur does particularly well.</p>
<p>I do agree with <a href="https://github.com/akkartik/mu">Kartik Agaram</a>. Our practice generally outstrips our theories. But I think we can gain a lot by reflecting on practice and understanding. For example, as software engineers, we do a lot of what is called "Conceptual Engineering" in the philosophy world. Understanding what we do in light of that framework and how it relates to other things in the world can help us quite a bit.</p>
<p><a href="https://www.amazon.com/Fixing-Language-Essay-Conceptual-Engineering/dp/0198814712"></a><a href="https://www.amazon.com/Fixing-Language-Essay-Conceptual-Engineering/dp/0198814712">https://www.amazon.com/Fixing-Language-Essay-Conceptual-Engineering/dp/0198814712</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:49:36.170Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-10-08T19:49:36.170Z" class="date">2020-10-08 19:49:36</a> <div class="message"><p>Naur‚Äôs article is a good worldview, but (IMO) the devil is in the details. We have no idea how programmers build theories, what the shape of those theories are, what language constructs promote or hinder theory construction, and so on. We‚Äôve had 50 years of distributed practice in programming, but I don‚Äôt think that‚Äôs been sufficient to meaningfully understand the psychological nature of programming beyond intuition. You can see this failure most acutely in intro to CS classes, where our top universities will fail to teach even the most basic skills like debugging or decomposition in a meaningful way.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:53:03.170Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-08T19:53:03.170Z" class="date">2020-10-08 19:53:03</a> <div class="message"><p>Curious <a href="willcrichton.net">Will Crichton</a> to hear your view of how we'd go about starting that project. Would we solve these issues by doing empirical studies and finding statistical results? Or would it be more a matter of reflecting and exploring our own processes?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T19:59:12.170Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-10-08T19:59:12.170Z" class="date">2020-10-08 19:59:12</a> <div class="message"><p>This is the subject of my research, so my views evolve rapidly over time. But right now, my sense is: there‚Äôs a lot of inspiration we can draw from cognitive psychologists up to anthropologists/sociologists on how to study human behavior, particularly for skilled tasks. There‚Äôs a lot of theories that could be applied to programming (e.g. I‚Äôve been thinking about working memory recently, just submitted a paper to CHI about that). And there‚Äôs a lot of methodologies that can be used to study programmers. For example, Barbara Tversky‚Äôs book Mind in Motion is a really good overview of how simple experiments can build a really rich model of how people build mental models of space and action, and how action informs perception.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T20:00:53.170Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-10-08T20:00:53.170Z" class="date">2020-10-08 20:00:53</a> <div class="message"><p>Theory-building inevitably involves both controlled lab experiments (whether protocol analyses of quantitative studies) and data mining (of software repositories, education statistics, etc). But I think an underexplored area is experiment design: what are interesting situations in which we can put programmers, and methods to observe them that reveal patterns in their behavior?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T21:44:51.171Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-10-08T21:44:51.171Z" class="date">2020-10-08 21:44:51</a> <div class="message"><p><a href="https://jimmyhmiller.github.io/">Jimmy Miller</a> Naur's paper is one of my two or three "anchor" influences, so absolutely relevant. However, the "theories" in it are for understanding individual codebases or domains, as I recall. A general theory of comprehension is far more ambitious.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T21:47:40.171Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-08T21:47:40.171Z" class="date">2020-10-08 21:47:40</a> <div class="message"><p>Yeah, but he was basing his work on Ryle and James who probably took themselves to have something like that more general theory. (I don't particularly agree with them) But yes I agree. I think naur offers constraints that have largely been ignored. I'd be interesting to know you other anchor influences.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-08T21:53:17.171Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-10-08T21:53:17.171Z" class="date">2020-10-08 21:53:17</a> <div class="message"><p>I'd say Christopher Alexander and Richard Gabriel (the latter for making the former accessible to me). But I have a longer list at the bottom of <a href="https://github.com/akkartik/mu"></a><a href="https://github.com/akkartik/mu">https://github.com/akkartik/mu</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/akkartik/mu">akkartik/mu</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-10-09T00:03:58.171Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-09T00:03:58.171Z" class="date">2020-10-09 00:03:58</a> <div class="message"><p><a href="willcrichton.net">Will Crichton</a> This is an area I have trouble expressing my thoughts on. I skimmed chapters 1 and 2 and read chapter 3 of minds in motion. I will even taking the studies as a given, the conclusion drawn from them seem a bit off to me. But that said, I have very bad spatial awareness, have aphantasia, and in general see abstract thought as a retreat away from the spatial/visual world that I feel mostly uneasy in. I see some parallels for sure, but I sure hope my abstract thought isn‚Äôt based on my spatial abilities, because I like to think I‚Äôm better at the former than the latter.</p>
<p>I do think this more experiment based side of things is something I need to read more on though. I have a pretty large bias in this area. Perhaps it comes from reading one too many papers declaring free will to be disproved because of some fmri scan üôÇ. I will try reading a bit more of minds in motion with an open mind. Feel free to drop any other works you think are worth reading :)</p>
<p>Thanks <a href="https://github.com/akkartik/mu">Kartik Agaram</a> for the references.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T00:10:19.172Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-10-09T00:10:19.172Z" class="date">2020-10-09 00:10:19</a> <div class="message"><p><a href="https://jimmyhmiller.github.io/">Jimmy Miller</a> IMO the two most influential pieces that synthesize cogsci ideas are TRG Greene‚Äôs ‚ÄúCognitive Dimensions of Notation‚Äù and Bret Victor‚Äôs ‚ÄúLearnable Programming‚Äù. Not sure if you‚Äôve read but both are excellent. Some other fun papers:</p>
<ul><li>Don Knuth invents the term ‚Äúprofile‚Äù while studying FORTRAN programs in the wild: <a href="http://doi.wiley.com/10.1002/spe.4380010203"></a><a href="http://doi.wiley.com/10.1002/spe.4380010203">http://doi.wiley.com/10.1002/spe.4380010203</a></li><li>Plan composition shows us how programmers combine abstract program templates to create individual programs, and often fail in the process: <a href="http://portal.acm.org/citation.cfm?doid=6592.6594"></a><a href="http://portal.acm.org/citation.cfm?doid=6592.6594">http://portal.acm.org/citation.cfm?doid=6592.6594</a></li><li>Really good summary of a lot of experimental work on programming psychology in 70s/80s: <a href="https://telearn.archives-ouvertes.fr/hal-00190531/document"></a><a href="https://telearn.archives-ouvertes.fr/hal-00190531/document">https://telearn.archives-ouvertes.fr/hal-00190531/document</a></li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-10-09T00:23:42.172Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-10-09T00:23:42.172Z" class="date">2020-10-09 00:23:42</a> <div class="message"><p>Thanks <a href="willcrichton.net">Will Crichton</a> I have read Victor, but none of the rest of them. Have added them to my reading list. Thanks</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
