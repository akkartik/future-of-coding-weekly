
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2020-09-17T03:14:03.026Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2020-09-17T03:14:03.026Z" class="date">2020-09-17 03:14:03</a> <div class="message"><p>A funny story</p>
<p>A few weeks ago I built a function to read keystrokes from the keyboard. (In machine code, of course.) I figured I'd support just ASCII keys for starters, and gradually add the rest.</p>
<p>Today I tried to force myself to work on "the rest". Terminal escape sequences like arrow keys, utf-8, and somehow distinguishing between the two.</p>
<p>Surprise: both were already working! I just had to read 32 bits rather than 8 from stdin. Legal utf-8 doesn't conflict with terminal escapes in 32-bit space, and modern OSs do the right thing.</p>
<p><a href="https://github.com/akkartik/mu/commit/e403d15732"></a><a href="https://github.com/akkartik/mu/commit/e403d15732">https://github.com/akkartik/mu/commit/e403d15732</a></p>
</div> <div class="attachments"><blockquote><p>ðŸ”— <a href="https://github.com/akkartik/mu/commit/e403d15732">6794 - cleaner interface for keyboard Â· akkartik/mu@e403d15</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2020-09-17T03:29:24.026Z" class="reply"><span class="user">Tim Lipp</span> <a href="#2020-09-17T03:29:24.026Z" class="date">2020-09-17 03:29:24</a> <div class="message"><p>Love a good serendipity!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T02:32:30.000Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-18T02:32:30.000Z" class="date">2020-09-18 02:32:30</a> <div class="message"><p>Surprised by "and it just works!"</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-17T16:38:17.037Z" class="post"><span class="user">Stefan Lesser</span> <a href="#2020-09-17T16:38:17.037Z" class="date">2020-09-17 16:38:17</a> <div class="message"><p>Question about programming languages with static type systems and support for generics: in the language communities I spend most time in, the usual advice is to write specific algorithms first, and then generalize them when it makes sense. That's probably good advice.</p>
<p>Still, I'm trying something different and wonder: are there language communities that approach this the opposite way, ie. write algorithms as generic as possible and specialize only when needed, and only as far as needed? For instance, if you absolutely need a type to represent a sequence of elements, you only specify that the type conforms to some Iterable protocol, but leave it generic otherwise?</p>
<p>I'd think Haskell is probably a good place to look for thatâ€¦? And what about proof-oriented languages?</p>
<p>Which affordances do these languages offer to specifically support such a programming style?</p>
<p>And is this programming technique a thing that has a name?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-17T16:48:56.037Z" class="reply"><span class="user">Jimmy Miller</span> <a href="#2020-09-17T16:48:56.037Z" class="date">2020-09-17 16:48:56</a> <div class="message"><p>I definitely think you will find that this is pretty common in haskell. Starting with the generic let's you write reusable code, but also can help constrain what implementations are valid and not. I know of one article that argues specifically for this practice.</p>
<p><a href="https://degoes.net/articles/insufficiently-polymorphic"></a><a href="https://degoes.net/articles/insufficiently-polymorphic">https://degoes.net/articles/insufficiently-polymorphic</a></p>
<p>(John De Goes is a very controversial figure and this is not meant as an endorsement of his views. In fact, I don't know his views just that he is controversial.)</p>
</div> <div class="attachments"><blockquote><p>ðŸ”— <a href="https://degoes.net/articles/insufficiently-polymorphic">Descriptive Variable Names: A Code Smell</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-17T17:01:28.037Z" class="reply"><span class="user">Will Crichton</span> <a href="#2020-09-17T17:01:28.037Z" class="date">2020-09-17 17:01:28</a> <div class="message"><p>In languages that support polymorphic type inference, this isnâ€™t actually a trade-off you need to make. You can write code without types, and the compiler will infer the most general type possible. For example, in OCaml, if I do:</p>
<pre><code>let rec map f l = match l with 

  [] -&gt; [] | x :: xs -&gt; f x :: map f xs</code></pre><p>Then the compiler gets the right generic type for <code>f</code> and <code>l</code> , including the constraint that the elements of <code>l</code> have to be the same type as the input to <code>f</code>.</p>
<p>You probably knew that already, but itâ€™s worth reframing in terms of your question. You should write the algorithm exactly as needed ignoring types, and then decide what capabilities you need from your types.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-17T17:29:45.038Z" class="reply"><span class="user">Henning Dieterichs</span> <a href="#2020-09-17T17:29:45.038Z" class="date">2020-09-17 17:29:45</a> <div class="message"><p>I thought for a long time that abstractions and generalizations just complicate stuff. Particularly, I found natural numbers very easy to understand and groups/fields etc. very hard to grasp.</p>
<p>Now I think it is completely the opposite. Natural numbers are incredibly hard. Abstractions are meant for simplification - they remove the noise from the actual problem.</p>
<p>I think similarly about programming and interfaces or generic types.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-17T19:30:58.040Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-17T19:30:58.040Z" class="date">2020-09-17 19:30:58</a> <div class="message"><p><a href="https://jimmyhmiller.github.io/">Jimmy Miller</a> Thanks for sharing that article. That is in fact pretty much exactly what I was thinking about.</p>
<p><a href="willcrichton.net">Will Crichton</a> Polymorphic type inference is absolutely one of these affordances I had in mind. It seems all the languages in the ML family seem to be pretty good at that.</p>
<p><a href="https://twitter.com/hediet_dev">Henning Dieterichs</a> Completely agree. Abstractions remove detail; and that's exactly why everything gets a lot simpler if you use them right. If you have a thing and you only know that it has elements you can iterate over, you can implement a lot of algorithms on top of that, but you can't accidentally assume another property of that thing, because the compiler won't let you. In most imperative and/or dynamically typed languages it's easy to make such assumptions and as long as it works, you'll never know you did. Which might not be a problem, but I do think a lot of the complexity in refactoring comes from such assumptions that were only possible, because a much more specific (and therefore more powerful) type was used.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T02:43:35.000Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-18T02:43:35.000Z" class="date">2020-09-18 02:43:35</a> <div class="message"><p>Yes, in Haskell people are going to start with type variables because lowercase <code>a</code>, <code>b</code>, <code>c</code> translates into don't care, doesn't matter, no worries.  The place where you fall down a hole is where you have interacting type classes.  Next thing you know you're surrounded by multi-parameter type class with functional dependencies, type families, and worse.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T08:03:28.000Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-18T08:03:28.000Z" class="date">2020-09-18 08:03:28</a> <div class="message"><p>Good abstractions are helpful, bad abstractions are an obstacle. I don't expect much opposition to this statement. So the real question is how to deal with experimental abstractions, when working in a domain you don't understand very well. Is it better to abstract early or abstract late?</p>
<p>I like <a href="https://twitter.com/stefanlesser">Stefan Lesser</a>'s idea of exploring how various communities deal with this, but I think it would be even more instructive to extend this exploration beyond programming. We (in the sense of human societies) have a lot more experience with mathematical and engineering abstractions, for example.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T15:42:00.001Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-18T15:42:00.001Z" class="date">2020-09-18 15:42:00</a> <div class="message"><p>Yeah, I'm coming at this from my explorations of linguistics and my recently improved understanding of Christopher Alexander's pattern languages. It seems that an overlooked property of regular human language is that we are perfectly fine in communicating in abstract concepts all the time and there is no need to go and define everything all the way down to the nitty-gritty details as long as we roughly understand the words we use in the same way.</p>
<p>A form of applying this more or less directly to programming is to try to stay on that abstract level where a list is just that, and you go as long as you can without saying what's actually in the list. Of course, with programming languages you'll have to eventually provide some real specific values, if you want to see your program running and doing something. But if you did the generic part properly and your language supports it, it should be as easy as picking a few concrete values for a test case, stick them in, and it should just work (even if it doesn't verify the complete range of possible types/values), because your program is defined for all lists of any type, whatever type you end up using.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T15:50:11.001Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-18T15:50:11.001Z" class="date">2020-09-18 15:50:11</a> <div class="message"><p>What I'm looking at here though, is not the benefit of having more generic algorithms which can be reused (which is usually the motivation), but the benefit of not having to (and not being able to) define specifics before you have to. This is much closer to what Alexander has in mind when he talks about "unfolding", I think, and it is what I misunderstood about pattern languages â€” they weren't meant for reusable components, as Design Patterns will make you think â€” they were meant as a design technique that keeps you focused on the whole and leads you through a process of progressive refinement, step by step adding more details transforming, but never replacing or destroying the structure you have built thus far.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-19T06:08:45.009Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-19T06:08:45.009Z" class="date">2020-09-19 06:08:45</a> <div class="message"><p>Humans communicate in a context of shared abstractions. In programming we create formalizations for abstractions. Not sure this is comparable.</p>
<p>This reminds me of a long-ago discussion with colleagues about teaching mathematical concepts in physics. Is it better to start from examples and then develop abstractions, or start with the abstract and then introduce examples for illustration? There were good arguments on both sides.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-17T17:52:25.039Z" class="post"><span class="user">Nuno Leiria</span> <a href="#2020-09-17T17:52:25.039Z" class="date">2020-09-17 17:52:25</a> <div class="message"><p>Does anyone know of prior art on hot-reloading of data structures in programming languages? Similar to this: <a href="https://mun-lang.org/blog/2020/05/01/memory-mapping/"></a><a href="https://mun-lang.org/blog/2020/05/01/memory-mapping/">https://mun-lang.org/blog/2020/05/01/memory-mapping/</a></p>
</div> <div class="attachments"><blockquote><p>ðŸ”— <a href="https://mun-lang.org/blog/2020/05/01/memory-mapping/">Hot Reloadable structs: Memory Mapping</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2020-09-17T18:14:25.039Z" class="reply"><span class="user">Mariano Guerra</span> <a href="#2020-09-17T18:14:25.039Z" class="date">2020-09-17 18:14:25</a> <div class="message"><p>automatic? or can it be enabled by the runtime but manual? the Erlang virtual machine supports data structure migration on hot-reloading of a new release</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-17T20:22:28.040Z" class="reply"><span class="user">Emmanuel Oga</span> <a href="#2020-09-17T20:22:28.040Z" class="date">2020-09-17 20:22:28</a> <div class="message"><p>so that mun lang blog post, seems like the hot reloading requires a clever algorithm depending on whether the name of the fields of the struct are the same as before, etc. I wonder if a more intentional approach could work, like a refactoring tool that tells both the editor and the running program a certain field was migrated from one thing to the next.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-17T20:33:08.040Z" class="reply"><span class="user">Henning Dieterichs</span> <a href="#2020-09-17T20:33:08.040Z" class="date">2020-09-17 20:33:08</a> <div class="message"><p>I've been exploring hot reload in nodejs for a while now. I figured that most algorithms run in a couple of milliseconds, so rather than doing some unstable automatic migrations, restarting the last pure function + manual data migration works reasonable well.</p>
<p>(<a href="https://github.com/hediet/node-reload"></a><a href="https://github.com/hediet/node-reload">https://github.com/hediet/node-reload</a>)</p>
</div> <div class="attachments"><blockquote><p>ðŸ”— <a href="https://github.com/hediet/node-reload">hediet/node-reload</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-17T20:45:47.041Z" class="reply"><span class="user">Nuno Leiria</span> <a href="#2020-09-17T20:45:47.041Z" class="date">2020-09-17 20:45:47</a> <div class="message"><p><a href="https://twitter.com/warianoguerra">Mariano Guerra</a> Automatic. Developer makes changes to a data structure at runtime (struct, class, etc), those changes are picked up and propagated, and the program continues to run normally.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T08:06:09.001Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-18T08:06:09.001Z" class="date">2020-09-18 08:06:09</a> <div class="message"><p>Live programming systems have been doing this for decades. Smalltalk is probably the best example to study. When you change a class, all its instances get updated. Common Lisp has such a mechanism as well, but it's not automatic.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T08:58:49.001Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-18T08:58:49.001Z" class="date">2020-09-18 08:58:49</a> <div class="message"><p>Picked up and propagated is the trick.  There are a few different senses of propagation.  In Smalltalk and Lisp usually, adding a field or whatever will work with existing objects, but the new field won't have a value.  So there might be a bit of migration involved.  In other cases (Ruby sometimes), you might rebind the name MyRecord to something new so now the old my records refer to a class, or whatever, that isn't called MyRecord anymore.  A third thing you might want to do (what I often do) is you make a change and now you want to go back and rerun (over some scope) with that change replacing the objects with the new alternative.  And then, of course, you want to compare to see what the knock-on effects are of the change are between patched and unpatched possible worlds.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-18T18:24:16.002Z" class="reply"><span class="user">Nuno Leiria</span> <a href="#2020-09-18T18:24:16.002Z" class="date">2020-09-18 18:24:16</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> <strong>@William Taysom</strong> Thanks, could you point me to any references or papers I could have a look at specifically about this?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-19T06:02:19.004Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-19T06:02:19.004Z" class="date">2020-09-19 06:02:19</a> <div class="message"><p><strong>@Nuno Leiria</strong> Sorry, no references. I know these systems as a user, not as an academic.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-19T06:36:54.009Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-19T06:36:54.009Z" class="date">2020-09-19 06:36:54</a> <div class="message"><p>Curiously, no particular paper stands out in my mind.  The only academic insight that I have is that the semantics of how state responds to a change in definition corresponds to an ordering of monads.  And I only remember this faintly as a good example of how monads don't commute (as a rule) and why one shouldn't be too disappointed.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-20T06:46:25.018Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-20T06:46:25.018Z" class="date">2020-09-20 06:46:25</a> <div class="message"><p>Thatâ€™s indeed a very practical problem as well. Illustration: todayâ€™s Pharo stores code as a sequence of instructions in Git repositories. But those instructions donâ€™t reflect the order in which the changes were made interactively. If you understand the issues, thatâ€™s not too hard to deal with, but it must be hell for beginners.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
