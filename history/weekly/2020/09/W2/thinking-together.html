
<!doctype html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Future of Coding History</title>
    <link rel="stylesheet" href="https://marianoguerra.github.io/future-of-coding-weekly/history/style.css">
  </head>
  <body>
    <div id="ui">
      <a id="logo" href="https://futureofcoding.org">
        <img src="https://marianoguerra.github.io/future-of-coding-weekly/history/logo.svg" alt="Future of Coding History">
      </a>
      <div id="small-logo">
        <a href="https://futureofcoding.org">Future of Coding</a> History
      </div>
      <div id="center">
        <h4>
          You are viewing archived messages.<br>
          Go <a href="https://marianoguerra.github.io/future-of-coding-weekly/history">here</a> to search the history.
        </h4>
      </div>
      <div id="actions"></div>
    </div>
    <div id="msgs-output">
<div id="2020-09-06T17:07:13.118Z" class="post"><span class="user">nicolas decoster</span> <a href="#2020-09-06T17:07:13.118Z" class="date">üï∞Ô∏è 2020-09-06 17:07:13</a> <div class="message"><p>I am very interested in programming tools that non-experts can use. I.e. people that didn‚Äôt learn to program initially but want or need to sometimes.</p>
<p>Last week I have discussed with someone that could be interested in this kind of tool. And during the discussion about her use case, something appeared very clearly. In her journey in using programming, there are good chances that at one point she will need help from more experienced people. My feeling after that discussion is that this will be very common and that it is very important to take this into account early in the vision and the design of such tools or in the building of the community around it.</p>
<p>I.e. creating tools that allow non-experts to program, make them feel it is normal to not know everything, making it really easy for them to find some help, and make it easy for a more experienced programmer to give help for the programming task.</p>
<p>I guess I had this idea/feeling for some time, but I really feel its importance after that discussion.</p>
<p>What do you think of that? Do you have examples of tools/communities where this is taken very seriously? Or any research work on this? Be it for end-user programming or not (in fact even experts need help from ‚Äúmore‚Äù experts).</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-06T22:26:35.121Z" class="reply"><span class="user">larry</span> <a href="#2020-09-06T22:26:35.121Z" class="date">2020-09-06 22:26:35</a> <div class="message"><p>This is, I think, an excellent book on end-user programming. <a href="https://www.amazon.com/Small-Matter-Programming-Perspectives-Computing/dp/026228040X"></a><a href="https://www.amazon.com/Small-Matter-Programming-Perspectives-Computing/dp/026228040X">https://www.amazon.com/Small-Matter-Programming-Perspectives-Computing/dp/026228040X</a> It includes a significant discussion of the role of peer support</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.amazon.com/Small-Matter-Programming-Perspectives-Computing/dp/026228040X">A Small Matter of Programming: Perspectives on End User Computing</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-06T22:32:19.121Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-06T22:32:19.121Z" class="date">2020-09-06 22:32:19</a> <div class="message"><p>Indeed. Searching <a href="http://history.futureofcoding.org"></a><a href="http://history.futureofcoding.org">http://history.futureofcoding.org</a> for 'nardi' brings up some good past threads.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T02:45:34.121Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-07T02:45:34.121Z" class="date">2020-09-07 02:45:34</a> <div class="message"><p>Here's a way to put it... If you're making sufficiently rich software (from the end-user perspective), they are going to need help using it.  You can choose to assist them in getting help, or you can hope that users will self-organize a forum for helping each other.  Either way, help will be needed in order to get the most out of your software.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T06:24:21.122Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-07T06:24:21.122Z" class="date">2020-09-07 06:24:21</a> <div class="message"><p>This is a frequent situation in computational science as well. It's not quite end-user programming, but a mixture of next-to-end-user and end-plus-next-to-end-user programming. Typically collaboration of a domain expert with some computing knowledge and a software professional with some domain knowledge.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T09:54:12.122Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-07T09:54:12.122Z" class="date">2020-09-07 09:54:12</a> <div class="message"><p>I think there are increasing levels of end-user programmability:</p>
<ul><li>adjusting an app's configurations and settings, customising in your settings</li><li>simple rules: email filters, IFTTT</li><li>spreadsheet formulae; box-n-wire dataflow through function boxes</li><li>copying someone else's code and changing the obvious parameters, etc</li><li>doing lots of the above and realising it's become a massive program, then panic!</li></ul><p>So I think we're talking about the latter here? Where an EUP system is very easy to get into, but then as a result it's very easy to create a huge blob of dense, opaque programming?</p>
<p>I think it's important that the EUP system offers a model that is structured from the start, and where the normie programmer can draw on the work of others in a structured way, not just copy-pasting.</p>
<p>They should be able to build a complex system incrementally and safely because the structure enables them to see how both their own constructions come alive and also how the work of others operates, and to see the effects of their changes immediately.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T09:55:28.122Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-07T09:55:28.122Z" class="date">2020-09-07 09:55:28</a> <div class="message"><p>(needless to say, I'm designing Onex this way, in the hope of addressing this issue!)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T10:19:53.124Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-07T10:19:53.124Z" class="date">2020-09-07 10:19:53</a> <div class="message"><p>Of course, all this tech is irrelevant if you can't nurture a vibrant open source community that is willing to create examples and to help normies!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T13:29:57.125Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-09-07T13:29:57.125Z" class="date">2020-09-07 13:29:57</a> <div class="message"><p>Thanks <a href="https://twitter.com/duncancragg">Duncan Cragg</a> for your comment! You are right: an important thing I want to address is how to design a system that can manage the "panic" step. And you point that one way to do it, is to try to propose tools that limit the risk of occurrence of the panic, by offering a safe environment where complexity doesn't "hit" the programmer to late.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T13:37:10.125Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-09-07T13:37:10.125Z" class="date">2020-09-07 13:37:10</a> <div class="message"><p>But what I also want to address, is even if the programmer doesn't panic, there will be some points where obviously he misses some knowledge/experience/etc. that prevent him to go forward. And to keep going, some external help is needed.</p>
<p>So I would like to take this into account in the design of programming environments. This situations will always happen and how to improve the experience for both the one(s) that need/get help and the one(s) that give it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T13:40:29.125Z" class="reply"><span class="user">nicolas decoster</span> <a href="#2020-09-07T13:40:29.125Z" class="date">2020-09-07 13:40:29</a> <div class="message"><p><strong>@William Taysom</strong>:</p>
<blockquote><p>You can choose to assist them in getting help, or you can hope that users will self-organize a forum for helping each other.Here, I have already "choose to assist them in getting help", and moreover, the environment must be "between-users-help aware".</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T13:40:49.126Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-07T13:40:49.126Z" class="date">2020-09-07 13:40:49</a> <div class="message"><p>Well that is perhaps leading to an idea of a distributed, semantic (AST not text) IDE?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T11:06:02.134Z" class="reply"><span class="user">Don Abrams</span> <a href="#2020-09-08T11:06:02.134Z" class="date">2020-09-08 11:06:02</a> <div class="message"><p>It's also worth noting that decreasing scope can often reduce essential complexity; for example we could probably write some crazy huge language that can compile to all other languages but it'd likely be more useless than any of the others too. In the past I've seen a simple core, with pattern-based replacement for "optimization" work well, though the replacements often carry inexpressible constraints (leaky abstractions) and can increase complexity :/</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T16:32:47.135Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-08T16:32:47.135Z" class="date">2020-09-08 16:32:47</a> <div class="message"><p>Here's a doc on my site talking about this: <a href="http://object.network/onex-app.html"></a><a href="http://object.network/onex-app.html">http://object.network/onex-app.html</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="http://object.network/onex-app.html">Onex | The Object Network</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-08T16:34:33.135Z" class="reply"><span class="user">Duncan Cragg</span> <a href="#2020-09-08T16:34:33.135Z" class="date">2020-09-08 16:34:33</a> <div class="message"><p>In Onex, you already get a distributed "AST" graph for both rules and data, both of which can be edited by multiple users</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-02T18:10:10.092Z" class="post"><span class="user">Charlie Roberts</span> <a href="#2020-09-02T18:10:10.092Z" class="date">üï∞Ô∏è 2020-09-02 18:10:10</a> <div class="message"><p>Does anyone have tools / processes to recommend for rapidly iterating the design of a language? I‚Äôm looking for strategies to produce a document that captures the design, evolution, and potential variations of a language interface separate from implementation concerns. Good examples of this would also be very much appreciated!</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-07T16:03:38.126Z" class="reply"><span class="user">Jason Brennan</span> <a href="#2020-09-07T16:03:38.126Z" class="date">2020-09-07 16:03:38</a> <div class="message"><p>Reviving this thread üëã</p>
<p>One thing I‚Äôve found helpful is to consider: What sorts of things do you want people to be able to do with your system? What goals can they accomplish? How will their thinking be changed by using your system? Why should they turn to it, instead of something else? Don‚Äôt think about how you‚Äôll do this yet, just focus on human needs that need meeting.</p>
<p>From there, you can start to sketch out ideas (I‚Äôd start on paper, as it‚Äôs the most free form). Remember the needs and contexts of the people you‚Äôre trying to help! Are they best met with text files (and things like git, other source code tools) or are they better met with something more graphical? (Or really far out: are they best met with an entirely new kind of computer??)</p>
<p>At this point, I like to move into something more like a drawing tool (I use Sketch on the Mac) that lets me mock things up and write notes, spatially. I like to imagine different kinds of UIs for solving issues, and then I can write notes along side them, etc.</p>
<p>As far as actually prototyping these things, that‚Äôs where I struggle to do so rapidly (as far as real working systems go). But I think there‚Äôs something very powerful (and cheap!) about mocking things up in a drawing tool (or in a text file ‚Äî but beware, if you do everything in a text file, you‚Äôll probably narrow your ability to work on programming UX things provided by your environment)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T16:15:54.127Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-07T16:15:54.127Z" class="date">2020-09-07 16:15:54</a> <div class="message"><p><strong>@Jason Brennan</strong> the original thread seems to be about designing languages. I interpret that as about designing textual programming languages. Does prototyping those still have a limitation with text files? (Earlier phases certainly benefit from the ability to draw lines and boxes and so on.)</p>
<p>In general I'm a bit bemused by this thread. As a programmer it all feels quite waterfall-y. If you try to "mock up" a language before giving it a grammar you're quite likely to end up introducing ambiguities that need modifying the language to resolve. Similarly with many other aspects of the activity. If an activity eventually needs to be mapped on non-linear primitives (as computer programs do), it seems to me that it benefits from lots of feedback loops.</p>
<p>Funny story: the original waterfall diagram [1] had feedback loops between phases, so even waterfall practiced right can be quite effective. Of course, that's not what anybody means by the term anymore..</p>
<p>[1] <a href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf"></a><a href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf">http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf</a>, figure 3</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T16:21:40.127Z" class="reply"><span class="user">Jason Brennan</span> <a href="#2020-09-07T16:21:40.127Z" class="date">2020-09-07 16:21:40</a> <div class="message"><p>Yep! I still think there‚Äôs a ton of benefit to mocking this stuff up in a drawing of some kind, even if you‚Äôre doing a textual language.</p>
<p>There‚Äôs lots of ‚Äúprogramming experience‚Äù I hope everyone in here aims to include for their languages, like auto-complete, debugging tools, visualizations, etc. In my view, it‚Äôs better to design these things along with the language itself (not as goodies added on later), as they‚Äôll help you steer how you want the language to work.</p>
<p>Of course, as you say, it‚Äôs still important to have a somewhat working implementation to know the limits of what can be reasonably expressed in your language, but I look at that more as a limitation than a guiding tool</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T17:13:50.127Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-07T17:13:50.127Z" class="date">2020-09-07 17:13:50</a> <div class="message"><p>The tendency of grammars to become ambiguous is not a limitation of some single tool, it's more like a limitation of the universe you live in. It's a little bit like the speed of light. I suppose you could see it as a technical limitation of current technology rather than a property of the universe, but either way it seems as unfair as asking a carmaker why they haven't managed to add a fusion drive yet to their creation. If you create an ambiguous grammar, all your tools like autocomplete, visualizations, etc. have to now deal with the grammar. And the drag (amount of implementation needed) compounds over time.</p>
<p>Perhaps this is getting off-topic. I'll just reiterate that programming isn't just something you do once you know what you want. It's a tool in the toolbox for arriving at good designs.</p>
<p>"Writing doesn't just communicate ideas. It generates them." -- Paul Graham (<a href="http://www.paulgraham.com/writing44.html"></a><a href="http://www.paulgraham.com/writing44.html">http://www.paulgraham.com/writing44.html</a>)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T20:28:32.130Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-07T20:28:32.130Z" class="date">2020-09-07 20:28:32</a> <div class="message"><p>Ohhh, <a href="https://github.com/akkartik/mu">Kartik Agaram</a>, have you read A Timeless Way of Building? If you haven‚Äôt, you‚Äôd probably enjoy it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T20:35:52.130Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-07T20:35:52.130Z" class="date">2020-09-07 20:35:52</a> <div class="message"><p>I've read bits and pieces of it as others have pointed them out. But I really ought to. Particularly since I cited it in <a href="http://akkartik.name/akkartik-convivial-20200607.pdf"></a><a href="http://akkartik.name/akkartik-convivial-20200607.pdf">http://akkartik.name/akkartik-convivial-20200607.pdf</a> üòï</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T20:45:54.134Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-07T20:45:54.134Z" class="date">2020-09-07 20:45:54</a> <div class="message"><p>I never really got that Alexander had generative grammars in mind for what he calls pattern language. But that becomes quite clear in ATWoB. That elevates the concept to pretty much your description above. </p>
<p>Obviously, I can‚Äôt make you read a 500 page book, but please do and then tell me (us) what you think. :-)</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-08-29T07:01:21.204Z" class="post"><span class="user">Chris Pearson</span> <a href="#2020-08-29T07:01:21.204Z" class="date">üï∞Ô∏è 2020-08-29 07:01:21</a> <div class="message"><p>I'd like to know more about how Eve managed reactivity (eg 'commit vs bind' and the idea of tables that contain events). What worked well? Did later iterations/inspired projects tweak this approach? How (if at all) can lazy vs eager reactivity be managed using this approach?</p>
<p><a href="http://docs-next.witheve.com/v0.2/handbook/bind/"></a><a href="http://docs-next.witheve.com/v0.2/handbook/bind/">http://docs-next.witheve.com/v0.2/handbook/bind/</a></p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>üì∑ <a href="https://files.slack.com/files-pri/T5TCAFTA9-F019A98J6UX/image.png">image.png</a></p>
</blockquote>
</div> <div class="replies"><div id="2020-09-07T18:10:58.128Z" class="reply"><span class="user">Jamie Brandon</span> <a href="#2020-09-07T18:10:58.128Z" class="date">2020-09-07 18:10:58</a> <div class="message"><p>I think differential dataflows loops might be useful here. They allow having lexically scoped areas of ordered time, rather than having to try to mash everything into a single global timestep.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-07T18:37:58.128Z" class="reply"><span class="user">Chris Granger</span> <a href="#2020-09-07T18:37:58.128Z" class="date">2020-09-07 18:37:58</a> <div class="message"><p>Yeah with DD, you‚Äôre bringing more imperative control to the declarative-ness so you can try to manually resolve some of the semantic issues that arise (via a combination of careful ordering and explicit branching)</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-08T18:06:34.135Z" class="post"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:06:34.135Z" class="date">2020-09-08 18:06:34</a> <div class="message"><p>Is there any hope for end-user programming when programmers themselves don't use programming to solve their own problems?</p>
<p>For a long time, I've been asking myself the question about why more programmers don't use programming to solve their own problems, but it just occurred to me the implications of that to end-user programming. Does end-user programming ever have a chance of succeeding for non-programmers to solve their problems if programmers themselves aren't using programming to solve their problems?</p>
<p>When I say programmers don't solve their own problems with programming, what I mean is, there is sort of a ladder of useful techniques to use programming to make programming itself easier. It starts with customizing your shell or your text editor by cut-and-pasting code snippets you find online, and progresses to writing your own customizations from scratch, to writing your own shell/text editor extensions, and finally to writing your own full programs to solve your own problems.</p>
<p>I find it so odd that it's so rare for any of the programmers I know personally to progress beyond the first stage (some light shell/text editor customization by cut-and-pasting some code they found online). Since programmers are experts at programming, and they generally choose not to use solve their own problems with programming, what hope is there for end-users to use programming to solve their problems? Or is there something wrong with the lens I'm looking through here? Perhaps programmers are using programming to solve their own problems in a way I'm not seeing? (I.e., that aren't shell and text editor scripting)?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-08T18:10:26.136Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:10:26.136Z" class="date">2020-09-08 18:10:26</a> <div class="message"><p>We first need to articulate what is meant by "programming." Without a coherent definition, we will be at a loss to come up with some modified form of it called "end user programming." My view on this is that "telling a computer what to do, later" is a reasonable enough definition, and from that it's easy for us to see that most things done using a computer are "programming-like" already.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:10:52.136Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:10:52.136Z" class="date">2020-09-08 18:10:52</a> <div class="message"><p>The next stage is then to divorce the contemporary association of "programming" with languages and text editors</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:11:18.136Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:11:18.136Z" class="date">2020-09-08 18:11:18</a> <div class="message"><p>Using a computer involves using a computing environment, not a language</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:11:44.136Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:11:44.136Z" class="date">2020-09-08 18:11:44</a> <div class="message"><p>That environment can certainly prefer a language, or even deeply support a single language (see: older systems that boot into BASIC, etc)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:12:07.136Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:12:07.136Z" class="date">2020-09-08 18:12:07</a> <div class="message"><p>But what is important for everyone -- whether you are the power user called a "programmer" or the regular user today -- is the environment</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:12:41.137Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:12:41.137Z" class="date">2020-09-08 18:12:41</a> <div class="message"><p>What I mean by this is that there is not going to be a compelling "end user programming" experience in contemporary computing environments</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:12:48.137Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:12:48.137Z" class="date">2020-09-08 18:12:48</a> <div class="message"><p>I mean, many people work at companies on products they don‚Äôt themselves use. Part of the rise in the profession of Product Managers and Customer Success is to help bridge the gap to the end-users and their goals.</p>
<p>Programmers ALONE sitting in a cave probably can‚Äôt create programming tools / interfaces / languages that accidentally empower end-users. I would agree there</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:12:54.137Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:12:54.137Z" class="date">2020-09-08 18:12:54</a> <div class="message"><p>They are not designed with that goal in mind, and are in fact actively hostile towards it</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:13:16.137Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:13:16.137Z" class="date">2020-09-08 18:13:16</a> <div class="message"><p>yeah I broadly agree with <strong>@Eric Casteleijn</strong></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:13:30.137Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:13:30.137Z" class="date">2020-09-08 18:13:30</a> <div class="message"><p>the current software ecosystem is too complex and instills values that are somewhat counter to the goals of EUP</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:14:02.138Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:14:02.138Z" class="date">2020-09-08 18:14:02</a> <div class="message"><p>even if you built an awesome EUP tool like Excel, it will need to interface with a MySQL database or hosted in a cloud server somewhere or have complex permissions that enterprises need</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:14:16.138Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:14:16.138Z" class="date">2020-09-08 18:14:16</a> <div class="message"><p>Another way to look at this is to look at compelling examples from the past of end user programmable systems</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:14:21.138Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:14:21.138Z" class="date">2020-09-08 18:14:21</a> <div class="message"><p>thats why new mediums / platforms entirely are interesting. Like Dynamicland or VR / AR or some new platform entirely</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:14:53.138Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:14:53.138Z" class="date">2020-09-08 18:14:53</a> <div class="message"><p>there‚Äôs an opportunity to start greenfield on a hardware + software platform that‚Äôs uninteresting to existing programmers and build strong values &amp; cultural ideals around observability, understandability, and accessibility \</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:15:01.138Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:15:01.138Z" class="date">2020-09-08 18:15:01</a> <div class="message"><p>but thats not easy!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:15:40.139Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:15:40.139Z" class="date">2020-09-08 18:15:40</a> <div class="message"><p>Hypercard is a good example. It was great, and extremely popular in its own day. There are clones today -- why are they not as popular? My answer is because HC fit holistically into the OS of its day. It could do a large part of what the whole OS could do, but within its own environment</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:15:50.139Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:15:50.139Z" class="date">2020-09-08 18:15:50</a> <div class="message"><p><a href="https://twitter.com/SriniKadamati">Srini Kadamati</a> yeah I agree</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:16:38.139Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:16:38.139Z" class="date">2020-09-08 18:16:38</a> <div class="message"><p>Here's an analogy: why is it so hard to navigate the streets of older world cities? Because they've built atop themselves over the centuries, and were designed before mass transit, cars, etc</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:17:05.139Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:17:05.139Z" class="date">2020-09-08 18:17:05</a> <div class="message"><p>You couldn't build an NYC style grid layout on top of an old European city without razing the whole thing to the ground first</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:18:12.140Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:18:12.140Z" class="date">2020-09-08 18:18:12</a> <div class="message"><p>Likewise, a teletype-based operating system for time-sharing computing systems isn't going to easily "evolve" towards something that is amenable to end user programming</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:22:06.143Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:22:06.143Z" class="date">2020-09-08 18:22:06</a> <div class="message"><p>all good analogies. Here‚Äôs a more computing related one‚Ä¶ Microsoft was investigated for anti-trust b/c of Windows dominance and their shenanigans with IE. Google ended up being more important b/c they were kinda the homepage for the internet after 2000. Then, Apple ended up becoming super important b/c of their control of mobile.</p>
<p>But neither of these companies threatened Windows by fighting directly. They would have lost! Google tried to commodotize / trivialize the OS by focusing on the web (Search + chrome). Apple built a parallel platform that had nothing to do with Windows</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:22:10.143Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-08T18:22:10.143Z" class="date">2020-09-08 18:22:10</a> <div class="message"><p>The main reason I don't solve more of my problems with programming is that the tools for doing so are so clumsy that it's only worth it for really big jobs. There's an aspect of learnability (bash language is a nightmare) and of integration with the system (hooking most applications is a nightmare AFAIK, especially GUI)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:22:41.144Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:22:41.144Z" class="date">2020-09-08 18:22:41</a> <div class="message"><p>Most of these comments are (interesting) observations about why it‚Äôs hard for end-users to use existing environments for programming. Any comments specific to why programmers don‚Äôt use them for programming? (E.g., they write code as their job, but don‚Äôt write much code to do their job more effectively.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:23:33.144Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-08T18:23:33.144Z" class="date">2020-09-08 18:23:33</a> <div class="message"><p>I'm probably not the only programmer who started off trying to use programming to solve things, but got burned because it was just way more efficient to do it manually.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:23:46.145Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:23:46.145Z" class="date">2020-09-08 18:23:46</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a> it's the same reason</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:24:12.146Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:24:12.146Z" class="date">2020-09-08 18:24:12</a> <div class="message"><p>It's too complicated and takes too much time</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:24:23.146Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:24:23.146Z" class="date">2020-09-08 18:24:23</a> <div class="message"><p>Yeah totally makes sense, things like Bash seem incredibly clumsy until you try to use something else, and then realize it‚Äôs the task itself that‚Äôs clumsy (my interpretation)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:24:27.146Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:24:27.146Z" class="date">2020-09-08 18:24:27</a> <div class="message"><p>If you are a professional programmer, someone is paying you to do all that complicated stuff</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:24:32.146Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:24:32.146Z" class="date">2020-09-08 18:24:32</a> <div class="message"><p>But personal time is more valuable</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:25:25.148Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:25:25.148Z" class="date">2020-09-08 18:25:25</a> <div class="message"><p>That said, bash scripting and things of that sort definitely constitute programming, and developers do it for themselves all the time as far as I've seen</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:26:13.149Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:26:13.149Z" class="date">2020-09-08 18:26:13</a> <div class="message"><p>I do a ton of this kind of thing on company time, I usually automate all the things everyone is doing manually. But the people who do this work are maybe 1 out of 10 programmers in my experience.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:00.150Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:27:00.150Z" class="date">2020-09-08 18:27:00</a> <div class="message"><p>I think Bash is the most popular, but I still find it to be rare, but that would be an interesting data point if others find it less rare</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:03.150Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-08T18:27:03.150Z" class="date">2020-09-08 18:27:03</a> <div class="message"><p>The task is usually more burdened by accidental complexity than actually clumsy. That's the system integration aspect a couple of us have mentioned. Doing everything in plain text was cute but causes a lot of friction when working with structured data, especially when you have to convert between formats.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:28.150Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:27:28.150Z" class="date">2020-09-08 18:27:28</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a> can you clarify what you mean by:</p>
<blockquote><p> For a long time, I‚Äôve been asking myself the question about why more programmers don‚Äôt use programming to solve their own problems,</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:30.151Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:27:30.151Z" class="date">2020-09-08 18:27:30</a> <div class="message"><p>No <a href="https://twitter.com/robenkleene">Roben Kleene</a> I think you are right; most paid people are not doing it</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:33.151Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:27:33.151Z" class="date">2020-09-08 18:27:33</a> <div class="message"><p>what do you mean by ‚Äútheir own problems‚Äù?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:54.151Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:27:54.151Z" class="date">2020-09-08 18:27:54</a> <div class="message"><p>But most paid people are working in environments that are clumsy, archaic, and in many ways hostile</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:27:57.151Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:27:57.151Z" class="date">2020-09-08 18:27:57</a> <div class="message"><p>problems b/c of programming / their code? Or like problems in their life (e.g. too much time spent running errands)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:28:12.152Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:28:12.152Z" class="date">2020-09-08 18:28:12</a> <div class="message"><p>or like ‚ÄúI have too many meetings‚Äù</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:28:27.153Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:28:27.153Z" class="date">2020-09-08 18:28:27</a> <div class="message"><p>personally I don't write too many bash scripts because I'd rather shove a meat thermometer into my ear and wiggle it around. And if I'd rather to that, then I'm always up for just manually doing whatever the task is</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:28:55.153Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:28:55.153Z" class="date">2020-09-08 18:28:55</a> <div class="message"><p>yeah I do 0 bash scripting myself</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:29:02.154Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:29:02.154Z" class="date">2020-09-08 18:29:02</a> <div class="message"><p>often end up doing a lazy python script</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:29:37.154Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:29:37.154Z" class="date">2020-09-08 18:29:37</a> <div class="message"><p>Writing a bash script to do a huge find and replace programmatically, making scripts to quickly open projects they open over and over again, customizations, e.g., I always adding a shortcut to open hyperlinks from my text editor. It‚Äôs more lots of small things rather than one big thing.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:29:44.155Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:29:44.155Z" class="date">2020-09-08 18:29:44</a> <div class="message"><p>Then I think "maybe there is some linux program that does this" and I'm off to the races trying to find a command name that makes sense, usually dropping vowels for no reason</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:30:27.156Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:30:27.156Z" class="date">2020-09-08 18:30:27</a> <div class="message"><p>Yeah I think you'll find among Emacs users a higher concentration of people that do what you are suggesting. And I'd say part of the reason for that is the quality of the environment</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:30:30.156Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-08T18:30:30.156Z" class="date">2020-09-08 18:30:30</a> <div class="message"><p>Jeez, this thread is going fast. I'll wait for it to slow down, except to say: I don't understand <a href="https://twitter.com/robenkleene">Roben Kleene</a>'s original question, and why it assumes customizing is not programming, and why extensions are not programming. Why is only writing new full programs considered programming? Most of us only modify existing programs in our day jobs.</p>
<p>A founding ethos of programming is to do as little of it as possible. That's broadly true even in my vision of utopia.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:31:02.157Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:31:02.157Z" class="date">2020-09-08 18:31:02</a> <div class="message"><p>I always think of <strong>@Steve Krouse</strong> example he talked about a ‚Äúemail construction kit‚Äù, I keep thinking, wait a minute programmers already have that (Emacs) and they barely use it, and they already know how to program...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:31:08.157Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T18:31:08.157Z" class="date">2020-09-08 18:31:08</a> <div class="message">
<blockquote><p>Writing a bash script to do a huge find and replace programmatically, making scripts to quickly open projects they open over and over again, customizations, e.g., I always adding a shortcut to open hyperlinks from my text editor. It‚Äôs more lots of small things rather than one big thing.Now I see what you mean, kinda like ‚Äòautomate the boring things‚Äô.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:31:14.158Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:31:14.158Z" class="date">2020-09-08 18:31:14</a> <div class="message"><p>I'm with <a href="https://github.com/akkartik/mu">Kartik Agaram</a> here -- configuration is also "programming"</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:33:05.161Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-08T18:33:05.161Z" class="date">2020-09-08 18:33:05</a> <div class="message"><p>These seem worth reflecting on:</p>
<ul><li><p><a href="https://xkcd.com/1205"></a><a href="https://xkcd.com/1205">https://xkcd.com/1205</a></p>
</li><li><p><a href="https://xkcd.com/1319"></a><a href="https://xkcd.com/1319">https://xkcd.com/1319</a></p>
</li></ul></div> <div class="attachments"><blockquote><p>üîó <a href="https://xkcd.com/1205/">Is It Worth the Time?</a></p>
<p>üîó <a href="https://xkcd.com/1319/">Automation</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-08T18:33:19.161Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:33:19.161Z" class="date">2020-09-08 18:33:19</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> Those are all programming! My point is mainly that they stay low on the hierarchy, and don‚Äôt progress to writing their own customizations. E.g., when we talk about end users programming, presumably that‚Äôs more than cut and pasting a few common snippets online, and that‚Äôs about as far as most programmers go with their own environment (while I agree that 100%) qualifies as programming.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:35:55.164Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:35:55.164Z" class="date">2020-09-08 18:35:55</a> <div class="message"><p><strong>@Eric Gade</strong> I agree regarding Emacs, part of my inspiration for this question is why isn‚Äôt it more popular? And, furthermore, VS Code, which is arguably the most popular text editor ever, specifically makes these types of customizations harder (there‚Äôs no <code>.emacs</code> equivalent).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:36:59.165Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:36:59.165Z" class="date">2020-09-08 18:36:59</a> <div class="message"><p>Emacs is not more popular because it is designed to be a system that is text only</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:37:16.166Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:37:16.166Z" class="date">2020-09-08 18:37:16</a> <div class="message"><p>But the systems everyone uses -- even programmers -- have robust GUIs</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:37:38.166Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-08T18:37:38.166Z" class="date">2020-09-08 18:37:38</a> <div class="message"><p>Re the xkcd, if we haven‚Äôt been able to make automation a worthwhile time investment for experts, then what chance is there we'll be able to make it worthwhile for non-programmers?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:38:44.167Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:38:44.167Z" class="date">2020-09-08 18:38:44</a> <div class="message"><p>I think your question is a very good one actually</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:39:04.167Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:39:04.167Z" class="date">2020-09-08 18:39:04</a> <div class="message"><p>But I'd say that perhaps professional programmers are "experts" in many of the wrong things</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:39:56.167Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:39:56.167Z" class="date">2020-09-08 18:39:56</a> <div class="message"><p>Frankly if I was building a new computing system from the ground up, I would not want to work with most people trained in CS these days, or anyone who has extensive software development experience</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:44:24.167Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:44:24.167Z" class="date">2020-09-08 18:44:24</a> <div class="message"><p>My litmus for a computing system in 2020, both as a professional programmer and as a user, is this: can I easily create a button that does some task I want when I click it?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:44:38.168Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:44:38.168Z" class="date">2020-09-08 18:44:38</a> <div class="message"><p>The answer is no, both for the programmer and for the user</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:44:52.168Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T18:44:52.168Z" class="date">2020-09-08 18:44:52</a> <div class="message"><p>On some personal computing systems this used to be quite easy for both</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T18:54:02.168Z" class="reply"><span class="user">Jared Windover</span> <a href="#2020-09-08T18:54:02.168Z" class="date">2020-09-08 18:54:02</a> <div class="message"><p>For me the answer is that nothing feels like a stable foundation on which to build. If somebody wants to pay me to spend a majority of my time fixing previous code I and others wrote, that‚Äôs fine, but there‚Äôs something deeply frustrating about it when you see the extent to which your tools get in the way of your own vision. I don‚Äôt want to live in the command line, but that‚Äôs about the only place I feel confident that what I build can persist.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T19:00:38.168Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-08T19:00:38.168Z" class="date">2020-09-08 19:00:38</a> <div class="message">
<blockquote><p>... if we haven't been able to make automation a worthwhile time investment for experts, then what chance is there we'll be able to make it worthwhile for non-programmers?</p>
</blockquote>
<p>"There never was much hope, just a fool's hope"... but for some reason we're all in this Future of Coding thingy anyway. I see this as the exact problem we're here to solve.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T19:29:49.169Z" class="reply"><span class="user">Alexey Shmalko</span> <a href="#2020-09-08T19:29:49.169Z" class="date">2020-09-08 19:29:49</a> <div class="message"><p>I actually do automate a lot of things (and I use Emacs). Mainly because the emacs makes it easy to do.</p>
<p>For me, the important aspect is extensibility. In many cases there is an almost good solution but with one or two things I need to do differently. And too often the cost to modify the solution is about as hard as to reimplement it from scratch. Especially true for full-blown GUI and android apps.</p>
<p>For emacs, you can always take a half-baked solution, modify its code on the fly and you're done.</p>
<p>If I were to speculate about why others don't do the same and automate easy tasks, I would say that the tools have high learning curve. It took me quite a while before I started to feel proficient scripting Emacs. There is also an attitude problem‚Äînot all programmers know they can extend their editor and what's possible, so they don't even look for opportunities.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:01:01.174Z" class="reply"><span class="user">Garth Goldwater</span> <a href="#2020-09-08T20:01:01.174Z" class="date">2020-09-08 20:01:01</a> <div class="message"><p>in particular, i think that the majority of the ‚Äúold european cities‚Äù we‚Äôre living in we‚Äôre built for batch processes. most of the tasks i‚Äôd like to automate have to do with user input (the click a button example is really stark and appropriate). and that user input isn‚Äôt the start or end of the program. id really like pretty much any environment that gave me live insight into how eg keyboard shortcuts and button presses were flowing across the system, and similar insight into graphical primitives and responses. i can build data abstractions pretty much anywhere but gui and input processes always feel like i‚Äôm running a marathon with petulant snakes around my ankles</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:16:13.175Z" class="reply"><span class="user">Chris Knott</span> <a href="#2020-09-08T20:16:13.175Z" class="date">2020-09-08 20:16:13</a> <div class="message"><p>Another relevant xkcd;</p>
<p><a href="https://xkcd.com/974/"></a><a href="https://xkcd.com/974/">https://xkcd.com/974/</a></p>
<p>I think currently automation appeals to people who actually enjoy the problem solving aspect. The fact that it may or may not be massively more efficient is secondary. </p>
<p>I wrote a python script to combine image files into 2x2 combined images of 4, because it was slightly cheaper to print those as "single" images for my wedding than use the company's own quarter size print option. Probably only saved a few quid in total but I enjoyed the task.</p>
<p>This instinct is kinda orthogonal to people who like programming/computers.</p>
<p>I know people who come up with elaborate schemes for making sandwiches/wrapping presents/stuffing envelopes etc en masse. These type of people are the ones who will jump on end user programming when it becomes easier.</p>
<p>A lot of users though, aren't even using copy-paste, select all, find-replace etc yet</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://xkcd.com/974/">The General Problem</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-08T20:46:49.175Z" class="reply"><span class="user">Tak Tran</span> <a href="#2020-09-08T20:46:49.175Z" class="date">2020-09-08 20:46:49</a> <div class="message"><p>Maybe because we are programmers, we know the cost of creating/maintaining the things we make, so we rather spend our time doing other things. One quote that has stuck recently is, ‚ÄúIn software, anything is possible, but nothing is free‚Äù. Even though, I can certainly optimize some of the things I want to do, I don‚Äôt want to pay the time and effort to do so.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:48:47.176Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:48:47.176Z" class="date">2020-09-08 20:48:47</a> <div class="message"><p><a href="https://twitter.com/no_defects">Garth Goldwater</a> I will add that when I'm working on Smalltalk projects, I tend to make those kinds of buttons all the time, and just pop them out onto the desktop. I wish I could do it in macOS</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:50:37.176Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:50:37.176Z" class="date">2020-09-08 20:50:37</a> <div class="message"><p><a href="https://github.com/ChrisKnott">Chris Knott</a> There is lots of evidence from the past that the kind of division you are describing is more of a gradient. Apple used to be really good about this, not only with Hypercard, but also with Applescript, which they have shamefully allowed to die on the vine. Macs were the desktop publishing platform of choice because "users" could write Applescripts for performing tasks across applications like Illustrator and Quark etc</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:52:35.176Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:52:35.176Z" class="date">2020-09-08 20:52:35</a> <div class="message"><p>What I think is important in future systems is that they should be discoverable in the sense that you can "peel back a layer" and see how things work in some slightly more complicated context, and then when and if you are interested, peel back a subsequent layer. Ideally this would have manifested itself in, for example, a MacOS where the "top layer" was all described in HyperTalk/Applescript</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:52:42.176Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:52:42.176Z" class="date">2020-09-08 20:52:42</a> <div class="message"><p>But they never went that far</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:53:08.176Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:53:08.176Z" class="date">2020-09-08 20:53:08</a> <div class="message"><p>Now if you want to make your own buttons in macOS, say, you have to download xcode, learn about unix, build processes, and a full on programming language</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T20:53:33.177Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-08T20:53:33.177Z" class="date">2020-09-08 20:53:33</a> <div class="message"><p>There is nothing in between, and for no good reason!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T21:34:55.177Z" class="reply"><span class="user">Chris Granger</span> <a href="#2020-09-08T21:34:55.177Z" class="date">2020-09-08 21:34:55</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a> I eventually came to believe that it‚Äôd take a pretty significant societal shift for it to be realistic now. The time that many of us base our dreams on (the days of hypercard and VB6) just doesn‚Äôt exist anymore - there are now endless distractions and more apps to do what you want than you could ever begin to look at. In the earlier days of computing there was just.. less stuff. And it was more obvious that if you wanted something maybe you‚Äôd put it together yourself. Even with the perfect toolset, most people aren‚Äôt aware that they even could change things and even when you tell them they can, they don‚Äôt know what to do with it.</p>
<p>Fortunately if you take a longer view, there is one clear exception to that: contexts where you can use programming to build stories/worlds. Games like Minecraft, Roblox, etc, expose kids to programming in a way that isn‚Äôt ‚Äúlet‚Äôs do this faster,‚Äù but instead through the joy of making universes to explore. If I were going at this now, I‚Äôd be focused on building a path for the folks who grow up in those worlds to apply what they learned to the more mundane ‚Äúadult‚Äù life.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T21:39:02.177Z" class="reply"><span class="user">Chris Granger</span> <a href="#2020-09-08T21:39:02.177Z" class="date">2020-09-08 21:39:02</a> <div class="message"><p>We can definitely continue to lower the floor of programming and open it up to more people, but to achieve the true ‚Äúend-user programming‚Äù goal, we‚Äôd have to significantly change people‚Äôs relationship to computing. Realistically I think that‚Äôd take growing a generation.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T22:00:45.178Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T22:00:45.178Z" class="date">2020-09-08 22:00:45</a> <div class="message"><p>to second <a href="https://twitter.com/ibdknox">Chris Granger</a> in the early days, there weren‚Äôt these dominant platforms / models that everyone was already used to having. I think there‚Äôs optimism here if you look at other areas entirely where the experience &amp; tooling is very different for an end-user vs a professional.</p>
<p>Cooking is the best example I keep coming back. Home chefs / ‚Äôamateur‚Äôs use scaled down pots &amp; pans. Industrial kitchens are more like factories and use giant equipment that an ‚Äòend-user‚Äô would never really consider buying. But both of these are 100% valid industries and crafts. There‚Äôs more content targeting end-user home-chefs than there is for elite chefs. In theory, restaurants could provide 99% of the meals that all humans need but cost, cultural traditions, etc are still big barriers.</p>
<p>This has preserved home-cooking for literally centuries! If restaurants / central kitchens could provide all meals at the same cost as you making it, I predict we‚Äôd see a huge dip in home-cooking. Most people don‚Äôt make their own furniture anymore but pretty much everyone still cooks to some degree (even if you‚Äôre just microwaving food). Necessity is really the driver / mother of invention here. Home-cooking is still the best hammer for most people‚Äôs food problems</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-08T22:14:49.178Z" class="reply"><span class="user">Shalabh Chaturvedi</span> <a href="#2020-09-08T22:14:49.178Z" class="date">2020-09-08 22:14:49</a> <div class="message"><p>This just showed up on my feed and seems relevant.</p>
<p><a href="https://twitter.com/tayroga/status/1296538378255491072"></a><a href="https://twitter.com/tayroga/status/1296538378255491072">https://twitter.com/tayroga/status/1296538378255491072</a></p>
<p>Essentially programmers (and myself) do some programming for our own problems. But the systems we have aren't fundamentally designed for end user programability. So the burden is large. We do it more where some software has been designed for extension in some respects only - e.g write a plugin for your editor.</p>
</div> <div class="attachments"><blockquote><p>üê¶ <a href="https://twitter.com/@tayroga">Taylor Rogalski</a>: Alan Kay on end-user programming (WWDC 1990)</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-08T22:18:54.179Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-08T22:18:54.179Z" class="date">2020-09-08 22:18:54</a> <div class="message"><p>I like Alan‚Äôs heuristic of fist / hand of code, and then a  ‚Äúpage of code‚Äù. If adding something takes more than these‚Ä¶ the burden might be too much. Anyone (even kids) can quickly load code-context into their short-term memory and extend / modify software. Past that, you‚Äôre closer to a programmer</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T06:38:53.179Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-09T06:38:53.179Z" class="date">2020-09-09 06:38:53</a> <div class="message"><p>Speculation: The vision that Alan Kay describes in this talk hasn't been realized in mainstream software because it doesn't fit with how industrial societies see production as separate from consumption. We even use the economic  link between the two (money flow, GDP) as the measure of collective wealth. People solving their own problems don't contribute to GDP, so their work has no value for the economy.</p>
<p>If there is some truth to this, the good news is that industrial societies are slowly realizing that maximizing GDP isn't such a great idea. And in a way the FOSS movement is a first sign of this in the software world.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:09:27.184Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T13:09:27.184Z" class="date">2020-09-09 13:09:27</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> I agree but I think my comment from earlier adds another tidbit here:</p>
<p><a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599602445178200?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL"></a><a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599602445178200?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL">https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599602445178200?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL</a></p>
<p>There‚Äôs no economic story around end user programming. In my cooking analogy I give, making food yourself has pretty much always been cheaper than buying restaurant or mass produced food. There‚Äôs also been strong cultural ideals around cooking. But if it was ONLY the culture, I‚Äôd suspect very few people would cook.</p>
</div> <div class="attachments"><blockquote><p>[September 8th, 2020 3:00 PM] skadamat: to second &lt;@UEBG0NPDK&gt; in the early days, there weren‚Äôt these dominant platforms / models that everyone was already used to having. I think there‚Äôs optimism here if you look at other areas entirely where the experience &amp;amp; tooling is very different for an end-user vs a professional.</p>
<p>Cooking is the best example I keep coming back. Home chefs / ‚Äôamateur‚Äôs use scaled down pots &amp;amp; pans. Industrial kitchens are more like factories and use giant equipment that an ‚Äòend-user‚Äô would never really consider buying. But both of these are 100% valid industries and crafts. There‚Äôs more content targeting end-user home-chefs than there is for elite chefs. In theory, restaurants could provide 99% of the meals that all humans need but cost, cultural traditions, etc are still big barriers.</p>
<p>This has preserved home-cooking for literally centuries! If restaurants / central kitchens could provide all meals at the same cost as you making it, I predict we‚Äôd see a huge dip in home-cooking. Most people don‚Äôt make their own furniture anymore but pretty much everyone still cooks to some degree (even if you‚Äôre just microwaving food). Necessity is really the driver / mother of invention here. Home-cooking is still the best hammer for most people‚Äôs food problems</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-09T13:10:30.185Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T13:10:30.185Z" class="date">2020-09-09 13:10:30</a> <div class="message"><p>Commercial software is so so cheap because of the 0 distribution cost of software. The ‚Äòjunk food‚Äô / ‚Äòprocessed food‚Äô of software is good enough for most people most of the time</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:13:29.185Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T13:13:29.185Z" class="date">2020-09-09 13:13:29</a> <div class="message"><p>I think its interesting to think about areas, users, personas, use cases, etc where customization, culture, and cost are aligned towards EUP.</p>
<ul><li>Creative art. Sure many folks use Photoshop and what not, but people are willing to experiment with new tools if they can express themselves in new ways.</li><li>Kids / K-12. There‚Äôs definitely pressure to ‚Äúteach Python for jobs‚Äù or w/e but many kids intrinsically don‚Äôt yet care about jobs and more about creative activities / things that solve problems now for them (e.g. setting up Minecraft servers or making their own games)</li><li>Non-technical users that dream of making technical things. I found out from this Slack that a lot of the award winning game Hollow Knight was created using Playmaker (no-code / wires &amp; boxes editor for Unity). The creators didn‚Äôt let their lack of deep coding skills stop them!</li><li>Data science. This is my world, and the trend here is to make everything work via a SQL interface, literally. SQL is learnable by pretty much anyone IMO (my mom struggled with Java and Python but is better at SQL than me!). Getting analysts to learn Python is a big ask and people worry about mistakes that could be make (plus that type of code is harder to audit). Also, I‚Äôll throw in obligatory popularity of Excel here! You still got the ML in Python people but most analysts and less technical people don‚Äôt necessarily want Python / R right away.</li><li>Note taking / personal organization. There‚Äôs a subset of note-taking (2nd brain, Roam, Digital Garden etc) who are interested in adapting their current tools even more to their personal workflows &amp; preferences and don‚Äôt mind simple scripting.</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:18:08.185Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T13:18:08.185Z" class="date">2020-09-09 13:18:08</a> <div class="message"><p>When <a href="https://twitter.com/ibdknox">Chris Granger</a> says we need a cultural change, he‚Äôs right. Our culture is utilitarian and wrapped in short-termism. This is reflected in computing as well.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:19:01.186Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T13:19:01.186Z" class="date">2020-09-09 13:19:01</a> <div class="message"><p>FOSS is good in some ways, but kind of counterproductive structurally: we know from the 60s and 70s that in order to get truly qualitative leaps in computing, we need to fund people for longer periods of time with not so many restrictions. The current economic thinking precludes that kind of funding model</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:19:42.186Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T13:19:42.186Z" class="date">2020-09-09 13:19:42</a> <div class="message"><p>Additionally, as <a href="https://twitter.com/SriniKadamati">Srini Kadamati</a> has pointed out, our education system has also become a victim of this cultural shift. Students are not educated, but rather trained for jobs. Hence the obsession with ‚Äúteaching kids to code‚Äù</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:20:59.186Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T13:20:59.186Z" class="date">2020-09-09 13:20:59</a> <div class="message"><p>FOSS kind of reinforces all this by providing increments upon the leaps of the previous generation, without providing a means for future leaps. Corporate sponsorships and people doing projects in their free time isn‚Äôt going to cut it. They need the means to follow sometimes errant paths for years at a time, and they need to be funded during that time so they can concentrate</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:22:42.186Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T13:22:42.186Z" class="date">2020-09-09 13:22:42</a> <div class="message"><p>I respect the whole free software / libre movement, but if there is not a change to the greater political economy, it‚Äôs going to be a movement that noodles around in unix and other partial techs from the 70s until the end of time</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T13:44:34.187Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T13:44:34.187Z" class="date">2020-09-09 13:44:34</a> <div class="message"><p>I share all of your thoughts <strong>@Eric Gade</strong> and sentiments. There‚Äôs a pessimistic and an optimistic view, but the nature of the change of revolutions seems to be about the niches that adopt these ideas.</p>
<p>The good thing with some of the areas I listed above is that I feel / think that those end-users are a bit more patient. They want to do more with less and they‚Äôre willing to try tools that are different but can enhance their workflow.</p>
<p>There‚Äôs still the ‚Äúintegration with existing tools / workflow‚Äù problem though. The data science one is that ultimately any fancy EUP tooling still has to talk to a clunky big database. With art, people expect similar formats as the output (SVG, PNG, MP4, etc).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T15:41:37.187Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T15:41:37.187Z" class="date">2020-09-09 15:41:37</a> <div class="message"><p><a href="https://twitter.com/SriniKadamati">Srini Kadamati</a> Great examples! I'm particularly interested in the Hollow Knight story, if you happen to have a link or any other source I'd love to read more about it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T15:52:03.187Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T15:52:03.187Z" class="date">2020-09-09 15:52:03</a> <div class="message"><p>The theme of the responses here seems to be: Only a small percentage of people are interested in using programming to improve their own workflow, but much more people are interested in using programming to build things to share. Which I think resolves my initial conundrum about programmers not using programming to solve their own problems: I was looking at scripting and customization, but what I probably should have been looking at is things like side projects and personal sites. Which to me seem much more popular than scripting/customization?</p>
<p>There might be a lesson for end-using programming here too: It's probably better to focus on tools that let people create things for other people than it is to focus on anything that you'd call "automation".  For whatever reason most people aren't interested in automation (maybe just because it's not worth the time, e.g., the relevant xkcds)? But they are interested in building things to share, e.g., see the Hollow Knight example above. This seems consistent with the no code movement going on as well.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:20:25.188Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T16:20:25.188Z" class="date">2020-09-09 16:20:25</a> <div class="message"><p>Perhaps expressiveness &gt; utility</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:23:34.188Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-09T16:23:34.188Z" class="date">2020-09-09 16:23:34</a> <div class="message"><p>Lots of good contributions here... just one more comment on the "most people don't need more than ready-made apps" argument: that's really a cultural issues. People need food and shelter, plus whatever it takes to become a worthy and respected member of their society. Software is new, it appeared when our societies were already well into an industrial mindset of production and consumption. Other DIY activities, including cooking, have been part of our culture since long before the industrial era. One reason people cook at home is that they grew up seeing other people do it, and they have seen the advantages (economic, social, etc.) it brings. In a culture without end-user programming, it's not surprising that few people miss it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:26:33.188Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T16:26:33.188Z" class="date">2020-09-09 16:26:33</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a> <a href="https://twitter.com/AsherVo/status/1293653951309426688"></a><a href="https://twitter.com/AsherVo/status/1293653951309426688">https://twitter.com/AsherVo/status/1293653951309426688</a></p>
</div> <div class="attachments"><blockquote><p>üê¶ <a href="https://twitter.com/@AsherVo">Asher Vollmer</a>: Just learned that Hollow Knight was coded almost entirely in a visual scripting language. <a href="https://unity.com/madewith/hollow-knight">https://unity.com/madewith/hollow-knight</a> <a href="https://pbs.twimg.com/media/EfP7YtFVAAAENhQ.png">https://pbs.twimg.com/media/EfP7YtFVAAAENhQ.png</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-09T16:28:36.189Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T16:28:36.189Z" class="date">2020-09-09 16:28:36</a> <div class="message"><p>Thanks! Made in Unity with Playmaker (which I'd never heard of) <a href="https://assetstore.unity.com/packages/tools/visual-scripting/playmaker-368"></a><a href="https://assetstore.unity.com/packages/tools/visual-scripting/playmaker-368">https://assetstore.unity.com/packages/tools/visual-scripting/playmaker-368</a> Just amazing!</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://assetstore.unity.com/packages/tools/visual-scripting/playmaker-368">Playmaker | Visual Scripting | Unity Asset Store</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-09T16:32:11.189Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T16:32:11.189Z" class="date">2020-09-09 16:32:11</a> <div class="message">
<blockquote><p>The theme of the responses here seems to be: Only a small percentage of people are interested in using programming to improve their own workflow,&nbsp;&gt; but much more people are interested in using programming to build things to share&gt; . Which I think resolves my initial conundrum about programmers not using programming to solve their own problems: I was looking at scripting and customization, but what I probably should have been looking at is things like side projects and personal sites. Which to me seem much more popular than scripting/customization?</p>
</blockquote>
<p>I would nuance this more. Clayton Christenssen / Jobs-to-be-done framework and all these other stuff from product management land (disclaimer: I used to be a PM) emphasize that people don‚Äôt care about your product. They care about making progress towards a problem they have and they may hire your product / service or another one based on how well it solves their needs.</p>
<p>Cooking food solves many problems for people (cost to feed family, taste ‚Äî restaurants can‚Äôt quite replicate home food taste for many, convenience once you know how to cook, feeling of self-sustenance, social ‚Äî cooking for others, and probably 5 more). Getting food delivered is a worse proposition in many cases (except when you‚Äôre busy or money isn‚Äôt a concern or you want specific cuisine). Right now, most programming doesn‚Äôt solve problems people have today. It‚Äôs not ‚Äòeconomically‚Äô a better solution for anything for most people.</p>
<blockquote><p>using programming to improve their own workflow,&nbsp;&gt; but much more people are interested in using programming to build things to share&gt; . </p>
</blockquote>
<p>There ARE people who care about improving their workflow. Bankers and traders üôÇ they learn the shit out of Excel and use it to automate their workflow, check for errors, etc. B/c it literally saves them time and helps them make more money or get an advantage in the market.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:47:08.189Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T16:47:08.189Z" class="date">2020-09-09 16:47:08</a> <div class="message"><p>Regarding bankers and traders, do you think a higher percentage of those groups customize their workflow with scripts than programmers customize their workflows? Sort of my starting theses is that for programmers, using programming to improve their own workflow is niche. I'd be very curious if there are other industries where using programming to improve their workflow is mainstream (for that industry).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:48:46.189Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T16:48:46.189Z" class="date">2020-09-09 16:48:46</a> <div class="message"><p>no idea tbh, but I know a large % of them maximize the hell outta Excel. They really learn them well. Maybe programmers do this in other ways (customize their emacs setup, or their shell setup or w/e for little wins here / there).</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:49:23.190Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T16:49:23.190Z" class="date">2020-09-09 16:49:23</a> <div class="message"><p>I mean we have an eng team at work and they‚Äôre constantly looking for ways to improve the cloud deployment infrastructure, speeding up test suite, etc. I categorize those as ‚Äòworkflow improvements‚Äô even though they accrue to all engineers in an org instead of just the engineer themselves</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T16:52:12.190Z" class="reply"><span class="user">Shalabh Chaturvedi</span> <a href="#2020-09-09T16:52:12.190Z" class="date">2020-09-09 16:52:12</a> <div class="message"><p>Re "FOSS being counterproductive strategically" - this twitter has interesting takes: <a href="https://twitter.com/jonathoda/status/1104522585092481024"></a><a href="https://twitter.com/jonathoda/status/1104522585092481024">https://twitter.com/jonathoda/status/1104522585092481024</a></p>
<p>Hypothetically lets say what's holding us back is poor forms of composition and the existing ontology of computing, so we need to design new forms that scale up better. However to be adopted we must be compatible with the existing world and so "compose" with it - so we perpetuate the existing composition and ontology models. This affects both commercial and free/open source software. Might affect side projects more because of a greater need to 'fit in'.</p>
</div> <div class="attachments"><blockquote><p>üê¶ <a href="https://twitter.com/@jonathoda">Jonathan Edwards</a>: Open source slows progress in software technology by demonetizing it. <a href="https://twitter.com/AmarachiAmaechi/status/1104383478483902464">https://twitter.com/AmarachiAmaechi/status/1104383478483902464</a></p>
<p>üê¶ <a href="https://twitter.com/@AmarachiAmaechi">Amycruz üë©üèΩ‚Äçüíªüë©üèΩ‚Äçüíªüë©üèΩ‚Äçüíª</a>: UNPOPULAR OPINION: TECH EDITION</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-09T16:57:42.190Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-09T16:57:42.190Z" class="date">2020-09-09 16:57:42</a> <div class="message"><p>yeah I saw Jonathan‚Äôs tweet when it went out and it really made me ponder! At work, we‚Äôre commercializing / stewarding this viz / BI tool called Apache Superset - <a href="https://github.com/apache/incubator-superset"></a><a href="https://github.com/apache/incubator-superset">https://github.com/apache/incubator-superset</a> but right now the #1 reason people use Superset and leave PowerBI / Tableau is because ‚Äúwe‚Äôre free‚Äù lol. We haven‚Äôt leveled up yet on the value front</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/apache/incubator-superset">apache/incubator-superset</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-09T17:01:54.190Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T17:01:54.190Z" class="date">2020-09-09 17:01:54</a> <div class="message"><p>I‚Äôve described it this way. I think of FOSS and perhaps establishment computing today as being like the medieval scholastics. The certainly produced a lot of work, even original work in some sense, but it was all confined to Aristotelian thinking, and their contributions were increments on rehashing Aristotle. For centuries.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:02:32.191Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T17:02:32.191Z" class="date">2020-09-09 17:02:32</a> <div class="message"><p>There‚Äôs lots of cool stuff out there in FOSS that makes a lot of different things possible in computing (though we should be honest that most of those things are commercially useful)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:02:47.191Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T17:02:47.191Z" class="date">2020-09-09 17:02:47</a> <div class="message"><p>But that doesn‚Äôt mean FOSS isn‚Äôt rehashing unix forever. It seems that‚Äôs what is happening</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:03:03.191Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-09T17:03:03.191Z" class="date">2020-09-09 17:03:03</a> <div class="message"><p>Look on HN where any discussion of a ‚Äúnew operating system‚Äù is really just a new linux distribution</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:05:00.191Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T17:05:00.191Z" class="date">2020-09-09 17:05:00</a> <div class="message"><p>Regarding:</p>
<blockquote><p>I mean we have an eng team at work and they‚Äôre constantly looking for ways to improve the cloud deployment infrastructure, speeding up test suite, etc.</p>
</blockquote>
<p>Personally, I've struggled to get other engineers interested in working on these things, but of course that's extremely anecdotal. I'd love to hear perspectives from others on this.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:07:32.191Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T17:07:32.191Z" class="date">2020-09-09 17:07:32</a> <div class="message"><p>Regarding Unix, the general pattern seems to be moving towards Unix system, e.g., Windows Linux Subsystem. My interpretation of that is that consumer computers seem to be going the way of locked-down smartphones, so traditional computer operating systems are mainly for programmers and other "heavy" workflows (media editing, etc...). There's just too much infrastructure on Unix systems to support those workflows to do anything else.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:12:05.192Z" class="reply"><span class="user">Tak Tran</span> <a href="#2020-09-09T17:12:05.192Z" class="date">2020-09-09 17:12:05</a> <div class="message">
<blockquote><blockquote><p>I mean we have an eng team at work and they‚Äôre constantly looking for ways to improve the cloud deployment infrastructure, speeding up test suite, etc.</p>
</blockquote>
</blockquote>
<p>Personally, I‚Äôve struggled to get other engineers interested in working on these thingsI think when an org is big enough to have an internal products or platform team, they would work on these optimization/efficiency/infrastructure tasks.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T17:44:05.192Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-09T17:44:05.192Z" class="date">2020-09-09 17:44:05</a> <div class="message"><p>In my experience, once an org reaches a certain size, there will be a dedicated team to maintain this stuff, but until then no one really wants to work on it. (Which I find so odd, because if there are any problems with it, if you're a dev, you're feeling those problems on a daily basis.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T20:07:20.192Z" class="reply"><span class="user"></span> <a href="#2020-09-09T20:07:20.192Z" class="date">2020-09-09 20:07:20</a> <div class="message"><p>I agree, based on working at a company with about 200 engineers. In a startup there is a lot of firefighting and pressure to launch / work on user-facing products, and infrastructure can be just good enough. When you have permission and management support (and even incentives) to make infrastructure really solid, then you can fix a lot of systemic problems.</p>
<p>At the opposite end, you can go on infrastructure vision quests, making something that other devs don't want to use, etc.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-09T23:59:58.193Z" class="reply"><span class="user">larry</span> <a href="#2020-09-09T23:59:58.193Z" class="date">2020-09-09 23:59:58</a> <div class="message"><p>It's probably been said in the other 109 comments, but more people would shell script if the tool names and interfaces weren't so incredibly unmemorable. Is anti-memorable a thing?  (I just decided it is.) The interface kinda stinks.</p>
<p>Git has an anti-memorable user interface, but by building GitHub and the GitHub desktop on top, it's now pretty easy to use without the fear of never seeing your code again. More people use git (i'm guessing) than shell scripts, even though its command line interface is irregular, dangerous, and unpredictable.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T01:10:26.194Z" class="reply"><span class="user">Garth Goldwater</span> <a href="#2020-09-10T01:10:26.194Z" class="date">2020-09-10 01:10:26</a> <div class="message"><p>was just checking out some of bessemer‚Äôs recently released investment memos and i think an argument can be made that Shopify is actually a great example of an end-user programming success story: <a href="https://www.bvp.com/memos/shopify"></a><a href="https://www.bvp.com/memos/shopify">https://www.bvp.com/memos/shopify</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://www.bvp.com/memos/shopify">Shopify</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-10T01:16:20.195Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-10T01:16:20.195Z" class="date">2020-09-10 01:16:20</a> <div class="message"><p>yeah I agree. Shopify is a beast of a company and they aren‚Äôt interested in trying to centralize everyone onto a vague platform like Medium did. They embraced ‚Äúthe edges‚Äù</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T06:02:14.196Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-10T06:02:14.196Z" class="date">2020-09-10 06:02:14</a> <div class="message"><p>I might be missing it in the thread here, but one reason even programmers don't script things is that there's no good way to do it, a huge gap between interacting with a GUI and automating the interactions.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T06:17:48.204Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-10T06:17:48.204Z" class="date">2020-09-10 06:17:48</a> <div class="message"><p>Coming back to this thread, I am wondering; what is that "programmer" category? Professional software developers, perhaps? Is that a sufficienly homogeneous group in their professional practices to discuss how much they develop software for their own needs?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T23:56:07.228Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-09-10T23:56:07.228Z" class="date">2020-09-10 23:56:07</a> <div class="message"><p>My perspective: I did more "end-user programming" before I was a programmer, but knew enough programming to be useful. This was at an office job, where everything ran on Excel. I was doing lots of web scraping, data processing, making small tools for tedious tasks, etc.</p>
<p>Then I got a job doing programming, and didn't have any material problems to solve with programming any more!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T00:00:21.228Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-09-11T00:00:21.228Z" class="date">2020-09-11 00:00:21</a> <div class="message"><p>So, to the question:</p>
<p>"Does end-user programming ever have a chance of succeeding for non-programmers to solve their problems if programmers themselves aren't using programming to solve their problems?"</p>
<p>my answer is:</p>
<p>"yes! Non-programmers have way more problems solvable with programming than programmers do"</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T00:11:30.232Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-09-11T00:11:30.232Z" class="date">2020-09-11 00:11:30</a> <div class="message"><p>To the specific point in the original post about some programmers not customizing their programming tools:</p>
<p>one hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools. </p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T11:00:09.269Z" class="reply"><span class="user">Chris Knott</span> <a href="#2020-09-11T11:00:09.269Z" class="date">2020-09-11 11:00:09</a> <div class="message"><p>My experience definitely matches <a href="https://twitter.com/yoshikischmitz">yoshiki</a>'s (although I went the other direction, out of software development).</p>
<p>The amount of menial, manual use of computers that goes on in the world is a travesty. I'm talking about stuff like physically typing filenames into a Word doc.</p>
<p>It's long been recognised that a manager might send emails to her staff, instructing them to do some task on a computer, in a way that is almost pseudocode. e.g. "can you go through every sales report on the K drive for February and check if any of the unit codes have expired?".</p>
<p>End user programming should be looking to eliminate the middle human from this kind of human-&gt;human-&gt;computer situation.</p>
<p>This is the type of thing that SQL was meant to eliminate, but it didn't. I think the issue is solutions like SQL demand too much subservience in how information is managed, and they want it stored in a way that is different to how humans would naturally do it. The also demand labour up front (at the point of storing), for no immediate reward, which is always a foolishly optimistic thing to require.</p>
<p>I have high hopes for a system that approaches the OS from the same perspective as the user, for example all text OCRed, structure automatically inferred from physical layout etc.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T13:35:11.269Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T13:35:11.269Z" class="date">2020-09-11 13:35:11</a> <div class="message"><p><a href="https://github.com/ChrisKnott">Chris Knott</a> Totally agree about the manager request example. I did a freelance job a couple of years ago for a non profit. They really just needed a specific way to process bank account information from several online services into an Excel template they used. The people working there knew exactly ‚Äúwhat needed to happen,‚Äù but the tools on their system had no way for them to express it, and the services they were using were siloed from each other</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T13:36:04.270Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T13:36:04.270Z" class="date">2020-09-11 13:36:04</a> <div class="message"><p>In the end I had to make them a quick electron app that did it, and it was really eye opening how complicated the programming task was even though the real task was conceptually simple, and all the ‚Äúparts‚Äù were already there in the system</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T13:36:45.270Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T13:36:45.270Z" class="date">2020-09-11 13:36:45</a> <div class="message"><p>As time has passed, I consider the design that got them (and myself) into that position to be hostile. But it gave me work, just like poor design gives programmers work every day across the world</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:43:54.271Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T15:43:54.271Z" class="date">2020-09-11 15:43:54</a> <div class="message"><p>Regarding:</p>
<blockquote><p>one hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools.</p>
</blockquote>
<p>This is an interesting perspective, and I believe it's true to an extent, e.g., while almost every powerful application from Excel to Photoshop to DAWs has a cottage industry of extensions that surround it, it's certainly true that developer tools dwarf the others in quantity of existing customizations.</p>
<p>But I still see a lot of contrary evidence. E.g., it still seems that most programmers, when they encounter a problem with a programmatic solution, they'll tend to choose a manual solution. The canonical example is automated testing. While automated testing has certainly become popular, it still seems to be in the "eat your vegetables" category, instead of something programmers just do naturally. Which is odd if you think about it, because manual testing is just that, manual, and programmers are master automators, so...?</p>
<p>More personally, what I find most fulfilling about writing my own scripts and customizations is that I can make the software behave the way I want it to. When you're using someone else's customizations you're always at the mercy of the creator's decisions. I don't think that wishing your tools worked differently is rare, that's a sentiment that I feel almost every computer user has, but programmers are the only group that's empowered to change how their tools work today, and for the most part, they still choose not to.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:50:00.271Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-11T15:50:00.271Z" class="date">2020-09-11 15:50:00</a> <div class="message"><p>I‚Äôll challenge some of your assumptions here <a href="https://twitter.com/robenkleene">Roben Kleene</a> not sure if this is useful, but could be another perspective!:</p>
<ul><li>Automating isn‚Äôt always better than manual. Clicking through a new UI sequence can give you the ULTIMATE end-user gut check. Things can still go wrong (caching, what have you) but less is likely to go wrong. You can build a burrito robot but unless you taste the burrito at the end with your own mouth, you just don‚Äôt know if everything worked as you thought it would.</li><li>Automation is often less concrete / tangible. Similar to the first 1, but automation is also more abstraction. Abstraction is complexity. Even if the automation script is something simple, there‚Äôs overhead now to maintain a list of automations. Perhaps we need better ‚Äòautomation interfaces‚Äô where the overhead is brought to 0. Analogy: I don‚Äôt think about not eating cookies in my day to day, I just don‚Äôt keep cookies in the house. 0 overhead!</li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:51:55.271Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T15:51:55.271Z" class="date">2020-09-11 15:51:55</a> <div class="message"><p>I agree 100% with both of these points. I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric besides my own personal preference.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:53:38.272Z" class="reply"><span class="user">Srini Kadamati</span> <a href="#2020-09-11T15:53:38.272Z" class="date">2020-09-11 15:53:38</a> <div class="message"><p>this is a long thread‚Ä¶ it could be interesting to fork and start a new thread and this time include like 5-10 concrete examples in your life / things you‚Äôve seen other programmers do <a href="https://twitter.com/robenkleene">Roben Kleene</a> etc to spark the discussion!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:54:31.272Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T15:54:31.272Z" class="date">2020-09-11 15:54:31</a> <div class="message"><p>I'd also say that "how can doing things manually still be better than automating them in 2020?" Because I believe that it's still better for many, possibly even most, cases is one of the central questions I'm grappling with.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T16:49:14.273Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-11T16:49:14.273Z" class="date">2020-09-11 16:49:14</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a>: Nooooooo! üòÑ It seemed like you were moving towards the light here:</p>
<blockquote><p>I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric..But then you immediately put your blind spot back on in the next comment:</p>
<p>how can doing things manually still be better than automating them in 2020?That framing is only going to lead you in circles. As <a href="https://twitter.com/SriniKadamati">Srini Kadamati</a> pointed out above, and as I tried to say in the overflow thread ‚Ü™:</p>
</blockquote>
<ul><li><p>The line between 'manual' and 'automated' is fuzzy on the computer. If I switch windows and type a command on the shell, I'm still making use of automation. Just less of it.</p>
</li><li><p>Adding levels of automation always has costs. If it seems always a good idea to you, just wait a few years. We can improve lots of things here, but it's just not a reasonable goal to aim for "adding levels of automation should always improve life". There will always be situations where doing something manual is simpler, faster, less alienating. Start developing some warm and fuzzy feeling for doing things manually.</p>
</li><li><p>Desire for automation is subjective to some extent, as you pointed out in your first comment.</p>
</li></ul><p>I'd say join me over here where the goal isn't automation but comprehension. Practice throwing kicks not because kicks are always a good idea, but just so you build up judgment on when to use a kick, and so you can do a lot more with a single kick when the moment arrives.</p>
<p>(Movie recommendation: <a href="https://www.imdb.com/title/tt0061770"></a><a href="https://www.imdb.com/title/tt0061770">https://www.imdb.com/title/tt0061770</a>)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T17:55:32.274Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T17:55:32.274Z" class="date">2020-09-11 17:55:32</a> <div class="message">
<blockquote><p>Adding levels of automation always has costs. If it seems always a good idea to you, just wait a few years.I think you're misunderstanding me here, I'm specifically saying I don't always think automation is a good idea, I'm saying that it's the way I prefer to solve problems. It's an inclination that has more to do with me, than it does the problem. Correspondingly, I tend to choose to solve problems my approach is a good fit for. I do a lot of work with frameworks, where automated testing is more important. I tend to avoid issues in the UI layer, since manual testing is usually more efficient there. (I actually love working on design-system level UI stuff, but bugs that exist between the UI and the data layer are probably my least favorite thing.)</p>
</blockquote>
<p>I would love to hear more about this "love of doing things manually" though.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T18:57:03.278Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T18:57:03.278Z" class="date">2020-09-11 18:57:03</a> <div class="message">
<blockquote><p>I would love to hear more about this ‚Äúlove of doing things manually‚Äù though.I‚Äôm thinking if the environment you are in is introspective and malleable enough, the manual approach is just so easy</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T18:57:16.278Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T18:57:16.278Z" class="date">2020-09-11 18:57:16</a> <div class="message"><p>And the lines between manual / automatic become hazy</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:09:47.278Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T19:09:47.278Z" class="date">2020-09-11 19:09:47</a> <div class="message"><p>Sure... I agree that line can be fuzzy, but I guess I'm not sure how useful that distinction is, e.g., I'd put someone using a malleable environment / using automation on one side of the coin, but most programmers are still on the other side of the coin, where they're not using a malleable environment (or at least leveraging it), and they're not automating.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:12:56.279Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T19:12:56.279Z" class="date">2020-09-11 19:12:56</a> <div class="message"><p>I think someone should do this as a real study</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:13:13.279Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T19:13:13.279Z" class="date">2020-09-11 19:13:13</a> <div class="message"><p>And collect background information about the programmers in question</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:19:39.279Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T19:19:39.279Z" class="date">2020-09-11 19:19:39</a> <div class="message"><p>Also if anyone wants to share there definitions or examples of malleable environments (i.e., environments that are so efficient that they remove the advantages of automation) I'd love to hear about that</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:49:20.279Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2020-09-11T19:49:20.279Z" class="date">2020-09-11 19:49:20</a> <div class="message"><p>The most obvious thing that comes to mind is text editor keyboard macros</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:51:08.280Z" class="reply"><span class="user">S.M Mukarram Nainar</span> <a href="#2020-09-11T19:51:08.280Z" class="date">2020-09-11 19:51:08</a> <div class="message"><p>You can record one, use it over and over, and save it if you want.</p>
<p>Importantly, you are personally in control at every step, and it is a very lightweight abstraction.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:53:11.280Z" class="reply"><span class="user">Eric Gade</span> <a href="#2020-09-11T19:53:11.280Z" class="date">2020-09-11 19:53:11</a> <div class="message"><p>Ditto for doing things in Emacs lisp. Once you have the lisp made for it, turning it into a command is easy</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:54:15.280Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T19:54:15.280Z" class="date">2020-09-11 19:54:15</a> <div class="message"><p>Yeah, that's the first thing I thought of too. Keyboard macros seem pretty clearly automation to me? (And correspondingly, would be a feature most programmers don't use). It sounds like there's a concept of a malleable system that's not based in automation here, I'd love to understand what that is. (And I'd love to hear any more examples of both.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T20:22:10.280Z" class="reply"><span class="user">Jared Windover</span> <a href="#2020-09-11T20:22:10.280Z" class="date">2020-09-11 20:22:10</a> <div class="message"><p>While I object to needing your IDE to have thought of the things you want, JetBrains does a pretty good job of thinking of the things that my coworkers and I want, and I think we do leverage it to an extent that it is ‚Äúautomation‚Äù. Multi-cursor, regexp-replace and structural-replace are some examples that come to mind.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T00:56:11.287Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-12T00:56:11.287Z" class="date">2020-09-12 00:56:11</a> <div class="message"><p>These text editor examples highlight something: good automation blurs the line between manual and automated action. Specifically, it makes the automation invisible by making it so easy it feels like manual work (this might just be my view of what you folks are talking about re malleable systems). Multi-selections are a great example. You can think of them as automating repetitive identical edits, but they feel like just cutting with a sharper knife, not programming a chopping machine.</p>
<p>Possibly one of the key things that makes them feel manual is that you can see the changes as they're made. Not exactly a new idea (oh hai Bret Victor), but maybe a new perspective on why it's important. If every bulk edit operation on a doc or database ran in a transaction with a live preview of the changes, people might feel more comfortable playing with them.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T01:51:25.288Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-09-12T01:51:25.288Z" class="date">2020-09-12 01:51:25</a> <div class="message">
<blockquote><p>but programmers are the only group that's empowered to change how their tools work today, and for the most part, they still choose not to.<a href="https://twitter.com/robenkleene">Roben Kleene</a> I don't think it's so much that they choose not to, it's often that they don't need to.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T11:40:03.292Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-12T11:40:03.292Z" class="date">2020-09-12 11:40:03</a> <div class="message"><p><a href="https://twitter.com/yoshikischmitz">yoshiki</a> Do you have any thoughts on preceding part?</p>
<blockquote><p>When you're using someone else's customizations you're always at the mercy of the creator's decisions. I don't think that wishing your tools worked differently is rare, that's a sentiment that I feel almost every computer user has,</p>
</blockquote>
<p>E.g., my observation is that developers tend to be frustrated with their tools (especially more experienced ones). Do you not find this to be the case?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T11:41:48.293Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-12T11:41:48.293Z" class="date">2020-09-12 11:41:48</a> <div class="message"><p>(I guess I should add that VS Code appears to be the first very popular text editor that developers don't seem to be frustrated with, so perhaps my perspective is outdated.)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T03:47:55.339Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-13T03:47:55.339Z" class="date">2020-09-13 03:47:55</a> <div class="message"><p>Don't you also see experienced developers being more resigned to their tools? In fact, that's one way to diagnose all of us pushing back on you in this thread: we've been living with our chains so long that we've forgotten about them. That would certainly explain why we don't customize more.</p>
<p>I had more customizations in 2001-2005, then I moved and changed a lot of stuff and just restarted my text editor settings from scratch. And they've never grown back to the sort of multi-megabyte state they were in then.</p>
<p>Backing up to your previous comment to me (I wrote a response yesterday that the Slack app ate):</p>
<blockquote><p>I think you're misunderstanding me here, I'm specifically saying I don't always think automation is a good idea, I'm saying that it's the way I prefer to solve problems. It's an inclination that has more to do with me, than it does the problem.I don't understand the distinction you're making here. At least, what you're saying sounds like it answers your earlier question, "how can doing things manually still be better than automating them in 2020?"</p>
</blockquote>
<p>Funny thing is, I do a lot to automate testing. In fact, one way to view my Mu project is as making the UI layer easy to test.</p>
<blockquote><p>I would love to hear more about this "love of doing things manually" though.When I do something manually I sleep soundly at night that I haven't created new tech debt for myself. I don't have something new I have to maintain, or try to read later to try to understand just what I was thinking. Manual labor can be therapeutic, like gardening. All these things have nothing to do with the state of the underlying system. They're just about the mess I make, and about taking care of my own state of mind.</p>
</blockquote>
<p>Sometimes I do things manually for a few days even when I'm sure I have to automate them eventually. Manual work keeps me close to the data and might give me some new insight. "Being the computer" helps me understand the problem before I try to solve it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T05:03:03.340Z" class="reply"><span class="user">yoshiki</span> <a href="#2020-09-13T05:03:03.340Z" class="date">2020-09-13 05:03:03</a> <div class="message">
<blockquote><p> E.g., my observation is that developers tend to be frustrated with their tools (especially more experienced ones). Do you not find this to be the case?I see pockets of people feeling frustrated and other pockets of people who aren't. It's difficult to summarize since I think the landscape is complex(like you said, experience plays a part). I agree though that not everyone is satisfied. I'll have to revisit this later when I have more to say.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T13:06:27.365Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-13T13:06:27.365Z" class="date">2020-09-13 13:06:27</a> <div class="message"><p>On automation: it has two very different costs that need to be weighed against the benefits. One has already been cited: the initial effort to put automation in place. The other one is less obvious: a fading understanding of what is really happening. It's much more pronounced if you run someone else's automation, but also happens when you run your own code for a long time without studying it from time to time. And if then you have to change something, it can be difficult.</p>
<p>So automation is an obvious win only if the two costs are low. Stuff like renaming hundreds of files: shallow but lengthy. The loop with a few-line body.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T15:50:50.372Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-13T15:50:50.372Z" class="date">2020-09-13 15:50:50</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> I really appreciate these comments, some responses below:</p>
<blockquote><p>Don't you also see experienced developers being more resigned to their tools? In fact, that's one way to diagnose all of us pushing back on you in this thread: we've been living with our chains so long that we've forgotten about them. That would certainly explain why we don't customize more.</p>
</blockquote>
<p>This seems to be saying the same thing I am, experienced programmers are unhappy with their tools, but accept them (that's the way I'm interpreting "resigned" at least?) The question is just why. You've given some great reasons, but I'm not entirely convinced (not saying I disagree either, just not sure either way), but I think the best response would be to give some concrete examples. That's also something a couple of others have requested too, and I also think it's a good idea, so I'm going to start a new thread soon with examples.</p>
<blockquote><p>I had more customizations in 2001-2005, then I moved and changed a lot of stuff and just restarted my text editor settings from scratch. And they've never grown back to the sort of multi-megabyte state they were in then.</p>
</blockquote>
<p>I used off-the-shelf software for the first half of my career (2002-2010), mainly with the defaults, then started customizing after that. I realized it solved a really really big problem for me: I used to keep changing software because an alternative would solve some problem I have, but after using the new software I'd realize the old software did some other things better. So my total number of problems would always stay the same.</p>
<p>Now that I customize, my total number of problems goes down. Now I think of applications like as a shell that I can customize to make it do the things that are important to me very quickly. And I'm so much happier as a computer user this way, because I'm not in a constant state of frustration because nothing works the way I want it to like I was before (this is is probably a core trait of customizers/automators, as well as contrarians in general).</p>
<blockquote><blockquote><p>I think you're misunderstanding me here, I'm specifically saying I don't always think automation is a good idea, I'm saying that it's the way I prefer to solve problems. It's an inclination that has more to do with me, than it does the problem.</p>
</blockquote>
<p>I don't understand the distinction you're making here. At least, what you're saying sounds like it answers your earlier question, "how can doing things manually still be better than automating them in 2020?"</p>
</blockquote>
<p>To me these are two separate thoughts: In the first, I'd guesstimate automators are about 1/10 of programmers, I'm just saying I'm in that 1/10. The second part is just surprise that using a computer programmatically is still so difficult in 2020, given it's a problem so many people have worked on. Not sure there's a contradiction here? I think you're saying #2 leads to the 1/10 in #1, which I agree with. But I don't see why that would change my personal preference?</p>
<blockquote><p>When I do something manually I sleep soundly at night that I haven't created new tech debt for myself. I don't have something new I have to maintain, or try to read later to try to understand just what I was thinking. Manual labor can be therapeutic, like gardening. All these things have nothing to do with the state of the underlying system. They're just about the mess I make, and about taking care of my own state of mind.</p>
</blockquote>
<p>I understand this in theory, but I just don't experience using computers this way. This reminds me of how I feel when I watch Gray Bernhardt type, I find him amazing to watch, but he has an affinity for the mechanical act of typing that I just do not share. I find just imagining doing what he does myself exhausting. (Also, doing that many small mechanical motions relative to his output seems like a recipe for RSI to me.) There is just no way I'm ever going to use a computer by typing everything out the way he does, the "cost of a key stroke" is just higher for me than it is for him.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T16:33:22.376Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-13T16:33:22.376Z" class="date">2020-09-13 16:33:22</a> <div class="message"><p><a href="https://twitter.com/robenkleene">Roben Kleene</a> That really helps clarify things. I certainly agree that computers today fit better for people with a certain profile (who find certain things like typing cheaper to do), and that there are huge barriers to customizing them for other profiles. I think it analogous to the direction of a vector rather than its magnitude. The things you want are not that far from the current defaults, it's just that there's huge impassable mountains in the direction you want to take computers, whereas I[1] and Gary Bernhardt have the advantage of living in the direction of the flat plains. (And the poor laypeople are out in outer space with no service.)</p>
<p>[1] Though I see myself moving closer to you over time, what with my recent RSI troubles.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T16:55:28.385Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-13T16:55:28.385Z" class="date">2020-09-13 16:55:28</a> <div class="message"><p>I‚Äôll just add that I think both approaches work, John Carmack seems like a use the defaults type (<a href="https://twitter.com/id_aa_carmack/status/1302651878065475584?s=21"></a><a href="https://twitter.com/id_aa_carmack/status/1302651878065475584?s=21">https://twitter.com/id_aa_carmack/status/1302651878065475584?s=21</a>). Linus seems like a customizer (maintaining his own Emacs, and <code>git</code> seems like explosion of Bash scripts, at least when I‚Äôve looked at it under the hood).</p>
</div> <div class="attachments"><blockquote><p>üê¶ <a href="https://twitter.com/@ID_AA_Carmack">John Carmack</a>: I have never been a power editor user; typing just never felt like a bottleneck worth fighting over (unlike exploration).  It is interesting watching my kids get excited as they discover various Sublime Text features that I never use.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-13T17:09:38.385Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-13T17:09:38.385Z" class="date">2020-09-13 17:09:38</a> <div class="message"><p>I'm noticing an analogy here with lifestyle design. A few years ago there was a movement towards minimalism until people realized that not everyone is rich enough to afford minimalism[1]. Similarly, I think when you see someone who says they just use the defaults, you're really seeing someone privileged to be better suited to their environment.</p>
<p>[1] Arguably this pandemic has made us all poorer by forcing us to run less lean and maintain more inventory of more types.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-10T06:39:33.216Z" class="post"><span class="user">Kartik Agaram</span> <a href="#2020-09-10T06:39:33.216Z" class="date">2020-09-10 06:39:33</a> <div class="message"><p>I'm going to start an opinionated overflow thread for the previous discussion (<a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599588394135900"></a><a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599588394135900">https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599588394135900</a>)</p>
<p>Why programmers shouldn't program for themselves (my editorializing)</p>
<p>Focusing on "quantity of programming" feels like the wrong frame. My ideal society of people educated in programming may not involve most people actually doing much programming most days. What matters is the potential. Compounding advantages from programming for one day per year.</p>
<ul><li><p>Impulse to generalize is self-limiting (some maintenance burden may be irreducible). A good end-user computer needs to be extremely parsimonious in out-of-the-box capabilities, and leave lots of space for users to "pollute" it with what they care about. Give people space to make mistakes, raze things and start over. If it's too built-up, it discourages experimentation and customization.</p>
</li><li><p>Baiting big to catch small. (<a href="https://xkcd.com/1319"></a><a href="https://xkcd.com/1319">https://xkcd.com/1319</a>) The long tail of manual tasks are not really economic to automate just for oneself.</p>
</li><li><p>First-world problems. Until we get good sensors/actuators, programming is kiddie-pool stuff for the most part. "I wrote a script that lets me open projects easily so that I can write more scripts." There's more to life. (Not for me, but for most people üòÑ)</p>
</li></ul><p>Why programmers don't program for themselves (snapshot summary of the previous thread)</p>
<ul><li><p>Interoperability limitations. Between any putative new script and other devices, platforms, programs.</p>
</li><li><p>GUI limitations.</p>
</li><li><p>Operational/maintenance burden (Ivan Illich). Keeping up with security advisories, for example (<a href="https://mastodon.social/@akkartik/104790515855023278"></a><a href="https://mastodon.social/@akkartik/104790515855023278">https://mastodon.social/@akkartik/104790515855023278</a>)</p>
</li><li><p>Programming for employers sucking up all the oxygen. Building for oneself is economically invisible in the current paradigm. (Thanks <a href="https://khinsen.net/">Konrad Hinsen</a>.)</p>
</li><li><p>Long-term trend towards locked-down, consumption-oriented devices. Morlocks turning Eloi.</p>
</li><li><p>Lack of DIY culture. Programming for others may be poor preparation for listening to one's own needs (e.g. <a href="https://mastodon.social/@akkartik/103994830568601931"></a><a href="https://mastodon.social/@akkartik/103994830568601931">https://mastodon.social/@akkartik/103994830568601931</a>). Perhaps the original sin was framing programming as driven by exernal "requirements"? But computers always had to start out expensive; hard to imagine how we could dodge that bullet..</p>
</li><li><p>Fragmentation in incumbent programming models. High barrier to entry for exploring new programming models.</p>
</li><li><p>Poor discoverability/unmemorability/anti-memorability.</p>
</li></ul><p>(Bullets are not disjoint, just interlocking/overlapping frames I've been finding useful.)</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-10T08:26:15.217Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-09-10T08:26:15.217Z" class="date">2020-09-10 08:26:15</a> <div class="message"><p>As someone who comes from the antediluvian era when personal computers were personal, that was one of the most depressing threads I've read since joining this community. üò•</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T10:50:53.217Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-10T10:50:53.217Z" class="date">2020-09-10 10:50:53</a> <div class="message"><p>Yes! Sadly.</p>
<p>The more I learn about that "antediluvian era" the more I think we have this whole thing backwards. Back then, people like Alan Kay were trying to figure out how to make computers work for everybody. "Programmer" was just a synonym for "computer user".</p>
<p>But then we somehow accepted the idea that it's better to distinguish between so-called "experts" that can create all the software for "not experts" to use, even though these "experts" knew nothing of what the "not experts" really wanted to achieve. Primarily it seems, so we can sell a sh*tload of products and turn a planetary-scale nuclear attack-proof knowledge-sharing computer network into a shopping mall.</p>
<p>The result is that now everything is so complicated that not even the "experts" find it feasible to do most things with a computer themselves, and the "not experts" are now convinced that they can't possibly learn how to do anything useful with computers unless somebody else creates it for them.</p>
<p>We should've never stopped trying to make computers work for everyone.</p>
<p>And we should've kept talking about the "medium" aspect of computing more.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T10:57:39.217Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-10T10:57:39.217Z" class="date">2020-09-10 10:57:39</a> <div class="message"><p>Ah, sorry, that turned into a not very constructive rant‚Ä¶ I do appreciate that there are still a few people trying to make computers work for everyone, and in this community in particular.</p>
<p>This whole "end-user programming" thing (even though I've adapted to use the term because otherwise it just makes communication more complicated than it already is) just feels totally backwards to me ‚Äî starting from a programmer mindset and trying to invent an easier way for non-programmers to do programmer things just seems wrong, wrong, wrong to me.</p>
<p>We need better options for non-programmers to teach us how to use computers in ways that are more useful and more relevant.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T11:43:42.218Z" class="reply"><span class="user">Ricardo A. Medina</span> <a href="#2020-09-10T11:43:42.218Z" class="date">2020-09-10 11:43:42</a> <div class="message"><p><a href="https://twitter.com/stefanlesser">Stefan Lesser</a> (last paragraph) have you expanded on it elsewhere?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T13:09:15.221Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-10T13:09:15.221Z" class="date">2020-09-10 13:09:15</a> <div class="message"><p><a href="https://twitter.com/ricmedr">Ricardo A. Medina</a> I have a lot more thoughts about it than I have written down anywhere (yet?). Every once in a while I keep rambling about it here. What I did write down elsewhere is this: <a href="https://stefan-lesser.com/2019/12/13/democratize-programming/"></a><a href="https://stefan-lesser.com/2019/12/13/democratize-programming/">https://stefan-lesser.com/2019/12/13/democratize-programming/</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T14:31:23.222Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-10T14:31:23.222Z" class="date">2020-09-10 14:31:23</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> Regarding the thread being depressing, I personally am more hopeful after the realization I made here <a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599666723187800?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL"></a><a href="https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599666723187800?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL">https://futureofcoding.slack.com/archives/C5T9GPWFL/p1599666723187800?thread_ts=1599588394.135900&amp;cid=C5T9GPWFL</a> That I think a better place to look at how programmers use programming for themselves is to create things to share with others. E.g., it seems to me that things are like personal sites and side projects (sharing) are much more common than using programming to improve personal productivity. Correspondingly, it seems to me that the most fruitful area in end-user programming would likely be in making it as easy as possible for non-programmers to share their creations with others. I think the history of the web also reflects this, with the move towards services that remove the technical hurdles to sharing (e.g., Twitter/Medium, for better or worse) and the current no-code movement.</p>
</div> <div class="attachments"><blockquote><p>[September 9th, 2020 8:52 AM] services: The theme of the responses here seems to be: Only a small percentage of people are interested in using programming to improve their own workflow, <em>but much more people are interested in using programming to build things to share</em>. Which I think resolves my initial conundrum about programmers not using programming to solve their own problems: I was looking at scripting and customization, but what I probably should have been looking at is things like side projects and personal sites. Which to me seem much more popular than scripting/customization?</p>
<p>There might be a lesson for end-using programming here too: It's probably better to focus on tools that let people create things for other people than it is to focus on anything that you'd call "automation".  For whatever reason most people aren't interested in automation (maybe just because it's not worth the time, e.g., the relevant xkcds)? But they are interested in building things to share, e.g., see the Hollow Knight example above. This seems consistent with the no code movement going on as well.</p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-10T15:36:10.223Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-10T15:36:10.223Z" class="date">2020-09-10 15:36:10</a> <div class="message"><p>I am from that antediluvian era as well, my first computer (<a href="https://en.wikipedia.org/wiki/Colour_Genie"></a><a href="https://en.wikipedia.org/wiki/Colour_Genie">https://en.wikipedia.org/wiki/Colour_Genie</a>) was so personal that it didn't even have any connection to the outside world other than via physical artefacts (cassette tapes). But I never left the universe of end-user programming. All the software I write is for my own use. Often published for sharing with others, but never written exclusively for that purpose. From this perspective, the evolution of the last 30 years looks like computers becoming ever more powerful and at the same time ever more difficult to use. I spend more time today on administrative overhead (software updates, ...) than I did 30 years ago.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T17:24:51.223Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-10T17:24:51.223Z" class="date">2020-09-10 17:24:51</a> <div class="message"><p>Related to Roben's point, I've always thought it should be easy to share workspace customizations and the like as well as code. Config packages should be easy to create, install, and uninstall.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T17:42:02.224Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-10T17:42:02.224Z" class="date">2020-09-10 17:42:02</a> <div class="message"><p><strong>@Andrew F</strong> I think the right way to share workspace customization is as "naked code". Copy-pasting fragments. One link from my OP above is relevant: <a href="https://mastodon.social/@akkartik/103994830568601931"></a><a href="https://mastodon.social/@akkartik/103994830568601931">https://mastodon.social/@akkartik/103994830568601931</a>. My argument goes like this:</p>
<ul><li><p>Settings often grow in an unruly fashion compared to codebases. We're more careful about organizing modules in a repo than we are in adding knobs to a config file. Even though the modules are internal details and the config file is externally visible.</p>
</li><li><p>Settings in config files often depend on each other in subtle, hard-to-debug ways.</p>
</li><li><p>Creating packages to manage customizations requires dealing with these dependencies. That creates a lot of bloat to sense lots of different combinations of settings and behave appropriately.</p>
</li><li><p>The bloat hinders further customization. People start to rely more on packages created by others, and the muscle of doing your own customization atrophies.</p>
</li></ul><p>Bottomline: If you make something look polished, people will assume someone else should make it. If you make it look half-assed, it will encourage, even beg for, helping oneself. This is a case where worse is actually better, not just pragmatically but really.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://mastodon.social/@akkartik/103994830568601931">Kartik Agaram (@akkartik@mastodon.social)</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-10T17:43:59.224Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-09-10T17:43:59.224Z" class="date">2020-09-10 17:43:59</a> <div class="message"><p><a href="https://khinsen.net/">Konrad Hinsen</a> I, too, still write tools for myself constantly, including little 10-15 minute programs meant to be thrown away. All I could think looking at that thread is that if one's normal toolchain makes producing nonce personal code that difficult, something has gone terribly wrong.</p>
<p><a href="https://twitter.com/robenkleene">Roben Kleene</a> The first time we used Maria.cloud to teach a class of novices we added a feature where any "cell" in a notebook could be shared as a an "app" -- a view onto the whole notebook via an interactive graphical cell -- with a single mouse click. At the end of the first day everyone had made a game or some art, and they loved sending around their creations. It was great. So, yes, this is definitely something "non-programmers" (rather, not yet programmers!) respond to quite readily.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T17:50:19.225Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-10T17:50:19.225Z" class="date">2020-09-10 17:50:19</a> <div class="message"><p>Aye aye aye, what a cool idea, a social networking platform based around sharing little interactive bits of code. Twitter x CodePen</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T18:05:38.225Z" class="reply"><span class="user">Andrew F</span> <a href="#2020-09-10T18:05:38.225Z" class="date">2020-09-10 18:05:38</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> you argument is compelling for text config files as they are today. However, looking to the future, blobs of text config can't be the only way people make customizations. The whole hidden dependency thing especially needs to die (that alone would take you a long way). Basically what I mean by "it should be easy" is that the obstacles in your post should be defeated. :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T18:31:10.225Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-10T18:31:10.225Z" class="date">2020-09-10 18:31:10</a> <div class="message"><p>Totally agreed. But it's not really about text. In fact, text helps here because it's still easier in 2020 to throw text into a random text box than it is to attach files to it.</p>
<p>The real problem is the indisciplined dependencies, and it's a devilishly subtle problem. For the obstacles to be defeated we need somehow for everybody to do "the right thing" -- even after we figure out the rules of engagement. I don't know how to even start attacking that social-organization problem.</p>
<p>In the meantime, it seems to me the best way to share customization is to encourage sharing what works for you, with the expectation that others will need to tweak it to get it working for themselves. It's fiddly and annoying, but still on balance better than the current world of pervasive learned helplessness.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-10T22:43:41.227Z" class="reply"><span class="user">Jamie Brandon</span> <a href="#2020-09-10T22:43:41.227Z" class="date">2020-09-10 22:43:41</a> <div class="message"><p>I don't think the explanation even needs to be specific to programming. There has been a long-term trend towards people doing less and less for themselves, and instead satisfying more and more of their desires through market interactions. Cooking, cleaning, basic repairs, altering clothing, music, story-telling etc are all often outsourced now. End-user programming is swimming against that tide.</p>
<p>Maybe there is inspiration to be found by looking at surviving knots of diy culture, where people are still interested in learning new skills. Eg my old housemate used to hang out at a community carpentry workshop.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T07:11:56.267Z" class="reply"><span class="user">Konrad Hinsen</span> <a href="#2020-09-11T07:11:56.267Z" class="date">2020-09-11 07:11:56</a> <div class="message"><p><a href="https://github.com/akkartik/mu">Kartik Agaram</a> I disagree about one point: your argument is all about text. In a universe where people share small pieces of code for inspection and adaptation to their own needs, it is crucial to have a representation that is universally supported by communication media, and that means text. I actually guess we all agree that it means text for now, but my claim is that this is not going to change. Text is the dominant mode of time-delayed communication between humans, with pictures taking the second place and everything else (voice recording etc.) lagging far behind. Therefore text is going to be the preferred medium for the kind of interaction you describe for a long time. Perhaps we will develop picture-based communiction with machines to the point that it can complement text, but that's no more than a dream for now.</p>
<p>What made me realize the importance of text-based representations is my recent involvement with Pharo (i.e. Smalltalk). When interacting with a Smalltalk system, text is used only at the most fine-grained level, inside a method. But that means that discussing Smalltalk code by e-mail or in discussion forums is very cumbersome. People end up using constructs that are legal Smalltalk code but which nobody ever uses for code development, such as creating classes by sending a message to another class. This creates a serious disconnect between human-computer interaction and interhuman communication.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T07:23:14.267Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-11T07:23:14.267Z" class="date">2020-09-11 07:23:14</a> <div class="message"><p>I've been trying to keep an open mind and work against my pro-text bias, but I'll be very happy if that's not needed üôÇ</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T12:50:41.269Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-09-11T12:50:41.269Z" class="date">2020-09-11 12:50:41</a> <div class="message"><p>Re: DIY's passing, I sometimes wonder whether having an entire industry competing to building seductive simulations of personal development might be interfering with the actual personal development of human beings. Or, to put it another way, how many music lovers have spent more hours playing Garage Band than it would have taken to learn how to play and form an actual garage band?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T15:33:20.270Z" class="reply"><span class="user">Roben Kleene</span> <a href="#2020-09-11T15:33:20.270Z" class="date">2020-09-11 15:33:20</a> <div class="message"><p>The killer features of plain text are collaboration and sharing. One pet theory is that one reason for the incredible popularity of visual programming languages practically everywhere except for software development (e.g., <a href="https://twitter.com/robenkleene/status/1280182521796399106"></a><a href="https://twitter.com/robenkleene/status/1280182521796399106">https://twitter.com/robenkleene/status/1280182521796399106</a>) is that most those are areas much less dependent on collaboration.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T04:18:10.288Z" class="reply"><span class="user">Jamie Brandon</span> <a href="#2020-09-12T04:18:10.288Z" class="date">2020-09-12 04:18:10</a> <div class="message"><p><a href="https://twitter.com/jackrusher">Jack Rusher</a> I saw some back of the envelope math recently - if it takes about 1000 hours to become competent (not expert) at a skill, and the average american watches 4 hours of tv per day, then the opportunity cost of tv is 1.5 skills per year.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T06:42:58.289Z" class="reply"><span class="user">Alexey Shmalko</span> <a href="#2020-09-12T06:42:58.289Z" class="date">2020-09-12 06:42:58</a> <div class="message"><p><a href="https://scattered-thoughts.net/">Jamie Brandon</a> 1000 hours must be about deliberate practice, which is highly demanding and you can't put too much of it in a day. You can't easily replace 4 hours of watching tv with 4 hours of high-intense practice. But replacing 4 hours of tv with 30 minutes or an hour of practice should be fine.</p>
<p>But on the other hand, I don't believe you need a thousand hours to be competent either. My guess is 100‚Äì500 hours depending on the skill.</p>
<p>That should give you 1‚Äì3 skills per year. So yeah, tv is huge waste either way.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T03:52:00.339Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-13T03:52:00.339Z" class="date">2020-09-13 03:52:00</a> <div class="message">
<blockquote><p>what a cool idea, a social networking platform based around sharing little interactive bits of code. Twitter x CodePen</p>
</blockquote>
<p>You mean like <a href="http://www.bashoneliners.com"></a><a href="http://www.bashoneliners.com">http://www.bashoneliners.com</a>?</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="http://www.bashoneliners.com/">bashoneliners.com | Bash One-Liners</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-13T10:41:19.362Z" class="reply"><span class="user">U01A57MG2HM</span> <a href="#2020-09-13T10:41:19.362Z" class="date">2020-09-13 10:41:19</a> <div class="message"><p><a href="https://scattered-thoughts.net/">Jamie Brandon</a> It's funny I was actually talking about this with a few friends and we sort of all had the opposite experience. Not sure if we're part of the same generation. We found that the generation of our parents (born in the 50s early 60s) didn't have a DIY culture at all.</p>
<p>From real experience:</p>
<ul><li>If you're bike is broken :Parents =&gt; bring it to the bike shop</li></ul><p>Us =&gt; Watch a youtube tutorial</p>
<ul><li>You want to organize a trip:Parent =&gt; Contact a local travel agent</li></ul><p>Us =&gt; Do some research, go on Sky Scanner, try to find local guides, <a href="http://booking.com"></a><a href="http://booking.com">http://booking.com</a>...</p>
<p>I was also talking to my step dad about it, who was also leaning to the same conclusion, He was amazed that kids of our generation all seem to cook. He is a city guy from Italy, he never cooked for himself. Being a bit counter-cultural he associated cooking yourself with the older more repressive generation (he was a bit of a hippy).  And maybe we are doing the same things he did, we cook because our parents didn't.</p>
<p>I think there might be some vertical and also horizontal cultural differences. Most of my friends come from cities/big towns and we are Europeans. There might be different shift depending on your generation/location.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-11T06:25:35.266Z" class="post"><span class="user">Robin Allison</span> <a href="#2020-09-11T06:25:35.266Z" class="date">2020-09-11 06:25:35</a> <div class="message"><p>Broad question here.</p>
<p>Do people here know of any tools that separates the complexity component of a program from the underlying behavior it would eventually produce, and then let you manipulate code so the behavior is fixed? By behavior I mean something like the user-facing behavior of a program, or its effect on some data. Its a flexible concept in my mind. A large portion of programming seems to be rewriting code so it maintains the same behavior, but is then also extensible in some way. Factoring code is an example of this activity, but you could also rewrite code to produce the same behavior which is not a factorization of the original code. To be concrete, you could factor in two different ways, so each factorization would produce the same behavior but neither is a factorization of one another. Moving back to the unfactored code and factoring in the other way is then a means of transforming the code to produce the same behavior that isn't mere factoring.</p>
<p>(picture: code&lt;--factoring&lt;--code--&gt;factoring--&gt;code)</p>
<p>(this is very reminiscent of factoring in abstract algebra and you could imagine an algebra about manipulating the code in this way, and going down this road you can ask whether two programs will produce the same behavior implies there is a common factorization but this might be another conversation).</p>
<p>I'm curious about this question mostly as a proxy for a related question in math: How can you transform one proof into an equivalent proof? This is a slippery concept because nobody knows how to make precise the idea of "equivalence of proofs". If you know about Hilbert and his 23 problems you might find it interesting that he originally had a 24th problem on the equivalence of proofs! Even though the idea is notoriously difficult to pin down, I think it is intuitive enough to take a pragmatic stance and ask how you could go about implementing technology to carry out these transformations. This is important to me because in math we "factor" proofs all the time and often compare proofs to determine the essential and incidental aspects of each. So what I'm really looking for is any techniques or perspectives in the domain of programming that could be taken back into mathematics. I've seen some approaches down at the level of the lambda calculus but I haven't found them useful. I think a pragmatic/experimental approach is better than a theoretical approach at this point.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-11T07:10:52.266Z" class="reply"><span class="user">Jack Rusher</span> <a href="#2020-09-11T07:10:52.266Z" class="date">2020-09-11 07:10:52</a> <div class="message"><p>The closest thing to what I think you're asking about is using Logic Programming to do program synthesis. Here's a video demoing a system of this kind:</p>
<p><a href="https://www.youtube.com/watch?v=5vtC7WEN76w"></a><a href="https://www.youtube.com/watch?v=5vtC7WEN76w">https://www.youtube.com/watch?v=5vtC7WEN76w</a></p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=5vtC7WEN76w">(seventh RacketCon): Keynote -- Dan Friedman &amp;amp; Will Byrd -- The Reasoned Racketeers</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-11T07:21:38.267Z" class="reply"><span class="user">Martin Sosic</span> <a href="#2020-09-11T07:21:38.267Z" class="date">2020-09-11 07:21:38</a> <div class="message"><p>At risk of coming up as very naive: what about tests on the practical side and formal verification on the other side? Since those are allowing us to refactor code while ensuring (to varying degree) its correctnes and behaviour, how do those fit into what you are looking for?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T08:40:45.268Z" class="reply"><span class="user">U01AN8DFFBN</span> <a href="#2020-09-11T08:40:45.268Z" class="date">2020-09-11 08:40:45</a> <div class="message"><p>I wonder how different proofs for the same theorem compare after resolving all abstractions and breaking them down to ZF. But I guess even proofs using the minimal amount of axioms aren't unambiguous, as two different axioms could share a common idea.</p>
<p>However, it is undecidable whether a set of axioms contains redundant axioms. </p>
<p>In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T09:23:24.268Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-11T09:23:24.268Z" class="date">2020-09-11 09:23:24</a> <div class="message"><p>When dealing with undecidability, it's best to say, "well, we'll just handle the easy cases," and see how far you go.  Compiler optimizations are certainly an exercise in factoring as is partial evaluation, which is a good deal more fun.  Come to think of it, conventional refactoring is sort of the opposite transformation.  Instead of removing indirection, add it so that the rest is more regular.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T17:19:58.273Z" class="reply"><span class="user">Robin Allison</span> <a href="#2020-09-11T17:19:58.273Z" class="date">2020-09-11 17:19:58</a> <div class="message"><p><strong>@Martin Sosic</strong> I appreciate the answer. Talking about testing is more concrete than talking about an abstract idea of behavior, and as you said the practice of testing is about manipulating code so the same tests (at least) still pass. I guess the picture I have in my mind is that when you are coding you are moving around a space of strings of symbols, and in that huge space is a space of valid programs, and once you write tests, then there is an even smaller space of programs that pass those tests. Is there any means of restricting code rewrites to discrete steps that take place entirely in the space of programs that pass the tests? Rewriting for-loops as while-loops wouldn't change any tests. Changing some variable names. Refactoring. These wouldn't change the tests at all, and in a specific context you could possibly have more. If you have various pieces of code that are interchangeable then you have something like an algebra where you can substitute equivalent expressions. Tests tell you when code is interchangeable so it gives you some algebra-like thing and how can you manipulate code at this level?</p>
<p>So tests are relevant for what I'm looking for because they let you say when two programs are equivalent. I don't think proof verification does the same in math.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T17:45:24.273Z" class="reply"><span class="user">Robin Allison</span> <a href="#2020-09-11T17:45:24.273Z" class="date">2020-09-11 17:45:24</a> <div class="message"><p><strong>@U01AN8DFFBN</strong> "In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior."</p>
<p>Neat! Good to know there isn't a universal tool.</p>
<p><strong>@William Taysom</strong> Easy cases is right! I haven't seen compiler optimizations before. I might take a peek into that area, but I have a feeling I might get scarred.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T19:02:14.278Z" class="reply"><span class="user">Ray Imber</span> <a href="#2020-09-11T19:02:14.278Z" class="date">2020-09-11 19:02:14</a> <div class="message"><p>I agree with <strong>@William Taysom</strong>. This very much reminds me of compiler optimization.</p>
<p>Classical compiler optimization makes use of many transformations that maintain equivalence such as <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form"></a><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">https://en.wikipedia.org/wiki/Static_single_assignment_form</a> form. These sorts of transformations combined with heuristic based analysis are the bread and butter of compiler optimization. The GHC Haskell compiler is probably the epitome of the classical compiler optimization approach.</p>
<p>Then there are the recent results in applying Machine Learning and Genetic algorithms to compiler optimization. These compilers often produce extremely novel, unexpected, even bizarre, machine code, and yet the results have been shown to be "equivalent", and yet much more efficient in some dimension than known state of the art classical approaches (often either better runtime or less resulting machine code.) AFAIK, the way the ML compilers seems to work today is essentially unit testing and manual inspection against programs compiled with classical compilers.</p>
<p><a href="https://arxiv.org/pdf/1805.03441.pdf"></a><a href="https://arxiv.org/pdf/1805.03441.pdf">https://arxiv.org/pdf/1805.03441.pdf</a></p>
<p><a href="https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0"></a><a href="https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0">https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0</a></p>
<p>A key idea is that all these algorithms must have some notion of equivalence of programs. An optimization is only useful if the resulting behavior is equivalent.</p>
<p>The real heart of this is the Church-Turing thesis. Program optimization is essentially saying one program is equivalent to another program, but just computed in a different way. The fact that such equivalent programs can even exist is a direct result the Church-Turing thesis.</p>
<p>Your line of reasoning is related to some of the inspiration of the creators of logic programming and proof assistants like Coq and Agda. If you can encode a proof in a programming language, you have essentially shown that the proof is computable. If it's computable, then there are infinite equivalent programs (via Church-Turing). You can then apply all the known computable transformations like SSA, or graph pruning analysis, etc...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T07:30:01.289Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-12T07:30:01.289Z" class="date">2020-09-12 07:30:01</a> <div class="message"><p>Wow, GCC flags <a href="https://www.linkedin.com/in/raymond-imber-3a445b21">Ray Imber</a>?  I do like the idea of ML being applied at high level "moves" than it often is.  I mean, for instance, allow for only valid application of inference rules rather than random term rewrites.  Let the system play over that space.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-08-24T05:10:56.072Z" class="post"><span class="user">Nick Smith</span> <a href="#2020-08-24T05:10:56.072Z" class="date">üï∞Ô∏è 2020-08-24 05:10:56</a> <div class="message"><p>Why isn't any kind of logic programming considered a <a href="https://en.wikipedia.org/wiki/Model_of_computation"></a><a href="https://en.wikipedia.org/wiki/Model_of_computation">https://en.wikipedia.org/wiki/Model_of_computation</a>? Why do we talk about Turing Machines and recursive functions as fundamental, but not inference? I can't find any resources discussing this disparity. It's like there are two classes of academics that don't talk to each other. Am I missing something?</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-11T13:07:35.269Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-09-11T13:07:35.269Z" class="date">2020-09-11 13:07:35</a> <div class="message"><p><a href="https://twitter.com/NickSmit_">Nick Smith</a> I think logic programming indeed began as identifying itself as a programming language: <a href="http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf"></a><a href="http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf">http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf</a></p>
<p>The extant thread of how this plays out I think is in the work of John Reynolds in the form of logic relations right now. But the present day incarnations that have the major mindshare happens to be Prolog variety of languages and I think its a fertile ground for bringing in novel work with it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-11T18:29:27.277Z" class="post"><span class="user">Shalabh Chaturvedi</span> <a href="#2020-09-11T18:29:27.277Z" class="date">2020-09-11 18:29:27</a> <div class="message"><p>(My comment below generated a bit of interest in another forum so I want to copy it here as a prompt.)</p>
<p>What do folks think about the emphasis on "readability" for programming languages?</p>
<blockquote><p>Readability in PLs is nice, but ultimately a red herring. It doesn't scale. We may be able to read a small snippet and get it, but once we have more code or more abstractions, we're lost again. The real goal should be to offload all mechanical computation to the machine.IOW, readability gives a very small step. It may be easier to build a "structure in your head" after reading a "more readable" representation (vs a less readable representation of the same thing). However the work really starts after you have this structure, when we begin "playing computer" in our heads.</p>
</blockquote>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-11T19:51:33.280Z" class="reply"><span class="user">Kartik Agaram</span> <a href="#2020-09-11T19:51:33.280Z" class="date">2020-09-11 19:51:33</a> <div class="message"><p><a href="http://akkartik.name/post/readable-bad"></a><a href="http://akkartik.name/post/readable-bad">http://akkartik.name/post/readable-bad</a></p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-11T21:32:20.281Z" class="reply"><span class="user">Andrew Carr</span> <a href="#2020-09-11T21:32:20.281Z" class="date">2020-09-11 21:32:20</a> <div class="message"><p>Oh, it's a local vs global argument? Interesting. The point being that locally readable code is not the bottle neck, but globally "readable" (comprehensible?) code is.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T00:24:48.283Z" class="reply"><span class="user">Nick Smith</span> <a href="#2020-09-12T00:24:48.283Z" class="date">2020-09-12 00:24:48</a> <div class="message"><p>Locally-readable code is definitely a bottleneck. I dare you to try and tell my students otherwise after they‚Äôve spent 12 weeks trying to learn Python fundamentals :/</p>
<p>But anyone defining ‚Äúreadability‚Äù as merely naming plus commenting is missing the obvious: the actual language that those names and comments are embedded within! The grammar and semantics of a language matters at least as much as the names that are used within it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T00:29:32.287Z" class="reply"><span class="user">Nick Smith</span> <a href="#2020-09-12T00:29:32.287Z" class="date">2020-09-12 00:29:32</a> <div class="message"><p>But yes, large-scale understanding is a separate issue requiring its own solutions.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T07:23:06.289Z" class="reply"><span class="user">taowen</span> <a href="#2020-09-12T07:23:06.289Z" class="date">2020-09-12 07:23:06</a> <div class="message"><p>global readability is a by product of global consensus.  It is harder now days to achieve   global consensus, because the skill and platform driving teams to be more and more narrowly focused. When everybody has ideas of how to organize, global readability is hard to achieve.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T07:40:34.289Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-12T07:40:34.289Z" class="date">2020-09-12 07:40:34</a> <div class="message"><p>Code is pretty low level: it's hard to get an overview of it.  Low level consistency, in naming for instance, will give you insight into what's going on, and I think more importantly, those who write locally readable code are also more likely have a good architecture.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T10:56:20.363Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2020-09-13T10:56:20.363Z" class="date">2020-09-13 10:56:20</a> <div class="message"><p>I would say observability is equally important. It's nice and all if the code is readable, but many times the code goes slightly out of date with it's names. And, the way it works makes a lot more sense when you have good tools for inspection into what's going on or what happened.</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-12T10:25:50.292Z" class="post"><span class="user">Prathyush</span> <a href="#2020-09-12T10:25:50.292Z" class="date">2020-09-12 10:25:50</a> <div class="message"><p>I tried to write a narrative of how studies in universal algebra and category theory is providing a deep understanding of how programming languages are united/distinct in the way they treat computational structures: <a href="https://github.com/prathyvsh/morphisms-of-control-constructs"></a><a href="https://github.com/prathyvsh/morphisms-of-control-constructs">https://github.com/prathyvsh/morphisms-of-control-constructs</a></p>
<p>I am pretty new to this field and thought the story of this evolution is less told away from academic circles and started piecing together parts of the story as I read twitter feeds / blogposts / papers on it. If anyone here is knowledgeable in this, can you please provide some feedback on what I have missed or what needs polishing? Pretty sure that there could be some significant details I have missed out.</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/prathyvsh/morphisms-of-control-constructs">prathyvsh/morphisms-of-control-constructs</a></p>
</blockquote>
</div> <div class="files"></div> <div class="replies"><div id="2020-09-12T16:52:05.295Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-12T16:52:05.295Z" class="date">2020-09-12 16:52:05</a> <div class="message"><p>I don‚Äôt know much about this and certainly a lot less than you do, but I am super interested in this and really appreciate you writing about it and putting together all these resources. So here‚Äôs my feedback: thank you and please keep going! :)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T18:56:53.296Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-09-12T18:56:53.296Z" class="date">2020-09-12 18:56:53</a> <div class="message"><p>Thanks a lot for the encouragement! I just bumped into this after exploring random stuff related to PLT. A certain kind of recurrent idea here seems to me that there is something fundamental about computational structures (in a topology like sense) that we are all groping at in our daily lives.</p>
<p>Programming seems to me now to be an activity in creating some kind of &lt;hypothesis&gt;semiotic ground for manipulating Platonic forms&lt;/hypothesis&gt;.</p>
<p>I am trying to see if those things can be made first class in a visual fashion and PLT semantics looked to me like the place where I can dig in as I have some idea of PLs and a bit of logic knowledge. Also, there are a great community of people studying this deeply and communicating about it in this field. But it is filled up with waaaay too much jargon to repel most programming practitioners as the notations are dense and require an understanding of mathematics before approaching it.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T19:04:41.296Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-09-12T19:04:41.296Z" class="date">2020-09-12 19:04:41</a> <div class="message"><p>This sort of aligns with a direction of using computation graph as a first class entity which I think some people here and in Twitter is about to embark on. This can be seen in Twitter convos in the form of RoamOS or as Codex lately proposed: <a href="https://twitter.com/codexeditor/status/1303985191912747009"></a><a href="https://twitter.com/codexeditor/status/1303985191912747009">https://twitter.com/codexeditor/status/1303985191912747009</a></p>
<p>This would result in a computational would of structure, I think, close to the attached image. Where each context has a program inside it like in a graph editing tool which then becomes the ground for further computation. Think of modules referring each other and creating intermediate representations of computations in this stage, just before getting visualized out as UI elements in a pixel matrix.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>üì∑ <a href="https://files.slack.com/files-pri/T5TCAFTA9-F01AY746RG9/image.png">image.png</a></p>
</blockquote>
</div></div><div id="2020-09-12T19:09:17.296Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-09-12T19:09:17.296Z" class="date">2020-09-12 19:09:17</a> <div class="message"><p>But I think the links go deeper, and (un)fortunately semanticists, philosophers, and mathematicians working on specialized areas seems to be the ones with intimations of what these general structures could be like. Here is another image from Rocco Gangle‚Äôs work (He mixes Category Theory with philosophy to propose some kind of ‚Äúdiagrammatic immanence‚Äù). This but for programming is what I think is lurking inside the morphisms of control constructs.</p>
</div> <div class="attachments"></div> <div class="files"><blockquote><p>üì∑ <a href="https://files.slack.com/files-pri/T5TCAFTA9-F01ARPQ2U9J/image.png">image.png</a></p>
</blockquote>
</div></div><div id="2020-09-12T20:52:30.309Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-12T20:52:30.309Z" class="date">2020-09-12 20:52:30</a> <div class="message"><p>Yes! I understand maybe half of what you‚Äôre saying, but that half feels true and important to me. I‚Äôve been looking at linguistics, category theory, bidirectional transformations, parsers/grammars, complexity theory, and Christopher Alexander‚Äôs work on Wholeness/Life and his generative process of unfolding which I just recently started to understand as having parallels to Chomsky and grammars (search for Greg Bryant, if that sounds interesting). </p>
<p>All these things are very different disciplines but somehow I started to see strong parallels and connections which I totally believe can be expressed mathematically. And very likely we have already identified all the structures we need, we just need to make the connections explicit. Unfortunately, I often find it hard to describe and it makes total sense in my head, but then I‚Äôm struggling explaining it to others.</p>
<p>It looks like you‚Äôre onto something that ties into this and might help me find ways to explain some of these connections better.</p>
<p>And that‚Äôs not even touching on all the exciting ways this might help us find better visual representations for programming systems!</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-12T21:18:17.318Z" class="reply"><span class="user">Prathyush</span> <a href="#2020-09-12T21:18:17.318Z" class="date">2020-09-12 21:18:17</a> <div class="message"><p>Exactly my thoughts! You put this better than I did. Christopher Alexander‚Äôs work was a big influence and he is a strong center of this kind of interdisciplinary thought. Much respect to him for his work. I need to look up Greg Bryant, thanks for the pointer!</p>
<p>I am working on and off on my mathematical skills to see how I can represent these ideas well. This is why I started the research on notation to see how historically they have helped us in expressing that other realm that we have inside us: <a href="https://github.com/prathyvsh/notation"></a><a href="https://github.com/prathyvsh/notation">https://github.com/prathyvsh/notation</a> I am pursuing it under a feel that there is a good ROI from having a good fitness between the content/context relationship for the constructs you device to ground these forms.</p>
<p>Will definitely share when I have some clarity on this. Thanks for the good words ‚úå</p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://github.com/prathyvsh/notation">prathyvsh/notation</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-12T21:24:31.323Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-12T21:24:31.323Z" class="date">2020-09-12 21:24:31</a> <div class="message"><p>Exciting. I‚Äôll keep following you here and on Twitter.</p>
<p>Re Greg Bryant start here: <a href="https://www.youtube.com/watch?v=X-5KG73fzJ4"></a><a href="https://www.youtube.com/watch?v=X-5KG73fzJ4">https://www.youtube.com/watch?v=X-5KG73fzJ4</a></p>
<p>Then read this whole blog in chronological order (it‚Äôs not as much content as it seems): <a href="https://chomskyalexander.blogspot.com/?m=1"></a><a href="https://chomskyalexander.blogspot.com/?m=1">https://chomskyalexander.blogspot.com/?m=1</a></p>
<p>And feel free to ping me on anything related to this. I still have to dig through all what you posted but maybe there are chances to loosely collaborate.</p>
</div> <div class="attachments"><blockquote><p>üé• <a href="https://www.youtube.com/watch?v=X-5KG73fzJ4">Christopher Alexander and Beautiful Software ‚Äî A conversation with Greg Bryant</a></p>
<p>üîó <a href="https://chomskyalexander.blogspot.com/?m=1">Chomsky &amp;amp; Alexander</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-12T22:09:55.335Z" class="reply"><span class="user">Garth Goldwater</span> <a href="#2020-09-12T22:09:55.335Z" class="date">2020-09-12 22:09:55</a> <div class="message"><p>i‚Äôm going to have to give this sincere focused time, but i wanted to reply before my initial reaction before i lost the references‚Äîi‚Äôll come by and fill these out with hyperlinks later. i too feel like all of this programming language research is swimming in a dark cave, and in our hunting around i‚Äôve got this suspicion that there‚Äôs a light switch not too far away. and that it has a lot to do with reifying the process of evaluation and letting users interact with it directly. in particular,  </p>
<blockquote><p>...there is something fundamental about computational structures (in a topology like sense) that we are all groping at in our daily lives...</p>
</blockquote>
<p>I am trying to see if those things can be made first class in a visual fashion and PLT semantics looked to me like the place where I can dig in as I have some idea of PLs and a bit of logic knowledge. Also, there are a great community of people studying this deeply and communicating about it in this field. But it is filled up with waaaay too much jargon to repel most programming practitioners as the notations are dense and require an understanding of mathematics before approaching it.</p>
<p>and</p>
<blockquote><p>All these things are very different disciplines but somehow I started to see strong parallels and connections which I totally believe can be expressed mathematically. And very likely we have already identified all the structures we need, we just need to make the connections explicit. Unfortunately, I often find it hard to describe and it makes total sense in my head, but then I‚Äôm struggling explaining it to others.</p>
</blockquote>
<p>resonate really strongly with me‚Äîbetter-worded versions of stuff i‚Äôd tried to explain to other people in the past</p>
<p>the aforementioned references im working with off the top of my head:</p>
<ul><li>call by push value</li><li>ohm/ometa</li><li>kernel/vau/f-expressions</li><li>partial evaluation</li><li>programming should eat itself</li><li>the work going on at red planet labs, alluded to by a few talks on the specter library for clojure</li><li>meander, another clojure library</li><li>the stuff rich hickey has started saying about functions having some knowledge about what they require to work properly (instead of specifying requirements on data structures directly)</li><li>towers of interpreters</li><li>f-algebras, recursion schemes</li><li>scoping and binding in the rebol programming language, APL</li><li>defunctionalization and refunctionalization</li><li>concatenative languages, because: the current continuation for them is always the state of the stack plus the rest of the tokens in the source, so you can always split a program at any point, pause it and restart it, and composition instead of application is the default action of putting two words next to each other. another way of looking at it is that every concatenative program always carries with it the context it‚Äôs operating in/on. plus there‚Äôs this cool video i shared before: <a href="https://youtu.be/R3MNcA2dpts"></a><a href="https://youtu.be/R3MNcA2dpts">https://youtu.be/R3MNcA2dpts</a></li></ul></div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T10:12:04.362Z" class="reply"><span class="user">Stefan Lesser</span> <a href="#2020-09-13T10:12:04.362Z" class="date">2020-09-13 10:12:04</a> <div class="message"><p>Here‚Äôs something I‚Äôve been looking into for a while that I didn‚Äôt see you mention specifically: the connection between</p>
<ul><li>(embedded) domain specific languages</li><li>parser combinators</li><li>abstract algebra</li><li>transducers (you kind of mention that with generators/iterators, I think)</li><li>transformation passes (towers of interpreters?)</li><li>‚Ä¶it appears I‚Äôm going to list all of computer science if I keep going, but there are certainly some more items that belong in that list</li></ul><p>There are quite obvious connections between some of them, for instance parser combinators are more or less directly applied abstract algebra. But there seems to be a more fundamental pattern that is reflected in all of them (and here we get to the part where I‚Äôm usually failing at describing it well enough ‚Äî probably due to my lack of depth in mathematical understanding):</p>
<ul><li>They all involve (or at least can facilitate) transformations from a sequential to hierarchical structure.</li><li>They all represent a set of well-defined composable entities that together form something like a grammar (some more directly than others).</li><li>They all in a sense resemble words of a language, which can be combined to describe a lower level thing in more detail (-&gt; Alexander‚Äôs Pattern Language).</li><li>They all enable and/or are based on a fundamentally recursive pattern which allows them to be used on various levels of abstraction at the same time; they‚Äôre something like an abstraction of an abstraction, if that makes sense?</li></ul><p>I mean, maybe I‚Äôm just looking at lambda calculus shining through in all of them (and in all of computing), and that‚Äôs that ‚Äî and there‚Äôs nothing more to see here. But I don‚Äôt think that‚Äôs it.</p>
<p>I know, this is kind of weird, but maybe to some of you what I just wrote makes somewhat sense and you will have some comments that help me on the path to computational enlightenment‚Ä¶ ;-)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T14:40:06.370Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2020-09-13T14:40:06.370Z" class="date">2020-09-13 14:40:06</a> <div class="message"><p><a href="https://twitter.com/no_defects">Garth Goldwater</a> pointed this out to me in a recent conversation: continuations could be seen as the same as monads. I dug up this little discussion with more discussion around this idea <a href="https://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads"></a><a href="https://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads">https://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads">continuation passing style vs monads</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-13T16:26:29.373Z" class="reply"><span class="user">Garth Goldwater</span> <a href="#2020-09-13T16:26:29.373Z" class="date">2020-09-13 16:26:29</a> <div class="message"><p><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads"></a><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads">https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads</a> here‚Äôs the article i was referencing in that conversation </p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div><div id="2020-09-13T01:56:56.338Z" class="post"><span class="user">Drewverlee</span> <a href="#2020-09-13T01:56:56.338Z" class="date">2020-09-13 01:56:56</a> <div class="message"><p>What if it's important, for comprehension, that we be able to speak programming languages not just write them.</p>
</div> <div class="attachments"></div> <div class="files"></div> <div class="replies"><div id="2020-09-13T02:19:13.338Z" class="reply"><span class="user">Drewverlee</span> <a href="#2020-09-13T02:19:13.338Z" class="date">2020-09-13 02:19:13</a> <div class="message"><p>Semi relevant article <a href="https://medium.com/@old_sound/programming-languages-are-not-languages-c6f161a78c44"></a><a href="https://medium.com/@old_sound/programming-languages-are-not-languages-c6f161a78c44">https://medium.com/@old_sound/programming-languages-are-not-languages-c6f161a78c44</a></p>
</div> <div class="attachments"><blockquote><p>üîó <a href="https://medium.com/@old_sound/programming-languages-are-not-languages-c6f161a78c44">Programming Languages are not Languages</a></p>
</blockquote>
</div> <div class="files"></div></div><div id="2020-09-13T10:51:39.363Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2020-09-13T10:51:39.363Z" class="date">2020-09-13 10:51:39</a> <div class="message"><p>I suppose I'd it's important for comprehension, then the programming language environment might need to be more tolerant to potential error, right? For example if someone says "with each user online in slack, I want to ask them when their birthday is" I'd love for the computer to be able to help incrementally qualify that for us even if there are subtle "grammar fixes" that need to be applied. Then, programming with correct syntax would be a bit more similar to writing correct English with Grammarly.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T12:15:32.364Z" class="reply"><span class="user">William Taysom</span> <a href="#2020-09-13T12:15:32.364Z" class="date">2020-09-13 12:15:32</a> <div class="message"><p>Even for the professional programmer, a system that comes up with "but have you considered" questions could prove fairly useful.  How many bugs are caused by odd interactions from otherwise fairly independent subsystems?</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T12:29:24.364Z" class="reply"><span class="user">Drewverlee</span> <a href="#2020-09-13T12:29:24.364Z" class="date">2020-09-13 12:29:24</a> <div class="message"><p>Though it would be interesting to consider talking to the computer and having it translate. I was thinking more about just a way to converse with other developers. The lack of humanity in the development process seems to lead to a lot of stress. People enjoy interacting with other people.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T12:31:57.364Z" class="reply"><span class="user">Drewverlee</span> <a href="#2020-09-13T12:31:57.364Z" class="date">2020-09-13 12:31:57</a> <div class="message"><p>I do this now in clojure, but I'm curious if we developed shared rules around the speaking patterns.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T12:48:18.365Z" class="reply"><span class="user">Don Abrams</span> <a href="#2020-09-13T12:48:18.365Z" class="date">2020-09-13 12:48:18</a> <div class="message"><p>This comes up a lot in mob programming. I'd love research in what gets named and if there are patterns for it. The GoF book also stresses the reason for naming the patterns and the follow up refactoring books use the new vocab with some additional verbs.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T12:50:56.365Z" class="reply"><span class="user">Don Abrams</span> <a href="#2020-09-13T12:50:56.365Z" class="date">2020-09-13 12:50:56</a> <div class="message"><p>Also, programming languages hit the same areas in the brain as everyday languages... But the ambiguity restriction is very different (due to shared context)</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T14:22:21.365Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2020-09-13T14:22:21.365Z" class="date">2020-09-13 14:22:21</a> <div class="message"><p>Aha, indeed, I misunderstood the original idea.</p>
<p>It's tough to be able to verbally communicate anything involving multiple actors (DB, Load balancer, Http endpoints; Text buffer, RegExp, validation messages; etc.) That's why when we can't communicate it by writing the code, I tend to try drawing it out and annotating with different levels of annotation. So, if we were communicating how notifications work, I would start by writing out the high level actors involved in sequence of a notification being sent. Then, I'd incrementally add notes for where our business requirements are applied. Then, I might show where the data is stored, etc.</p>
<p>In this situation it is incredibly difficult to share knowledge only orally. It is far easier to write it out in a shared code editor, or through sending back and forth snippets, than it is to try to hold all the info in your brain as the conversation moves forward.</p>
<p>In some of the most complex topics, my peers and I will actually write out the questions we're asking in comments in the shared editor, so we can encode each other's thoughts carefully to save time from having to repeat ourselves and losing context.</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T14:25:10.366Z" class="reply"><span class="user">Cole Lawrence</span> <a href="#2020-09-13T14:25:10.366Z" class="date">2020-09-13 14:25:10</a> <div class="message"><p>It kinda sounds like as if a math teacher quizzed students orally without writing out the problem on the board. It would lead to too much repetition and clarifications, just so the student is able to write out the problem the teacher is asking...</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T16:13:28.372Z" class="reply"><span class="user">Mark Santolucito</span> <a href="#2020-09-13T16:13:28.372Z" class="date">2020-09-13 16:13:28</a> <div class="message"><p>would be really interested to know if there is any MRI research looking at how much overlap there is in which parts of the brain "light up" when speaking/writing/read code vs natural language</p>
</div> <div class="attachments"></div> <div class="files"></div></div><div id="2020-09-13T16:37:05.380Z" class="reply"><span class="user">Garth Goldwater</span> <a href="#2020-09-13T16:37:05.380Z" class="date">2020-09-13 16:37:05</a> <div class="message"><p>i think <strong>@Cole Lawrence</strong> is pointing at something important here, which is that the main affordance given by non-spoken language is asynchrony‚Äîbeing able to look at things in different orders, return to old topics, and read without listening or speaking. i think the idea of spoken language (and an interactive conversation) also probably have unexpected side benefits, but i‚Äôm struggling to think of them at the moment (probably because i don‚Äôt  use spoken interfaces very often). the only one that comes to mind is that spoken interactions imply an awareness of context‚Äîthink of how much more often you get to say things like ‚Äúwhat‚Äôs this?‚Äù out loud rather than when you‚Äôre writing</p>
</div> <div class="attachments"></div> <div class="files"></div></div></div></div>
    </div>
  </body>
</html>
