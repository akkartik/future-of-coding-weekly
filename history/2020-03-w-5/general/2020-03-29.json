[
    {
        "client_msg_id": "b3156eba-53a7-4e07-aa20-f2922a81763f",
        "type": "message",
        "text": "\"The Humane Environment\" was renamed \"Archie\", then the project collapsed because \"Archy turned out to be too big a project for what the small team was capable of.\u00a0It was more complex, given a number of the spec'ed features surrounding universal undo, than any OS I know of. Ubiquity and Enso are a small and high-value portion of it. Archy is written in Python and is fully open source.\" Here's a github copy of the code: <https://github.com/MySheep/Archy>",
        "user": "UJN1TAYEQ",
        "ts": "1585442167.015900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "MySheep/Archy",
                "title_link": "https://github.com/MySheep/Archy",
                "text": "Archy from <http://RaskinCenter.org|RaskinCenter.org> WebArchive . Contribute to MySheep/Archy development by creating an account on GitHub.",
                "fallback": "GitHub: MySheep/Archy",
                "thumb_url": "https://avatars0.githubusercontent.com/u/3278935?s=400&v=4",
                "from_url": "https://github.com/MySheep/Archy",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/MySheep/Archy"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gav",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"The Humane Environment\" was renamed \"Archie\", then the project collapsed because \"Archy turned out to be too big a project for what the small team was capable of.\u00a0It was more complex, given a number of the spec'ed features surrounding universal undo, than any OS I know of. Ubiquity and Enso are a small and high-value portion of it. Archy is written in Python and is fully open source.\" Here's a github copy of the code: "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/MySheep/Archy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585428256.013700",
        "parent_user_id": "U85HCL7JP",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d0a4a219-d363-4e60-9afb-8b1959873862",
        "type": "message",
        "text": "Svelte is a wonderful way to get around some of JS's most glaring problems. One can have a very interesting discussion whether it is better to bite the bullet and go for a new cleaner language, or use the existing language and soup it up with some inline stuff (Svelte approach). One can see people getting into Svelte very easily from the existing JS code, while a new language could take  20 hours to learn.",
        "user": "UEQ6M68H0",
        "ts": "1585444322.016200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9pQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Svelte is a wonderful way to get around some of JS's most glaring problems. One can have a very interesting discussion whether it is better to bite the bullet and go for a new cleaner language, or use the existing language and soup it up with some inline stuff (Svelte approach). One can see people getting into Svelte very easily from the existing JS code, while a new language could take  20 hours to learn."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "1cc5f151-a6e2-40c6-92fb-f16d81a9f437",
        "type": "message",
        "text": "<@UJN1TAYEQ> Archie, now that's a name I haven't heard in a long time... a long time.",
        "user": "UA14TGLTC",
        "ts": "1585460940.016700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k00",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Archie, now that's a name I haven't heard in a long time... a long time."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585428256.013700",
        "parent_user_id": "U85HCL7JP",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "94a0b761-8298-400f-8ff6-762f309d9bdc",
        "type": "message",
        "text": "I disagree with Edward's assertion that \"call/return (subroutines) are an intrinsic part of all programming\". There is no evidence that the only way to re-use code is to put it into a function that is used in such a way that the output of the function (and/or its control flow) is routed to the location of the inputs. In fact, we already have a counter-example in logic programming (Datalog moreso than Prolog, which is a weird imperative hybrid). In logic programming, data flows between rules, and only ever flows \"forward\". There are no \"return values\", unless you start mashing logic programming together with imperative programming (which many people have done in the past). Dataflow programming has a similar philosophy.",
        "user": "UCGAK10LS",
        "ts": "1585463893.017000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585464203.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+2s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I disagree with Edward's assertion that \"call/return (subroutines) are an intrinsic part of all programming\". There is no evidence that the only way to re-use code is to put it into a function that is used in such a way that the output of the function (and/or its control flow) is routed to the location of the inputs. In fact, we already have a counter-example in logic programming (Datalog moreso than Prolog, which is a weird imperative hybrid). In logic programming, data flows between rules, and only ever flows \"forward\". There are no \"return values\", unless you start mashing logic programming together with imperative programming (which many people have done in the past). Dataflow programming has a similar philosophy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a2f1908c-3d51-43f7-a406-6fde518294fb",
        "type": "message",
        "text": "I'm working on a logic programming environment that has no functions, yet (eventually...) aims to be practical and allow re-use of code. This means there will probably be a need for *macros* to avoid needing to have slightly-different rulesets for slighty-different use-cases, but there will be no call/return behaviour.",
        "user": "UCGAK10LS",
        "ts": "1585464089.017200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NDest",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm working on a logic programming environment that has no functions, yet (eventually...) aims to be practical and allow re-use of code. This means there will probably be a need for "
                            },
                            {
                                "type": "text",
                                "text": "macros",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to avoid needing to have slightly-different rulesets for slighty-different use-cases, but there will be no call/return behaviour."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "6b6f146c-2516-496d-b6d5-fa4aee105e91",
        "type": "message",
        "text": "Here's the website for the project: <http://objective.st>\n\nI don't understand the paper at all. If you liked it, please post a summary in different words. Perhaps that will help me triangulate. As best I can tell, the author is advocating for manipulating objects directly rather than instructions to create the objects. Does that cover it?",
        "user": "UCUSW7WVD",
        "ts": "1585464633.017500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1585464756.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PhZ2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's the website for the project: "
                            },
                            {
                                "type": "link",
                                "url": "http://objective.st"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI don't understand the paper at all. If you liked it, please post a summary in different words. Perhaps that will help me triangulate. As best I can tell, the author is advocating for manipulating objects directly rather than instructions to create the objects. Does that cover it?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "type": "message",
        "text": "<@UAVCC2X70> free anytime this week. how about yourself? <@UD6EXQVM0> you're more than welcome to join too",
        "user": "U01003H81UM",
        "ts": "1585465775.017800",
        "team": "T5TCAFTA9",
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "client_msg_id": "260a0e39-c9dd-4955-b6df-5480be7f98ed",
        "type": "message",
        "text": "<@UCGAK10LS> what exactly do you mean saying that Datalog in particular shows that subroutines are not an intrinsic part of all programming?  Let me throw out some ideas that you might want ot latch on to.  Certainly Datalog rules induce a tree-ish structure on how some facts are inferred from others.  This inference structure has strong parallels to a trace of subroutine calls and returns.  Now in a pure (functionally) Datalog, inference has no temporal component: can happen in any order, results can be precomputed or cached, who cares.  Imperative programs, in contrast, are best understood within a strict call return tree \u2014 what with shared state threads immediately giving rise to endless trouble.  Finally, good old fashioned cut Prolog has a strict search strategy, which to me at least, feels practically identical to imperative call/return albeit enriched.",
        "user": "UA14TGLTC",
        "ts": "1585468955.018100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6i=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " what exactly do you mean saying that Datalog in particular shows that subroutines are not an intrinsic part of all programming?  Let me throw out some ideas that you might want ot latch on to.  Certainly Datalog rules induce a tree-ish structure on how some facts are inferred from others.  This inference structure has strong parallels to a trace of subroutine calls and returns.  Now in a pure (functionally) Datalog, inference has no temporal component: can happen in any order, results can be precomputed or cached, who cares.  Imperative programs, in contrast, are best understood within a strict call return tree \u2014 what with shared state threads immediately giving rise to endless trouble.  Finally, good old fashioned cut Prolog has a strict search strategy, which to me at least, feels practically identical to imperative call/return albeit enriched."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "type": "message",
        "text": "<@UA14TGLTC> The standard evaluation strategy for Datalog programs is known as \"semi-naive evaluation\". I've attached the algorithm to this message. Notably, the only function call is \"Eval/Eval-incr\", which is just a lookup table for a sequence of relational algebra (RA) operations for the current rule (the program code) being executed. The RA operations are applied to sets of input tuples to produce a set of output tuples. So Datalog evaluation requires no call stack! Accordingly, it's not helpful to think about subroutines when reading, writing, or executing Datalog programs. It's easy (and recommended) to think of Datalog programs as a bunch of rules that \"fire\" in response to inputs to compute an output (a deduction), for as long as new deductions can be made.",
        "files": [
            {
                "id": "F010N6PQCH1",
                "created": 1585470341,
                "timestamp": 1585470341,
                "name": "IMG_044A83AAC0A9-1.jpeg",
                "title": "IMG_044A83AAC0A9-1.jpeg",
                "mimetype": "image/jpeg",
                "filetype": "jpg",
                "pretty_type": "JPEG",
                "user": "UCGAK10LS",
                "editable": false,
                "size": 287050,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F010N6PQCH1/img_044a83aac0a9-1.jpeg",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F010N6PQCH1/download/img_044a83aac0a9-1.jpeg",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_64.jpg",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_80.jpg",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_360.jpg",
                "thumb_360_w": 360,
                "thumb_360_h": 187,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_480.jpg",
                "thumb_480_w": 480,
                "thumb_480_h": 249,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_160.jpg",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_720.jpg",
                "thumb_720_w": 720,
                "thumb_720_h": 373,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_800.jpg",
                "thumb_800_w": 800,
                "thumb_800_h": 415,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_960.jpg",
                "thumb_960_w": 960,
                "thumb_960_h": 498,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F010N6PQCH1-0922bc5886/img_044a83aac0a9-1_1024.jpg",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 531,
                "image_exif_rotation": 1,
                "original_w": 1925,
                "original_h": 998,
                "thumb_tiny": "AwAYADDQIOfvGgAnqTSkc5oB570AL+dLijNGaADFGKM0UANOc9KAOadRQAUUUUAFFFFAH//Z",
                "permalink": "https://futureofcoding.slack.com/files/UCGAK10LS/F010N6PQCH1/img_044a83aac0a9-1.jpeg",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F010N6PQCH1-4e352b305c",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9eNeP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " The standard evaluation strategy for Datalog programs is known as \"semi-naive evaluation\". I've attached the algorithm to this message. Notably, the only function call is \"Eval/Eval-incr\", which is just a lookup table for a sequence of relational algebra (RA) operations for the current rule (the program code) being executed. The RA operations are applied to sets of input tuples to produce a set of output tuples. So Datalog evaluation requires no call stack! Accordingly, it's not helpful to think about subroutines when reading, writing, or executing Datalog programs. It's easy (and recommended) to think of Datalog programs as a bunch of rules that \"fire\" in response to inputs to compute an output (a deduction), for as long as new deductions can be made."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UCGAK10LS",
        "display_as_bot": false,
        "ts": "1585470347.018300",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585470616.000000"
        },
        "client_msg_id": "d122ad83-56dc-4362-b7b5-474c1d567b6a",
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "789ab61c-f893-4e25-9e74-21becaa0385a",
        "type": "message",
        "text": "Prolog on the other hand (as you point out), was designed around a specific (convoluted) evaluation strategy involving imperative functions and call/return traversal. I don't have any good things to say about Prolog, beyond its role in inspiring better alternatives.",
        "user": "UCGAK10LS",
        "ts": "1585470495.018800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1585470586.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IWXVN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Prolog on the other hand (as you point out), was designed around a specific (convoluted) evaluation strategy involving imperative functions and call/return traversal. I don't have any good things to say about Prolog, beyond its role in inspiring better alternatives."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "416c1dee-cc15-406d-b680-901acfc27e68",
        "type": "message",
        "text": "Weird that it discusses the obvious elephant in the room, FRP, only towards the end, and then in the form of non-native reactive frameworks, not actual FRP languages, then dismisses it as being costly/complex/non-native.. seems the authors have some research to catch up with",
        "user": "UHDQ62M4P",
        "ts": "1585497243.019400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jJ/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Weird that it discusses the obvious elephant in the room, FRP, only towards the end, and then in the form of non-native reactive frameworks, not actual FRP languages, then dismisses it as being costly/complex/non-native.. seems the authors have some research to catch up with"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "082a2953-4468-4780-8716-ab041ed529ca",
        "type": "message",
        "text": "that said, doing something FRP-like in an imperative context seems valuable to me, though I'd like to see it at a larger scale: functions that map intrinsic data to derived data (like functional relation programming - different from functional reactive programming)",
        "user": "UHDQ62M4P",
        "ts": "1585497362.019600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NvU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that said, doing something FRP-like in an imperative context seems valuable to me, though I'd like to see it at a larger scale: functions that map intrinsic data to derived data (like functional relation programming - different from functional reactive programming)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "d164c107-1501-41e2-8223-2dd0355eadd0",
        "type": "message",
        "text": "<@UCUSW7WVD> I'm also having some difficulty understanding the paper, both the problem it sees with call/return and the suggested solution. Here's my sense of it:\n\nMost languages assume functions or subroutines (call/return) as the smallest unit of organization.\n\nYou can use call/return to implement other organizational schemes, like dataflow or data-binding.\n\nBut if you do that,\n\u2022 you still need to think in terms of call/return when deeply analyzing the system \u2014\u00a0when debugging, or doing other similar things that require mechanical sympathy.\n\u2022\u00a0the character of call/return set the character of the language, affecting all code written with it.\n\nInstead, it would be better if a programming language had additional kinds of organization at the fundamental / smallest / bottom level.",
        "user": "UC2A2ARPT",
        "ts": "1585501213.020200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1585501259.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ttjo2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I'm also having some difficulty understanding the paper, both the problem it sees with call/return and the suggested solution. Here's my sense of it:\n\nMost languages assume functions or subroutines (call/return) as the smallest unit of organization.\n\nYou can use call/return to implement other organizational schemes, like dataflow or data-binding.\n\nBut if you do that,\n\u2022 you still need to think in terms of call/return when deeply analyzing the system \u2014\u00a0when debugging, or doing other similar things that require mechanical sympathy.\n\u2022\u00a0the character of call/return set the character of the language, affecting all code written with it.\n\nInstead, it would be better if a programming language had additional kinds of organization at the fundamental / smallest / bottom level."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e1bcee49-3730-4a5c-8b8f-0781c4265645",
        "type": "message",
        "text": "<@UEQ6M68H0>\n\nYou said:\n\n&gt; Call/return (subroutines) are an intrinsic part of all programming\nFrom the paper:\n\n&gt; One of the reasons programming is so hard and requires seemingly excessive amounts of engineering is that the (linguistic) tools we use no longer match the systems we are expected to build using those tools.\n&gt; However, the assumption that this particular architectural style is the only one that amounts to \u201cprogramming\u201d is so deeply entrenched that we tend to describe alternatives as _not-programming_, so _modeling, configuring or architectural-description_.\n/ Objection! meme /",
        "user": "UC2A2ARPT",
        "ts": "1585501447.021400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7ad",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": "\n\nYou said:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Call/return (subroutines) are an intrinsic part of all programming"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFrom the paper:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of the reasons programming is so hard and requires seemingly excessive amounts of engineering is that the (linguistic) tools we use no longer match the systems we are expected to build using those tools.\nHowever, the assumption that this particular architectural style is the only one that amounts to \u201cprogramming\u201d is so deeply entrenched that we tend to describe alternatives as "
                            },
                            {
                                "type": "text",
                                "text": "not-programming",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", so "
                            },
                            {
                                "type": "text",
                                "text": "modeling, configuring or architectural-description",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n/ Objection! meme /"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "5cb74446-ae72-4fa7-b58d-7d9ac8cc1b8a",
        "type": "message",
        "text": "<@UC2A2ARPT> I see. So it doesn't matter that these additional kinds of organization are built out of call/ret at the lowest level, because he's taking the hit for the rest of us?",
        "user": "UCUSW7WVD",
        "ts": "1585501648.021600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "blyT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " I see. So it doesn't matter that these additional kinds of organization are built out of call/ret at the lowest level, because he's taking the hit for the rest of us?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "ABEE3D46-5AC6-4D1F-827E-F8F9091B5D35",
        "type": "message",
        "text": "Yeah, pretty much. As long as you never need to think about things lower down than the language primitives. * tugs collar *\n\nAt least, that's my read. Not sure I got the right takeaways.",
        "user": "UC2A2ARPT",
        "ts": "1585501844.023700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1585502131.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2la9i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, pretty much. As long as you never need to think about things lower down than the language primitives. * tugs collar *\n\nAt least, that's my read. Not sure I got the right takeaways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "19dce77d-8f2d-4bdb-966b-efe95047af59",
        "type": "message",
        "text": "Struggling with the strange syntax gave me greater empathy for readers of my own paper with its own strange syntax.",
        "user": "UCUSW7WVD",
        "ts": "1585513258.024400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "urm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Struggling with the strange syntax gave me greater empathy for readers of my own paper with its own strange syntax."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1585420887.013400",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "beers",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    }
]