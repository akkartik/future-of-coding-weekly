[
    {
        "client_msg_id": "8b9bd5ad-c319-4118-84c2-bd36450a3e68",
        "type": "message",
        "text": "There's an interesting connection betwen BP and <http://people.csail.mit.edu/brooks/papers/AIM-864.pdf>",
        "user": "UCUSW7WVD",
        "ts": "1581289273.060800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3WF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's an interesting connection betwen BP and "
                            },
                            {
                                "type": "link",
                                "url": "http://people.csail.mit.edu/brooks/papers/AIM-864.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580955499.046800",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "b2b6fda0-cb46-41ff-b129-95ac3f699695",
        "type": "message",
        "text": "Imperative programming is concerned with the order in which things happen.\n\nFunctional programming tries to make things as atemporal as possible, robust to multiple orderings of operations.\n\nOP shows how to write unordered behaviors -- but rely on the operations happening in just the right order. (at time 9:30) I don't understand why this is a good thing! It seems to be the worst of both worlds. I still have to think about the order in which I want things to happen, but now I can't just describe the order directly. I have to arrange behaviors to make that order emergently occur. And now readers can't just read behaviors and understand their purpose. They have to _simulate_ them to understand implications. Why is this an improvement on just regular much-maligned imperative programming?\n\nIn fairness, OP is not by the creator of BP. But it doesn't seem like a strong case.",
        "user": "UCUSW7WVD",
        "ts": "1581289598.061000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WGBHK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Imperative programming is concerned with the order in which things happen.\n\nFunctional programming tries to make things as atemporal as possible, robust to multiple orderings of operations.\n\nOP shows how to write unordered behaviors -- but rely on the operations happening in just the right order. (at time 9:30) I don't understand why this is a good thing! It seems to be the worst of both worlds. I still have to think about the order in which I want things to happen, but now I can't just describe the order directly. I have to arrange behaviors to make that order emergently occur. And now readers can't just read behaviors and understand their purpose. They have to "
                            },
                            {
                                "type": "text",
                                "text": "simulate",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " them to understand implications. Why is this an improvement on just regular much-maligned imperative programming?\n\nIn fairness, OP is not by the creator of BP. But it doesn't seem like a strong case."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580955499.046800",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "5b362a56-29ca-4713-81cd-f1410bce6902",
        "type": "message",
        "text": "I'm at 12 minutes now, and OP is talking about modifying a program based on just reading an event trace. I _love_ traces, and I _want_ to nod along. But wait a minute, what if a program needed events to happen in different orders in two different scenarios? Most real-world programs have many many scenarios they need to work in. Never allowing ourselves to touch existing parts of the program seems like a bad way to reliably get the desired effect.\n\nIt's not clear to me how this block means \"block loadingAccount until adShown\":\n```yield {\n  wait: 'adShown'\n  block: 'loadingAccount'\n}```\nCan somebody explain this? Is it assuming there's another b-thread somewhere pumping out 'loadingAccount' events _ad infinitum_?",
        "user": "UCUSW7WVD",
        "ts": "1581290295.061600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4wSAy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm at 12 minutes now, and OP is talking about modifying a program based on just reading an event trace. I "
                            },
                            {
                                "type": "text",
                                "text": "love",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " traces, and I "
                            },
                            {
                                "type": "text",
                                "text": "want",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to nod along. But wait a minute, what if a program needed events to happen in different orders in two different scenarios? Most real-world programs have many many scenarios they need to work in. Never allowing ourselves to touch existing parts of the program seems like a bad way to reliably get the desired effect.\n\nIt's not clear to me how this block means \"block loadingAccount until adShown\":\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yield {\n  wait: 'adShown'\n  block: 'loadingAccount'\n}"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCan somebody explain this? Is it assuming there's another b-thread somewhere pumping out 'loadingAccount' events "
                            },
                            {
                                "type": "text",
                                "text": "ad infinitum",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580955499.046800",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "ec4d5d1b-b17d-4cfa-b78a-60d8d518e44b",
        "type": "message",
        "text": "The animations suggest that b-threads run in lock step, each `yield` in them taking equal time. Is this true? Certainly the examples here would have wildly different behavior for different relative timings. Being this sensitive to timing seems really bad. It gives me flashbacks to writing Verilog code and running into bugs from signals not getting to a latch in time for the next clock cycle.\n\nOk, I'll stop spamming this thread. Summary: I have been slowly thinking about BP over 1.5 years now, and my opinion is slowly crystallizing to opposition. OP seems like a poor advertisement for BP. Either it's misunderstanding BP or it's making certain drawbacks very obvious but not self-aware of doing so.",
        "user": "UCUSW7WVD",
        "ts": "1581290720.061800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dJXEQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The animations suggest that b-threads run in lock step, each "
                            },
                            {
                                "type": "text",
                                "text": "yield",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in them taking equal time. Is this true? Certainly the examples here would have wildly different behavior for different relative timings. Being this sensitive to timing seems really bad. It gives me flashbacks to writing Verilog code and running into bugs from signals not getting to a latch in time for the next clock cycle.\n\nOk, I'll stop spamming this thread. Summary: I have been slowly thinking about BP over 1.5 years now, and my opinion is slowly crystallizing to opposition. OP seems like a poor advertisement for BP. Either it's misunderstanding BP or it's making certain drawbacks very obvious but not self-aware of doing so."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580955499.046800",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "2bcb4d41-2e1b-4457-9c31-c22f66568e75",
        "type": "message",
        "text": "Ah, I see that <http://www.wisdom.weizmann.ac.il/~amarron/BP%20-%20CACM%20-%20Author%20version.pdf> (the original BP paper?) admits the possibility of conflicting b-threads in Section 5.1. They point out that:\n\n* Conflicts can be resolved using priorities. Which absolutely requires new b-threads to be aware of what older b-threads exist.\n* A model-checker is required to warn programmers when conflict may arise.\n\nUsing BP in React seems like a recipe for spaghetti until React gains a model-checker. Is there one in development somewhere?",
        "user": "UCUSW7WVD",
        "ts": "1581292548.062100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vh7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah, I see that "
                            },
                            {
                                "type": "link",
                                "url": "http://www.wisdom.weizmann.ac.il/~amarron/BP%20-%20CACM%20-%20Author%20version.pdf"
                            },
                            {
                                "type": "text",
                                "text": " (the original BP paper?) admits the possibility of conflicting b-threads in Section 5.1. They point out that:\n\n* Conflicts can be resolved using priorities. Which absolutely requires new b-threads to be aware of what older b-threads exist.\n* A model-checker is required to warn programmers when conflict may arise.\n\nUsing BP in React seems like a recipe for spaghetti until React gains a model-checker. Is there one in development somewhere?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580955499.046800",
        "parent_user_id": "USUMN6XLH"
    }
]