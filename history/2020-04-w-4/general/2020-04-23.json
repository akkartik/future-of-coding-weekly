[
    {
        "client_msg_id": "db95f5ad-7cf4-4bec-a81f-66c9e7d9d854",
        "type": "message",
        "text": "Bazel looks nicer than Make, but since it doesn't compute the dependencies, you have to set up the dependencies yourself, and making the makefile for C was always a pain. It is one of the weaknesses of many older languages is that you can't compute the dependencies quickly and easily. Contrast that with Modula-2 which did not allow dynamic dependencies, and forced all IMPORT statements in the first lines of the program, so you can could scan them instantly to find out what other modules are needed. I am trying like heck to not need a tool like Bazel in my language. Especially with possible remote installation steps to consider, it is a very tricky problem indeed.",
        "user": "UEQ6M68H0",
        "ts": "1587600597.128200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1587600614.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "B9+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Bazel looks nicer than Make, but since it doesn't compute the dependencies, you have to set up the dependencies yourself, and making the makefile for C was always a pain. It is one of the weaknesses of many older languages is that you can't compute the dependencies quickly and easily. Contrast that with Modula-2 which did not allow dynamic dependencies, and forced all IMPORT statements in the first lines of the program, so you can could scan them instantly to find out what other modules are needed. I am trying like heck to not need a tool like Bazel in my language. Especially with possible remote installation steps to consider, it is a very tricky problem indeed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U79HM6726",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "39d75a7b-9caf-4580-aa74-e411b130d0e6",
        "type": "message",
        "text": "Certainly more duplication of effort outside Google in the tens/hundreds of thousands of software companies who write their own glue code than inside Google. (The same is true of any big company, mind you).",
        "user": "UKJGU23KP",
        "ts": "1587605589.128500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5=uX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Certainly more duplication of effort outside Google in the tens/hundreds of thousands of software companies who write their own glue code than inside Google. (The same is true of any big company, mind you)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UBSMEUXAA"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "E2A314C1-F63E-4CD8-8CB1-8CD7A40878A1",
        "type": "message",
        "text": "Yeah, I don\u2019t think Edward was saying Google\u2019s repo was any more of a cesspool than any other (in this instance? :), but that even in a situation that theoretically maximizes the capacity for reuse, there\u2019s a crazy amount of code, which I would agree with.\n\nHickey had that whole talk about decoupling the various semantics of \u201cmap\u201d just to the extent that it could run in serial or in parallel, and it\u2019s just plain impossible for every engineer to put that amount of thought into every bit of code they write. I feel that most of the lack of reuse / repo bloat is just that: someone writes a module that complects the type of input, type of output, programming language, runtime, threading model, framework, etc, and separating any of those is just so hard that it gets rewritten instead, but with all the same rigidness in a new configuration, because it\u2019s still hard to write in a factored way.",
        "user": "UFEQUBNNT",
        "ts": "1587607050.139900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFEQUBNNT",
            "ts": "1587607135.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YhhE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I don\u2019t think Edward was saying Google\u2019s repo was any more of a cesspool than any other (in this instance? :), but that even in a situation that theoretically maximizes the capacity for reuse, there\u2019s a crazy amount of code, which I would agree with.\n\nHickey had that whole talk about decoupling the various semantics of \u201cmap\u201d just to the extent that it could run in serial or in parallel, and it\u2019s just plain impossible for every engineer to put that amount of thought into every bit of code they write. I feel that most of the lack of reuse / repo bloat is just that: someone writes a module that complects the type of input, type of output, programming language, runtime, threading model, framework, etc, and separating any of those is just so hard that it gets rewritten instead, but with all the same rigidness in a new configuration, because it\u2019s still hard to write in a factored way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U79HM6726",
                    "UE0ETTCG7"
                ],
                "count": 2
            },
            {
                "name": "point_up",
                "users": [
                    "UNCP67JSK",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "045cb5c7-8233-4e79-95a9-a322eb45b1c8",
        "type": "message",
        "text": "It is the tangle of dependencies that one encounters that is the main impediment to code re-use. You try to use just one routine, but it calls 3 others which call 3 others, etc., leading to an above-linear increase in the number of included code accompanying the small piece you really wanted. Some languages are more easy to \"tree shake\" than others. I once converted a giant C program to Modula2, and the lines dropped in half, even though the languages are 1:1 identical in almost every statement. The trick was that in Modula2 you had to name every import, and it took work to do that, and to avoid that hassle, unconsciously you would write code that minimized dependencies, and the net result was a higher level of sharing. I would bet with their high salaries and consequent high quality of workers, Google is probably  better than average companies at encouraging code re-use, but Google cannot escape the fact that they are using C++, JS, Java, etc; all languages designed without much care about code re-use, so the geometric increases are going to happen whether they like it or not, simply because of the languages they are using. This same problem of \"copy-pasta\" i believe it is called happened at IBM many years ago. IBM actually encouraged duplication (!) because they felt that otherwise you would be breaking other people's projects with your changes, so they thought non-sharing was safer. Of course it leads to low productivity and the non-fixing of bugs across semi-shared code. Then you have the opposite approach in big open source projects where the damn thing is broken constantly, and you have to cherry pick the right release day to get something reasonably stable. No question in my mind that a world of interchangeable software parts is possible, and will represent a seismic shift in the industry.",
        "user": "UEQ6M68H0",
        "ts": "1587613858.140400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1587614042.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hp+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is the tangle of dependencies that one encounters that is the main impediment to code re-use. You try to use just one routine, but it calls 3 others which call 3 others, etc., leading to an above-linear increase in the number of included code accompanying the small piece you really wanted. Some languages are more easy to \"tree shake\" than others. I once converted a giant C program to Modula2, and the lines dropped in half, even though the languages are 1:1 identical in almost every statement. The trick was that in Modula2 you had to name every import, and it took work to do that, and to avoid that hassle, unconsciously you would write code that minimized dependencies, and the net result was a higher level of sharing. I would bet with their high salaries and consequent high quality of workers, Google is probably  better than average companies at encouraging code re-use, but Google cannot escape the fact that they are using C++, JS, Java, etc; all languages designed without much care about code re-use, so the geometric increases are going to happen whether they like it or not, simply because of the languages they are using. This same problem of \"copy-pasta\" i believe it is called happened at IBM many years ago. IBM actually encouraged duplication (!) because they felt that otherwise you would be breaking other people's projects with your changes, so they thought non-sharing was safer. Of course it leads to low productivity and the non-fixing of bugs across semi-shared code. Then you have the opposite approach in big open source projects where the damn thing is broken constantly, and you have to cherry pick the right release day to get something reasonably stable. No question in my mind that a world of interchangeable software parts is possible, and will represent a seismic shift in the industry."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "1d98ffaa-68e3-4c92-a99f-da302b7cb29a",
        "type": "message",
        "text": "150 lines of code added per person per day, times 200 days a year times 30K developers equals 900 million lines per year added to the repository. If it was 2 billion lines 2015, let's guess that it is about 4-5 billion lines now, based on hopefully replacements rather than pure addition.",
        "user": "UEQ6M68H0",
        "ts": "1587614238.140700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1587614317.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zXkoE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "150 lines of code added per person per day, times 200 days a year times 30K developers equals 900 million lines per year added to the repository. If it was 2 billion lines 2015, let's guess that it is about 4-5 billion lines now, based on hopefully replacements rather than pure addition."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "a7e444bd-5f4c-4c8b-b2be-52bb0bef0b5b",
        "type": "message",
        "text": "Fortunately 150 LoC/day is an order of magnitude too high for a large company. By the time you've checked that things work for 100M users, and gone through 30k tests, and put up with 16 rounds of bikeshedding and miscellaneous language lawyers, you're lucky to average 10 lines a day.",
        "user": "UCUSW7WVD",
        "ts": "1587614379.141000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1587623528.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "azfl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fortunately 150 LoC/day is an order of magnitude too high for a large company. By the time you've checked that things work for 100M users, and gone through 30k tests, and put up with 16 rounds of bikeshedding and miscellaneous language lawyers, you're lucky to average 10 lines a day."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "laughing",
                "users": [
                    "UFEQUBNNT",
                    "U8A5MS6R1",
                    "U79HM6726",
                    "UNCP67JSK"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "38521F2D-B76A-4145-AEC3-0319682A6ED8",
        "type": "message",
        "text": "Excuse my ignorance of Modula2, but when you say that it encourages you to minimize dependencies, and that you solve that in a way besides copy-pasting, does that mean you have just one dependency on a \u201ckitchensink\u201d module?",
        "user": "UFEQUBNNT",
        "ts": "1587615630.146000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d3NcZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Excuse my ignorance of Modula2, but when you say that it encourages you to minimize dependencies, and that you solve that in a way besides copy-pasting, does that mean you have just one dependency on a \u201ckitchensink\u201d module?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "c128702c-f9ec-464a-8d41-f278809d90e3",
        "type": "message",
        "text": "I built two of the biggest Modula-2 projects ever made in the language, and used it exclusively for 20 years. Modula2 was the 10 year later sequel to Pascal. The big improvement other than a few expansions of the type system so you could have POINTER TO ARRAY [-5..+5] OF A_RECORD, which beats the hell out of C's nutty notation, was the module system. Modula2 had a unique approach that actually Prof. Wirth discard as cumbersome in Oberon. In Modula-2 each module had 2 separate files, an implementation file (the big one with the actual code) and a definition module, which held publicly visible constants, types, and function declarations. You compiled each of these 2 files separately; the definition first of course. What this gave you is that once you pinned down the external aspects of a module you were free to change the implementation part, and any other module that depended on it did not have to be recompiled when you change only the implementation file; just relink the program and execute. This goes way beyond compiled headers in C, because most of the time you change something in the implementation module, and don't modify the number or type of function parameters. This means recompilation of a 100k line program takes seconds. For small projects it is like having a REPL. There is a freeware Windows compiler (formerly the Stony Brook compiler) on the ADW website. This was the compiler i used for the WIndows side, and there is a small german firm P1 that made the Macintosh compiler.\n\nAnyway by forcing you to constantly evaluate what symbols are public or private, and being able to check that every call has the correct precise type, a great many errors are caught at compile time. Modula-2 was targeting system programming; it had no graphical primitives, so I used Win32 API and on the Macintosh the QuickDraw system (for OS7).  The way the language is structured, it drives you subtly towards a very modular type of coding style. You end up with various function libraries that tackle different tasks, and as your program gets larger you tend to make it even more modular and systematic. So it is a language that encourages virtue and a slightly lower exponent of expansion than C for example. When runtime checks are fully enabled in Modula-2 it puffs up the code by 30%, but that means you have tens of thousands of range checks, assignment compatibility, null pointer, etc. that are very helpful during testing. For golden master you turn them off and your program gets a big speed boost. Although i only got to speak with Prof. Wirth once, i consider myself a disciple of his Swiss school of programming which is all about neatness, economy, and rigor.\n\nModula2 as a language was damaged severely when Prof. Wirth made a sequel called Oberon, but in Oberon 1 he stripped out some very valuable features from Modula-2 and thus made it impossible for the Modula-2 users to move forward. This was not corrected until Oberon 2 and by that time the world has discovered the new panacea of OOP (a disaster IMHO), and Java ran away with the academic market. Modula2 did not have a good free compiler. Interestingly enough Logitech, the famous Mouse maker, was founded by a Swiss person, and they offered one of the first symbolic debuggers, which had the amazing feature that when your program crashed, it would save the entire state of memory and registers, and you could then browse the moment of the crash will full symbols. This post-mortem dump as it was called was a fantastic step forward over the memory dumps and very crude crash reporting systems of other languages.\n\nI mention this because the single hardest feature of my Beads language is the ability to time travel debug post mortem from user submitted dumps. It is pretty easy on a huge development machine to support time travel debugging, but to do that in a shipping product in the customer hands, that is something you don't see often. It is the intermittent errors that are the hardest to debug in my experience, and recreating the exact conditions of the user can be often impossible. I think the biggest scandal in computers today is not the size of the code bases, because with enough sweat and blood you can get  code pretty clean; what is embarrassing is that all the big companies have bug reports numbering in the hundreds of thousands if not millions of open cases that will never get fixed because the staff \"cannot duplicate\".",
        "user": "UEQ6M68H0",
        "ts": "1587625193.146500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S0B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I built two of the biggest Modula-2 projects ever made in the language, and used it exclusively for 20 years. Modula2 was the 10 year later sequel to Pascal. The big improvement other than a few expansions of the type system so you could have POINTER TO ARRAY [-5..+5] OF A_RECORD, which beats the hell out of C's nutty notation, was the module system. Modula2 had a unique approach that actually Prof. Wirth discard as cumbersome in Oberon. In Modula-2 each module had 2 separate files, an implementation file (the big one with the actual code) and a definition module, which held publicly visible constants, types, and function declarations. You compiled each of these 2 files separately; the definition first of course. What this gave you is that once you pinned down the external aspects of a module you were free to change the implementation part, and any other module that depended on it did not have to be recompiled when you change only the implementation file; just relink the program and execute. This goes way beyond compiled headers in C, because most of the time you change something in the implementation module, and don't modify the number or type of function parameters. This means recompilation of a 100k line program takes seconds. For small projects it is like having a REPL. There is a freeware Windows compiler (formerly the Stony Brook compiler) on the ADW website. This was the compiler i used for the WIndows side, and there is a small german firm P1 that made the Macintosh compiler.\n\nAnyway by forcing you to constantly evaluate what symbols are public or private, and being able to check that every call has the correct precise type, a great many errors are caught at compile time. Modula-2 was targeting system programming; it had no graphical primitives, so I used Win32 API and on the Macintosh the QuickDraw system (for OS7).  The way the language is structured, it drives you subtly towards a very modular type of coding style. You end up with various function libraries that tackle different tasks, and as your program gets larger you tend to make it even more modular and systematic. So it is a language that encourages virtue and a slightly lower exponent of expansion than C for example. When runtime checks are fully enabled in Modula-2 it puffs up the code by 30%, but that means you have tens of thousands of range checks, assignment compatibility, null pointer, etc. that are very helpful during testing. For golden master you turn them off and your program gets a big speed boost. Although i only got to speak with Prof. Wirth once, i consider myself a disciple of his Swiss school of programming which is all about neatness, economy, and rigor.\n\nModula2 as a language was damaged severely when Prof. Wirth made a sequel called Oberon, but in Oberon 1 he stripped out some very valuable features from Modula-2 and thus made it impossible for the Modula-2 users to move forward. This was not corrected until Oberon 2 and by that time the world has discovered the new panacea of OOP (a disaster IMHO), and Java ran away with the academic market. Modula2 did not have a good free compiler. Interestingly enough Logitech, the famous Mouse maker, was founded by a Swiss person, and they offered one of the first symbolic debuggers, which had the amazing feature that when your program crashed, it would save the entire state of memory and registers, and you could then browse the moment of the crash will full symbols. This post-mortem dump as it was called was a fantastic step forward over the memory dumps and very crude crash reporting systems of other languages.\n\nI mention this because the single hardest feature of my Beads language is the ability to time travel debug post mortem from user submitted dumps. It is pretty easy on a huge development machine to support time travel debugging, but to do that in a shipping product in the customer hands, that is something you don't see often. It is the intermittent errors that are the hardest to debug in my experience, and recreating the exact conditions of the user can be often impossible. I think the biggest scandal in computers today is not the size of the code bases, because with enough sweat and blood you can get  code pretty clean; what is embarrassing is that all the big companies have bug reports numbering in the hundreds of thousands if not millions of open cases that will never get fixed because the staff \"cannot duplicate\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U79HM6726"
                ],
                "count": 1
            },
            {
                "name": "pray::skin-tone-3",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dda3fd05-c0db-48dd-97f7-83d9698d575c",
        "type": "message",
        "text": "Here is an example of a bug i recently encountered, where Chrome doesn't display the chess unicode character for white piece correctly, because even when instructed to not promote to an emoji form, it does it anyway. I looked it up, and this bug has been outstanding in Chrome for over a year. Companies just can't seem to get their software fully correct. There's always a huge backlog of feature requests and bug reports, and years can go by with obvious errors lingering. This is the scandal. The hardware guys don't have this problem.",
        "user": "UEQ6M68H0",
        "ts": "1587625285.146700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1587625425.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OwVsa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here is an example of a bug i recently encountered, where Chrome doesn't display the chess unicode character for white piece correctly, because even when instructed to not promote to an emoji form, it does it anyway. I looked it up, and this bug has been outstanding in Chrome for over a year. Companies just can't seem to get their software fully correct. There's always a huge backlog of feature requests and bug reports, and years can go by with obvious errors lingering. This is the scandal. The hardware guys don't have this problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "type": "message",
        "text": "white pawns are drawing as emoji incorrectly",
        "files": [
            {
                "id": "F01263LKG2J",
                "created": 1587625306,
                "timestamp": 1587625306,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UEQ6M68H0",
                "editable": false,
                "size": 75387,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F01263LKG2J/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F01263LKG2J/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 194,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 259,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 388,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 432,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 518,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F01263LKG2J-71c1d453c4/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 552,
                "original_w": 1027,
                "original_h": 554,
                "thumb_tiny": "AwAZADBgBO0kEHsPWjBzkA7uMinDICgnJI4P92l5zgHDd29agsZt4IGSvOTU8aK0S5JOPeo+MZAwvdfWposeWMDA54pxEw8pff8AOhY1U5Gc/Wn0VViblRPunb93+Kl5KgEfL2/rUK/dNB+4KgonO/dk43jp6f561NFnyxnrzmqZ++Ktw/6papCZJRSUVRJ//9k=",
                "permalink": "https://futureofcoding.slack.com/files/UEQ6M68H0/F01263LKG2J/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F01263LKG2J-4ada9fdb0f",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xeO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "white pawns are drawing as emoji incorrectly"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UEQ6M68H0",
        "display_as_bot": false,
        "ts": "1587625310.146900",
        "client_msg_id": "4c8705ae-a9dc-4405-b5cd-449d9cc0302e",
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "1857be2a-3abf-42af-9420-c294eef9e7a7",
        "type": "message",
        "text": "When you have strict rules people will hack them aka \u201cgame the system\u201d.\n\nAn anecdote from 10 years ago - someone filed a ticket to request that the Python API for an internal service that I was maintaining be more Pythonic, which I guess it indeed wasn\u2019t.\n\nTo motivate his case he linked to 3 Pythonic wrappers for the API in the Google code base.\nThis was quite fishy in my eyes - if someone already made a Pythonic wrapper why did the other two write their own rather than use it? So I checked and indeed those 2 were pieces of code that were used to obtain the coveted internal language proficiency certification called \u201cReadability\u201d. While that certification was easy to get for many, due to its conditions it was challenging specifically for those tasked with maintaining existing production systems, so they needed to write unnecessary duplicated code to get the certification..\n\nThis is a small example out of many of how the system incentivized inefficiency and work of lesser quality.",
        "user": "U79HM6726",
        "ts": "1587634217.147600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U79HM6726",
            "ts": "1587634270.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vyD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you have strict rules people will hack them aka \u201cgame the system\u201d.\n\nAn anecdote from 10 years ago - someone filed a ticket to request that the Python API for an internal service that I was maintaining be more Pythonic, which I guess it indeed wasn\u2019t.\n\nTo motivate his case he linked to 3 Pythonic wrappers for the API in the Google code base.\nThis was quite fishy in my eyes - if someone already made a Pythonic wrapper why did the other two write their own rather than use it? So I checked and indeed those 2 were pieces of code that were used to obtain the coveted internal language proficiency certification called \u201cReadability\u201d. While that certification was easy to get for many, due to its conditions it was challenging specifically for those tasked with maintaining existing production systems, so they needed to write unnecessary duplicated code to get the certification..\n\nThis is a small example out of many of how the system incentivized inefficiency and work of lesser quality."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "43e8b9c4-b344-42c9-83a3-bb398093fa6c",
        "type": "message",
        "text": "<@UEQ6M68H0>'s comment about Modula2 (which I remember fondly as well) reminds me of something I have been looking for for a while: a comparative evaluation of software architectures that different languages and toolsets end up encouraging in practice. Has anyone ever seen something like that?",
        "user": "UJBAJNFLK",
        "ts": "1587634501.148000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WGbV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": "'s comment about Modula2 (which I remember fondly as well) reminds me of something I have been looking for for a while: a comparative evaluation of software architectures that different languages and toolsets end up encouraging in practice. Has anyone ever seen something like that?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "afabce4d-4261-4df6-8504-e87895cfede2",
        "type": "message",
        "text": "As I programming language designer, I do believe in a weak form of the Sapir-Whorf hypothesis. There is now enough experimental evidence that I consider it proven. See the work by Lera Boroditsky, for example.",
        "user": "UJN1TAYEQ",
        "ts": "1587656695.149000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1G7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As I programming language designer, I do believe in a weak form of the Sapir-Whorf hypothesis. There is now enough experimental evidence that I consider it proven. See the work by Lera Boroditsky, for example."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586922294.436000",
        "parent_user_id": "UJRDRMWQN"
    },
    {
        "client_msg_id": "0770253a-48c7-4943-984b-f84a4866a760",
        "type": "message",
        "text": "The author says that programming languages aren't languages, and that Sapir Whorf doesn't apply to programming languages. My personal experience contradicts both statements.",
        "user": "UJN1TAYEQ",
        "ts": "1587656818.149200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U8H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The author says that programming languages aren't languages, and that Sapir Whorf doesn't apply to programming languages. My personal experience contradicts both statements."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586922294.436000",
        "parent_user_id": "UJRDRMWQN"
    },
    {
        "client_msg_id": "443574fe-9192-4666-b3b4-8132be9dff34",
        "type": "message",
        "text": "Programming languages are more than just tools. They are notation for describing algorithms. For communicating ideas between human beings, just like written language. In the early days of programming, before the first compiler, we wrote programs in high level languages for the purpose of communicating algorithms between programmers, and mathematical notation was invented centuries before that. The lambda calculus is now considered an early programming language, but it was invented in the 1930's as a notation for describing recursive functions, and it clearly wasn't a \"tool\" then.",
        "user": "UJN1TAYEQ",
        "ts": "1587659053.149400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1587659142.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mK8j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Programming languages are more than just tools. They are notation for describing algorithms. For communicating ideas between human beings, just like written language. In the early days of programming, before the first compiler, we wrote programs in high level languages for the purpose of communicating algorithms between programmers, and mathematical notation was invented centuries before that. The lambda calculus is now considered an early programming language, but it was invented in the 1930's as a notation for describing recursive functions, and it clearly wasn't a \"tool\" then."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586922294.436000",
        "parent_user_id": "UJRDRMWQN",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ade65569-3001-4a97-a7e6-ead49b15848d",
        "type": "message",
        "text": "Here's another perspective. Hominins have been making tools for a million years (fire, stone knives). Anatomically modern homo sapiens has existed for 200,000 years (AFAWK our brains have been anatomically modern for this long). But language is only about 40,000 years old. Language is a technology: it is a tool of communication, and a tool of thought. We invented language as a tool, just as we invented flint knives and various other technologies in even earlier eras.",
        "user": "UJN1TAYEQ",
        "ts": "1587660709.149700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eh4kP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's another perspective. Hominins have been making tools for a million years (fire, stone knives). Anatomically modern homo sapiens has existed for 200,000 years (AFAWK our brains have been anatomically modern for this long). But language is only about 40,000 years old. Language is a technology: it is a tool of communication, and a tool of thought. We invented language as a tool, just as we invented flint knives and various other technologies in even earlier eras."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586922294.436000",
        "parent_user_id": "UJRDRMWQN"
    },
    {
        "client_msg_id": "092dcc37-b995-4ecd-aa13-527c86c3ea22",
        "type": "message",
        "text": "i honestly just got excited at the thought of like a wacky hyperbolic geometry interface to grid structures or something",
        "user": "UHWC9PXBL",
        "ts": "1587664771.150000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1587664828.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pNCd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i honestly just got excited at the thought of like a wacky hyperbolic geometry interface to grid structures or something"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587409068.093400",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "9ba87c9b-533f-4810-82ed-2846e28d697b",
        "type": "message",
        "text": "Okay, so relations are not relationships (which certainly feel second-class in SQL). But what does it mean for tables to be first class? Couldn't we say, for example, that that a growable list of records (objects with properties) in C# is basically the same as a table, and that it is first-class in some sense? It seems like maybe the goal is to make \"query composition\" first class, or something like that.",
        "user": "UD6EXQVM0",
        "ts": "1587670819.150400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1587670890.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3l/o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Okay, so relations are not relationships (which certainly feel second-class in SQL). But what does it mean for tables to be first class? Couldn't we say, for example, that that a growable list of records (objects with properties) in C# is basically the same as a table, and that it is first-class in some sense? It seems like maybe the goal is to make \"query composition\" first class, or something like that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587276251.075500",
        "parent_user_id": "U012FRV0EV7"
    },
    {
        "client_msg_id": "a2d7e362-3ed1-4fe0-a072-a9487a4b0e99",
        "type": "message",
        "text": "<@UEQ6M68H0> you're assuming the primary function of large companies is some sort of idealized engineering efficiency (and that shared components and small code bases would realize that...)  and not primarily financially and politically motivated",
        "user": "UBSMEUXAA",
        "ts": "1587671996.151000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IT5zA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " you're assuming the primary function of large companies is some sort of idealized engineering efficiency (and that shared components and small code bases would realize that...)  and not primarily financially and politically motivated"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "c4e78fc6-27cc-42bd-b2a2-70d531a03e61",
        "type": "message",
        "text": "At big tech companies employees are rewarded when they duplicate engineering work in manner that is efficient for the business and/or efficient politically",
        "user": "UBSMEUXAA",
        "ts": "1587672058.151200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1pUyg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At big tech companies employees are rewarded when they duplicate engineering work in manner that is efficient for the business and/or efficient politically"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "e7f945f6-254c-4cdf-90ca-5989808668f7",
        "type": "message",
        "text": "That means impress/appease someone higher up than you and potentially other teams that are in alignment, but harming teams that are in competition with you by making it harder for them to share can also be advantageous",
        "user": "UBSMEUXAA",
        "ts": "1587672140.151400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mmw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That means impress/appease someone higher up than you and potentially other teams that are in alignment, but harming teams that are in competition with you by making it harder for them to share can also be advantageous"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "5ae1f468-cf34-4983-9cb0-957b737c42e1",
        "type": "message",
        "text": "I'm not saying it's not fucked up, but you can't examine any large tech company's engineering practice and ignore the business incentives that got us here",
        "user": "UBSMEUXAA",
        "ts": "1587672188.151600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eKa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not saying it's not fucked up, but you can't examine any large tech company's engineering practice and ignore the business incentives that got us here"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "37bec22b-0ce2-4aea-81bf-3f33f926fc4b",
        "type": "message",
        "text": "Much of this starts with hypergrowth preferring VC investment, but large multinational corporations are generally \"inefficient\" when that inefficiency can lead to some kind of economic success",
        "user": "UBSMEUXAA",
        "ts": "1587672269.151800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NWEl2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Much of this starts with hypergrowth preferring VC investment, but large multinational corporations are generally \"inefficient\" when that inefficiency can lead to some kind of economic success"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "962ccec8-e60a-4bc4-a063-81ef23365874",
        "type": "message",
        "text": "I am not arguing against you btw, I'm mostly on agreement",
        "user": "UBSMEUXAA",
        "ts": "1587672360.152000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FVi9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am not arguing against you btw, I'm mostly on agreement"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "18c7f9a7-b26e-4eda-82e9-f1803b3e5219",
        "type": "message",
        "text": "I think it's worth examining how large companies get to where they are though",
        "user": "UBSMEUXAA",
        "ts": "1587672384.152200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GKL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think it's worth examining how large companies get to where they are though"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "ff72a931-bc1d-40e8-8caa-7d7942d45a80",
        "type": "message",
        "text": "I have long suspected that COBOL was selected over the mostly superior FORTRAN by the employees of big corporations because it afforded more billable hours. Many a computer company lived on consulting fees earned programming in a supposedly easy to maintain language like COBOL. COBOL was verbose and very annoying. It did have BCD arithmetic and a convenient number formatting syntax, but overall was inferior. The same kind of decision was made to elevate Java to the #1 slot, when it is also a ponderous, ugly language. If your managers have no clue as to the quality of your work, they may indeed judge you \"by the pound\", and the more verbose the language, and the more copy/paste you perform, the higher your apparent productivity. The inability to measure and judge accurately the code quality of programmers is an interesting area. It is pretty easy for anyone to recognize good singing, dancing, and painting. Poetry is a great deal more subjective. I think programming is a great deal like mathematical poetry. And people f*cking hate poetry.",
        "user": "UEQ6M68H0",
        "ts": "1587680564.152600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2LLZq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have long suspected that COBOL was selected over the mostly superior FORTRAN by the employees of big corporations because it afforded more billable hours. Many a computer company lived on consulting fees earned programming in a supposedly easy to maintain language like COBOL. COBOL was verbose and very annoying. It did have BCD arithmetic and a convenient number formatting syntax, but overall was inferior. The same kind of decision was made to elevate Java to the #1 slot, when it is also a ponderous, ugly language. If your managers have no clue as to the quality of your work, they may indeed judge you \"by the pound\", and the more verbose the language, and the more copy/paste you perform, the higher your apparent productivity. The inability to measure and judge accurately the code quality of programmers is an interesting area. It is pretty easy for anyone to recognize good singing, dancing, and painting. Poetry is a great deal more subjective. I think programming is a great deal like mathematical poetry. And people f*cking hate poetry."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587586029.117700",
        "parent_user_id": "UFEQUBNNT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UBSMEUXAA",
                    "U79HM6726"
                ],
                "count": 2
            }
        ]
    }
]