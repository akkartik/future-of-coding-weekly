[
    {
        "client_msg_id": "614884f2-9f94-41f2-9861-b84268cb232a",
        "type": "message",
        "text": "Python has no great event associated with its ascendancy. It is purely by good ergonomic design that it has crept up slowly and steadily. Better languages will replace JS, Java and Python, because those languages are inherently poor as they leave the user spending over 80% of their time debugging. All 3 are low productivity languages, and when something comes along that fixes the largest remaining problem in programming - which is debugging - they will finally start to wither. You can see the pressure building on JS, as TypeScript and so many others keep increasing share. JS, as a mandated language, has not had to compete on merit, but the eventual opening up to other languages via the evolution of WASM  will cause it to be dethroned. That being said, programming languages move like glaciers, very slowly. It took Python 25 years to get to where it is now.",
        "user": "UEQ6M68H0",
        "ts": "1577761209.335100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "j5+g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Python has no great event associated with its ascendancy. It is purely by good ergonomic design that it has crept up slowly and steadily. Better languages will replace JS, Java and Python, because those languages are inherently poor as they leave the user spending over 80% of their time debugging. All 3 are low productivity languages, and when something comes along that fixes the largest remaining problem in programming - which is debugging - they will finally start to wither. You can see the pressure building on JS, as TypeScript and so many others keep increasing share. JS, as a mandated language, has not had to compete on merit, but the eventual opening up to other languages via the evolution of WASM  will cause it to be dethroned. That being said, programming languages move like glaciers, very slowly. It took Python 25 years to get to where it is now."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "92A02D12-12B9-4967-8380-5569109DE695",
        "type": "message",
        "text": "My impression (which may be wrong) is that python took off when web server scripting took off and it was the only OO Unix scripting language. Ruby followed but had no traction until Rails.",
        "user": "ULM3U6275",
        "ts": "1577763252.337500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1577763670.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9Z3YH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My impression (which may be wrong) is that python took off when web server scripting took off and it was the only OO Unix scripting language. Ruby followed but had no traction until Rails."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "137cd97c-95ac-4752-a30c-7f854adad75b",
        "type": "message",
        "text": "I'm late to this post (coming via the newsletter) \u2014 sorry!\n\nOne kind of fun reading it is in looking at each of these principles and deciding where in the divide my own work falls.\n\n&gt; Tools for everyone &gt; better tools for experts\nIn this case, my first reaction was to assert to myself, \"I'm 100% working on tools for experts!\" But upon reflection, I realized that I'm actually trying to do both.\n\nI'm working on tools for everyone, that allow for the gradual development of deep expertise in those tools. Tools for new experts.\n\nThis is an interesting framing device, especially in light of the recent discussion about <https://ralphammer.com/make-me-think/>. When people say \"programming tools for everyone\", I think there's usually a tacit assumption that these tools will reduce incidental complexity as much as possible, sure, but then hide whatever complexity remains but the designer feels hinders approachability. I wonder if that's just my assumption, though, informed by existing examples of accessible but sharply curtailed \"everyone can do it\" programming tools \u2014 Shortcuts, for instance.\n\nWhat do you (person reading this) think of when you read the phrase \"tools for everyone\"? Do you imagine people becoming dizzyingly virtuosic with those tools, or do you mostly imagine children and non-tech adults taking their first steps into computation and playing with data in new but relatively simple ways?",
        "user": "UC2A2ARPT",
        "ts": "1577823396.338700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1577823808.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bE6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm late to this post (coming via the newsletter) \u2014 sorry!\n\nOne kind of fun reading it is in looking at each of these principles and deciding where in the divide my own work falls.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Tools for everyone > better tools for experts"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIn this case, my first reaction was to assert to myself, \"I'm 100% working on tools for experts!\" But upon reflection, I realized that I'm actually trying to do both.\n\nI'm working on tools for everyone, that allow for the gradual development of deep expertise in those tools. Tools for new experts.\n\nThis is an interesting framing device, especially in light of the recent discussion about "
                            },
                            {
                                "type": "link",
                                "url": "https://ralphammer.com/make-me-think/"
                            },
                            {
                                "type": "text",
                                "text": ". When people say \"programming tools for everyone\", I think there's usually a tacit assumption that these tools will reduce incidental complexity as much as possible, sure, but then hide whatever complexity remains but the designer feels hinders approachability. I wonder if that's just my assumption, though, informed by existing examples of accessible but sharply curtailed \"everyone can do it\" programming tools \u2014 Shortcuts, for instance.\n\nWhat do you (person reading this) think of when you read the phrase \"tools for everyone\"? Do you imagine people becoming dizzyingly virtuosic with those tools, or do you mostly imagine children and non-tech adults taking their first steps into computation and playing with data in new but relatively simple ways?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577227635.106800",
        "parent_user_id": "UE6EFEPTQ",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    }
]