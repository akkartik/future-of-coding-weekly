[
    {
        "client_msg_id": "ea480e0b-4d5d-4740-96ed-932e57d27e5f",
        "type": "message",
        "text": "<@UCUSW7WVD> great! Were there any points that really stuck? Or warrant further explanation?",
        "user": "UFB8STN7K",
        "ts": "1595805531.423200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vmm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " great! Were there any points that really stuck? Or warrant further explanation?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595636687.411800",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "b620db54-e47e-401b-b8b8-941b92c62b99",
        "type": "message",
        "text": "Aha's for me:\n* the borrow checker is incomplete\n* It conflates type parameters\n* It conflates array indices (makes sense once I think about it)\n* Your checklist of questions on existing an error message.\n* The need for teaching ownership-based reasoning.\n* How perverse the bag of tricks can be.\n* How more complex analysis has the unanticipated drawback of reducing opportunities for learning.\n\nMaybe we need multiple analysis engines that can be swapped out?",
        "user": "UCUSW7WVD",
        "ts": "1595810020.423400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zMHL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Aha's for me:\n* the borrow checker is incomplete\n* It conflates type parameters\n* It conflates array indices (makes sense once I think about it)\n* Your checklist of questions on existing an error message.\n* The need for teaching ownership-based reasoning.\n* How perverse the bag of tricks can be.\n* How more complex analysis has the unanticipated drawback of reducing opportunities for learning.\n\nMaybe we need multiple analysis engines that can be swapped out?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595636687.411800",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ba23d221-a0ed-4dcb-b3f9-93cc0ef23941",
        "type": "message",
        "text": "Here is a bit of context. I have a very small Rust experience. As small as reading half of \"Programming Rust\" from O'Reilly, start coding in Rust, trying to replicate other languages habits, struggle with lot's of compiler error messages, finally actually understand the hard way that habits must change, unperfectly change them, implement some basic toy CRDT algorithm in Rust (which target WebAssembly for use in the browser), forget about all of this (it was one year ago and I didn't use Rust again since).\n\nFor your first question:\n&gt; Does the process of interpreting a type error make sense? Does it ring true to your own experience (in Rust or other languages?)\nYes, completely. And especially with Rust. Even if my memory of Rust is a bit... rusty (sorry for the bad pun...) and even if I didn't catch very well all your code examples (maybe I read it too fast too) reading the discussion totally makes sense and resonates with what I have experienced. To be precise on one point: I didn't write any unsafe code, even if there were several cases where it can be a solution. But as I was learning, and it strongly feels against the Rust idea, and that it seems complicated to write (and need to learn new things like you point in the article), I didn't do it.\n\nAnd for the other question:\n&gt; Did you learn something new? Does this paper help you understand/frame the usability challenges about Rust specifically, or potentially a different language?\nTotally, it is a kind of global 'aha' moment too for me. All your points are like I felt them during my Rust experience but didn't really grasp or \"put a name\" on it. Especially, it wasn't clear to me that some compiler errors were due to incompletness, and I feel like knowing this would have been of great help in the way to manage the compiler and its messages, and knowing it now will definitely helps me in my future Rust experience (if any).",
        "user": "UJ6LDMMN0",
        "ts": "1595837470.424000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VzJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here is a bit of context. I have a very small Rust experience. As small as reading half of \"Programming Rust\" from O'Reilly, start coding in Rust, trying to replicate other languages habits, struggle with lot's of compiler error messages, finally actually understand the hard way that habits must change, unperfectly change them, implement some basic toy CRDT algorithm in Rust (which target WebAssembly for use in the browser), forget about all of this (it was one year ago and I didn't use Rust again since).\n\nFor your first question:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does the process of interpreting a type error make sense? Does it ring true to your own experience (in Rust or other languages?)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, completely. And especially with Rust. Even if my memory of Rust is a bit... rusty (sorry for the bad pun...) and even if I didn't catch very well all your code examples (maybe I read it too fast too) reading the discussion totally makes sense and resonates with what I have experienced. To be precise on one point: I didn't write any unsafe code, even if there were several cases where it can be a solution. But as I was learning, and it strongly feels against the Rust idea, and that it seems complicated to write (and need to learn new things like you point in the article), I didn't do it.\n\nAnd for the other question:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Did you learn something new? Does this paper help you understand/frame the usability challenges about Rust specifically, or potentially a different language?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally, it is a kind of global 'aha' moment too for me. All your points are like I felt them during my Rust experience but didn't really grasp or \"put a name\" on it. Especially, it wasn't clear to me that some compiler errors were due to incompletness, and I feel like knowing this would have been of great help in the way to manage the compiler and its messages, and knowing it now will definitely helps me in my future Rust experience (if any)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595636687.411800",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "UFB8STN7K"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "36e7c4e2-49ee-4f29-833a-611e93bb050e",
        "type": "message",
        "text": "Currently, we work with OpenGL. Skia already supports Metal, but we just didn\u2019t adopt it yet. We will in the near future.\n\nSo, currently, if you have OpenGL context, you can just draw to texture and we display it as is. For now, if you want to try Metal, it would require an extra step of going from a texture to a pixel buffer.\u00a0But, when we will be on Metal, that extra step will not be needed anymore.",
        "user": "UE1JQM9HQ",
        "ts": "1595840892.424200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wYI3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Currently, we work with OpenGL. Skia already supports Metal, but we just didn\u2019t adopt it yet. We will in the near future.\n\nSo, currently, if you have OpenGL context, you can just draw to texture and we display it as is. For now, if you want to try Metal, it would require an extra step of going from a texture to a pixel buffer.\u00a0But, when we will be on Metal, that extra step will not be needed anymore."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595571873.400800",
        "parent_user_id": "UE1JQM9HQ"
    }
]