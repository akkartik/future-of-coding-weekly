[
    {
        "client_msg_id": "fc374913-3ed2-4266-b402-c0fd70be53f7",
        "type": "message",
        "text": "you might also be pleased to see (if you haven\u2019t) the inspiration for sparklines: <https://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=00004p>",
        "user": "UHWC9PXBL",
        "ts": "1594504815.250800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iOP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you might also be pleased to see (if you haven\u2019t) the inspiration for sparklines: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=00004p"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594305313.149000",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "type": "message",
        "text": "roughly \u201cif you look at saturn with a really great lens on your telescope, it looks like &lt;this&gt;. if you look at it with a really crappy lens, it looks like &lt;this&gt;\u2014galileo",
        "files": [
            {
                "id": "F016YA19P2P",
                "created": 1594504845,
                "timestamp": 1594504845,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UHWC9PXBL",
                "editable": false,
                "size": 2716399,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F016YA19P2P/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F016YA19P2P/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_360.png",
                "thumb_360_w": 244,
                "thumb_360_h": 360,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_480.png",
                "thumb_480_w": 326,
                "thumb_480_h": 480,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_720.png",
                "thumb_720_w": 489,
                "thumb_720_h": 720,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 1179,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_960.png",
                "thumb_960_w": 651,
                "thumb_960_h": 960,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA19P2P-8e81f2d59b/image_1024.png",
                "thumb_1024_w": 695,
                "thumb_1024_h": 1024,
                "original_w": 857,
                "original_h": 1263,
                "thumb_tiny": "AwAwACC2B8i/SgAE9B+VA+4v0pR1FIYhUA4AH5UoHB+lDfeNAHX6UAKFOBlT09RS7PY/nTJD85pMUASYyfun8xRggHCn8xTBTk64oAaxQk5Y8+1A2f3/ANKjKk5wMD6Clxx/9YUASjZjO4/lSqVA+91qLJGOM/lSjkjg8+w4oA//2Q==",
                "permalink": "https://futureofcoding.slack.com/files/UHWC9PXBL/F016YA19P2P/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F016YA19P2P-a12f9e9eb5",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PELk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "roughly \u201cif you look at saturn with a really great lens on your telescope, it looks like <this>. if you look at it with a really crappy lens, it looks like <this>\u2014galileo"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UHWC9PXBL",
        "display_as_bot": false,
        "ts": "1594504872.251000",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1594504924.000000"
        },
        "thread_ts": "1594305313.149000",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "text": "finally found a blog post about rebol/red that communicates some of what I suspected was interesting about it: <http://www.codeconscious.com/rebol/articles/rebol-concepts.html> . in particular, in the screencap: the body of a function and its argument list are just data structures. so you can use them as first-class citzens as you like. please let me know if any of you know of any other languages with this level of flexibility!",
        "files": [
            {
                "id": "F017ANDA6F3",
                "created": 1594505082,
                "timestamp": 1594505082,
                "name": "Screen Shot 2020-07-11 at 6.04.38 PM.png",
                "title": "Screen Shot 2020-07-11 at 6.04.38 PM.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UHWC9PXBL",
                "editable": false,
                "size": 181646,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F017ANDA6F3/screen_shot_2020-07-11_at_6.04.38_pm.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F017ANDA6F3/download/screen_shot_2020-07-11_at_6.04.38_pm.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_360.png",
                "thumb_360_w": 345,
                "thumb_360_h": 360,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_480.png",
                "thumb_480_w": 460,
                "thumb_480_h": 480,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_720.png",
                "thumb_720_w": 689,
                "thumb_720_h": 720,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 836,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_960.png",
                "thumb_960_w": 919,
                "thumb_960_h": 960,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F017ANDA6F3-245ad79763/screen_shot_2020-07-11_at_6.04.38_pm_1024.png",
                "thumb_1024_w": 980,
                "thumb_1024_h": 1024,
                "original_w": 1126,
                "original_h": 1176,
                "thumb_tiny": "AwAwAC2sFyB8tLt/2aRSMDmlyPWpJEIOfuik2n0FLuHvRuHvQAmD/dWjB/urS7h70hY54JxQA5ThR0o3fShSdo/woyf8ikAZozRk/wCRQSewzQAE0m4/3TRlv7tGW/u0AAOFHNLn/a/SlU4UcH8qXI9DTAbn3/SkLfX8qd+B/KgkD1/GkA3d7H8qTc3p+lO3D1o3D1oA/9k=",
                "permalink": "https://futureofcoding.slack.com/files/UHWC9PXBL/F017ANDA6F3/screen_shot_2020-07-11_at_6.04.38_pm.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F017ANDA6F3-9da1fe806d",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TrX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "finally found a blog post about rebol/red that communicates some of what I suspected was interesting about it: "
                            },
                            {
                                "type": "link",
                                "url": "http://www.codeconscious.com/rebol/articles/rebol-concepts.html"
                            },
                            {
                                "type": "text",
                                "text": " . in particular, in the screencap: the body of a function and its argument list are just data structures. so you can use them as first-class citzens as you like. please let me know if any of you know of any other languages with this level of flexibility!"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UHWC9PXBL",
        "display_as_bot": false,
        "ts": "1594505114.252600",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1594505233.000000"
        },
        "thread_ts": "1594505114.252600",
        "reply_count": 38,
        "reply_users_count": 10,
        "latest_reply": "1594610547.326300",
        "reply_users": [
            "UHWC9PXBL",
            "U01661S9F34",
            "UCUSW7WVD",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "U8A5MS6R1",
            "U01448TH3PG",
            "UJBAJNFLK",
            "UMWF81HTP",
            "UA14TGLTC"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "b6e72ff2-5bad-48f1-94d5-3320c5be6694",
        "type": "message",
        "text": "bizarrely, some of rebol\u2019s choices about mutability extend to the source code:",
        "user": "UHWC9PXBL",
        "ts": "1594505161.253000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E/0y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "bizarrely, some of rebol\u2019s choices about mutability extend to the source code:"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "type": "message",
        "text": "",
        "files": [
            {
                "id": "F016YA3JQ1Z",
                "created": 1594505181,
                "timestamp": 1594505181,
                "name": "Screen Shot 2020-07-11 at 6.06.18 PM.png",
                "title": "Screen Shot 2020-07-11 at 6.06.18 PM.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UHWC9PXBL",
                "editable": false,
                "size": 205912,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F016YA3JQ1Z/screen_shot_2020-07-11_at_6.06.18_pm.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F016YA3JQ1Z/download/screen_shot_2020-07-11_at_6.06.18_pm.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 355,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 473,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 710,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 789,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 946,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F016YA3JQ1Z-3d10b7710c/screen_shot_2020-07-11_at_6.06.18_pm_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 1009,
                "original_w": 1128,
                "original_h": 1112,
                "thumb_tiny": "AwAvADCsAcdD+QowfT9BT1OBz6UE1Fybkfzeg/IUYb0FPoouFxnzeg/IUm0+lSUUXC4gxgf40ce350oAwOKCB6U7hcTj2/Ojj2opaLhcTj2pG288nNOpKLhcA3AG4UZH94UBhgc0bh60AGR/eFGR/eFJvHpRvHoaAFyP7wpCfQg0bx6Gms2QOtAH/9k=",
                "permalink": "https://futureofcoding.slack.com/files/UHWC9PXBL/F016YA3JQ1Z/screen_shot_2020-07-11_at_6.06.18_pm.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F016YA3JQ1Z-593d4692f6",
                "is_starred": false,
                "has_rich_preview": false
            },
            {
                "id": "F016RBYNT8W",
                "created": 1594505193,
                "timestamp": 1594505193,
                "name": "Screen Shot 2020-07-11 at 6.06.30 PM.png",
                "title": "Screen Shot 2020-07-11 at 6.06.30 PM.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UHWC9PXBL",
                "editable": false,
                "size": 118303,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F016RBYNT8W/screen_shot_2020-07-11_at_6.06.30_pm.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F016RBYNT8W/download/screen_shot_2020-07-11_at_6.06.30_pm.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 185,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 247,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 371,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 412,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 494,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F016RBYNT8W-81003c7e26/screen_shot_2020-07-11_at_6.06.30_pm_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 527,
                "original_w": 1142,
                "original_h": 588,
                "thumb_tiny": "AwAYADCuFGBx2o2j0pVUECl2ipuTcbtHoKMDuAKMCjA9KLhcPl9qawGOCPwp20elBUY6UXC4BsAUu7/OaioosBJn/OaM/wCc1HRRYCTP+c0hYdKZRRYD/9k=",
                "permalink": "https://futureofcoding.slack.com/files/UHWC9PXBL/F016RBYNT8W/screen_shot_2020-07-11_at_6.06.30_pm.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F016RBYNT8W-8f35949b3d",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "user": "UHWC9PXBL",
        "ts": "1594505195.253200",
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "FB8A4219-B8C3-4005-A19F-98BD78CFD6A8",
        "type": "message",
        "text": "Thanks everybody for insights. Speaking of the types of business practices <@UC2A2ARPT> mentioned, it strikes me that maybe this is not really a problem of our relationship with the software itself, but of business behind it. The software is a similar proxy as a traditional service rep; both are employed to help customers when helping them is in the interest of the business, politely refusing to help using specific sanctioned language when it\u2019s not, and just empathizing without really helping in the gray area between.",
        "user": "U0137BUHUBW",
        "ts": "1594506342.260000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KjB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks everybody for insights. Speaking of the types of business practices "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " mentioned, it strikes me that maybe this is not really a problem of our relationship with the software itself, but of business behind it. The software is a similar proxy as a traditional service rep; both are employed to help customers when helping them is in the interest of the business, politely refusing to help using specific sanctioned language when it\u2019s not, and just empathizing without really helping in the gray area between."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7C6EFB3A-73EE-4E79-A7EC-1E71D1B04BD9",
        "type": "message",
        "text": "Thus when Apple insists on me updating my OS, they can\u2019t allow me to tell them \u201cNo\u201d, because they believe they need to keep as many users as possible in the latest version.",
        "user": "U0137BUHUBW",
        "ts": "1594506560.262000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W5n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thus when Apple insists on me updating my OS, they can\u2019t allow me to tell them \u201cNo\u201d, because they believe they need to keep as many users as possible in the latest version."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW"
    },
    {
        "client_msg_id": "20F0A4FD-C47C-4856-9264-82E6CE8CC4A5",
        "type": "message",
        "text": "Of course, I can just keep hitting \u201cremind me later\u201d and it\u2019s effectively a \u201cNo\u201d, so it\u2019s effectively just a silly power demonstration",
        "user": "U0137BUHUBW",
        "ts": "1594506856.264800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VNNNe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Of course, I can just keep hitting \u201cremind me later\u201d and it\u2019s effectively a \u201cNo\u201d, so it\u2019s effectively just a silly power demonstration"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW"
    },
    {
        "client_msg_id": "47ee77b9-083b-4d43-98ff-8e6afc757bd3",
        "type": "message",
        "text": "Lisp is the benevolent grandparent of this concept. But this aspect of Red / Rebol reminds me more of concatenative languages and stack languages like <https://en.wikipedia.org/wiki/Forth_(programming_language)|Forth>.\n\nMy hobby language of choice is <https://nim-lang.org/|Nim>. Nim is a much more traditional programming language in many ways. It exposes the \"code as data\" / macro features by essentially providing you with the same AST data structures that the compiler itself uses. Macros in Nim are \"compiler plugins\" in a very concrete way. This has it's own pros and cons and gotchas.\n\nNot many \"big syntax\", non-homoiconic languages are able to do this. Rebol/Red is one of the few in this category that can.\n\nRuby and Smalltalk arguably achieve similar things, but in a different way. They push more semantics into the runtime via OOP and message passing.",
        "user": "U01661S9F34",
        "ts": "1594507792.265000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1594507914.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U9X+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Lisp is the benevolent grandparent of this concept. But this aspect of Red / Rebol reminds me more of concatenative languages and stack languages like "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Forth_(programming_language)",
                                "text": "Forth"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nMy hobby language of choice is "
                            },
                            {
                                "type": "link",
                                "url": "https://nim-lang.org/",
                                "text": "Nim"
                            },
                            {
                                "type": "text",
                                "text": ". Nim is a much more traditional programming language in many ways. It exposes the \"code as data\" / macro features by essentially providing you with the same AST data structures that the compiler itself uses. Macros in Nim are \"compiler plugins\" in a very concrete way. This has it's own pros and cons and gotchas.\n\nNot many \"big syntax\", non-homoiconic languages are able to do this. Rebol/Red is one of the few in this category that can.\n\nRuby and Smalltalk arguably achieve similar things, but in a different way. They push more semantics into the runtime via OOP and message passing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "c090ae29-27b4-415f-abf9-0f84d80e25c9",
        "type": "message",
        "text": "yeah\u2014this is a step beyond lisp (and by extension ruby, and maaybe smalltalk)",
        "user": "UHWC9PXBL",
        "ts": "1594508966.265500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QfC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah\u2014this is a step beyond lisp (and by extension ruby, and maaybe smalltalk)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "a4288970-328d-4ece-87b8-a5c232b21449",
        "type": "message",
        "text": "Can you elaborate on what you mean by \"a step beyond lisp\"?\n\nIt's pretty hard to beat lisp on flexibility lol.\nIf you look at <https://gist.github.com/chaitanyagupta/9324402|lisp reader macros>, and Racket with <https://cacm.acm.org/magazines/2018/3/225475-a-programmable-programming-language/fulltext|it's many DSL's philosophy>, I think you will see the same level of flexibility, just in a different form.\n\nIMO this is not a case in which one solution is strictly better or more powerful than another. I have a hunch that many macro, DSL generation, \"code as data\", and \"programmable programming language\" ideas are isomorphic to each other and are fundamentally equivalent.\n\nIt comes down to taste, and which solution you prefer on a practical level. I think this is an example of the phrase \"there are many ways to cook an egg...\" (replace with equivalent phrase from your childhood here :slightly_smiling_face: ).",
        "user": "U01661S9F34",
        "ts": "1594512848.265900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1594512859.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "026j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can you elaborate on what you mean by \"a step beyond lisp\"?\n\nIt's pretty hard to beat lisp on flexibility lol.\nIf you look at "
                            },
                            {
                                "type": "link",
                                "url": "https://gist.github.com/chaitanyagupta/9324402",
                                "text": "lisp reader macros"
                            },
                            {
                                "type": "text",
                                "text": ", and Racket with "
                            },
                            {
                                "type": "link",
                                "url": "https://cacm.acm.org/magazines/2018/3/225475-a-programmable-programming-language/fulltext",
                                "text": "it's many DSL's philosophy"
                            },
                            {
                                "type": "text",
                                "text": ", I think you will see the same level of flexibility, just in a different form.\n\nIMO this is not a case in which one solution is strictly better or more powerful than another. I have a hunch that many macro, DSL generation, \"code as data\", and \"programmable programming language\" ideas are isomorphic to each other and are fundamentally equivalent.\n\nIt comes down to taste, and which solution you prefer on a practical level. I think this is an example of the phrase \"there are many ways to cook an egg...\" (replace with equivalent phrase from your childhood here "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " )."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "c08bc708-eaa2-4557-a510-ea0d27970ef5",
        "type": "message",
        "text": "It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways. More powerful than reader macros.\n\nAlso, there's a principled way for macros to track the scope of variables.\n\nI'm not experienced in it so don't have a sense for what the cons (ha!) are.",
        "user": "UCUSW7WVD",
        "ts": "1594513549.266300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nspi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways. More powerful than reader macros.\n\nAlso, there's a principled way for macros to track the scope of variables.\n\nI'm not experienced in it so don't have a sense for what the cons (ha!) are."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "rolling_on_the_floor_laughing",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "98821032-4d97-4c66-95b0-886614b04ab0",
        "type": "message",
        "text": "\"It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways.\"\nCan you explain that more? I have to admit I have limited experience with reader macros myself. What you are describing sounds equivalent to reader macros to me.",
        "user": "U01661S9F34",
        "ts": "1594513910.266600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1594513934.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kS=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways.\"\nCan you explain that more? I have to admit I have limited experience with reader macros myself. What you are describing sounds equivalent to reader macros to me."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "10875740-69fa-471e-9ddc-42f1999767ae",
        "type": "message",
        "text": "Reader macros have to follow certain rules Red doesn't. I don't remember the details, but Red allows special syntax for urls and html I believe. You can't do that with reader macros.",
        "user": "UCUSW7WVD",
        "ts": "1594514481.266900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "s14ep",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Reader macros have to follow certain rules Red doesn't. I don't remember the details, but Red allows special syntax for urls and html I believe. You can't do that with reader macros."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "a06e55ea-02a0-42cc-80bd-e057bb28075e",
        "type": "message",
        "text": "The link in my first post uses as an example a reader macro for embedding a full JSON object directly into a lisp program. And <https://docs.racket-lang.org/scribble/index.html|Racket Scribble> is like a fully embedded markdown parser that can freely mix with lisp code to create a \"literate code\" experience.",
        "user": "U01661S9F34",
        "ts": "1594515716.267100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5NU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The link in my first post uses as an example a reader macro for embedding a full JSON object directly into a lisp program. And "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.racket-lang.org/scribble/index.html",
                                "text": "Racket Scribble"
                            },
                            {
                                "type": "text",
                                "text": " is like a fully embedded markdown parser that can freely mix with lisp code to create a \"literate code\" experience."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "125183f7-00c4-44a7-91bf-755a5f862964",
        "type": "message",
        "text": "I'm not an expert on reader macros, and I wasn't including Scribble. Feel free to dig into Red and show me how I'm wrong :slightly_smiling_face:",
        "user": "UCUSW7WVD",
        "ts": "1594516033.267300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0tC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not an expert on reader macros, and I wasn't including Scribble. Feel free to dig into Red and show me how I'm wrong "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "8dabf22a-8791-41b9-8638-f96d5904d641",
        "type": "message",
        "text": "lol. Fair enough. I'm not trying to attack your premise. I'm legitimately curious what the differences are now. I find macros and DSL's endlessly fascinating :slightly_smiling_face: . I'm now googling for more details, though I'm not sure if it will bear any fruit.",
        "user": "U01661S9F34",
        "ts": "1594516262.267500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "brb+3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "lol. Fair enough. I'm not trying to attack your premise. I'm legitimately curious what the differences are now. I find macros and DSL's endlessly fascinating "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " . I'm now googling for more details, though I'm not sure if it will bear any fruit."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "1e13c760-8e52-4575-afea-49e6e4765db5",
        "type": "message",
        "text": "No reason to be skeptical. I'm sure this has been discussed many times out there. I haven't seen anyone say Lisp reader macros are equivalent.\n\nAh, found the link about how Red tracks variable scope in macros: <https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red>",
        "user": "UCUSW7WVD",
        "ts": "1594516425.267700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Stack Overflow",
                "title": "Is there a overall explanation about definitional scoping in Rebol and Red",
                "title_link": "https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red",
                "text": "From the REBOL/Core Users Guide, and What is Red, I have learned that both Rebol and Red use definitional scoping. From the guide, I know it is a form of static scoping, \"the scope of a variable is",
                "fallback": "Stack Overflow: Is there a overall explanation about definitional scoping in Rebol and Red",
                "thumb_url": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
                "from_url": "https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red",
                "thumb_width": 316,
                "thumb_height": 316,
                "service_icon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon.png?v=c78bd457575a",
                "id": 1,
                "original_url": "https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Py6ws",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No reason to be skeptical. I'm sure this has been discussed many times out there. I haven't seen anyone say Lisp reader macros are equivalent.\n\nAh, found the link about how Red tracks variable scope in macros: "
                            },
                            {
                                "type": "link",
                                "url": "https://stackoverflow.com/questions/21964110/is-there-a-overall-explanation-about-definitional-scoping-in-rebol-and-red"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01661S9F34",
                    "UHWC9PXBL",
                    "UFLN9JFRT"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "dcda1f34-1079-446b-94cd-d1f8b7cb3a39",
        "type": "message",
        "text": "Red is the rebirth of Rebol. Nenad is running the project. They have funding (done via a Crypto coin offering), and they have very active community on Gitter. They don't visit here at FoC at all. I occasionally pop in and kibitz. Anyway Rebol is effectively a language where each function is its own domain specific language.\n\nIt is fairly jarring to those coming from Algol family languages. They use colon (:) for the equal sign, and parameters to functions, which they call refinements, are prefaced with a slash /. They use a clever feature to distinguish type name spaces, a type name has an exclamation point afterwards like rect!, and then you can tell if a name is a variable or is it a type name. I've considered imitating this feature, it solves a lot of namespace collision issues.\n\nThere are various libraries which go way beyond what a Python library does for example, because it is a whole domain specific language. Red can be justly proud of its \"Parse\" module, which approaches the pattern matching power of Icon, the king of string manipulators.\n\nThe Red team is focusing on crypto contracts, but it has a GUI library that can make interesting things. Any dynamic language like LISP or Red abounds with user created custom languages, and learning the subtleties of those languages is not easy. I personally find that the dynamic languages create a memory burden on the reader, as the reader must have in their mind the domain specific language. For very bright people, these languages are attractive, but the high leverage achieved in these languages means that small changes can have drastic effects. Leverage works both ways.\n\nInstead of trying to create ever more powerful stacks of function by long sequences of domain specific languages or function composition, i have tried in my Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust.\n\nCSS is an example of a language i consider maddening, because an extra or missing character can cause a baffling scrambling of a page's layout. This type of fragility is not friendly to maintenance. PHP has a similar fragility to it, because it is typically generating HTML/CSS code, and thus doubly fragile. For this reason PHP is losing its luster.",
        "user": "UEQ6M68H0",
        "ts": "1594516435.268000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1594525269.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uh4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Red is the rebirth of Rebol. Nenad is running the project. They have funding (done via a Crypto coin offering), and they have very active community on Gitter. They don't visit here at FoC at all. I occasionally pop in and kibitz. Anyway Rebol is effectively a language where each function is its own domain specific language.\n\nIt is fairly jarring to those coming from Algol family languages. They use colon (:) for the equal sign, and parameters to functions, which they call refinements, are prefaced with a slash /. They use a clever feature to distinguish type name spaces, a type name has an exclamation point afterwards like rect!, and then you can tell if a name is a variable or is it a type name. I've considered imitating this feature, it solves a lot of namespace collision issues.\n\nThere are various libraries which go way beyond what a Python library does for example, because it is a whole domain specific language. Red can be justly proud of its \"Parse\" module, which approaches the pattern matching power of Icon, the king of string manipulators.\n\nThe Red team is focusing on crypto contracts, but it has a GUI library that can make interesting things. Any dynamic language like LISP or Red abounds with user created custom languages, and learning the subtleties of those languages is not easy. I personally find that the dynamic languages create a memory burden on the reader, as the reader must have in their mind the domain specific language. For very bright people, these languages are attractive, but the high leverage achieved in these languages means that small changes can have drastic effects. Leverage works both ways.\n\nInstead of trying to create ever more powerful stacks of function by long sequences of domain specific languages or function composition, i have tried in my Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust.\n\nCSS is an example of a language i consider maddening, because an extra or missing character can cause a baffling scrambling of a page's layout. This type of fragility is not friendly to maintenance. PHP has a similar fragility to it, because it is typically generating HTML/CSS code, and thus doubly fragile. For this reason PHP is losing its luster."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U01661S9F34",
                    "UFLN9JFRT"
                ],
                "count": 2
            },
            {
                "name": "point_up",
                "users": [
                    "UUQ2EQW21",
                    "UC6997THT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "21a73422-8dc9-4912-9fb4-78338b9321c6",
        "type": "message",
        "text": "&gt; Instead of trying to create ever more powerful stacks of function by long sequences of domain specific languages or function composition, i have tried in my Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust.\nNice!",
        "user": "UCUSW7WVD",
        "ts": "1594516510.268200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0YW65",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Instead of trying to create ever more powerful stacks of function by long sequences of domain specific languages or function composition, i have tried in my Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNice!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "f6a6ace8-51b2-450a-b6e2-65e46f4eab36",
        "type": "message",
        "text": "&gt; I personally find that the dynamic languages create a memory burden on the reader, as the reader must have in their mind the domain specific language. For very bright people, these languages are attractive, but the high leverage achieved in these languages means that small changes can have drastic effects. Leverage works both ways.\nThis is a really good point. DSL's and Macros are a double edge sword for exactly this reason. I think it has been a big contributor to lisps downfall. It's something I personally struggle with reconciling.\n\n&gt; Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust.\nI'm curious about how you achieve this. It reminds me of this research project, <https://github.com/melt-umn/ableC|AbleC>, in which they try to create a C compiler that supports extensions / plugins that could be proven to have only local effects in much the same way.",
        "user": "U01661S9F34",
        "ts": "1594517419.268600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1594517426.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2e1",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I personally find that the dynamic languages create a memory burden on the reader, as the reader must have in their mind the domain specific language. For very bright people, these languages are attractive, but the high leverage achieved in these languages means that small changes can have drastic effects. Leverage works both ways."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a really good point. DSL's and Macros are a double edge sword for exactly this reason. I think it has been a big contributor to lisps downfall. It's something I personally struggle with reconciling.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Beads language to create compartmentalization, where a section of code's possible effects are constantly being narrowed, so that a mistake in a module can only have a local effect, and thus the overall system is more robust."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm curious about how you achieve this. It reminds me of "
                            },
                            {
                                "type": "text",
                                "text": "this research project, ",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/melt-umn/ableC",
                                "text": "AbleC"
                            },
                            {
                                "type": "text",
                                "text": ",",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in which they try to create a C compiler that supports extensions / plugins that could be proven to have only local effects in much the same way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e96a8fe5-2425-4d91-8971-001bd74e6c2d",
        "type": "message",
        "text": "Adobe in the post Warnock era, has shifted from a purchase model to a rental model, and this has its attendant drawbacks. As a long time user of Adobe's Creative Suite, one cannot lay all of the problems with breaking changes on Adobe. Apple has deliberately broken with each successive version of OSX the super important CS series. OSX 10.14 breaks many of the apps, and OSX 10.15 kills off all 32 bit apps for no good reason other than to force you to buy new stuff. When you pay over $1000 for software, you plan to keep it working, and i personally hate subscription model software when it is a program i use perhaps once a month. Most of us are not practicing artists, and Adobe is creating the competition that may eventually damage them severely. But i also have to point out that other big companies in the software field have always been envious of Adobe, and have at times gone to war against them, spending resources to hinder or destroy them.  They have also been massive victims of piracy in the past, and the OS vendors did nothing to help them. The iTunes App Store is the first piracy free ecosystem for the PC, and it has flourished. Cheating ruins the game of capitalism, and there is so much cheating today that people are souring on the concept of capitalism. Mutually beneficial exchange of goods and services is the foundation of modern civilization, but many entities figure out it is cheaper to rig the game than to do more for less, which is the promise of ever higher technology.",
        "user": "UEQ6M68H0",
        "ts": "1594517595.269100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+fON",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Adobe in the post Warnock era, has shifted from a purchase model to a rental model, and this has its attendant drawbacks. As a long time user of Adobe's Creative Suite, one cannot lay all of the problems with breaking changes on Adobe. Apple has deliberately broken with each successive version of OSX the super important CS series. OSX 10.14 breaks many of the apps, and OSX 10.15 kills off all 32 bit apps for no good reason other than to force you to buy new stuff. When you pay over $1000 for software, you plan to keep it working, and i personally hate subscription model software when it is a program i use perhaps once a month. Most of us are not practicing artists, and Adobe is creating the competition that may eventually damage them severely. But i also have to point out that other big companies in the software field have always been envious of Adobe, and have at times gone to war against them, spending resources to hinder or destroy them.  They have also been massive victims of piracy in the past, and the OS vendors did nothing to help them. The iTunes App Store is the first piracy free ecosystem for the PC, and it has flourished. Cheating ruins the game of capitalism, and there is so much cheating today that people are souring on the concept of capitalism. Mutually beneficial exchange of goods and services is the foundation of modern civilization, but many entities figure out it is cheaper to rig the game than to do more for less, which is the promise of ever higher technology."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW"
    },
    {
        "client_msg_id": "0ce70362-0612-4415-a17e-b1ebe5e08088",
        "type": "message",
        "text": "<@UCUSW7WVD> That Stack Overflow article about scoping was very enlightening. Thank you! It makes Red remind me even more of Forth now! That's the only other language I can think of that works in a similar way.",
        "user": "U01661S9F34",
        "ts": "1594518181.269300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QQd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " That Stack Overflow article about scoping was very enlightening. Thank you! It makes Red remind me even more of Forth now! That's the only other language I can think of that works in a similar way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "0364806f-48d4-4074-9b29-317bdf5dda9f",
        "type": "message",
        "text": "&gt; It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways.\nSo it's the same thing as FEXPRs in Lisp. Not really beyond Lisp, because the idea was invented by Lisp first. <https://en.wikipedia.org/wiki/Fexpr>",
        "user": "UJN1TAYEQ",
        "ts": "1594518874.269500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n1ys",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's beyond Lisp because arguments are received unevaluated, and different operations may parse their args in very different ways."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So it's the same thing as FEXPRs in Lisp. Not really beyond Lisp, because the idea was invented by Lisp first. "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Fexpr"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            },
            {
                "name": "-1",
                "users": [
                    "UCUSW7WVD",
                    "UJN1TAYEQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "4767d6d7-9df8-4415-8a42-e85a2c7cb501",
        "type": "message",
        "text": "Smalltalk-72 had something similar: an object could dynamically parse the token stream as a sequence of unevaluated arguments, and that is how message passing worked. It was incredibly powerful, but the idea was abandoned in Smalltalk-76 for a syntax that is more static and more amenable to compilation. The real issue for Smalltalk was that it was difficult for humans to predict how a program would be parsed, and the API for parsing the message stream was more complex than what Smalltalk uses today for specifying message patterns.",
        "user": "UJN1TAYEQ",
        "ts": "1594519130.269700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Crzy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Smalltalk-72 had something similar: an object could dynamically parse the token stream as a sequence of unevaluated arguments, and that is how message passing worked. It was incredibly powerful, but the idea was abandoned in Smalltalk-76 for a syntax that is more static and more amenable to compilation. The real issue for Smalltalk was that it was difficult for humans to predict how a program would be parsed, and the API for parsing the message stream was more complex than what Smalltalk uses today for specifying message patterns."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMWF81HTP"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7a316e6b-3de9-4a95-a961-b37fd3eee44e",
        "type": "message",
        "text": "when I was referencing lisp, I meant modern and popular lisps from today\u2014I think rebol\u2019s model is a lot like fexprs but they seem to have a bunch of different handles for dealing with that situation. and they seem to use fexpr-equivalent stuff about a thousand times more often than older lisp programs did. I said \u201cmaybe smalltalk\u201d because I was specifically thinking about that thing about every object carrying its own parser. i think rebol gets around some of the lack of clarity by in general writing very small programs (I\u2019m not an expert) and keeping rules for how to treat unevaluated data very close to where you use those rules",
        "user": "UHWC9PXBL",
        "ts": "1594519551.270000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zJZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "when I was referencing lisp, I meant modern and popular lisps from today\u2014I think rebol\u2019s model is a lot like fexprs but they seem to have a bunch of different handles for dealing with that situation. and they seem to use fexpr-equivalent stuff about a thousand times more often than older lisp programs did. I said \u201cmaybe smalltalk\u201d because I was specifically thinking about that thing about every object carrying its own parser. i think rebol gets around some of the lack of clarity by in general writing very small programs (I\u2019m not an expert) and keeping rules for how to treat unevaluated data very close to where you use those rules"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "43179997-6af2-4641-ae66-ea6744527f56",
        "type": "message",
        "text": "forth is super similar, and I think factor\u2019s compilation model leverages some very similar stuff",
        "user": "UHWC9PXBL",
        "ts": "1594519564.270300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Hxqx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "forth is super similar, and I think factor\u2019s compilation model leverages some very similar stuff"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "eb997f5e-b184-4a7a-90b1-b90c9e428621",
        "type": "message",
        "text": "as far as the extra tooling for fexpr-like stuff\u2014red/rebol seem to have a bunch of quote-like facilities for dealing with different stages of evaluation etc. like a `set-word:` vs a `'lit-word` vs a `:get-word` vs a `word`. havent figured out how all of it works together yet, but it seems like it uses the same data structure in pretty much every case\u2026 almost like clojure\u2019s omnipresent use of nested maps/edn\u2014but it seems to extend to binding syntax instead of just raw data. idk. I\u2019m finding it pretty mind-bending",
        "user": "UHWC9PXBL",
        "ts": "1594519738.270600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "K4G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "as far as the extra tooling for fexpr-like stuff\u2014red/rebol seem to have a bunch of quote-like facilities for dealing with different stages of evaluation etc. like a "
                            },
                            {
                                "type": "text",
                                "text": "set-word:",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " vs a "
                            },
                            {
                                "type": "text",
                                "text": "'lit-word",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " vs a "
                            },
                            {
                                "type": "text",
                                "text": ":get-word",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " vs a "
                            },
                            {
                                "type": "text",
                                "text": "word",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". havent figured out how all of it works together yet, but it seems like it uses the same data structure in pretty much every case\u2026 almost like clojure\u2019s omnipresent use of nested maps/edn\u2014but it seems to extend to binding syntax instead of just raw data. idk. I\u2019m finding it pretty mind-bending"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "6dcc1e91-4465-4364-b3a3-782a93a6bc53",
        "type": "message",
        "text": "<http://blog.hostilefork.com/rebol-vs-lisp-macros/> found via a thread",
        "user": "UHWC9PXBL",
        "ts": "1594520261.270800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "rebol : Rebol vs. Lisp Macros",
                "title_link": "http://blog.hostilefork.com/rebol-vs-lisp-macros/",
                "text": "Author: HostileFork, Title: Rebol vs. Lisp Macros, Date: 19-Apr-2016, Length: 2220 words",
                "fallback": "rebol : Rebol vs. Lisp Macros",
                "from_url": "http://blog.hostilefork.com/rebol-vs-lisp-macros/",
                "service_icon": "http://blog.hostilefork.com/favicon.ico",
                "service_name": "blog.hostilefork.com",
                "id": 1,
                "original_url": "http://blog.hostilefork.com/rebol-vs-lisp-macros/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p=Mqs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://blog.hostilefork.com/rebol-vs-lisp-macros/"
                            },
                            {
                                "type": "text",
                                "text": " found via a thread"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "amiga-tick",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "76c03f48-67b3-4d20-a734-328873d0306f",
        "type": "message",
        "text": "Also relevant <https://en.m.wikipedia.org/wiki/Fexpr|https://en.m.wikipedia.org/wiki/Fexpr>",
        "user": "U8A5MS6R1",
        "ts": "1594520893.271200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Fexpr",
                "title_link": "https://en.m.wikipedia.org/wiki/Fexpr",
                "from_url": "https://en.m.wikipedia.org/wiki/Fexpr",
                "author_name": "Wikipedia",
                "author_link": "https://en.wikipedia.org/",
                "text": "In Lisp programming languages, a fexpr is a function whose operands are passed to it without being evaluated. When a fexpr is called, only the body of the fexpr is evaluated; no other evaluations take place except when explicitly initiated by the fexpr. In contrast, when an ordinary Lisp function is called, the operands are evaluated automatically, and only the results of these evaluations are provided to the function; and when a (traditional) Lisp macro is called, the operands are passed in unevaluated, but whatever result the macro function returns is automatically evaluated.",
                "fallback": "wikipedia: Fexpr",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png",
                "id": 1,
                "original_url": "https://en.m.wikipedia.org/wiki/Fexpr"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AJW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also relevant "
                            },
                            {
                                "type": "link",
                                "url": "https://en.m.wikipedia.org/wiki/Fexpr",
                                "text": "https://en.m.wikipedia.org/wiki/Fexpr"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "e0d6e0c8-db53-4c24-8b14-84e750469d20",
        "type": "message",
        "text": "There is also this Hacker News discussion: <https://news.ycombinator.com/item?id=11587952>",
        "user": "UJN1TAYEQ",
        "ts": "1594521541.271600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7oz0g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is also this Hacker News discussion: "
                            },
                            {
                                "type": "link",
                                "url": "https://news.ycombinator.com/item?id=11587952"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f732c1ee-10c0-42ff-aa8f-4284b9dea28f",
        "type": "message",
        "text": "Lol. I've been schooled. I was not familiar with this particular corner of comparative PL analysis. :rolling_on_the_floor_laughing: Thank you all for the reading material. :pray:",
        "user": "U01661S9F34",
        "ts": "1594521843.271800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bro",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Lol. I've been schooled. I was not familiar with this particular corner of comparative PL analysis. "
                            },
                            {
                                "type": "emoji",
                                "name": "rolling_on_the_floor_laughing"
                            },
                            {
                                "type": "text",
                                "text": " Thank you all for the reading material. "
                            },
                            {
                                "type": "emoji",
                                "name": "pray"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "1c8d8511-dbbf-4a3c-a9e8-f5a44d119d4c",
        "type": "message",
        "text": "As someone who's built an fexpr-based Lisp: no, Red is not like fexprs. Y'all know I like Lisp, but we lispers need to beware of treating other models as equivalent just because we can do what they do _as long as we stick to s-expressions_. Even reader macros (which are quite unlispy) don't get you out of jail free from the restrictions of s-expressions.\n\nThe _correct_ response from a lisper on conversations of syntax is to pooh-pooh it: \"syntax doesn't matter, dontcha know?\" :wink:",
        "user": "UCUSW7WVD",
        "ts": "1594523397.272100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1594523503.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YeS/3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As someone who's built an fexpr-based Lisp: no, Red is not like fexprs. Y'all know I like Lisp, but we lispers need to beware of treating other models as equivalent just because we can do what they do "
                            },
                            {
                                "type": "text",
                                "text": "as long as we stick to s-expressions",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Even reader macros (which are quite unlispy) don't get you out of jail free from the restrictions of s-expressions.\n\nThe "
                            },
                            {
                                "type": "text",
                                "text": "correct",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " response from a lisper on conversations of syntax is to pooh-pooh it: \"syntax doesn't matter, dontcha know?\" "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "fbcaab97-5c09-4c9d-a714-24ae867e950f",
        "type": "message",
        "text": "I'm sure I could google this, but what's the debugging experience like in rebol? It seems like the very flexible syntax you're describing would make visualizing debug information kind of tricky.",
        "user": "U01448TH3PG",
        "ts": "1594523679.272500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01448TH3PG",
            "ts": "1594523695.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vuRh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm sure I could google this, but what's the debugging experience like in rebol? It seems like the very flexible syntax you're describing would make visualizing debug information kind of tricky."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4ef92d71-711c-4921-a9b7-c36fce884cbe",
        "type": "message",
        "text": "red and rebol are both actually extremely difficult to google, and the documentation is either scattered or written directly to new programmers or at people who fully grok the language (the community is similar to that of APL in this regard). from what I can tell, debugging relies very heavily on the same reflection capabilities\u2014they have some specialized words i\u2019m not fluent in, like `probe`, `mold`,  `bind` , and `BIND?`. I imagine that if you\u2019ve fully learned to read the matrix, it can be really pleasant to hook into code and inspect what\u2019s bound where, evaluate with one function and compare it to another. Like if you had wrenches that fit all the nuts and bolts on your step-through debugger\u2014but it also seems like you have to build the debugger yourself from the kit. I\u2019m no expert, though. I hope (wish?) we have some people with more experience with red and/or rebol specifically in the slack",
        "user": "UHWC9PXBL",
        "ts": "1594525342.273300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1594525359.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3cG7=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "red and rebol are both actually extremely difficult to google, and the documentation is either scattered or written directly to new programmers or at people who fully grok the language (the community is similar to that of APL in this regard). from what I can tell, debugging relies very heavily on the same reflection capabilities\u2014they have some specialized words i\u2019m not fluent in, like "
                            },
                            {
                                "type": "text",
                                "text": "probe",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "mold",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ",  "
                            },
                            {
                                "type": "text",
                                "text": "bind",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " , and "
                            },
                            {
                                "type": "text",
                                "text": "BIND?",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I imagine that if you\u2019ve fully learned to read the matrix, it can be really pleasant to hook into code and inspect what\u2019s bound where, evaluate with one function and compare it to another. Like if you had wrenches that fit all the nuts and bolts on your step-through debugger\u2014but it also seems like you have to build the debugger yourself from the kit. I\u2019m no expert, though. I hope (wish?) we have some people with more experience with red and/or rebol specifically in the slack"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "6a66fd5a-a941-4a5e-a5bd-630de3a51592",
        "type": "message",
        "text": "sidenote: APL *also* has a really weird scoping model that I don\u2019t fully understand but that\u2019s alluded to during a very fast-paced breakdown of the defn compiler (available on youtube. I can find the link if anyone wants it)",
        "user": "UHWC9PXBL",
        "ts": "1594525430.273600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "siw89",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "sidenote: APL "
                            },
                            {
                                "type": "text",
                                "text": "also",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has a really weird scoping model that I don\u2019t fully understand but that\u2019s alluded to during a very fast-paced breakdown of the defn compiler (available on youtube. I can find the link if anyone wants it)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "b8d7d277-9ba3-4a12-b496-fea526f89d32",
        "type": "message",
        "text": "I should also point out that there are 2 main dialects of Red, Red/System is a special limited version that is intended for raw metal. It is intended for systems programming applications. Red has one big advantage is that the entire toolchain is around 1MB. So it is like FORTH in that it is super small.  A clever person can get a lot out of a language like Red.",
        "user": "UEQ6M68H0",
        "ts": "1594525697.273800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "373k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I should also point out that there are 2 main dialects of Red, Red/System is a special limited version that is intended for raw metal. It is intended for systems programming applications. Red has one big advantage is that the entire toolchain is around 1MB. So it is like FORTH in that it is super small.  A clever person can get a lot out of a language like Red."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "5cf8b4ce-01ba-4335-b76c-7abd44356060",
        "type": "message",
        "text": "I don't want to deviate the topic too much, but have a look at \"video game historian\" on YouTube. It's amazing how work, history, and context there is behind some things. Apparently Tetris played a major role in bridging connections between the US and Russia in the wake of the cold war.",
        "user": "UAVCC2X70",
        "ts": "1594533499.274400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1594533522.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e3yX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't want to deviate the topic too much, but have a look at \"video game historian\" on YouTube. It's amazing how work, history, and context there is behind some things. Apparently Tetris played a major role in bridging connections between the US and Russia in the wake of the cold war."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586022158.113700",
        "parent_user_id": "U01176YGU4W"
    },
    {
        "client_msg_id": "d6ccefd4-2f59-4ee5-a7a6-0e77bfcc6ee2",
        "type": "message",
        "text": "I see a sort of 3D manifold with different number classes in different lobes.",
        "user": "U013ZLJARC7",
        "ts": "1594537931.274800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "b/2p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see a sort of 3D manifold with different number classes in different lobes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594417065.212100",
        "parent_user_id": "UKP3B2J5D"
    },
    {
        "client_msg_id": "20987f8d-7f53-40f4-a9d0-ec63322d0a79",
        "type": "message",
        "text": "A comment on the \"memory burden\" issue with DSLs and related methods: it's all a matter of scale. Plenty of research papers in mathematics and physics start by introducing some new notation, which is the moral equivalent of a DSL. As long as it's a bit per paper, with no idea of universality or reusability behind it, that works very well. It starts getting problematic when someone starts with \"using the notation introduced by X in referende Y ...\". If you have to read another paper first just to parse the notation, it becomes a chore.\nSo perhaps a good solution is PSL (problem-specific language) rather than DSL. A very local scope for the language. In Lisp terms, one or two short macros that readers are expected to read and understand, rather than a complex language extension packaged as a library (which is what Racket advocates).",
        "user": "UJBAJNFLK",
        "ts": "1594544808.275300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uemfw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A comment on the \"memory burden\" issue with DSLs and related methods: it's all a matter of scale. Plenty of research papers in mathematics and physics start by introducing some new notation, which is the moral equivalent of a DSL. As long as it's a bit per paper, with no idea of universality or reusability behind it, that works very well. It starts getting problematic when someone starts with \"using the notation introduced by X in referende Y ...\". If you have to read another paper first just to parse the notation, it becomes a chore.\nSo perhaps a good solution is PSL (problem-specific language) rather than DSL. A very local scope for the language. In Lisp terms, one or two short macros that readers are expected to read and understand, rather than a complex language extension packaged as a library (which is what Racket advocates)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "text": "I was always intrigued by Red's promise of being \"truly full stack\". I wonder how it works out in practice. Specifically, the lower level is a DSL over Red itself, so what does it feel like to cross the boundary between levels?",
        "files": [
            {
                "id": "F016WVAUAHK",
                "created": 1594545430,
                "timestamp": 1594545430,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UMWF81HTP",
                "editable": false,
                "size": 39314,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F016WVAUAHK/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F016WVAUAHK/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F016WVAUAHK-5618d625c0/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F016WVAUAHK-5618d625c0/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F016WVAUAHK-5618d625c0/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 161,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F016WVAUAHK-5618d625c0/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 214,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F016WVAUAHK-5618d625c0/image_160.png",
                "image_exif_rotation": 1,
                "original_w": 560,
                "original_h": 250,
                "thumb_tiny": "AwAVADDPAzUm1fUfnTR9002gCQp6DNJs/wBn9aaMngZqamkJsh4BII/Wk49KlMYJzk0xkKjOeKLBcQNgYwDS7x/dWm0lIY8SY6KKXzT6Co6KLhYk80+gpC5YYxTKKB3ex//Z",
                "permalink": "https://futureofcoding.slack.com/files/UMWF81HTP/F016WVAUAHK/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F016WVAUAHK-9bb2e128f9",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gy6u6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was always intrigued by Red's promise of being \"truly full stack\". I wonder how it works out in practice. Specifically, the lower level is a DSL over Red itself, so what does it feel like to cross the boundary between levels?"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UMWF81HTP",
        "display_as_bot": false,
        "ts": "1594545543.281700",
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "EE07EC5B-615C-4CD8-B76F-980514AE94F8",
        "type": "message",
        "text": "It\u2019s all about the business models.\n\nIf you want to have people voluntarily give you large amounts of money preferably on a regular basis, you can either deliver value that one decision maker in a company can justify (B2B) or you deliver value that consumers want to pay for (B2C), which is a lot easier if you sell bits together with atoms.\n\nIf that\u2019s not your thing, or you want \u201ceveryone to be able to use it\u201d, you make it free and find other ways to get paid for the value you create. That can start with harmless ads, but then often spirals into selling data about your users to advertisers because targeted ads make so much more money.\n\nIf you build something customers pay you for directly, you need to keep pleasing them by adding value; you need to keep innovating. Then everything that holds you back is in your way.\n\nIf your users aren\u2019t your customers, you optimize for other things. Then your software just needs to run and you care a lot less about what it runs on, as long as it\u2019s still functional and users are still using it. Better yet, you might even optimize for staying around on older platforms for longer to maximize reach.\n\nI do believe that it\u2019s ultimately good that we have these very different approaches, as they somewhat keep each other in check. I also think that free (as in beer) software has done a lot more harm than good to our software ecosystems.\n\nWhat I find particularly interesting is that a lot of people in our industry who supposedly understand software very well, want things to be stable for eternity but at the same time always use the latest technology and don\u2019t seem to see any problems with that.",
        "user": "U5STGTB3J",
        "ts": "1594546751.293900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "K/f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s all about the business models.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "If you want to have people voluntarily give you large amounts of money preferably on a regular basis, you can either deliver value that one decision maker in a company can justify (B2B) or you deliver value that consumers want to pay for (B2C), which is a lot easier if you sell bits together with atoms.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "If that\u2019s not your thing, or you want \u201ceveryone to be able to use it\u201d, you make it free and find other ways to get paid for the value you create. That can start with harmless ads, but then often spirals into selling data about your users to advertisers because targeted ads make so much more money.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "If you build something customers pay you for directly, you need to keep pleasing them by adding value; you need to keep innovating. Then everything that holds you back is in your way.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "If your users aren\u2019t your customers, you optimize for other things. Then your software just needs to run and you care a lot less about what it runs on, as long as it\u2019s still functional and users are still using it. Better yet, you might even optimize for staying around on older platforms for longer to maximize reach.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "I do believe that it\u2019s ultimately good that we have these very different approaches, as they somewhat keep each other in check. I also think that free (as in beer) software has done a lot more harm than good to our software ecosystems.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "What I find particularly interesting is that a lot of people in our industry who supposedly understand software very well, want things to be stable for eternity but at the same time always use the latest technology and don\u2019t seem to see any problems with that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW"
    },
    {
        "client_msg_id": "A9CEF47B-C3D2-417F-BAF1-8BC46B3A6CBE",
        "type": "message",
        "text": "Finding powerful new primitives of thought:\n<https://twitter.com/michael_nielsen/status/1282142109680590848?s=20|https://twitter.com/michael_nielsen/status/1282142109680590848?s=20>\n\nRefers to <https://distill.pub/2017/aia/|https://distill.pub/2017/aia/>",
        "user": "U5STGTB3J",
        "ts": "1594548354.294800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1594585916.000000"
        },
        "attachments": [
            {
                "fallback": "<https://twitter.com/michael_nielsen|@michael_nielsen>: A few years ago, <https://twitter.com/shancarter|@shancarter> and I speculated a little about why the most interesting new interfaces often seem very strange: <https://distill.pub/2017/aia/> <https://pbs.twimg.com/media/EcsVLTcU4AEtIQX.png>",
                "ts": 1594521474,
                "author_name": "Michael Nielsen",
                "author_link": "https://twitter.com/michael_nielsen/status/1282142109680590848",
                "author_icon": "https://pbs.twimg.com/profile_images/2756243281/6d3d0ade1bd4364b75d7d0151dce38e5_normal.png",
                "author_subname": "@michael_nielsen",
                "text": "A few years ago, <https://twitter.com/shancarter|@shancarter> and I speculated a little about why the most interesting new interfaces often seem very strange: <https://distill.pub/2017/aia/> <https://pbs.twimg.com/media/EcsVLTcU4AEtIQX.png>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/michael_nielsen/status/1282142109680590848?s=20",
                "image_url": "https://pbs.twimg.com/media/EcsVLTcU4AEtIQX.png",
                "image_width": 633,
                "image_height": 467,
                "image_bytes": 33361,
                "id": 1,
                "original_url": "https://twitter.com/michael_nielsen/status/1282142109680590848?s=20",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F+oE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Finding powerful new primitives of thought:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/michael_nielsen/status/1282142109680590848?s=20",
                                "text": "https://twitter.com/michael_nielsen/status/1282142109680590848?s=20"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "Refers to "
                            },
                            {
                                "type": "link",
                                "url": "https://distill.pub/2017/aia/",
                                "text": "https://distill.pub/2017/aia/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594548354.294800",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1594548487.296000",
        "reply_users": [
            "U5STGTB3J"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "sparkles",
                "users": [
                    "U016LEA3J1H",
                    "UKP3B2J5D"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UJN1TAYEQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "015CE8E5-9C0F-4695-B4B7-7AACB91B3765",
        "type": "message",
        "text": "Sorry, I\u2019m on my phone and it seems I\u2019m not able to do anything about the six expanded links\u2026 :worried:",
        "user": "U5STGTB3J",
        "ts": "1594548487.296000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WuOn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sorry, I\u2019m on my phone and it seems I\u2019m not able to do anything about the six expanded links\u2026 "
                            },
                            {
                                "type": "emoji",
                                "name": "worried"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594548354.294800",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "hugging_face",
                "users": [
                    "UKP3B2J5D"
                ],
                "count": 1
            },
            {
                "name": "beers",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0634d0a2-29ea-490a-abf6-57a57272bcee",
        "type": "message",
        "text": "Good question... another one: is there a good reason to choose two levels with an explicit boundary in between them? Why not just one (as e.g. on a Lisp machine)? Why not more than two? In other words, is two some kind of optimum, or just a historical accident?",
        "user": "UJBAJNFLK",
        "ts": "1594549458.304300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iPq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good question... another one: is there a good reason to choose two levels with an explicit boundary in between them? Why not just one (as e.g. on a Lisp machine)? Why not more than two? In other words, is two some kind of optimum, or just a historical accident?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "C2FFDA14-D43B-4D80-9BB3-F84D4645C417",
        "type": "message",
        "text": "<@U0137BUHUBW> The Timeless Way of Building by Christopher Alexander might have the philosophy you\u2019re searching for. It\u2019s a book about buildings(but so much more), and one theme is his rejection of architecture as this highly professionalized, prescriptive, and paternalistic practice, instead advocating for the users of the building to be fully involved in its creation and ongoing maintenance. And to echo Doug\u2019s quotes from Ilich, part of that is rejecting industrial methods that diminish the individual.\n\nI feel strongly it has many deep parallels to the current situation we\u2019re in with software, and it has inspired me to create software that truly empowers people and makes them feel alive.",
        "user": "UMWF81HTP",
        "ts": "1594549464.304500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UMWF81HTP",
            "ts": "1594549491.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qbfnb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0137BUHUBW"
                            },
                            {
                                "type": "text",
                                "text": " The Timeless Way of Building by Christopher Alexander might have the philosophy you\u2019re searching for. It\u2019s a book about buildings(but so much more), and one theme is his rejection of architecture as this highly professionalized, prescriptive, and paternalistic practice, instead advocating for the users of the building to be fully involved in its creation and ongoing maintenance. And to echo Doug\u2019s quotes from Ilich, part of that is rejecting industrial methods that diminish the individual.\n\nI feel strongly it has many deep parallels to the current situation we\u2019re in with software, and it has inspired me to create software that truly empowers people and makes them feel alive."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U5STGTB3J",
                    "UKP3B2J5D"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "730f2a60-23a3-49cf-a287-355abe460c46",
        "type": "message",
        "text": "&gt;  As someone who's built an fexpr-based Lisp: no, Red is not like fexprs.\nThe original post was about Rebol, and I was talking about Rebol, not Red. Rebol and Red are different.\nThere are two kinds of Lisp dialect.\n\u2022 In the Macro dialects (modern compiled dialects like Common Lisp and Scheme), there are no FEXPRs. Instead, there are Macros, which receive their arguments as unevaluated syntax objects. There are two phases of evaluation. Calls to macros are expanded at compile time, not at run time. Macros are not first class values. \n\u2022 In the FEXPR dialects, you have FEXPR objects, which are like functions, except that the arguments are unevaluated syntax objects. FEXPRs are first class values. There is only one phase of evaluation: calls to FEXPRs are evaluated at run time. These dialects are interpreted, not compiled. Older examples are Lisp 1.5 and 3Lisp (these are historical dialects, not used today). A newer example is the Kernel language, a dialect of Scheme with FEXPRs instead of Macros, with multiple implementations on github: <http://web.cs.wpi.edu/~jshutt/kernel.html>\nEverything I said about FEXPR Lisp dialects seems to be also true of Rebol, and everything I said about Macro Lisp dialects seems to be also true of Red. So that is how I am categorizing Rebol and Red, pending more information. This page from the Red language site seems to confirm what I just wrote: <https://www.red-lang.org/2016/12/entering-world-of-macros.html>",
        "user": "UJN1TAYEQ",
        "ts": "1594549707.304800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Entering the World of Macros",
                "title_link": "https://www.red-lang.org/2016/12/entering-world-of-macros.html",
                "text": "In Rebol languages family, macros have been a topic every now and then, and despite one implementation offered, they never became mainstre...",
                "fallback": "Entering the World of Macros",
                "from_url": "https://www.red-lang.org/2016/12/entering-world-of-macros.html",
                "service_icon": "https://www.red-lang.org/favicon.ico",
                "service_name": "red-lang.org",
                "id": 1,
                "original_url": "https://www.red-lang.org/2016/12/entering-world-of-macros.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VcZ",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " As someone who's built an fexpr-based Lisp: no, Red is not like fexprs."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The original post was about Rebol, and I was talking about Rebol, not Red. Rebol and Red are different.\nThere are two kinds of Lisp dialect.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In the Macro dialects (modern compiled dialects like Common Lisp and Scheme), there are no FEXPRs. Instead, there are Macros, which receive their arguments as unevaluated syntax objects. There are two phases of evaluation. Calls to macros are expanded at compile time, not at run time. Macros are not first class values. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "In the FEXPR dialects, you have FEXPR objects, which are like functions, except that the arguments are unevaluated syntax objects. FEXPRs are first class values. There is only one phase of evaluation: calls to FEXPRs are evaluated at run time. These dialects are interpreted, not compiled. Older examples are Lisp 1.5 and 3Lisp (these are historical dialects, not used today). A newer example is the Kernel language, a dialect of Scheme with FEXPRs instead of Macros, with multiple implementations on github: "
                                    },
                                    {
                                        "type": "link",
                                        "url": "http://web.cs.wpi.edu/~jshutt/kernel.html"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Everything I said about FEXPR Lisp dialects seems to be also true of Rebol, and everything I said about Macro Lisp dialects seems to be also true of Red. So that is how I am categorizing Rebol and Red, pending more information. This page from the Red language site seems to confirm what I just wrote: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.red-lang.org/2016/12/entering-world-of-macros.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "6ff1746c-ded3-4479-8f14-8db3552f5fd3",
        "type": "message",
        "text": "&gt; Good question... another one: is there a good reason to choose two levels with an explicit boundary in between them? Why not just one (as e.g. on a Lisp machine)? Why not more than two? In other words, is two some kind of optimum, or just a historical accident?\nI don't know enough about Red to answer this in the Red context, but I can talk about my own experience. My Curv language has exactly 2 levels because Curv can be either interpreted on a CPU, or it can be compiled into GPU shader code and run on a GPU. The run time requirements for these two execution environments are quite different. On the GPU, I can't have a garbage collector, or first class function values, or general run-time polymorphism, whereas on the CPU, I can. So any Curv code that runs on the GPU is restricted to a statically typed subset of Curv. This statically typed subset is upward compatible with the full language, and GPU code can be executed on the CPU without any ceremony, so it feels like you are programming in a single language.\n\nThe Red language is claimed to be suitable for writing operating systems. You don't want to have a garbage-collected runtime environment inside an operating system kernel, because garbage collection pauses are incompatible with real time programming. For example, you need to be able process interrupts with guaranteed latency bounds. From <http://Red-lang.org|Red-lang.org>, \"*Red/System* is a C level language, where you are responsible for allocating and freeing memory, and where you may need precise manual control over those actions.\"\n\nI know that the Lisp machine operating system was written in Lisp. I don't know the details, but it seems plausible that they would have used a statically typed Lisp subset for low-level OS code (device drivers and such), which if true, would put Lisp machine Lisp into the same category as Curv and Red (two levels, including a low-level systems programming dialect).",
        "user": "UJN1TAYEQ",
        "ts": "1594552273.305200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1594552537.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lmKm8",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good question... another one: is there a good reason to choose two levels with an explicit boundary in between them? Why not just one (as e.g. on a Lisp machine)? Why not more than two? In other words, is two some kind of optimum, or just a historical accident?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know enough about Red to answer this in the Red context, but I can talk about my own experience. My Curv language has exactly 2 levels because Curv can be either interpreted on a CPU, or it can be compiled into GPU shader code and run on a GPU. The run time requirements for these two execution environments are quite different. On the GPU, I can't have a garbage collector, or first class function values, or general run-time polymorphism, whereas on the CPU, I can. So any Curv code that runs on the GPU is restricted to a statically typed subset of Curv. This statically typed subset is upward compatible with the full language, and GPU code can be executed on the CPU without any ceremony, so it feels like you are programming in a single language.\n\nThe Red language is claimed to be suitable for writing operating systems. You don't want to have a garbage-collected runtime environment inside an operating system kernel, because garbage collection pauses are incompatible with real time programming. For example, you need to be able process interrupts with guaranteed latency bounds. From "
                            },
                            {
                                "type": "link",
                                "url": "http://Red-lang.org",
                                "text": "Red-lang.org"
                            },
                            {
                                "type": "text",
                                "text": ", \""
                            },
                            {
                                "type": "text",
                                "text": "Red/System",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a C level language, where you are responsible for allocating and freeing memory, and where you may need precise manual control over those actions.\"\n\nI know that the Lisp machine operating system was written in Lisp. I don't know the details, but it seems plausible that they would have used a statically typed Lisp subset for low-level OS code (device drivers and such), which if true, would put Lisp machine Lisp into the same category as Curv and Red (two levels, including a low-level systems programming dialect)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "33801748-66f3-4131-9bbb-8b2252484d56",
        "type": "message",
        "text": "<@UCUSW7WVD>  thanks for clarifying! In this case I have a few more thoughts that may be useful:\n * Designing a language to purposely help increase the understanding of the problem would be interesting. Maybe allowing for both specific -&gt; general (like TDD) and general -&gt; specific (like Haskell type declarations before impl). Idris and type-driven development is one angle that's interesting here, and rust/elm/purescript+typedholes also leads devs to have a \"conversation\" with the compiler as well. (FWIW, I'm fairly ignorant of Mu so unsure what opinion it takes here, if any).\n * M*N situations do arise sadly. Most of abstract algebra and category theory is about describing ways to simplify and (hopefully) efficiently compose these cases. I believe that tools can help us with these, such as statebox, but the barrier to entry feels pretty high still. I worked on this a bit at Invision too (fun exceptions when nesting state machines that non-programming designers needed to be able to \"configure\"). [Side note: M*N problems are particularly annoying to represent in a linear view like text-based languages.  There's fun stuff from the category theory people on diagrammung multi-dimensional composition \"easier\" but I haven't seen non-math nerds be able to develop intuition around them yet. ]\n * Delaying complexity until later is super important to prototyping quickly. The problem is *knowing* that you skipped over something and if you are \"polluting your signal.\" I believe the sweet spot here is gradually typed languages, though I'd say they have mixed results in terms of lowering complexity so far. I'd bet that AI would be able to \"fill in the blanks\" sooner than they could design the skeleton.",
        "user": "UN57U8V53",
        "ts": "1594571109.307100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UN57U8V53",
            "ts": "1594571463.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ATp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "  thanks for clarifying! In this case I have a few more thoughts that may be useful:\n * Designing a language to purposely help increase the understanding of the problem would be interesting. Maybe allowing for both specific -> general (like TDD) and general -> specific (like Haskell type declarations before impl). Idris and type-driven development is one angle that's interesting here, and rust/elm/purescript+typedholes also leads devs to have a \"conversation\" with the compiler as well. (FWIW, I'm fairly ignorant of Mu so unsure what opinion it takes here, if any).\n * M*N situations do arise sadly. Most of abstract algebra and category theory is about describing ways to simplify and (hopefully) efficiently compose these cases. I believe that tools can help us with these, such as statebox, but the barrier to entry feels pretty high still. I worked on this a bit at Invision too (fun exceptions when nesting state machines that non-programming designers needed to be able to \"configure\"). [Side note: M*N problems are particularly annoying to represent in a linear view like text-based languages.  There's fun stuff from the category theory people on diagrammung multi-dimensional composition \"easier\" but I haven't seen non-math nerds be able to develop intuition around them yet. ]\n * Delaying complexity until later is super important to prototyping quickly. The problem is *knowing* that you skipped over something and if you are \"polluting your signal.\" I believe the sweet spot here is gradually typed languages, though I'd say they have mixed results in terms of lowering complexity so far. I'd bet that AI would be able to \"fill in the blanks\" sooner than they could design the skeleton."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3DBD4EBA-6C2B-4C23-B954-9D5AB00D4DBA",
        "type": "message",
        "text": "<@UCUSW7WVD> wrt synchronization, I was thinking about synchronization between UI, model, and database. This is an area that most developers would not think much about until they took a close look at how much of their code base (an bugs) is consumed with code that deals with these issues in poorly designed and inconsistent ways.",
        "user": "ULM3U6275",
        "ts": "1594572274.312000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ki7SK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " wrt synchronization, I was thinking about synchronization between UI, model, and database. This is an area that most developers would not think much about until they took a close look at how much of their code base (an bugs) is consumed with code that deals with these issues in poorly designed and inconsistent ways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bd1ab425-e384-4408-8172-43129bf074c5",
        "type": "message",
        "text": "If the system language were a strict subset, I wouldn't count it as distinct. In Lisp, for example, you can use type declarations as much as you like. A subset that requires them everywhere would be more of a style of using Lisp than a dialect, from my point of view at least. I do wonder how Lisp machines got around garbage collection at the lowest level though. In the Lisps I know, there is no opt-out.",
        "user": "UJBAJNFLK",
        "ts": "1594575681.312200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3q6/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If the system language were a strict subset, I wouldn't count it as distinct. In Lisp, for example, you can use type declarations as much as you like. A subset that requires them everywhere would be more of a style of using Lisp than a dialect, from my point of view at least. I do wonder how Lisp machines got around garbage collection at the lowest level though. In the Lisps I know, there is no opt-out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "bed19a78-a00b-4542-a120-779835c4f41b",
        "type": "message",
        "text": "Oh, I totally misunderstood what you meant by the word. Yes, the importance of keeping two distant sub-systems \"in sync\" in some way that's hard to express -- absolutely fits my original question.",
        "user": "UCUSW7WVD",
        "ts": "1594576202.312400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1594576754.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/6d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, I totally misunderstood what you meant by the word. Yes, the importance of keeping two distant sub-systems \"in sync\" in some way that's hard to express -- absolutely fits my original question."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "5A65840C-38DC-4407-9682-13AB9185CC35",
        "type": "message",
        "text": "A garbage collector could be seen as one form of automatic synchronization (of the free memory table and referenced objects). Either you do it manually (which involves tons of code and bugs) or you abstract it such that it can be done automatically (with far less net code and far greater reliability).",
        "user": "ULM3U6275",
        "ts": "1594576646.317300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+8jyo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A garbage collector could be seen as one form of automatic synchronization (of the free memory table and referenced objects). Either you do it manually (which involves tons of code and bugs) or you abstract it such that it can be done automatically (with far less net code and far greater reliability)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c3f0f3df-4ec5-41b0-ae93-31e3fe161ec2",
        "type": "message",
        "text": "<@UN57U8V53> I still feel like we're talking past each other. Yes, tools can amplify capabilities at various tasks. But if we're trying to _teach_ the elements of programming thinking, tools can paradoxically make that more difficult, by reducing the opportunities for some sort of thinking or other.",
        "user": "UCUSW7WVD",
        "ts": "1594577276.317700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=1dXk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UN57U8V53"
                            },
                            {
                                "type": "text",
                                "text": " I still feel like we're talking past each other. Yes, tools can amplify capabilities at various tasks. But if we're trying to "
                            },
                            {
                                "type": "text",
                                "text": "teach",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the elements of programming thinking, tools can paradoxically make that more difficult, by reducing the opportunities for some sort of thinking or other."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UN57U8V53"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "97a81fee-4057-4169-a33b-5aac6915d7e3",
        "type": "message",
        "text": "<@UJN1TAYEQ>, what \"original post\" are you referring to? Was it outside this thread?\n\nYou're right that I'd been clumping Rebol and Red in my mind. After your comment I went back and reread <http://blog.hostilefork.com/rebol-vs-lisp-macros>, and I still want to push back on your statement that \"Everything I said about FEXPR Lisp dialects seems to be also true of Rebol.\" The notion of definitional scoping turns out to also exist in Rebol, and it has a huge impact on how Rebol operations evaluate their arguments.\n\nIt's a very fruitful exercise to compare and contrast different programming models. Saying, \"A is just like B\" flattens a lot of the richness, I think. Even if an idea was \"invented by Lisp first,\" there's still been lots of parallel evolution that has converged in surprising ways. Rebol is worth framing as its own thing, on the same order as Forth. It's not a Lisp derivative.",
        "user": "UCUSW7WVD",
        "ts": "1594580277.318200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1594580318.000000"
        },
        "attachments": [
            {
                "title": "rebol : Rebol vs. Lisp Macros",
                "title_link": "http://blog.hostilefork.com/rebol-vs-lisp-macros",
                "text": "Author: HostileFork, Title: Rebol vs. Lisp Macros, Date: 19-Apr-2016, Length: 2220 words",
                "fallback": "rebol : Rebol vs. Lisp Macros",
                "from_url": "http://blog.hostilefork.com/rebol-vs-lisp-macros",
                "service_icon": "http://blog.hostilefork.com/favicon.ico",
                "service_name": "blog.hostilefork.com",
                "id": 1,
                "original_url": "http://blog.hostilefork.com/rebol-vs-lisp-macros"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=Fs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": ", what \"original post\" are you referring to? Was it outside this thread?\n\nYou're right that I'd been clumping Rebol and Red in my mind. After your comment I went back and reread "
                            },
                            {
                                "type": "link",
                                "url": "http://blog.hostilefork.com/rebol-vs-lisp-macros"
                            },
                            {
                                "type": "text",
                                "text": ", and I still want to push back on your statement that \"Everything I said about FEXPR Lisp dialects seems to be also true of Rebol.\" The notion of definitional scoping turns out to also exist in Rebol, and it has a huge impact on how Rebol operations evaluate their arguments.\n\nIt's a very fruitful exercise to compare and contrast different programming models. Saying, \"A is just like B\" flattens a lot of the richness, I think. Even if an idea was \"invented by Lisp first,\" there's still been lots of parallel evolution that has converged in surprising ways. Rebol is worth framing as its own thing, on the same order as Forth. It's not a Lisp derivative."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594505114.252600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL",
                    "U01661S9F34"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "1d2fbddc-7072-403c-a52e-c447a4cb9e01",
        "type": "message",
        "text": "Some pretty interesting speculative design here:\n<https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/|https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/>",
        "user": "UT60XSVCN",
        "ts": "1594581007.318600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Computing Is Broken and How to Fix It | Gavin D. Howard",
                "title_link": "https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/",
                "text": "Computing is broken, but what will it take to fix it? More than you might think.",
                "fallback": "Computing Is Broken and How to Fix It | Gavin D. Howard",
                "from_url": "https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/",
                "service_icon": "https://gavinhoward.com/favicon.ico",
                "service_name": "gavinhoward.com",
                "id": 1,
                "original_url": "https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "orR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some pretty interesting speculative design here:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/",
                                "text": "https://gavinhoward.com/2020/02/computing-is-broken-and-how-to-fix-it/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "reply_count": 14,
        "reply_users_count": 7,
        "latest_reply": "1595144785.477500",
        "reply_users": [
            "UT60XSVCN",
            "UEQ6M68H0",
            "UP28ETUSE",
            "UDQBTJ211",
            "UA14TGLTC",
            "ULM3U6275",
            "U0136G8R8KG"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a4713b80-09ff-4411-9a71-869dfeb08f78",
        "type": "message",
        "text": "He doesn't seem to talk about low level latency stuff that comes with that kind of hw design, NUMA, etc, which seems like an oversight. It's interesting to imagine what programming such a system would look like though.\n\nAlso, he says he wants C interop, but that he will only use safe languages, which is kinda odd.",
        "user": "UT60XSVCN",
        "ts": "1594581154.318800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fSQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "He doesn't seem to talk about low level latency stuff that comes with that kind of hw design, NUMA, etc, which seems like an oversight. It's interesting to imagine what programming such a system would look like though.\n\nAlso, he says he wants C interop, but that he will only use safe languages, which is kinda odd."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "b21595ab-94d5-406f-a012-6b06c9bdfaae",
        "type": "message",
        "text": "To back up to your original comment:\n\n&gt; This list feel more like language/tooling smells rather than coding requirements.\n\nAre there _any_ things to your mind that programmers _have_ to think about? Or are they all 'smells'? Is the role of the language designer to eliminate the need for thought altogether? How do you draw the line?",
        "user": "UCUSW7WVD",
        "ts": "1594582585.319000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1594582619.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DqdH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To back up to your original comment:\n\n> This list feel more like language/tooling smells rather than coding requirements.\n\nAre there "
                            },
                            {
                                "type": "text",
                                "text": "any",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " things to your mind that programmers "
                            },
                            {
                                "type": "text",
                                "text": "have",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to think about? Or are they all 'smells'? Is the role of the language designer to eliminate the need for thought altogether? How do you draw the line?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "BBB42C43-2FEA-43E3-BD51-2A93FF1BC648",
        "type": "message",
        "text": "He has some mistaken ideas. speculative execution is not a problem for hardly anyone. Is invisible to programmers. The chips are working perfectly well.",
        "user": "UEQ6M68H0",
        "ts": "1594584425.319700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UFXqw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "He has some mistaken ideas. speculative execution is not a problem for hardly "
                            },
                            {
                                "type": "text",
                                "text": "anyone"
                            },
                            {
                                "type": "text",
                                "text": ". "
                            },
                            {
                                "type": "text",
                                "text": "Is"
                            },
                            {
                                "type": "text",
                                "text": " invisible to "
                            },
                            {
                                "type": "text",
                                "text": "programmers"
                            },
                            {
                                "type": "text",
                                "text": "."
                            },
                            {
                                "type": "text",
                                "text": " The chips are working perfectly well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "0fe19a6d-5a69-4571-b7b4-6d1bbed45cf9",
        "type": "message",
        "text": "Speculative execution is the root cause of Spectre... <https://meltdownattack.com/>",
        "user": "UP28ETUSE",
        "ts": "1594584632.321400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R47",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Speculative execution is the root cause of Spectre... "
                            },
                            {
                                "type": "link",
                                "url": "https://meltdownattack.com/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "D96C84B4-849D-44AA-AE4D-DACDCA391687",
        "type": "message",
        "text": "And to imagine everything is a file is a major mistake, files are pain in the ass. They are unstructured arrays of bytes and one is constantly having to decode and encode files. Apple used to use a thing called a resource fork which was a secondary structured section of a file, in which to store indexed meta information. it was wonderful, tut because the Internet was based on stupid old unix and couldn't transfer files easily, they dropped it. And Microsoft had taken 10 years to copy that feature in a version of their file system called WinFS, was just about to release it and then they dropped it too, pushing us back to the 60s.",
        "user": "UEQ6M68H0",
        "ts": "1594584659.321700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1594627762.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wdz4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And to imagine everything is a file is a major mistake, files are pain in the ass. They are unstructured arrays of bytes and one is constantly having to decode and encode files. Apple used to use a thing called a resource fork which was a secondary structured section of a file, in which to store indexed meta information. it was wonderful, tut because the Internet was based on stupid old unix and couldn't transfer files easily, they dropped it. And Microsoft had taken 10 years to copy that feature in a version of their file system called WinFS, was just about to release it and then they dropped it too, pushing us back to the 60s."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UA14TGLTC",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "c7c7d715-4f47-4a47-8077-cc738d2a13ba",
        "type": "message",
        "text": "NTFS actually supports arbitrary meta data (called \"alternate data streams\") but they don't advertise it much because it confuses people that the info is lost when emailed or put on FAT32 usb stick",
        "user": "UDQBTJ211",
        "ts": "1594584965.321900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UDQBTJ211",
            "ts": "1594584980.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uer",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "NTFS actually supports arbitrary meta data (called \"alternate data streams\") but they don't advertise it much because it confuses people that the info is lost when emailed or put on FAT32 usb stick"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "49e3e957-fb59-4939-a496-decacafc958f",
        "type": "message",
        "text": "This post feels really timely: <https://breakingsmart.substack.com/p/the-next-experiments-in-elitism>",
        "user": "UCUSW7WVD",
        "ts": "1594585306.322200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "The Next Experiments in Elitism",
                "title_link": "https://breakingsmart.substack.com/p/the-next-experiments-in-elitism",
                "text": "Listen now | In today\u2019s episode, in honor of Bastille Day next week, and Fourth of July last week, I want to talk about the ongoing evolution in elitism, and the problem of how the emerging new elites can be better than the old ones being toppled. 1/ Elites are a constant and arguably necessary presence in history. Political revolutions that try to do away with elites invariably seem to either fail quickly, or install new elites without meaning to. So the question for me is not how to get rid of elites, but how to try and ensure the ones we end up with are better than the last lot.",
                "fallback": "The Next Experiments in Elitism",
                "image_url": "https://cdn.substack.com/image/fetch/h_600,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F8afb4151-ee4b-4382-b87b-83943a842477_800x600.png",
                "from_url": "https://breakingsmart.substack.com/p/the-next-experiments-in-elitism",
                "image_width": 333,
                "image_height": 250,
                "image_bytes": 107702,
                "service_icon": "https://bucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com/public/images/ca9d1206-147b-4104-b7bf-e9d714fdbb1f/apple-touch-icon-57x57.png",
                "service_name": "breakingsmart.substack.com",
                "id": 1,
                "original_url": "https://breakingsmart.substack.com/p/the-next-experiments-in-elitism"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O8V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This post feels really timely: "
                            },
                            {
                                "type": "link",
                                "url": "https://breakingsmart.substack.com/p/the-next-experiments-in-elitism"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594458004.219100",
        "parent_user_id": "U0137BUHUBW"
    },
    {
        "client_msg_id": "ad85ba42-6ca1-4992-90e8-804d252a8f8e",
        "type": "message",
        "text": "Awesome question! To me, the definition of the problem and its constraints are unique for each program and cross all languages (by the writer, not necessarily the reader, and not necessarily explicit in the code). Once you get to the how, opinions start. The role languages play is forcing or allowing a programmer to answer certain questions (usually some variation of where and when).",
        "user": "UN57U8V53",
        "ts": "1594585793.322600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UN57U8V53",
            "ts": "1594588767.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pNv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Awesome question! To me, the definition of the problem and its constraints are unique for each program and cross all languages (by the writer, not necessarily the reader, and not necessarily explicit in the code). Once you get to the how, opinions start. The role languages play is forcing or allowing a programmer to answer certain questions (usually some variation of where and when)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "85ebc4ad-77c8-4cd0-87d3-307192807506",
        "type": "message",
        "text": "Yeah I'm not much of a file fan either",
        "user": "UT60XSVCN",
        "ts": "1594585812.322800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UkM0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I'm not much of a file fan either"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "63d2d520-95a5-4f78-b704-4651b7ca17f6",
        "type": "message",
        "text": "I find it interesting how some of those ideas have already made it to the mainstream though",
        "user": "UT60XSVCN",
        "ts": "1594585841.323100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VDrb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find it interesting how some of those ideas have already made it to the mainstream though"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "c1fc02ec-d90d-4bd2-80af-c7f9289d4125",
        "type": "message",
        "text": "For example, his stuff about managing message passing with shared memory (ring) buffers will look familiar to anyone keeping up with linux kernel development as the recent io_uring facility",
        "user": "UT60XSVCN",
        "ts": "1594585903.323300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RGU+W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example, his stuff about managing message passing with shared memory (ring) buffers will look familiar to anyone keeping up with linux kernel development as the recent io_uring facility"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594581007.318600",
        "parent_user_id": "UT60XSVCN",
        "reactions": [
            {
                "name": "wave",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0895fac4-8e5c-4289-af64-bf6969f2d9d2",
        "type": "message",
        "text": "I don't follow that at all.. :smile:",
        "user": "UCUSW7WVD",
        "ts": "1594586096.324000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VdsVb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't follow that at all.. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593722002.162200",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "28a29cc1-909f-4717-be08-7652e92c1a15",
        "type": "message",
        "text": "&gt; engineering roadblocks at the edge of performance\nI can't help but get the impression that she isn't aware of the years of research in 3D game engine design. She is basically re-discovering scene graph optimization techniques like LOD rendering and spatial B-tree optimizations that game engines have been using for years. Techniques like offloading tasks onto another thread that may cause you to miss hard real time deadlines is how game engine physics and game AI have been implemented for years.\n\nIt's weird because she mentions taking the idea of a frame rate counter from graphics programming, but then seems to ignore everything else from graphics programming?\n\nDefinitely a cool app from a UI / UX research perspective though :slightly_smiling_face:",
        "user": "U01661S9F34",
        "ts": "1594590278.324700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1594590624.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2ueb",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "engineering roadblocks at the edge of performance"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI can't help but get the impression that she isn't aware of the years of research in 3D game engine design. She is basically re-discovering scene graph optimization techniques like LOD rendering and spatial B-tree optimizations that game engines have been using for years. Techniques like offloading tasks onto another thread that may cause you to miss hard real time deadlines is how game engine physics and game AI have been implemented for years.\n\nIt's weird because she mentions taking the idea of a frame rate counter from graphics programming, but then seems to ignore everything else from graphics programming?\n\nDefinitely a cool app from a UI / UX research perspective though "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1594409036.201800",
        "parent_user_id": "UHWC9PXBL"
    }
]