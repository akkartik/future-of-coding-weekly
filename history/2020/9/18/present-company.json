[
    {
        "client_msg_id": "b2dfd68c-b358-4512-9e40-51318072fd95",
        "type": "message",
        "text": "Surprised by \"and it just works!\"",
        "user": "UA14TGLTC",
        "ts": "1600396350.000200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sPi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Surprised by \"and it just works!\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600312443.026300",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "de1d9947-9524-426f-b1ef-74a87cdfe8f1",
        "type": "message",
        "text": "Yes, in Haskell people are going to start with type variables because lowercase `a`, `b`, `c` translates into don't care, doesn't matter, no worries.  The place where you fall down a hole is where you have interacting type classes.  Next thing you know you're surrounded by multi-parameter type class with functional dependencies, type families, and worse.",
        "user": "UA14TGLTC",
        "ts": "1600397015.000600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zxI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, in Haskell people are going to start with type variables because lowercase "
                            },
                            {
                                "type": "text",
                                "text": "a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "c",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " translates into don't care, doesn't matter, no worries.  The place where you fall down a hole is where you have interacting type classes.  Next thing you know you're surrounded by multi-parameter type class with functional dependencies, type families, and worse."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "814831b4-44e2-426b-8c77-cd3cbc2c0217",
        "type": "message",
        "text": "Good abstractions are helpful, bad abstractions are an obstacle. I don't expect much opposition to this statement. So the real question is how to deal with experimental abstractions, when working in a domain you don't understand very well. Is it better to abstract early or abstract late?\n\nI like <@U5STGTB3J>'s idea of exploring how various communities deal with this, but I think it would be even more instructive to extend this exploration beyond programming. We (in the sense of human societies) have a lot more experience with mathematical and engineering abstractions, for example.",
        "user": "UJBAJNFLK",
        "ts": "1600416208.000800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X5L",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good abstractions are helpful, bad abstractions are an obstacle. I don't expect much opposition to this statement. So the real question is how to deal with experimental abstractions, when working in a domain you don't understand very well. Is it better to abstract early or abstract late?\n\nI like "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": "'s idea of exploring how various communities deal with this, but I think it would be even more instructive to extend this exploration beyond programming. We (in the sense of human societies) have a lot more experience with mathematical and engineering abstractions, for example."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "5a825a19-1043-42ae-b513-21463fd02fec",
        "type": "message",
        "text": "Live programming systems have been doing this for decades. Smalltalk is probably the best example to study. When you change a class, all its instances get updated. Common Lisp has such a mechanism as well, but it's not automatic.",
        "user": "UJBAJNFLK",
        "ts": "1600416369.001100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FQFn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Live programming systems have been doing this for decades. Smalltalk is probably the best example to study. When you change a class, all its instances get updated. Common Lisp has such a mechanism as well, but it's not automatic."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    },
    {
        "client_msg_id": "b56d4e61-db95-4564-a560-f026b1bf4f81",
        "type": "message",
        "text": "Picked up and propagated is the trick.  There are a few different senses of propagation.  In Smalltalk and Lisp usually, adding a field or whatever will work with existing objects, but the new field won't have a value.  So there might be a bit of migration involved.  In other cases (Ruby sometimes), you might rebind the name MyRecord to something new so now the old my records refer to a class, or whatever, that isn't called MyRecord anymore.  A third thing you might want to do (what I often do) is you make a change and now you want to go back and rerun (over some scope) with that change replacing the objects with the new alternative.  And then, of course, you want to compare to see what the knock-on effects are of the change are between patched and unpatched possible worlds.",
        "user": "UA14TGLTC",
        "ts": "1600419529.001400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WWdD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Picked up and propagated is the trick.  There are a few different senses of propagation.  In Smalltalk and Lisp usually, adding a field or whatever will work with existing objects, but the new field won't have a value.  So there might be a bit of migration involved.  In other cases (Ruby sometimes), you might rebind the name MyRecord to something new so now the old my records refer to a class, or whatever, that isn't called MyRecord anymore.  A third thing you might want to do (what I often do) is you make a change and now you want to go back and rerun (over some scope) with that change replacing the objects with the new alternative.  And then, of course, you want to compare to see what the knock-on effects are of the change are between patched and unpatched possible worlds."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    },
    {
        "client_msg_id": "48716137-bf8e-4cc5-a626-f9ab15764b33",
        "type": "message",
        "text": "Yeah, I'm coming at this from my explorations of linguistics and my recently improved understanding of Christopher Alexander's pattern languages. It seems that an overlooked property of ~regular~ human language is that we are perfectly fine in communicating in abstract concepts all the time and there is no need to go and define everything all the way down to the nitty-gritty details as long as we roughly understand the words we use in the same way.\n\nA form of applying this more or less directly to programming is to try to stay on that abstract level where a list is just that, and you go as long as you can without saying what's actually in the list. Of course, with programming languages you'll have to eventually provide some real specific values, if you want to see your program running and doing something. But if you did the generic part properly and your language supports it, it should be as easy as picking a few concrete values for a test case, stick them in, and it should just work (even if it doesn't verify the complete range of possible types/values), because your program is defined for all lists of any type, whatever type you end up using.",
        "user": "U5STGTB3J",
        "ts": "1600443720.001600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1600446152.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5HKP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I'm coming at this from my explorations of linguistics and my recently improved understanding of Christopher Alexander's pattern languages. It seems that an overlooked property of "
                            },
                            {
                                "type": "text",
                                "text": "regular",
                                "style": {
                                    "strike": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " human language is that we are perfectly fine in communicating in abstract concepts all the time and there is no need to go and define everything all the way down to the nitty-gritty details as long as we roughly understand the words we use in the same way.\n\nA form of applying this more or less directly to programming is to try to stay on that abstract level where a list is just that, and you go as long as you can without saying what's actually in the list. Of course, with programming languages you'll have to eventually provide some real specific values, if you want to see your program running and doing something. But if you did the generic part properly and your language supports it, it should be as easy as picking a few concrete values for a test case, stick them in, and it should just work (even if it doesn't verify the complete range of possible types/values), because your program is defined for all lists of any type, whatever type you end up using."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "394e5540-f157-4f12-acf4-2893232ff459",
        "type": "message",
        "text": "What I'm looking at here though, is *not* the benefit of having more generic algorithms which can be reused (which is usually the motivation), but the benefit of not having to (and not being able to) define specifics before you have to. This is much closer to what Alexander has in mind when he talks about \"unfolding\", I think, and it is what I misunderstood about pattern languages \u2014 they weren't meant for reusable components, as _Design Patterns_ will make you think \u2014 they were meant as a design technique that keeps you focused on the _whole_ and leads you through a process of progressive refinement, step by step adding more details transforming, but never replacing or destroying the structure you have built thus far.",
        "user": "U5STGTB3J",
        "ts": "1600444211.001900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1600446289.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oJ6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I'm looking at here though, is "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the benefit of having more generic algorithms which can be reused (which is usually the motivation), but the benefit of not having to (and not being able to) define specifics before you have to. This is much closer to what Alexander has in mind when he talks about \"unfolding\", I think, and it is what I misunderstood about pattern languages \u2014 they weren't meant for reusable components, as "
                            },
                            {
                                "type": "text",
                                "text": "Design Patterns",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " will make you think \u2014 they were meant as a design technique that keeps you focused on the "
                            },
                            {
                                "type": "text",
                                "text": "whole",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and leads you through a process of progressive refinement, step by step adding more details transforming, but never replacing or destroying the structure you have built thus far."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "f993f404-d478-4b6c-8d1f-3dee41ce1105",
        "type": "message",
        "text": "<@UJBAJNFLK> <@UA14TGLTC> Thanks, could you point me to any references or papers I could have a look at specifically about this?",
        "user": "UPMFG2571",
        "ts": "1600453456.002800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3N8i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " Thanks, could you point me to any references or papers I could have a look at specifically about this?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    }
]