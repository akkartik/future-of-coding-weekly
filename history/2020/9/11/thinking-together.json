[
    {
        "client_msg_id": "072e0fff-31d5-4975-8e01-a4d9772e62f3",
        "type": "message",
        "text": "I don't think the explanation even needs to be specific to programming. There has been a long-term trend towards people doing less and less for themselves, and instead satisfying more and more of their desires through market interactions. Cooking, cleaning, basic repairs, altering clothing, music, story-telling etc are all often outsourced now. End-user programming is swimming against that tide.\n\nMaybe there is inspiration to be found by looking at surviving knots of diy culture, where people are still interested in learning new skills. Eg my old housemate used to hang out at a community carpentry workshop.",
        "user": "U71PMQ1V0",
        "ts": "1599777821.227000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U71PMQ1V0",
            "ts": "1599777838.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iPc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't think the explanation even needs to be specific to programming. There has been a long-term trend towards people doing less and less for themselves, and instead satisfying more and more of their desires through market interactions. Cooking, cleaning, basic repairs, altering clothing, music, story-telling etc are all often outsourced now. End-user programming is swimming against that tide.\n\nMaybe there is inspiration to be found by looking at surviving knots of diy culture, where people are still interested in learning new skills. Eg my old housemate used to hang out at a community carpentry workshop."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599719973.216100",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UMWF81HTP",
                    "UJBAJNFLK",
                    "UJ6LDMMN0",
                    "UA14TGLTC"
                ],
                "count": 5
            }
        ]
    },
    {
        "client_msg_id": "76b1f1c0-2d08-4b41-8171-1aa7e9f808a9",
        "type": "message",
        "text": "My perspective: I did more \"end-user programming\" before I was a programmer, but knew enough programming to be useful. This was at an office job, where everything ran on Excel. I was doing lots of web scraping, data processing, making small tools for tedious tasks, etc.\n\nThen I got a job doing programming, and didn't have any material problems to solve with programming any more!",
        "user": "UMWF81HTP",
        "ts": "1599782167.228000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ryoE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My perspective: I did more \"end-user programming\" before I was a programmer, but knew enough programming to be useful. This was at an office job, where everything ran on Excel. I was doing lots of web scraping, data processing, making small tools for tedious tasks, etc.\n\nThen I got a job doing programming, and didn't have any material problems to solve with programming any more!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "point_up_2",
                "users": [
                    "U01A0KANUUU",
                    "UFPPABQ7P"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "5a827eee-992a-42b8-9f58-6a769a915a14",
        "type": "message",
        "text": "So, to the question:\n_\"Does end-user programming ever have a chance of succeeding for non-programmers to solve their problems if programmers themselves aren't using programming to solve their problems?\"_\n\nmy answer is:\n_\"yes! Non-programmers have way more problems solvable with programming than programmers do\"_",
        "user": "UMWF81HTP",
        "ts": "1599782421.228200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "b3CD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So, to the question:\n"
                            },
                            {
                                "type": "text",
                                "text": "\"Does end-user programming ever have a chance of succeeding for non-programmers to solve their problems if programmers themselves aren't using programming to solve their problems?\"",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nmy answer is:\n"
                            },
                            {
                                "type": "text",
                                "text": "\"yes! Non-programmers have way more problems solvable with programming than programmers do\"",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "UJ6LDMMN0",
                    "U5STGTB3J",
                    "UML4ZEKDK",
                    "UHWC9PXBL",
                    "UFPPABQ7P"
                ],
                "count": 7
            }
        ]
    },
    {
        "client_msg_id": "C103F8B9-B536-4E8B-A5EC-8976D436B7AF",
        "type": "message",
        "text": "To the specific point in the original post about some programmers not customizing their programming tools:\n\none hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools. ",
        "user": "UMWF81HTP",
        "ts": "1599783090.232700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UMWF81HTP",
            "ts": "1599783122.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yjV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To the specific point in the original post about some programmers not customizing their programming tools:\n\none hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools. "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UP00ZLX6G",
                    "UML4ZEKDK",
                    "U01A0KANUUU"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "4a3b3d08-2bd6-4715-9930-92b30fd1f02c",
        "type": "message",
        "text": "Broad question here.\nDo people here know of any tools that separates the complexity component of a program from the underlying behavior it would eventually produce, and then let you manipulate code so the behavior is fixed? By behavior I mean something like the user-facing behavior of a program, or its effect on some data. Its a flexible concept in my mind. A large portion of programming seems to be rewriting code so it maintains the same behavior, but is then also extensible in some way. Factoring code is an example of this activity, but you could also rewrite code to produce the same behavior which is not a factorization of the original code. To be concrete, you could factor in two different ways, so each factorization would produce the same behavior but neither is a factorization of one another. Moving back to the unfactored code and factoring in the other way is then a means of transforming the code to produce the same behavior that isn't mere factoring.\n(picture: code&lt;--factoring&lt;--code--&gt;factoring--&gt;code)\n(this is very reminiscent of factoring in abstract algebra and you could imagine an algebra about manipulating the code in this way, and going down this road you can ask whether two programs will produce the same behavior implies there is a common factorization but this might be another conversation).\n\nI'm curious about this question mostly as a proxy for a related question in math: How can you transform one proof into an equivalent proof? This is a slippery concept because nobody knows how to make precise the idea of \"equivalence of proofs\". If you know about Hilbert and his 23 problems you might find it interesting that he originally had a 24th problem on the equivalence of proofs! Even though the idea is notoriously difficult to pin down, I think it is intuitive enough to take a pragmatic stance and ask how you could go about implementing technology to carry out these transformations. This is important to me because in math we \"factor\" proofs all the time and often compare proofs to determine the essential and incidental aspects of each. So what I'm really looking for is any techniques or perspectives in the domain of programming that could be taken back into mathematics. I've seen some approaches down at the level of the lambda calculus but I haven't found them useful. I think a pragmatic/experimental approach is better than a theoretical approach at this point.",
        "user": "UFPRPSA4S",
        "ts": "1599805535.266400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFPRPSA4S",
            "ts": "1599805615.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bc3O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Broad question here.\nDo people here know of any tools that separates the complexity component of a program from the underlying behavior it would eventually produce, and then let you manipulate code so the behavior is fixed? By behavior I mean something like the user-facing behavior of a program, or its effect on some data. Its a flexible concept in my mind. A large portion of programming seems to be rewriting code so it maintains the same behavior, but is then also extensible in some way. Factoring code is an example of this activity, but you could also rewrite code to produce the same behavior which is not a factorization of the original code. To be concrete, you could factor in two different ways, so each factorization would produce the same behavior but neither is a factorization of one another. Moving back to the unfactored code and factoring in the other way is then a means of transforming the code to produce the same behavior that isn't mere factoring.\n(picture: code<--factoring<--code-->factoring-->code)\n(this is very reminiscent of factoring in abstract algebra and you could imagine an algebra about manipulating the code in this way, and going down this road you can ask whether two programs will produce the same behavior implies there is a common factorization but this might be another conversation).\n\nI'm curious about this question mostly as a proxy for a related question in math: How can you transform one proof into an equivalent proof? This is a slippery concept because nobody knows how to make precise the idea of \"equivalence of proofs\". If you know about Hilbert and his 23 problems you might find it interesting that he originally had a 24th problem on the equivalence of proofs! Even though the idea is notoriously difficult to pin down, I think it is intuitive enough to take a pragmatic stance and ask how you could go about implementing technology to carry out these transformations. This is important to me because in math we \"factor\" proofs all the time and often compare proofs to determine the essential and incidental aspects of each. So what I'm really looking for is any techniques or perspectives in the domain of programming that could be taken back into mathematics. I've seen some approaches down at the level of the lambda calculus but I haven't found them useful. I think a pragmatic/experimental approach is better than a theoretical approach at this point."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "reply_count": 8,
        "reply_users_count": 6,
        "latest_reply": "1599895801.289600",
        "reply_users": [
            "U013ZLJARC7",
            "UUB7RA7PF",
            "U01AN8DFFBN",
            "UA14TGLTC",
            "UFPRPSA4S",
            "U01661S9F34"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "708500aa-c6ff-4614-adc7-d3a459ecfd90",
        "type": "message",
        "text": "The closest thing to what I think you're asking about is using Logic Programming to do program synthesis. Here's a video demoing a system of this kind:\n<https://www.youtube.com/watch?v=5vtC7WEN76w>",
        "user": "U013ZLJARC7",
        "ts": "1599808252.266700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "(seventh RacketCon): Keynote -- Dan Friedman &amp; Will Byrd -- The Reasoned Racketeers",
                "title_link": "https://www.youtube.com/watch?v=5vtC7WEN76w",
                "author_name": "Racket Lang",
                "author_link": "https://www.youtube.com/user/racketlang",
                "thumb_url": "https://i.ytimg.com/vi/5vtC7WEN76w/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: (seventh RacketCon): Keynote -- Dan Friedman & Will Byrd -- The Reasoned Racketeers",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/5vtC7WEN76w?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=5vtC7WEN76w",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=5vtC7WEN76w"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4elC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The closest thing to what I think you're asking about is using Logic Programming to do program synthesis. Here's a video demoing a system of this kind:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=5vtC7WEN76w"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFPRPSA4S"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a40de35e-a719-48f5-b1fc-678a7aa96502",
        "type": "message",
        "text": "<@UCUSW7WVD> I disagree about one point: your argument is all about text. In a universe where people share small pieces of code for inspection and adaptation to their own needs, it is crucial to have a representation that is universally supported by communication media, and that means text. I actually guess we all agree that it means text _for now_, but my claim is that this is not going to change. Text is the dominant mode of time-delayed communication between humans, with pictures taking the second place and everything else (voice recording etc.) lagging far behind. Therefore text is going to be the preferred medium for the kind of interaction you describe for a long time. Perhaps we will develop picture-based communiction with machines to the point that it can complement text, but that's no more than a dream for now.\n\nWhat made me realize the importance of text-based representations is my recent involvement with Pharo (i.e. Smalltalk). When interacting with a Smalltalk system, text is used only at the most fine-grained level, inside a method. But that means that discussing Smalltalk code by e-mail or in discussion forums is very cumbersome. People end up using constructs that are legal Smalltalk code but which nobody ever uses for code development, such as creating classes by sending a message to another class. This creates a serious disconnect between human-computer interaction and interhuman communication.",
        "user": "UJBAJNFLK",
        "ts": "1599808316.267000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XaU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I disagree about one point: your argument is all about text. In a universe where people share small pieces of code for inspection and adaptation to their own needs, it is crucial to have a representation that is universally supported by communication media, and that means text. I actually guess we all agree that it means text "
                            },
                            {
                                "type": "text",
                                "text": "for now",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but my claim is that this is not going to change. Text is the dominant mode of time-delayed communication between humans, with pictures taking the second place and everything else (voice recording etc.) lagging far behind. Therefore text is going to be the preferred medium for the kind of interaction you describe for a long time. Perhaps we will develop picture-based communiction with machines to the point that it can complement text, but that's no more than a dream for now.\n\nWhat made me realize the importance of text-based representations is my recent involvement with Pharo (i.e. Smalltalk). When interacting with a Smalltalk system, text is used only at the most fine-grained level, inside a method. But that means that discussing Smalltalk code by e-mail or in discussion forums is very cumbersome. People end up using constructs that are legal Smalltalk code but which nobody ever uses for code development, such as creating classes by sending a message to another class. This creates a serious disconnect between human-computer interaction and interhuman communication."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599719973.216100",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC",
                    "UE0ETTCG7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "a4d55475-419e-4c2f-9e81-6d31efccabb8",
        "type": "message",
        "text": "At risk of coming up as very naive: what about tests on the practical side and formal verification on the other side? Since those are allowing us to refactor code while ensuring (to varying degree) its correctnes and behaviour, how do those fit into what you are looking for?",
        "user": "UUB7RA7PF",
        "ts": "1599808898.267200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UUB7RA7PF",
            "ts": "1599808998.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uvH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At risk of coming up as very naive: what about tests on the practical side and formal verification on the other side? Since those are allowing us to refactor code while ensuring (to varying degree) its correctnes and behaviour, how do those fit into what you are looking for?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S"
    },
    {
        "client_msg_id": "becb4308-d2ad-4cff-ad6a-3fe6654f8fcb",
        "type": "message",
        "text": "I've been trying to keep an open mind and work against my pro-text bias, but I'll be very happy if that's not needed :slightly_smiling_face:",
        "user": "UCUSW7WVD",
        "ts": "1599808994.267500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kQqu4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been trying to keep an open mind and work against my pro-text bias, but I'll be very happy if that's not needed "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599719973.216100",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "grinning",
                "users": [
                    "UJBAJNFLK",
                    "UA14TGLTC",
                    "U013ZLJARC7",
                    "UE0ETTCG7"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "bbc24594-2eb9-4587-8a40-1c63c970e8f2",
        "type": "message",
        "text": "I wonder how different proofs for the same theorem compare after resolving all abstractions and breaking them down to ZF. But I guess even proofs using the minimal amount of axioms aren't unambiguous, as two different axioms could share a common idea.\nHowever, it is undecidable whether a set of axioms contains redundant axioms. \n\nIn general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior.",
        "user": "U01AN8DFFBN",
        "ts": "1599813645.268000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JGNKG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder how different proofs for the same theorem compare after resolving all abstractions and breaking them down to ZF. But I guess even proofs using the minimal amount of axioms aren't unambiguous, as two different axioms could share a common idea.\nHowever, it is undecidable whether a set of axioms contains redundant axioms. \n\nIn general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S"
    },
    {
        "client_msg_id": "f98b0bd8-2c5b-4bda-869a-785de09f395b",
        "type": "message",
        "text": "When dealing with undecidability, it's best to say, \"well, we'll just handle the easy cases,\" and see how far you go.  Compiler optimizations are certainly an exercise in factoring as is partial evaluation, which is a good deal more fun.  Come to think of it, conventional refactoring is sort of the opposite transformation.  Instead of removing indirection, add it so that the rest is more regular.",
        "user": "UA14TGLTC",
        "ts": "1599816204.268200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H/YKY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When dealing with undecidability, it's best to say, \"well, we'll just handle the easy cases,\" and see how far you go.  Compiler optimizations are certainly an exercise in factoring as is partial evaluation, which is a good deal more fun.  Come to think of it, conventional refactoring is sort of the opposite transformation.  Instead of removing indirection, add it so that the rest is more regular."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S"
    },
    {
        "client_msg_id": "c3129a1e-db16-4ff5-96d1-f9a70ccb00a0",
        "type": "message",
        "text": "My experience definitely matches <@UMWF81HTP>'s (although I went the other direction, out of software development).\n\nThe amount of menial, manual use of computers that goes on in the world is a travesty. I'm talking about stuff like physically typing filenames into a Word doc.\n\nIt's long been recognised that a manager might send emails to her staff, instructing them to do some task on a computer, in a way that is *almost* pseudocode. e.g. \"can you go through every sales report on the K drive for February and check if any of the unit codes have expired?\".\n\nEnd user programming should be looking to eliminate the middle human from this kind of human-&gt;human-&gt;computer situation.\n\nThis is the type of thing that SQL was meant to eliminate, but it didn't. I think the issue is solutions like SQL demand too much subservience in how information is managed, and they want it stored in a way that is different to how humans would naturally do it. The also demand labour up front (at the point of storing), for no immediate reward, which is always a foolishly optimistic thing to require.\n\nI have high hopes for a system that approaches the OS from the same perspective as the user, for example all text OCRed, structure automatically inferred from physical layout etc.",
        "user": "UDQBTJ211",
        "ts": "1599822009.269000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sSu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My experience definitely matches "
                            },
                            {
                                "type": "user",
                                "user_id": "UMWF81HTP"
                            },
                            {
                                "type": "text",
                                "text": "'s (although I went the other direction, out of software development).\n\nThe amount of menial, manual use of computers that goes on in the world is a travesty. I'm talking about stuff like physically typing filenames into a Word doc.\n\nIt's long been recognised that a manager might send emails to her staff, instructing them to do some task on a computer, in a way that is "
                            },
                            {
                                "type": "text",
                                "text": "almost",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " pseudocode. e.g. \"can you go through every sales report on the K drive for February and check if any of the unit codes have expired?\".\n\nEnd user programming should be looking to eliminate the middle human from this kind of human->human->computer situation.\n\nThis is the type of thing that SQL was meant to eliminate, but it didn't. I think the issue is solutions like SQL demand too much subservience in how information is managed, and they want it stored in a way that is different to how humans would naturally do it. The also demand labour up front (at the point of storing), for no immediate reward, which is always a foolishly optimistic thing to require.\n\nI have high hopes for a system that approaches the OS from the same perspective as the user, for example all text OCRed, structure automatically inferred from physical layout etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "383ac18d-1711-4851-b1cc-a96b0abe0eac",
        "type": "message",
        "text": "Re: DIY's passing, I sometimes wonder whether having an entire industry competing to building seductive simulations of personal development might be interfering with the actual personal development of human beings. Or, to put it another way, how many music lovers have spent more hours playing _Garage Band_ than it would have taken to learn how to play and form an actual garage band?",
        "user": "U013ZLJARC7",
        "ts": "1599828641.269200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R4Lp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Re: DIY's passing, I sometimes wonder whether having an entire industry competing to building seductive simulations of personal development might be interfering with the actual personal development of human beings. Or, to put it another way, how many music lovers have spent more hours playing "
                            },
                            {
                                "type": "text",
                                "text": "Garage Band",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " than it would have taken to learn how to play and form an actual garage band?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599719973.216100",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "664474c6-21cd-4b60-8873-2c62ebc637ef",
        "type": "message",
        "text": "<@UCGAK10LS> I think logic programming indeed began as identifying itself as a programming language: <http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf>\n\nThe extant thread of how this plays out I think is in the work of John Reynolds in the form of logic relations right now. But the present day incarnations that have the major mindshare happens to be Prolog variety of languages and I think its a fertile ground for bringing in novel work with it.",
        "user": "UDKTZSD6H",
        "ts": "1599829655.269400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DA5D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " I think logic programming indeed began as identifying itself as a programming language: "
                            },
                            {
                                "type": "link",
                                "url": "http://www-public.imtbs-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/Kowalski74.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThe extant thread of how this plays out I think is in the work of John Reynolds in the form of logic relations right now. But the present day incarnations that have the major mindshare happens to be Prolog variety of languages and I think its a fertile ground for bringing in novel work with it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598245856.072500",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "267c81fb-92c2-409f-bca7-dc1f7dd101ad",
        "type": "message",
        "text": "<@UDQBTJ211> Totally agree about the manager request example. I did a freelance job a couple of years ago for a non profit. They really just needed a specific way to process bank account information from several online services into an Excel template they used. The people working there knew exactly \u201cwhat needed to happen,\u201d but the tools on their system had no way for them to express it, and the services they were using were siloed from each other",
        "user": "U01A0KANUUU",
        "ts": "1599831311.269800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GT6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": " Totally agree about the manager request example. I did a freelance job a couple of years ago for a non profit. They really just needed a specific way to process bank account information from several online services into an Excel template they used. The people working there knew exactly \u201cwhat needed to happen,\u201d but the tools on their system had no way for them to express it, and the services they were using were siloed from each other"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "bb130066-a478-41a5-85a3-9a33c0eba083",
        "type": "message",
        "text": "In the end I had to make them a quick electron app that did it, and it was really eye opening how complicated the programming task was even though the real task was conceptually simple, and all the \u201cparts\u201d were already there in the system",
        "user": "U01A0KANUUU",
        "ts": "1599831364.270000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e3S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the end I had to make them a quick electron app that did it, and it was really eye opening how complicated the programming task was even though the real task was conceptually simple, and all the \u201cparts\u201d were already there in the system"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "76571da6-2d48-4b75-9e01-36e33828c352",
        "type": "message",
        "text": "As time has passed, I consider the design that got them (and myself) into that position to be hostile. But it gave me work, just like poor design gives programmers work every day across the world",
        "user": "U01A0KANUUU",
        "ts": "1599831405.270200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2WL5S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As time has passed, I consider the design that got them (and myself) into that position to be hostile. But it gave me work, just like poor design gives programmers work every day across the world"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "48e3345f-deed-48ba-842f-442e79b13e40",
        "type": "message",
        "text": "The killer features of plain text are collaboration and sharing. One pet theory is that one reason for the incredible popularity of visual programming languages practically everywhere except for software development (e.g., <https://twitter.com/robenkleene/status/1280182521796399106>) is that most those are areas much less dependent on collaboration.",
        "user": "UE0ETTCG7",
        "ts": "1599838400.270600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE0ETTCG7",
            "ts": "1599839151.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ehvP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The killer features of plain text are collaboration and sharing. One pet theory is that one reason for the incredible popularity of visual programming languages practically everywhere except for software development (e.g., "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/robenkleene/status/1280182521796399106"
                            },
                            {
                                "type": "text",
                                "text": ") is that most those are areas much less dependent on collaboration."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599719973.216100",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "ce63d026-453b-47d8-ad95-b72633c3bee0",
        "type": "message",
        "text": "Regarding:\n\n&gt; one hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools.\nThis is an interesting perspective, and I believe it's true to an extent, e.g., while almost every powerful application from Excel to Photoshop to DAWs has a cottage industry of extensions that surround it, it's certainly true that developer tools dwarf the others in quantity of existing customizations.\n\nBut I still see a lot of contrary evidence. E.g., it still seems that most programmers, when they encounter a problem with a programmatic solution, they'll tend to choose a manual solution. The canonical example is automated testing. While automated testing has certainly become popular, it still seems to be in the \"eat your vegetables\" category, instead of something programmers just do naturally. Which is odd if you think about it, because manual testing is just that, manual, and programmers are master automators, so...?\n\nMore personally, what I find most fulfilling about writing my own scripts and customizations is that I can make the software behave the way I want it to. When you're using someone else's customizations you're always at the mercy of the creator's decisions. I don't think that wishing your tools worked differently is rare, that's a sentiment that I feel almost every computer user has, but programmers are the only group that's empowered to change how their tools work today, and for the most part, they still choose not to.",
        "user": "UE0ETTCG7",
        "ts": "1599839034.271100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TAk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Regarding:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "one hypothesis is that programming tooling is already pretty well optimized for the output that the industry wants from programmers. Programmers are customers too: It only takes a small amount of dedicated people making tooling like IDEs, text editors, plugins etc for the majority to benefit from the care and thought put into these tools."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis is an interesting perspective, and I believe it's true to an extent, e.g., while almost every powerful application from Excel to Photoshop to DAWs has a cottage industry of extensions that surround it, it's certainly true that developer tools dwarf the others in quantity of existing customizations.\n\nBut I still see a lot of contrary evidence. E.g., it still seems that most programmers, when they encounter a problem with a programmatic solution, they'll tend to choose a manual solution. The canonical example is automated testing. While automated testing has certainly become popular, it still seems to be in the \"eat your vegetables\" category, instead of something programmers just do naturally. Which is odd if you think about it, because manual testing is just that, manual, and programmers are master automators, so...?\n\nMore personally, what I find most fulfilling about writing my own scripts and customizations is that I can make the software behave the way I want it to. When you're using someone else's customizations you're always at the mercy of the creator's decisions. I don't think that wishing your tools worked differently is rare, that's a sentiment that I feel almost every computer user has, but programmers are the only group that's empowered to change how their tools work today, and for the most part, they still choose not to."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "7074b22d-27bb-4518-9eab-0cef1ea7820c",
        "type": "message",
        "text": "I\u2019ll challenge some of your assumptions here <@UE0ETTCG7> not sure if this is useful, but could be another perspective!:\n\n\u2022 *Automating isn\u2019t always better than manual.* Clicking through a new UI sequence can give you the ULTIMATE end-user gut check. Things can still go wrong (caching, what have you) but less is likely to go wrong. You can build a burrito robot but unless you taste the burrito at the end with your own mouth, you just don\u2019t know if everything worked as you thought it would.\n\u2022 *Automation is often less concrete / tangible*. Similar to the first 1, but automation is also more abstraction. Abstraction is complexity. Even if the automation script is something simple, there\u2019s overhead now to maintain a list of automations. Perhaps we need better \u2018automation interfaces\u2019 where the overhead is brought to 0. Analogy: I don\u2019t think about not eating cookies in my day to day, I just don\u2019t keep cookies in the house. 0 overhead! ",
        "user": "UAJKEBGP8",
        "ts": "1599839400.271700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tWDo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019ll challenge some of your assumptions here "
                            },
                            {
                                "type": "user",
                                "user_id": "UE0ETTCG7"
                            },
                            {
                                "type": "text",
                                "text": " not sure if this is useful, but could be another perspective!:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Automating isn\u2019t always better than manual.",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " Clicking through a new UI sequence can give you the ULTIMATE end-user gut check. Things can still go wrong (caching, what have you) but less is likely to go wrong. You can build a burrito robot but unless you taste the burrito at the end with your own mouth, you just don\u2019t know if everything worked as you thought it would."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Automation is often less concrete / tangible",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ". Similar to the first 1, but automation is also more abstraction. Abstraction is complexity. Even if the automation script is something simple, there\u2019s overhead now to maintain a list of automations. Perhaps we need better \u2018automation interfaces\u2019 where the overhead is brought to 0. Analogy: I don\u2019t think about not eating cookies in my day to day, I just don\u2019t keep cookies in the house. 0 overhead! "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "e67a9040-ec04-41fe-9f7f-666e38b5304d",
        "type": "message",
        "text": "I agree 100% with both of these points. I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric besides my own personal preference.",
        "user": "UE0ETTCG7",
        "ts": "1599839515.271900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4/6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree 100% with both of these points. I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric besides my own personal preference."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UAJKEBGP8"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3f0e2ac8-1e5a-4d97-ba6e-ae789d36402c",
        "type": "message",
        "text": "this is a long thread\u2026 it could be interesting to fork and start a new thread and this time include like 5-10 concrete examples in your life / things you\u2019ve seen other programmers do <@UE0ETTCG7> etc to spark the discussion!",
        "user": "UAJKEBGP8",
        "ts": "1599839618.272200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rkgL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this is a long thread\u2026 it could be interesting to fork and start a new thread and this time include like 5-10 concrete examples in your life / things you\u2019ve seen other programmers do "
                            },
                            {
                                "type": "user",
                                "user_id": "UE0ETTCG7"
                            },
                            {
                                "type": "text",
                                "text": " etc to spark the discussion!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "96ba63b4-fe19-4e0b-850c-d705356e4aee",
        "type": "message",
        "text": "I'd also say that \"how can doing things manually still be better than automating them in 2020?\" Because I believe that it's still better for many, possibly even most, cases is one of the central questions I'm grappling with.",
        "user": "UE0ETTCG7",
        "ts": "1599839671.272400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE0ETTCG7",
            "ts": "1599839746.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IsU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd also say that \"how can doing things manually still be better than automating them in 2020?\" Because I believe that it's still better for many, possibly even most, cases is one of the central questions I'm grappling with."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "a9fd4323-2aff-4107-bba5-563d141ea356",
        "type": "message",
        "text": "<@UE0ETTCG7>: Nooooooo! :smile: It seemed like you were moving towards the light here:\n\n&gt; I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric..\nBut then you immediately put your blind spot back on in the next comment:\n\n&gt; how can doing things manually still be better than automating them in 2020?\nThat framing is only going to lead you in circles. As <@UGLSY9X3J> pointed out above, and as I tried to say in the overflow thread :arrow_right_hook::\n\n* The line between 'manual' and 'automated' is fuzzy on the computer. If I switch windows and type a command on the shell, I'm still making use of automation. Just less of it.\n* Adding levels of automation _always_ has costs. If it seems always a good idea to you, just wait a few years. We can improve lots of things here, but it's just not a reasonable goal to aim for \"adding levels of automation should always improve life\". There will always be situations where doing something manual is simpler, faster, less alienating. Start developing some warm and fuzzy feeling for doing things manually.\n* Desire for automation is subjective to some extent, as you pointed out in your first comment.\n\nI'd say join me over here where the goal isn't automation but comprehension. Practice throwing kicks not because kicks are always a good idea, but just so you build up judgment on _when_ to use a kick, and so you can do a lot more with a single kick when the moment arrives.\n\n(Movie recommendation: <https://www.imdb.com/title/tt0061770>)",
        "user": "UCUSW7WVD",
        "ts": "1599842954.273100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1599843207.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pE1Uf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UE0ETTCG7"
                            },
                            {
                                "type": "text",
                                "text": ": Nooooooo! "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " It seemed like you were moving towards the light here:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd be the first to admit that I like automating things because I don't like doing them manually, not because I think it's objectively better by any other metric.."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But then you immediately put your blind spot back on in the next comment:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "how can doing things manually still be better than automating them in 2020?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That framing is only going to lead you in circles. As "
                            },
                            {
                                "type": "user",
                                "user_id": "UGLSY9X3J"
                            },
                            {
                                "type": "text",
                                "text": " pointed out above, and as I tried to say in the overflow thread "
                            },
                            {
                                "type": "emoji",
                                "name": "arrow_right_hook"
                            },
                            {
                                "type": "text",
                                "text": ":\n\n* The line between 'manual' and 'automated' is fuzzy on the computer. If I switch windows and type a command on the shell, I'm still making use of automation. Just less of it.\n* Adding levels of automation "
                            },
                            {
                                "type": "text",
                                "text": "always",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has costs. If it seems always a good idea to you, just wait a few years. We can improve lots of things here, but it's just not a reasonable goal to aim for \"adding levels of automation should always improve life\". There will always be situations where doing something manual is simpler, faster, less alienating. Start developing some warm and fuzzy feeling for doing things manually.\n* Desire for automation is subjective to some extent, as you pointed out in your first comment.\n\nI'd say join me over here where the goal isn't automation but comprehension. Practice throwing kicks not because kicks are always a good idea, but just so you build up judgment on "
                            },
                            {
                                "type": "text",
                                "text": "when",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to use a kick, and so you can do a lot more with a single kick when the moment arrives.\n\n(Movie recommendation: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.imdb.com/title/tt0061770"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UAJKEBGP8",
                    "U01661S9F34",
                    "UFPPABQ7P"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "25ef5c55-0de3-43b9-b0e5-713f55d158af",
        "type": "message",
        "text": "<@UUB7RA7PF> I appreciate the answer. Talking about testing is more concrete than talking about an abstract idea of behavior, and as you said the practice of testing is about manipulating code so the same tests (at least) still pass. I guess the picture I have in my mind is that when you are coding you are moving around a space of strings of symbols, and in that huge space is a space of valid programs, and once you write tests, then there is an even smaller space of programs that pass those tests. Is there any means of restricting code rewrites to discrete steps that take place entirely in the space of programs that pass the tests? Rewriting for-loops as while-loops wouldn't change any tests. Changing some variable names. Refactoring. These wouldn't change the tests at all, and in a specific context you could possibly have more. If you have various pieces of code that are interchangeable then you have something like an algebra where you can substitute equivalent expressions. Tests tell you when code is interchangeable so it gives you some algebra-like thing and how can you manipulate code at this level?\n\nSo tests are relevant for what I'm looking for because they let you say when two programs are equivalent. I don't think proof verification does the same in math.",
        "user": "UFPRPSA4S",
        "ts": "1599844798.273600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NCm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UUB7RA7PF"
                            },
                            {
                                "type": "text",
                                "text": " I appreciate the answer. Talking about testing is more concrete than talking about an abstract idea of behavior, and as you said the practice of testing is about manipulating code so the same tests (at least) still pass. I guess the picture I have in my mind is that when you are coding you are moving around a space of strings of symbols, and in that huge space is a space of valid programs, and once you write tests, then there is an even smaller space of programs that pass those tests. Is there any means of restricting code rewrites to discrete steps that take place entirely in the space of programs that pass the tests? Rewriting for-loops as while-loops wouldn't change any tests. Changing some variable names. Refactoring. These wouldn't change the tests at all, and in a specific context you could possibly have more. If you have various pieces of code that are interchangeable then you have something like an algebra where you can substitute equivalent expressions. Tests tell you when code is interchangeable so it gives you some algebra-like thing and how can you manipulate code at this level?\n\nSo tests are relevant for what I'm looking for because they let you say when two programs are equivalent. I don't think proof verification does the same in math."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S"
    },
    {
        "client_msg_id": "313eb0f7-8e32-4014-943b-b1930a138696",
        "type": "message",
        "text": "<@U01AN8DFFBN> \"In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior.\"\n\nNeat! Good to know there isn't a universal tool.\n\n<@UA14TGLTC> Easy cases is right! I haven't seen compiler optimizations before. I might take a peek into that area, but I have a feeling I might get scarred.",
        "user": "UFPRPSA4S",
        "ts": "1599846324.273800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JfiV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01AN8DFFBN"
                            },
                            {
                                "type": "text",
                                "text": " \"In general, deciding whether two programs are semantically equivalent is undecidable too. So there cannot be a universal tool that enumerates all alternative function bodys with the same behavior.\"\n\nNeat! Good to know there isn't a universal tool.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " Easy cases is right! I haven't seen compiler optimizations before. I might take a peek into that area, but I have a feeling I might get scarred."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S"
    },
    {
        "client_msg_id": "db050e27-5c48-469f-a248-4a8f2976e03e",
        "type": "message",
        "text": "&gt; Adding levels of automation always has costs. If it seems always a good idea to you, just wait a few years.\nI think you're misunderstanding me here, I'm specifically saying I don't always think automation is a good idea, I'm saying that it's the way I prefer to solve problems. It's an inclination that has more to do with me, than it does the problem. Correspondingly, I tend to choose to solve problems my approach is a good fit for. I do a lot of work with frameworks, where automated testing is more important. I tend to avoid issues in the UI layer, since manual testing is usually more efficient there. (I actually love working on design-system level UI stuff, but bugs that exist between the UI and the data layer are probably my least favorite thing.)\n\nI would love to hear more about this \"love of doing things manually\" though.",
        "user": "UE0ETTCG7",
        "ts": "1599846932.274000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE0ETTCG7",
            "ts": "1599846996.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kbk",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Adding levels of automation always has costs. If it seems always a good idea to you, just wait a few years."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you're misunderstanding me here, I'm specifically saying I don't always think automation is a good idea, I'm saying that it's the way I prefer to solve problems. It's an inclination that has more to do with me, than it does the problem. Correspondingly, I tend to choose to solve problems my approach is a good fit for. I do a lot of work with frameworks, where automated testing is more important. I tend to avoid issues in the UI layer, since manual testing is usually more efficient there. (I actually love working on design-system level UI stuff, but bugs that exist between the UI and the data layer are probably my least favorite thing.)\n\nI would love to hear more about this \"love of doing things manually\" though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "a7b72578-ca58-43bb-9298-7bc169884885",
        "type": "message",
        "text": "(My comment below generated a bit of interest in another forum so I want to copy it here as a prompt.)\nWhat do folks think about the emphasis on \"readability\" for programming languages?\n&gt; Readability in PLs is nice, but ultimately a red herring. It doesn't scale. We may be able to read a small snippet and get it, but once we have more code or more abstractions, we're lost again. The real goal should be to offload all mechanical computation to the machine.\nIOW, readability gives a very small step. It may be easier to build a \"structure in your head\" after reading a \"more readable\" representation (vs a less readable representation of the same thing). However the work really starts after you have this structure, when we begin \"playing computer\" in our heads.",
        "user": "U8A5MS6R1",
        "ts": "1599848967.277900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z6FF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(My comment below generated a bit of interest in another forum so I want to copy it here as a prompt.)\nWhat do folks think about the emphasis on \"readability\" for programming languages?\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Readability in PLs is nice, but ultimately a red herring. It doesn't scale. We may be able to read a small snippet and get it, but once we have more code or more abstractions, we're lost again. The real goal should be to offload all mechanical computation to the machine."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IOW, readability gives a very small step. It may be easier to build a \"structure in your head\" after reading a \"more readable\" representation (vs a less readable representation of the same thing). However the work really starts after you have this structure, when we begin \"playing computer\" in our heads."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599848967.277900",
        "reply_count": 7,
        "reply_users_count": 6,
        "latest_reply": "1599994580.363500",
        "reply_users": [
            "UCUSW7WVD",
            "U019CPED6T1",
            "UCGAK10LS",
            "UKFNXF0F9",
            "UA14TGLTC",
            "UFPPABQ7P"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UKDM3GLAJ",
                    "U019CPED6T1",
                    "UA14TGLTC",
                    "UUB7RA7PF",
                    "U5STGTB3J",
                    "UGYGY18UX",
                    "UBSMEUXAA"
                ],
                "count": 7
            }
        ]
    },
    {
        "client_msg_id": "5e6c48e6-89a0-4e63-ac7b-57c0d6a83a45",
        "type": "message",
        "text": "&gt; I would love to hear more about this \u201clove of doing things manually\u201d though.\nI\u2019m thinking if the environment you are in is introspective and malleable enough, the manual approach is just so easy",
        "user": "U01A0KANUUU",
        "ts": "1599850623.278000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CL6JQ",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would love to hear more about this \u201clove of doing things manually\u201d though."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m thinking if the environment you are in is introspective and malleable enough, the manual approach is just so easy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "f864772d-37d4-44e2-9271-838d39b04692",
        "type": "message",
        "text": "And the lines between manual / automatic become hazy",
        "user": "U01A0KANUUU",
        "ts": "1599850636.278200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/gqPp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And the lines between manual / automatic become hazy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "03b5305d-5a4f-4c02-a9bb-d629027c110f",
        "type": "message",
        "text": "I agree with <@UA14TGLTC>. This very much reminds me of compiler optimization.\n\nClassical compiler optimization makes use of many transformations that maintain equivalence such as <https://en.wikipedia.org/wiki/Static_single_assignment_form|SSA> form. These sorts of transformations combined with heuristic based analysis are the bread and butter of compiler optimization. The GHC Haskell compiler is probably the epitome of the classical compiler optimization approach.\n\nThen there are the recent results in applying Machine Learning and Genetic algorithms to compiler optimization. These compilers often produce extremely novel, unexpected, even bizarre, machine code, and yet the results have been shown to be \"equivalent\", and yet much more efficient in some dimension than known state of the art classical approaches (often either better runtime or less resulting machine code.) AFAIK, the way the ML compilers seems to work today is essentially unit testing and manual inspection against programs compiled with classical compilers.\n<https://arxiv.org/pdf/1805.03441.pdf>\n<https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0>\n\nA key idea is that all these algorithms must have some notion of equivalence of programs. An optimization is only useful if the resulting behavior is equivalent.\nThe real heart of this is the Church-Turing thesis. Program optimization is essentially saying one program is equivalent to another program, but just computed in a different way. The fact that such equivalent programs can even exist is a direct result the Church-Turing thesis.\n\nYour line of reasoning is related to some of the inspiration of the creators of logic programming and proof assistants like Coq and Agda. If you can encode a proof in a programming language, you have essentially shown that the proof is computable. If it's computable, then there are infinite equivalent programs (via Church-Turing). You can then apply all the known computable transformations like SSA, or graph pruning analysis, etc...",
        "user": "U01661S9F34",
        "ts": "1599850934.278400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1599851000.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xb1j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": ". This very much reminds me of compiler optimization.\n\nClassical compiler optimization makes use of many transformations that maintain equivalence such as "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Static_single_assignment_form",
                                "text": "SSA"
                            },
                            {
                                "type": "text",
                                "text": " form. These sorts of transformations combined with heuristic based analysis are the bread and butter of compiler optimization. The GHC Haskell compiler is probably the epitome of the classical compiler optimization approach.\n\nThen there are the recent results in applying Machine Learning and Genetic algorithms to compiler optimization. These compilers often produce extremely novel, unexpected, even bizarre, machine code, and yet the results have been shown to be \"equivalent\", and yet much more efficient in some dimension than known state of the art classical approaches (often either better runtime or less resulting machine code.) AFAIK, the way the ML compilers seems to work today is essentially unit testing and manual inspection against programs compiled with classical compilers.\n"
                            },
                            {
                                "type": "link",
                                "url": "https://arxiv.org/pdf/1805.03441.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.semanticscholar.org/paper/Compiler-Optimization%3A-A-Genetic-Algorithm-Approach-Ballal-Sarojadevi/6676a5489ced5412fa2ba3ecb76ca3e5ca2723e0"
                            },
                            {
                                "type": "text",
                                "text": "\n\nA key idea is that all these algorithms must have some notion of equivalence of programs. An optimization is only useful if the resulting behavior is equivalent.\nThe real heart of this is the Church-Turing thesis. Program optimization is essentially saying one program is equivalent to another program, but just computed in a different way. The fact that such equivalent programs can even exist is a direct result the Church-Turing thesis.\n\nYour line of reasoning is related to some of the inspiration of the creators of logic programming and proof assistants like Coq and Agda. If you can encode a proof in a programming language, you have essentially shown that the proof is computable. If it's computable, then there are infinite equivalent programs (via Church-Turing). You can then apply all the known computable transformations like SSA, or graph pruning analysis, etc..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599805535.266400",
        "parent_user_id": "UFPRPSA4S",
        "reactions": [
            {
                "name": "sunglasses",
                "users": [
                    "UFPRPSA4S"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c7db2d34-1705-497e-a36d-91dd28b4b428",
        "type": "message",
        "text": "Sure... I agree that line can be fuzzy, but I guess I'm not sure how useful that distinction is, e.g., I'd put someone using a malleable environment / using automation on one side of the coin, but most programmers are still on the other side of the coin, where they're not using a malleable environment (or at least leveraging it), and they're not automating.",
        "user": "UE0ETTCG7",
        "ts": "1599851387.278800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE0ETTCG7",
            "ts": "1599851422.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V=fWO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure... I agree that line can be fuzzy, but I guess I'm not sure how useful that distinction is, e.g., I'd put someone using a malleable environment / using automation on one side of the coin, but most programmers are still on the other side of the coin, where they're not using a malleable environment (or at least leveraging it), and they're not automating."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "8b361b7f-ca8d-445a-b081-6c0c285cc651",
        "type": "message",
        "text": "I think someone should do this as a real study",
        "user": "U01A0KANUUU",
        "ts": "1599851576.279100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kMl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think someone should do this as a real study"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "74d37817-50c7-4379-81eb-577d7028c555",
        "type": "message",
        "text": "And collect background information about the programmers in question",
        "user": "U01A0KANUUU",
        "ts": "1599851593.279300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S8j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And collect background information about the programmers in question"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "e240813e-847f-4b84-ab07-b524290d5ebc",
        "type": "message",
        "text": "Also if anyone wants to share there definitions or examples of malleable environments (i.e., environments that are so efficient that they remove the advantages of automation) I'd love to hear about that",
        "user": "UE0ETTCG7",
        "ts": "1599851979.279500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5xxn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also if anyone wants to share there definitions or examples of malleable environments (i.e., environments that are so efficient that they remove the advantages of automation) I'd love to hear about that"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "690e2b41-8bf6-4319-a364-3184687acbfc",
        "type": "message",
        "text": "The most obvious thing that comes to mind is text editor keyboard macros",
        "user": "UT60XSVCN",
        "ts": "1599853760.279800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "COBNF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The most obvious thing that comes to mind is text editor keyboard macros"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "bc221948-228e-4757-b947-99aae3b8e8c0",
        "type": "message",
        "text": "You can record one, use it over and over, and save it if you want.\nImportantly, you are personally in control at every step, and it is a very lightweight abstraction.",
        "user": "UT60XSVCN",
        "ts": "1599853868.280000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qRL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can record one, use it over and over, and save it if you want.\nImportantly, you are personally in control at every step, and it is a very lightweight abstraction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "4896196a-e671-4ea8-be56-df64611d7cbe",
        "type": "message",
        "text": "<http://akkartik.name/post/readable-bad|http://akkartik.name/post/readable-bad>",
        "user": "UCUSW7WVD",
        "ts": "1599853893.280200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FO/X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/readable-bad",
                                "text": "http://akkartik.name/post/readable-bad"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599848967.277900",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "UJ6LDMMN0",
                    "UBSMEUXAA"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "6f169b08-f061-4095-8b72-6a43b86a0e1a",
        "type": "message",
        "text": "Ditto for doing things in Emacs lisp. Once you have the lisp made for it, turning it into a command is easy",
        "user": "U01A0KANUUU",
        "ts": "1599853991.280400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pziv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ditto for doing things in Emacs lisp. Once you have the lisp made for it, turning it into a command is easy"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "3ec52ad9-f0eb-49a5-95f8-e71802249538",
        "type": "message",
        "text": "Yeah, that's the first thing I thought of too. Keyboard macros seem pretty clearly automation to me? (And correspondingly, would be a feature most programmers don't use). It sounds like there's a concept of a malleable system that's not based in automation here, I'd love to understand what that is. (And I'd love to hear any more examples of both.)",
        "user": "UE0ETTCG7",
        "ts": "1599854055.280600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sZ7Y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, that's the first thing I thought of too. Keyboard macros seem pretty clearly automation to me? (And correspondingly, would be a feature most programmers don't use). It sounds like there's a concept of a malleable system that's not based in automation here, I'd love to understand what that is. (And I'd love to hear any more examples of both.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "7e096271-b73a-48c3-99bf-b74d5fed00ba",
        "type": "message",
        "text": "While I object to needing your IDE to have thought of the things you want, JetBrains does a pretty good job of thinking of the things that my coworkers and I want, and I think we do leverage it to an extent that it is \u201cautomation\u201d. Multi-cursor, regexp-replace and structural-replace are some examples that come to mind.",
        "user": "UKDM3GLAJ",
        "ts": "1599855730.280900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mxd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While I object to needing your IDE to have thought of the things you want, JetBrains does a pretty good job of thinking of the things that my coworkers and I want, and I think we do leverage it to an extent that it is \u201cautomation\u201d. Multi-cursor, regexp-replace and structural-replace are some examples that come to mind."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599588394.135900",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "bbe54928-7ee8-4e0b-8127-6f6533d71db1",
        "type": "message",
        "text": "Oh, it's a local vs global argument? Interesting. The point being that locally readable code is not the bottle neck, but globally \"readable\" (comprehensible?) code is.",
        "user": "U019CPED6T1",
        "ts": "1599859940.281400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CWrs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, it's a local vs global argument? Interesting. The point being that locally readable code is not the bottle neck, but globally \"readable\" (comprehensible?) code is."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1599848967.277900",
        "parent_user_id": "U8A5MS6R1"
    }
]