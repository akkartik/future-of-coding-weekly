[
    {
        "client_msg_id": "e8685bd5-68c5-4eb5-a803-dde04ef6ba05",
        "type": "message",
        "text": "*A funny story*\n\nA few weeks ago I built a function to read keystrokes from the keyboard. (In machine code, of course.) I figured I'd support just ASCII keys for starters, and gradually add the rest.\n\nToday I tried to force myself to work on \"the rest\". Terminal escape sequences like arrow keys, utf-8, and somehow distinguishing between the two.\n\nSurprise: both were already working! I just had to read 32 bits rather than 8 from stdin. Legal utf-8 doesn't conflict with terminal escapes in 32-bit space, and modern OSs do the right thing.\n\n<https://github.com/akkartik/mu/commit/e403d15732>",
        "user": "UCUSW7WVD",
        "ts": "1600312443.026300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "6794 - cleaner interface for keyboard \u00b7 akkartik/mu@e403d15",
                "title_link": "https://github.com/akkartik/mu/commit/e403d15732",
                "text": "So far I&amp;#39;ve been assuming that read-key only works for ascii, and that I&amp;#39;d need to get more sophisticated both for multi-byte utf-8 and multi-byte terminal escape codes like arrow keys. Rat...",
                "fallback": "GitHub: 6794 - cleaner interface for keyboard \u00b7 akkartik/mu@e403d15",
                "from_url": "https://github.com/akkartik/mu/commit/e403d15732",
                "thumb_url": "https://avatars3.githubusercontent.com/u/3161?s=400&v=4",
                "thumb_width": 250,
                "thumb_height": 250,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/akkartik/mu/commit/e403d15732"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0EbY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A funny story",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nA few weeks ago I built a function to read keystrokes from the keyboard. (In machine code, of course.) I figured I'd support just ASCII keys for starters, and gradually add the rest.\n\nToday I tried to force myself to work on \"the rest\". Terminal escape sequences like arrow keys, utf-8, and somehow distinguishing between the two.\n\nSurprise: both were already working! I just had to read 32 bits rather than 8 from stdin. Legal utf-8 doesn't conflict with terminal escapes in 32-bit space, and modern OSs do the right thing.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/akkartik/mu/commit/e403d15732"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600312443.026300",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1600396350.000200",
        "reply_users": [
            "USL4R0T61",
            "UA14TGLTC"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "amiga-tick",
                "users": [
                    "USL4R0T61",
                    "U8A5MS6R1",
                    "U01661S9F34",
                    "UHWC9PXBL",
                    "UC2A2ARPT",
                    "U013ZLJARC7",
                    "UA14TGLTC"
                ],
                "count": 7
            }
        ]
    },
    {
        "client_msg_id": "1db68613-8143-487a-a26f-41a31813e005",
        "type": "message",
        "text": "Love a good serendipity!",
        "user": "USL4R0T61",
        "ts": "1600313364.026600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/Kc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Love a good serendipity!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600312443.026300",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "38c4ce13-a76a-4863-a804-1bbbbec20842",
        "type": "message",
        "text": "Question about programming languages with _static type systems_ and _support for generics_: in the language communities I spend most time in, the usual advice is to write specific algorithms first, and then generalize them when it makes sense. That's probably good advice.\n\nStill, I'm trying something different and wonder: are there language communities that approach this the opposite way, ie. write algorithms as generic as possible and specialize only when needed, and only as far as needed? For instance, if you absolutely need a type to represent a sequence of elements, you only specify that the type conforms to some Iterable protocol, but leave it generic otherwise?\nI'd think Haskell is probably a good place to look for that\u2026? And what about proof-oriented languages?\n\nWhich affordances do these languages offer to specifically support such a programming style?\nAnd is this programming technique a thing that has a name?",
        "user": "U5STGTB3J",
        "ts": "1600360697.037500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JOne",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Question about programming languages with "
                            },
                            {
                                "type": "text",
                                "text": "static type systems",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "support for generics",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ": in the language communities I spend most time in, the usual advice is to write specific algorithms first, and then generalize them when it makes sense. That's probably good advice.\n\nStill, I'm trying something different and wonder: are there language communities that approach this the opposite way, ie. write algorithms as generic as possible and specialize only when needed, and only as far as needed? For instance, if you absolutely need a type to represent a sequence of elements, you only specify that the type conforms to some Iterable protocol, but leave it generic otherwise?\nI'd think Haskell is probably a good place to look for that\u2026? And what about proof-oriented languages?\n\nWhich affordances do these languages offer to specifically support such a programming style?\nAnd is this programming technique a thing that has a name?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "reply_count": 9,
        "reply_users_count": 6,
        "latest_reply": "1600495725.009300",
        "reply_users": [
            "UK3LH8CF5",
            "UFB8STN7K",
            "U01AN8DFFBN",
            "U5STGTB3J",
            "UA14TGLTC",
            "UJBAJNFLK"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UA14TGLTC",
                    "UHWC9PXBL",
                    "UJBAJNFLK"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "0cfc4f26-31ab-4862-b663-dae7ddccd831",
        "type": "message",
        "text": "I definitely think you will find that this is pretty common in haskell. Starting with the generic let's you write reusable code, but also can help constrain what implementations are valid and not. I know of one article that argues specifically for this practice.\n\n<https://degoes.net/articles/insufficiently-polymorphic>\n\n(John De Goes is a very controversial figure and this is not meant as an endorsement of his views. In fact, I don't know his views just that he is controversial.)",
        "user": "UK3LH8CF5",
        "ts": "1600361336.037600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "John A De Goes",
                "title": "Descriptive Variable Names: A Code Smell",
                "title_link": "https://degoes.net/articles/insufficiently-polymorphic",
                "text": "Polymorphic code is more likely to be correct than monomorphic code",
                "fallback": "John A De Goes: Descriptive Variable Names: A Code Smell",
                "from_url": "https://degoes.net/articles/insufficiently-polymorphic",
                "service_icon": "https://degoes.net/images/apple-touch-icon-precomposed.png",
                "id": 1,
                "original_url": "https://degoes.net/articles/insufficiently-polymorphic"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L3WW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I definitely think you will find that this is pretty common in haskell. Starting with the generic let's you write reusable code, but also can help constrain what implementations are valid and not. I know of one article that argues specifically for this practice.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://degoes.net/articles/insufficiently-polymorphic"
                            },
                            {
                                "type": "text",
                                "text": "\n\n(John De Goes is a very controversial figure and this is not meant as an endorsement of his views. In fact, I don't know his views just that he is controversial.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "0ee83a4c-e734-44dd-96b7-89b7906c8538",
        "type": "message",
        "text": "In languages that support polymorphic type inference, this isn\u2019t actually a trade-off you need to make. You can write code without types, and the compiler will infer the most general type possible. For example, in OCaml, if I do:\n\n```let rec map f l = match l with \n  [] -&gt; [] | x :: xs -&gt; f x :: map f xs```\nThen the compiler gets the right generic type for `f` and `l` , including the constraint that the elements of `l` have to be the same type as the input to `f`.\n\nYou probably knew that already, but it\u2019s worth reframing in terms of your question. You should write the algorithm exactly as needed ignoring types, and then decide what capabilities you need from your types.",
        "user": "UFB8STN7K",
        "ts": "1600362088.037900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFB8STN7K",
            "ts": "1600362193.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gkJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In languages that support polymorphic type inference, this isn\u2019t actually a trade-off you need to make. You can write code without types, and the compiler will infer the most general type possible. For example, in OCaml, if I do:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "let rec map f l = match l with \n  [] -> [] | x :: xs -> f x :: map f xs"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThen the compiler gets the right generic type for "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "l",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " , including the constraint that the elements of "
                            },
                            {
                                "type": "text",
                                "text": "l",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have to be the same type as the input to "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nYou probably knew that already, but it\u2019s worth reframing in terms of your question. You should write the algorithm exactly as needed ignoring types, and then decide what capabilities you need from your types."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7",
                    "UPX3PH28N",
                    "U8A5MS6R1"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "03c91684-d42d-4634-b7c2-fc6541b69a41",
        "type": "message",
        "text": "I thought for a long time that abstractions and generalizations just complicate stuff. Particularly, I found natural numbers very easy to understand and groups/fields etc. very hard to grasp.\nNow I think it is completely the opposite. Natural numbers are incredibly hard. Abstractions are meant for simplification - they remove the noise from the actual problem.\n\nI think similarly about programming and interfaces or generic types.",
        "user": "U01AN8DFFBN",
        "ts": "1600363785.038300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dzlF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I thought for a long time that abstractions and generalizations just complicate stuff. Particularly, I found natural numbers very easy to understand and groups/fields etc. very hard to grasp.\nNow I think it is completely the opposite. Natural numbers are incredibly hard. Abstractions are meant for simplification - they remove the noise from the actual problem.\n\nI think similarly about programming and interfaces or generic types."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "f96544fb-409a-4dbe-be72-e874f44a0f55",
        "type": "message",
        "text": "Does anyone know of prior art on hot-reloading of data structures in programming languages? Similar to this: <https://mun-lang.org/blog/2020/05/01/memory-mapping/>",
        "user": "UPMFG2571",
        "ts": "1600365145.039700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Hot Reloadable structs: Memory Mapping",
                "title_link": "https://mun-lang.org/blog/2020/05/01/memory-mapping/",
                "text": "The Mun v0.2 release is on the horizon, so we wanted to take this opportunity to delve a little deeper into this release's big newcomer: hot reloadable structs. Being able to effortlessly hot reload data was what we originally set out to do when designing Mun, so we are excited to share how we brought this feat about.",
                "fallback": "Hot Reloadable structs: Memory Mapping",
                "from_url": "https://mun-lang.org/blog/2020/05/01/memory-mapping/",
                "service_name": "mun-lang.org",
                "id": 1,
                "original_url": "https://mun-lang.org/blog/2020/05/01/memory-mapping/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nFJZ7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does anyone know of prior art on hot-reloading of data structures in programming languages? Similar to this: "
                            },
                            {
                                "type": "link",
                                "url": "https://mun-lang.org/blog/2020/05/01/memory-mapping/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "reply_count": 10,
        "reply_users_count": 6,
        "latest_reply": "1600584385.018100",
        "reply_users": [
            "UBN9AFS0N",
            "UN9SCH5RD",
            "U01AN8DFFBN",
            "UPMFG2571",
            "UJBAJNFLK",
            "UA14TGLTC"
        ],
        "subscribed": true,
        "last_read": "1600584385.018100"
    },
    {
        "client_msg_id": "59f832dc-5e71-4da4-8b37-7282287454ca",
        "type": "message",
        "text": "automatic? or can it be enabled by the runtime but manual? the Erlang virtual machine supports data structure migration on hot-reloading of a new release",
        "user": "UBN9AFS0N",
        "ts": "1600366465.039900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3eCx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "automatic? or can it be enabled by the runtime but manual? the Erlang virtual machine supports data structure migration on hot-reloading of a new release"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    },
    {
        "client_msg_id": "0b733ac4-c370-491e-9a46-dc9363bb9697",
        "type": "message",
        "text": "<@UK3LH8CF5> Thanks for sharing that article. That is in fact pretty much exactly what I was thinking about.\n\n<@UFB8STN7K> Polymorphic type inference is absolutely one of these affordances I had in mind. It seems all the languages in the ML family seem to be pretty good at that.\n\n<@U01AN8DFFBN> Completely agree. Abstractions remove detail; and that's exactly why everything gets a lot simpler if you use them right. If you have a thing and you only know that it has elements you can iterate over, you can implement a lot of algorithms on top of that, but you can't accidentally assume another property of that thing, because the compiler won't let you. In most imperative and/or dynamically typed languages it's easy to make such assumptions and as long as it works, you'll never know you did. Which might not be a problem, but I do think a lot of the complexity in refactoring comes from such assumptions that were only possible, because a much more specific (and therefore more powerful) type was used.",
        "user": "U5STGTB3J",
        "ts": "1600371058.040100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3fs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": " Thanks for sharing that article. That is in fact pretty much exactly what I was thinking about.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " Polymorphic type inference is absolutely one of these affordances I had in mind. It seems all the languages in the ML family seem to be pretty good at that.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U01AN8DFFBN"
                            },
                            {
                                "type": "text",
                                "text": " Completely agree. Abstractions remove detail; and that's exactly why everything gets a lot simpler if you use them right. If you have a thing and you only know that it has elements you can iterate over, you can implement a lot of algorithms on top of that, but you can't accidentally assume another property of that thing, because the compiler won't let you. In most imperative and/or dynamically typed languages it's easy to make such assumptions and as long as it works, you'll never know you did. Which might not be a problem, but I do think a lot of the complexity in refactoring comes from such assumptions that were only possible, because a much more specific (and therefore more powerful) type was used."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600360697.037500",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "36db6f7c-1ba3-413c-a270-083dc79e8f47",
        "type": "message",
        "text": "so that mun lang blog post, seems like the hot reloading requires a clever algorithm depending on whether the name of the fields of the struct are the same as before, etc. I wonder if a more intentional approach could work, like a refactoring tool that tells both the editor and the running program a certain field was migrated from one thing to the next.",
        "user": "UN9SCH5RD",
        "ts": "1600374148.040400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sLV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "so that mun lang blog post, seems like the hot reloading requires a clever algorithm depending on whether the name of the fields of the struct are the same as before, etc. I wonder if a more intentional approach could work, like a refactoring tool that tells both the editor and the running program a certain field was migrated from one thing to the next."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    },
    {
        "client_msg_id": "846c6510-f36e-47c2-837a-8a611ebbf7bf",
        "type": "message",
        "text": "I've been exploring hot reload in nodejs for a while now. I figured that most algorithms run in a couple of milliseconds, so rather than doing some unstable automatic migrations, restarting the last pure function + manual data migration works reasonable well.\n(<https://github.com/hediet/node-reload|https://github.com/hediet/node-reload>)",
        "user": "U01AN8DFFBN",
        "ts": "1600374788.040600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "hediet/node-reload",
                "title_link": "https://github.com/hediet/node-reload",
                "text": "An advanced hot reload solution for Node apps. Works very well for developing VSCode extensions and automating websites with puppeteer. - hediet/node-reload",
                "fallback": "GitHub: hediet/node-reload",
                "thumb_url": "https://avatars3.githubusercontent.com/u/2931520?s=400&v=4",
                "from_url": "https://github.com/hediet/node-reload",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/hediet/node-reload"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oT/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been exploring hot reload in nodejs for a while now. I figured that most algorithms run in a couple of milliseconds, so rather than doing some unstable automatic migrations, restarting the last pure function + manual data migration works reasonable well.\n("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/hediet/node-reload",
                                "text": "https://github.com/hediet/node-reload"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    },
    {
        "client_msg_id": "5526fefc-a705-4030-925d-8fcd9b72e14e",
        "type": "message",
        "text": "<@UBN9AFS0N> Automatic. Developer makes changes to a data structure at runtime (struct, class, etc), those changes are picked up and propagated, and the program continues to run normally.",
        "user": "UPMFG2571",
        "ts": "1600375547.041100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QLels",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBN9AFS0N"
                            },
                            {
                                "type": "text",
                                "text": " Automatic. Developer makes changes to a data structure at runtime (struct, class, etc), those changes are picked up and propagated, and the program continues to run normally."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600365145.039700",
        "parent_user_id": "UPMFG2571"
    }
]