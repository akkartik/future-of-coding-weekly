[
    {
        "client_msg_id": "819b9dae-8d71-453f-b73e-9a555bc41e50",
        "type": "message",
        "text": "I actually don't think the API matters, just which language it's written in. E.g., what's \"right\" about VS Code is simply that extensions are written in HTML, CSS, and JavaScript, the \"proof\" of that is simply all the extensions that have been written for it, especially relative to previous approaches. (And the point is doubly illustrated by Atom's initial explosion of extensions, with a completely different API.)\n\nI'd be happy to hear some evidence that the design of the API itself is important. I can think of examples that illustrate it's not important (VimScript as an example of successful poorly designed API, NeXTSTEP/AppKit as a well-designed API not being as successful as it should have been) but I can't think of any that illustrate that it is important. Generally my opinion is that what matters is platform momentum, and developers will support the platform regardless of the design of the API, as long as it can do what they need it to. (There's a bit of a contradiction here, in that the language choice could be considered part of the API, I have to think more about that, but I think the answer has something to do with the \"special\" nature of HTML/CSS/JS as the browser languages.)\n\nOne random side note: I do actually think VS Code has a weakness right now, and that's that it can't run in integrated browser. Historically that's been a tough feature to capitalize on though.",
        "user": "UE0ETTCG7",
        "ts": "1600900974.006300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LYZbN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I actually don't think the API matters, just which language it's written in. E.g., what's \"right\" about VS Code is simply that extensions are written in HTML, CSS, and JavaScript, the \"proof\" of that is simply all the extensions that have been written for it, especially relative to previous approaches. (And the point is doubly illustrated by Atom's initial explosion of extensions, with a completely different API.)\n\nI'd be happy to hear some evidence that the design of the API itself is important. I can think of examples that illustrate it's not important (VimScript as an example of successful poorly designed API, NeXTSTEP/AppKit as a well-designed API not being as successful as it should have been) but I can't think of any that illustrate that it is important. Generally my opinion is that what matters is platform momentum, and developers will support the platform regardless of the design of the API, as long as it can do what they need it to. (There's a bit of a contradiction here, in that the language choice could be considered part of the API, I have to think more about that, but I think the answer has something to do with the \"special\" nature of HTML/CSS/JS as the browser languages.)\n\nOne random side note: I do actually think VS Code has a weakness right now, and that's that it can't run in integrated browser. Historically that's been a tough feature to capitalize on though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "FCA6D6E8-EE65-4D58-AC21-14868D909126",
        "type": "message",
        "text": "One thing to clarify is that I think frameworks need a good API, e.g., Ruby on Rails needs a nice developer experiment, but platforms don\u2019t, like Twitter doesn\u2019t need a great API, or Windows, developers come to it for other reasons.",
        "user": "UE0ETTCG7",
        "ts": "1600901247.008900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aexR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing to clarify is that I think frameworks need a good API, e.g., Ruby on Rails needs a nice developer experiment, but platforms don\u2019t, like Twitter doesn\u2019t need a great API, or Windows, developers come to it for other reasons."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "E922C465-7252-460E-8B67-A44C912CE5A3",
        "type": "message",
        "text": "Come to think of it, I actually think VS Code is more evidence API doesn't matter. I honestly couldn't even say whether VS Code's API is well designed because I don't even know what it's design is. Atom has a beautiful API, communicated effectively through documentation (I appreciated their design and philosophy around lazy loading for example). I've now spent more time with VS Code than I ever had with Atom, but since documentation doesn't really communicate it, I don't feel like I even understand what philosophy or organizational principles of their extension system are. If I were to characterize VS Code's design approach it would be: Scale solves all problems (a play on \"given enough eyeballs, all bugs are shallow\"). E.g., just ship something and let people bicker it out in GitHub issues and eventually we'll arrive at a working design. And so far there been right! And I actually think the approach is brilliant, because it's future proof. Bad decisions now, get corrected over time, because correcting bad decisions literally is their process.",
        "user": "UE0ETTCG7",
        "ts": "1600902788.009900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BXlK4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Come to think of it, I actually think VS Code is more evidence API doesn't matter. I honestly couldn't even say whether VS Code's API is well designed because I don't even know what it's design is. Atom has a beautiful API, communicated effectively through documentation (I appreciated their design and philosophy around lazy loading for example). I've now spent more time with VS Code than I ever had with Atom, but since documentation doesn't really communicate it, I don't feel like I even understand what philosophy or organizational principles of their extension system are. If I were to characterize VS Code's design approach it would be: Scale solves all problems (a play on \"given enough eyeballs, all bugs are shallow\"). E.g., just ship something and let people bicker it out in GitHub issues and eventually we'll arrive at a working design. And so far there been right! And I actually think the approach is brilliant, because it's future proof. Bad decisions now, get corrected over time, because correcting bad decisions literally is their process."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "8e125125-ca6e-47c0-a48f-f0a5301e57fa",
        "type": "message",
        "text": "your article doesn't seem to address <https://microsoft.github.io/language-server-protocol/> or <https://microsoft.github.io/debug-adapter-protocol/> I suspect part of the reason the popularity of VS Code exploded is because both projects allow providing excellent IDE support at relatively low cost to language authors (at least when compared to the cost of creating a custom IDE or writing plugins for say, idea or visual studio)",
        "user": "UN9SCH5RD",
        "ts": "1600911456.010100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Official page for Language Server Protocol",
                "title_link": "https://microsoft.github.io/language-server-protocol/",
                "text": "Language Server Protocol documentation and specification page.",
                "fallback": "Official page for Language Server Protocol",
                "from_url": "https://microsoft.github.io/language-server-protocol/",
                "service_icon": "https://microsoft.github.io/language-server-protocol/img/favicon.png",
                "service_name": "microsoft.github.io",
                "id": 1,
                "original_url": "https://microsoft.github.io/language-server-protocol/"
            },
            {
                "title": "Official page for Debug Adapter Protocol",
                "title_link": "https://microsoft.github.io/debug-adapter-protocol/",
                "text": "Debug Adapter Protocol documentation and specification page.",
                "fallback": "Official page for Debug Adapter Protocol",
                "from_url": "https://microsoft.github.io/debug-adapter-protocol/",
                "service_name": "microsoft.github.io",
                "id": 2,
                "original_url": "https://microsoft.github.io/debug-adapter-protocol/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oTJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "your article doesn't seem to address "
                            },
                            {
                                "type": "link",
                                "url": "https://microsoft.github.io/language-server-protocol/"
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "link",
                                "url": "https://microsoft.github.io/debug-adapter-protocol/"
                            },
                            {
                                "type": "text",
                                "text": " I suspect part of the reason the popularity of VS Code exploded is because both projects allow providing excellent IDE support at relatively low cost to language authors (at least when compared to the cost of creating a custom IDE or writing plugins for say, idea or visual studio)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "83e70e90-fb30-49b8-80b7-c26674a489c5",
        "type": "message",
        "text": "Ah, I think I misinterpreted the \"There just isn't anywhere else to go\" paragraph as being about the API design. What exactly did you mean by that?",
        "user": "U016VUZGUUQ",
        "ts": "1600914748.010400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zSn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah, I think I misinterpreted the \"There just isn't anywhere else to go\" paragraph as being about the API design. What exactly did you mean by that?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "05df0a25-5b7a-4a97-93ea-4194d5c13268",
        "type": "message",
        "text": "This is a very interesting approach to conversational AI via growing dataflow programs that (among other things) claims that \"Task-oriented dialogue is interactive programming\":\n<https://www.microsoft.com/en-us/research/blog/dialogue-as-dataflow-a-new-approach-to-conversational-ai/>",
        "user": "U013ZLJARC7",
        "ts": "1600933934.001000",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Microsoft Research",
                "title": "Enlisting dataflow graphs to improve conversational AI",
                "title_link": "https://www.microsoft.com/en-us/research/blog/dialogue-as-dataflow-a-new-approach-to-conversational-ai/",
                "text": "Researchers at Microsoft Semantic Machines are taking a new approach to conversational AI\u2014modeling dialogues with compositional dataflow graphs. Learn how the framework supports flexible, open-ended conversations, and explore the dataset and leaderboard.",
                "fallback": "Microsoft Research: Enlisting dataflow graphs to improve conversational AI",
                "thumb_url": "https://www.microsoft.com/en-us/research/uploads/prod/2020/09/FeaturedImageSite_SMBlog.png",
                "ts": 1600716806,
                "from_url": "https://www.microsoft.com/en-us/research/blog/dialogue-as-dataflow-a-new-approach-to-conversational-ai/",
                "thumb_width": 1479,
                "thumb_height": 833,
                "service_icon": "https://www.microsoft.com/favicon.ico",
                "id": 1,
                "original_url": "https://www.microsoft.com/en-us/research/blog/dialogue-as-dataflow-a-new-approach-to-conversational-ai/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y1O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a very interesting approach to conversational AI via growing dataflow programs that (among other things) claims that \"Task-oriented dialogue is interactive programming\":\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.microsoft.com/en-us/research/blog/dialogue-as-dataflow-a-new-approach-to-conversational-ai/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600933934.001000",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1601018177.004600",
        "reply_users": [
            "UDQBTJ211",
            "U013ZLJARC7",
            "UA14TGLTC"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UDQBTJ211",
                    "ULK0Z4MPV",
                    "U013866H7LY",
                    "UA14TGLTC"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "7953b637-c1ab-440f-be8e-0fb860431c05",
        "type": "message",
        "text": "Great to see them putting an emphasis on trying to gracefully correct inevitable mistakes. Very practical and hype-free blog.\n\nI'm interested in how much builtin knowledge they are going to go for (\"...including pieces like *here* and *now* that are implicitly available from the beginning of the conversation...\"). Natural language is absolutely laced with assumed knowledge. Will it be able to understand \"my wife\", \"my sister\", \"my house\" etc. What about the gradient of niche or local knowledge - \"Boxing Day\" etc?\n\nThe problem with starting down this road is it is essentially arbitrary where you stop, and the user won't know where that is.\n\nI suppose it won't matter if the error correction is strong enough (\"When you say \"sister\" do you mean <mailto:Jane.Doe@outlook.com|Jane.Doe@outlook.com>?\")",
        "user": "UDQBTJ211",
        "ts": "1600942972.001400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZgM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great to see them putting an emphasis on trying to gracefully correct inevitable mistakes. Very practical and hype-free blog.\n\nI'm interested in how much builtin knowledge they are going to go for (\"...including pieces like "
                            },
                            {
                                "type": "text",
                                "text": "here",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "now",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that are implicitly available from the beginning of the conversation...\"). Natural language is absolutely laced with assumed knowledge. Will it be able to understand \"my wife\", \"my sister\", \"my house\" etc. What about the gradient of niche or local knowledge - \"Boxing Day\" etc?\n\nThe problem with starting down this road is it is essentially arbitrary where you stop, and the user won't know where that is.\n\nI suppose it won't matter if the error correction is strong enough (\"When you say \"sister\" do you mean "
                            },
                            {
                                "type": "link",
                                "url": "mailto:Jane.Doe@outlook.com",
                                "text": "Jane.Doe@outlook.com"
                            },
                            {
                                "type": "text",
                                "text": "?\")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600933934.001000",
        "parent_user_id": "U013ZLJARC7"
    },
    {
        "client_msg_id": "b0894a0f-5401-45de-b48c-941b3da5e9f6",
        "type": "message",
        "text": "<@UDQBTJ211> What you're pointing to here is one of the fundamental problems of natural language understanding: to really understand language one must understand the world in which the speaker lives, including the agents who live there and their motivations.\n\nOne thing I find interesting about this paper in particular for FoC is that what they're doing in the personal assistant context could repurpose well to the narrower context of descriptive programming.",
        "user": "U013ZLJARC7",
        "ts": "1600952742.001600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DGk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": " What you're pointing to here is one of the fundamental problems of natural language understanding: to really understand language one must understand the world in which the speaker lives, including the agents who live there and their motivations.\n\nOne thing I find interesting about this paper in particular for FoC is that what they're doing in the personal assistant context could repurpose well to the narrower context of descriptive programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600933934.001000",
        "parent_user_id": "U013ZLJARC7"
    },
    {
        "client_msg_id": "e058daf8-e821-478e-80f2-a7202e67646a",
        "type": "message",
        "text": "<@U016VUZGUUQ> Regarding \"There just isn't anywhere else to go\":\n\n*Installing extensions* went from manual (TextMate/Emacs/Vim) -&gt; to third-party, centralized, but CLI style UI (Sublime Text's Package Control) -&gt; to integrated \"App Store\"-style extension installing experiences (Atom/VS Code)\n\n*Extension capabilities* went from almost no ways to customize UI (TextMate, and VIM/Emacs for anything non-textual) to customizing the UI through a custom API (Sublime Text) to customizing the UI in a standardized way with HTML/CSS/JS (Atom/VS Code).\n\nThose are the progressions I don't see anywhere else they can go, i.e., installing extensions can't get any easier, and customizing UI can't get any easier.\n\nI think you're primarily asking about other parts of the API? But I'm not sure these APIs have had major limitations in other ways besides in customizing UI and installing extensions. The most notable example I can think of is async process management being added to Vim/NeoVim. For the most part there just aren't other limitations, unless I'm missing them?",
        "user": "UE0ETTCG7",
        "ts": "1600965052.001900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FTKr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " Regarding \"There just isn't anywhere else to go\":\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Installing extensions",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " went from manual (TextMate/Emacs/Vim) -> to third-party, centralized, but CLI style UI (Sublime Text's Package Control) -> to integrated \"App Store\"-style extension installing experiences (Atom/VS Code)\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Extension capabilities",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " went from almost no ways to customize UI (TextMate, and VIM/Emacs for anything non-textual) to customizing the UI through a custom API (Sublime Text) to customizing the UI in a standardized way with HTML/CSS/JS (Atom/VS Code).\n\nThose are the progressions I don't see anywhere else they can go, i.e., installing extensions can't get any easier, and customizing UI can't get any easier.\n\nI think you're primarily asking about other parts of the API? But I'm not sure these APIs have had major limitations in other ways besides in customizing UI and installing extensions. The most notable example I can think of is async process management being added to Vim/NeoVim. For the most part there just aren't other limitations, unless I'm missing them?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U016VUZGUUQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "28ae8239-1ae7-4453-8ecf-a2f5692c8814",
        "type": "message",
        "text": "<@UN9SCH5RD> Debugging and LSP are tough to address... to answer I think I have to zoom out. The way I wrote the piece was to draw on my observations watching conversations around people switching from TextMate to Sublime Text to Atom to VS Code, and reading people describing in their own words why they switching. And the overwhelming answer for Atom to VS Code isn't LSP or debugging, but it's because Atom was slow. (Note I'm leaving out the role extensions here because Atom and VS Code both have first-class extension support, whereas LSP is definitely a VS Code vs. Atom distinction.)\n\nThis isn't to say a lot of people don't also list debugging and LSP, but it was (and still is) dwarfed by performance discussions, and my goal was to have the article based as much as possible on what people are saying, not what I personally think is important.",
        "user": "UE0ETTCG7",
        "ts": "1600965892.002100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8k15R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UN9SCH5RD"
                            },
                            {
                                "type": "text",
                                "text": " Debugging and LSP are tough to address... to answer I think I have to zoom out. The way I wrote the piece was to draw on my observations watching conversations around people switching from TextMate to Sublime Text to Atom to VS Code, and reading people describing in their own words why they switching. And the overwhelming answer for Atom to VS Code isn't LSP or debugging, but it's because Atom was slow. (Note I'm leaving out the role extensions here because Atom and VS Code both have first-class extension support, whereas LSP is definitely a VS Code vs. Atom distinction.)\n\nThis isn't to say a lot of people don't also list debugging and LSP, but it was (and still is) dwarfed by performance discussions, and my goal was to have the article based as much as possible on what people are saying, not what I personally think is important."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UN9SCH5RD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d91ea1e7-6011-4ea6-86ad-d97f1f7613c9",
        "type": "message",
        "text": "Another point about LSP: Oddly enough, I think LSP benefits everyone except the incumbent more, because the incumbent can just get great support for these features through sheer inertia, whereas more resource-strapped outfits benefit more from the standardization by being able to work more efficiently.",
        "user": "UE0ETTCG7",
        "ts": "1600965971.002300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zI6nG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another point about LSP: Oddly enough, I think LSP benefits everyone except the incumbent more, because the incumbent can just get great support for these features through sheer inertia, whereas more resource-strapped outfits benefit more from the standardization by being able to work more efficiently."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "48a85fe2-06df-478e-9aff-d4c8de0ba232",
        "type": "message",
        "text": "And a quick bit on debugging: Personally the debugging integration is my all-time favorite feature of VS Code. But I can't imagine very many people are using it, outside of experts. As far as I can tell, you have to make an `launch.json` file just to debug a default Node app? That's madness.\n\nThat's a great example of an early-stage VS Code feature, where a completely nutty implementation is just dropped on users. But over time I'm sure setting up debugging will be amazing, because of the pace of development. That's the VS Code way.",
        "user": "UE0ETTCG7",
        "ts": "1600966188.002500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vgLo2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And a quick bit on debugging: Personally the debugging integration is my all-time favorite feature of VS Code. But I can't imagine very many people are using it, outside of experts. As far as I can tell, you have to make an "
                            },
                            {
                                "type": "text",
                                "text": "launch.json",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " file just to debug a default Node app? That's madness.\n\nThat's a great example of an early-stage VS Code feature, where a completely nutty implementation is just dropped on users. But over time I'm sure setting up debugging will be amazing, because of the pace of development. That's the VS Code way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "ca7341be-0012-4294-b809-df623b936948",
        "type": "message",
        "text": "(As a side note I had a section that got cut that had more personal opinions on VS Code's features, especially LSP/Debugging. But I decided to cut it and make it into a separate post because it was more based on what I personally think is important rather than what my pulse on the community at large thinks is important.)",
        "user": "UE0ETTCG7",
        "ts": "1600966490.002700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t6yvO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(As a side note I had a section that got cut that had more personal opinions on VS Code's features, especially LSP/Debugging. But I decided to cut it and make it into a separate post because it was more based on what I personally think is important rather than what my pulse on the community at large thinks is important.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600866849.001600",
        "parent_user_id": "UE0ETTCG7"
    }
]