[
    {
        "client_msg_id": "13d99e62-8ec2-4afa-bcac-00c9a1a9d8b4",
        "type": "message",
        "text": "A big issue in programming is that a program is an extremely lossy record of history. Even with good comments, it\u2019s hard to look at a program and know:\n\u2022 What are the alternatives that were considered, but ignored? Tried, but later discarded?\n\u2022 What order was this program written in? Is a particular line or function the focal point of this code?\n\u2022 What is the set of resources the author used to write this code? \n\u2022 How weathered is this code? How many bugs have happened in this code? How scared should I be to change it?\nWhat are some ways in which programming environments could help us record this info / answer these questions without requiring additional effort from the author?",
        "user": "UFB8STN7K",
        "ts": "1600909562.010100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Olj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A big issue in programming is that a program is an extremely lossy record of history. Even with good comments, it\u2019s hard to look at a program and know:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "What are the alternatives that were considered, but ignored? Tried, but later discarded?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "What order was this program written in? Is a particular line or function the focal point of this code?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "What is the set of resources the author used to write this code? "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How weathered is this code? How many bugs have happened in this code? How scared should I be to change it?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nWhat are some ways in which programming environments could help us record this info / answer these questions without requiring additional effort from the author?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "reply_count": 21,
        "reply_users_count": 9,
        "latest_reply": "1601154482.036400",
        "reply_users": [
            "UCUSW7WVD",
            "UUQ2EQW21",
            "UJ6LDMMN0",
            "UKDM3GLAJ",
            "U016LEA3J1H",
            "UK3LH8CF5",
            "U01A1C2K8MP",
            "UFB8STN7K",
            "U85HCL7JP"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UJ6LDMMN0",
                    "UKP3B2J5D"
                ],
                "count": 2
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UK3LH8CF5"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3b7a2995-7ef5-4df1-b707-1398e2b34c6a",
        "type": "message",
        "text": "You might find this older thread useful: <https://futureofcoding.slack.com/archives/C5T9GPWFL/p1595618648446000>",
        "user": "UCUSW7WVD",
        "ts": "1600910178.010200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1595618648446000",
                "fallback": "[July 24th, 2020 12:24 PM] daniel.garcia.carmona: I think that many companies are standardizing a workflow, that before writing any code you need to write a `design document` with the options on how to solve a problem and the chosen solution. A lot of times this document has the code changes required by any of the solution options.\nTo me the options that we didn't end up following seem as valuable as the chosen option, and those options should also be captured in code. A really easy way could be in separate branches, but then we loose visibility of them.\nIs anybody familiar with source control software or with patterns to work with source control that also keeps tracks of options considered but not followed at the end?",
                "ts": "1595618648.446000",
                "author_id": "U85HCL7JP",
                "author_subname": "Daniel Garcia",
                "channel_id": "C5T9GPWFL",
                "channel_name": "thinking-together",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "text": "I think that many companies are standardizing a workflow, that before writing any code you need to write a `design document` with the options on how to solve a problem and the chosen solution. A lot of times this document has the code changes required by any of the solution options.\nTo me the options that we didn't end up following seem as valuable as the chosen option, and those options should also be captured in code. A really easy way could be in separate branches, but then we loose visibility of them.\nIs anybody familiar with source control software or with patterns to work with source control that also keeps tracks of options considered but not followed at the end?",
                "author_name": "Daniel Garcia",
                "author_link": "https://futureofcoding.slack.com/team/U85HCL7JP",
                "author_icon": "https://avatars.slack-edge.com/2020-07-25/1286770110448_0c5d8f6a2266551a36f2_48.jpg",
                "mrkdwn_in": [
                    "text"
                ],
                "id": 1,
                "original_url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1595618648446000",
                "footer": "Thread in #thinking-together"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "s3Fg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You might find this older thread useful: "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1595618648446000"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFB8STN7K",
                    "UN57U8V53"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "33b0b6a4-547f-409c-8803-e48c3410dab0",
        "type": "message",
        "text": "Unit tests help some of this.  They encode the constraints of the program and the expected behavior - assuming they are well written!   In particular the last point - how scared should I be to change it?  That can be answered by how robust the unit tests are.  That is their great value; refactoring becomes much easier.",
        "user": "UUQ2EQW21",
        "ts": "1600929183.000100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xC9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unit tests help some of this.  They encode the constraints of the program and the expected behavior - assuming they are well written!   In particular the last point - how scared should I be to change it?  That can be answered by how robust the unit tests are.  That is their great value; refactoring becomes much easier."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d6997466-82ab-4b79-b0f3-ccfe91957196",
        "type": "message",
        "text": "This kinda goes in the opposite direction than the rest of the discussion, but besides design documents, there are *Architectural Decision Records (ADR)*. They are more lightweight, less focused on the implementation details and more on the reasoning behind the decision.\n\nIn a nutshell, it's just a problem statement, the context (current state of the code _and organization_), driving factors, analysis of options (pros and cons), the decision, and the consequences.\n\nI use ADRs for larger-scale decisions with multiple stakeholders and conflicting priorities.\n\nOne thing I find useful is that ADRs capture the current organizational context which is ephemeral and is never recorded otherwise. Examples might be (1) one team is overloaded while another one is idle, so we might lean to the solution that utilizes their expertise, (2) the other team in the organization is developing a similar solution, so we might piggyback on that program, but that adds an additional dependency on the other division, and we know they are slow to react.",
        "user": "UPX3PH28N",
        "ts": "1600930207.000300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uDOb8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This kinda goes in the opposite direction than the rest of the discussion, but besides design documents, there are "
                            },
                            {
                                "type": "text",
                                "text": "Architectural Decision Records (ADR)",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". They are more lightweight, less focused on the implementation details and more on the reasoning behind the decision.\n\nIn a nutshell, it's just a problem statement, the context (current state of the code "
                            },
                            {
                                "type": "text",
                                "text": "and organization",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), driving factors, analysis of options (pros and cons), the decision, and the consequences.\n\nI use ADRs for larger-scale decisions with multiple stakeholders and conflicting priorities.\n\nOne thing I find useful is that ADRs capture the current organizational context which is ephemeral and is never recorded otherwise. Examples might be (1) one team is overloaded while another one is idle, so we might lean to the solution that utilizes their expertise, (2) the other team in the organization is developing a similar solution, so we might piggyback on that program, but that adds an additional dependency on the other division, and we know they are slow to react."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595618648.446000",
        "parent_user_id": "U85HCL7JP",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f901a49e-7fcd-46a7-b5f0-c726597757b1",
        "type": "message",
        "text": "Maybe one way to address some of your points is to store all the code editing history. One missing point will the tracking of the resources and the alternatives that have been considered but not tried.\n\nI guess using environments that use CRDT can have this for free. CRDT used as editing actions log can be used to show what happen at what \"time\".\n\nAnd adding other not-code artifacts (resources and record of not-tried alternatives) in the environnement might also help covering all your points.",
        "user": "UJ6LDMMN0",
        "ts": "1600937449.000900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Aha0S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe one way to address some of your points is to store all the code editing history. One missing point will the tracking of the resources and the alternatives that have been considered but not tried.\n\nI guess using environments that use CRDT can have this for free. CRDT used as editing actions log can be used to show what happen at what \"time\".\n\nAnd adding other not-code artifacts (resources and record of not-tried alternatives) in the environnement might also help covering all your points."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "a23e7fea-18be-4e29-ae72-2a65ebd7cc34",
        "type": "message",
        "text": "I end up using git annotate as a proxy for some of this. It\u2019s limitations are being line-based and being just the most recent thing to have happened to each line. I\u2019m picturing something that turns the section of code I\u2019m looking at into a series of slices that let me step through commits while seeing what has been stable and what has been turbulent.",
        "user": "UKDM3GLAJ",
        "ts": "1600955918.001200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H8x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I end up using git annotate as a proxy for some of this. It\u2019s limitations are being line-based and being just the most recent thing to have happened to each line. I\u2019m picturing something that turns the section of code I\u2019m looking at into a series of slices that let me step through commits while seeing what has been stable and what has been turbulent."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "385217d4-f419-4376-ab90-66296fe5aa43",
        "type": "message",
        "text": "i think one big area that's possible right now without crazy advances in PL design is revealing production behaviour in the editor during development. it doesn't help that much with designing business logic and answering the questions you asked, but for managing all the accidental complexity of actually running code in production, there's a lot of data generated by logs, tracing systems, etc these days that i wish editors revealed much easier",
        "user": "U016LEA3J1H",
        "ts": "1600964214.001600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U016LEA3J1H",
            "ts": "1600964271.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h11p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i think one big area that's possible right now without crazy advances in PL design is revealing production behaviour in the editor during development. it doesn't help that much with designing business logic and answering the questions you asked, but for managing all the accidental complexity of actually running code in production, there's a lot of data generated by logs, tracing systems, etc these days that i wish editors revealed much easier"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "UKP3B2J5D"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "1f7ca2ed-41fa-461c-8e73-a250c7ff8184",
        "type": "message",
        "text": "think hovering a name in your editor and getting a popover that shows values that name held for various traces in production, or the values it tends to hold for successful requests vs failed requests, etc",
        "user": "U016LEA3J1H",
        "ts": "1600964262.001800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pIX70",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "think hovering a name in your editor and getting a popover that shows values that name held for various traces in production, or the values it tends to hold for successful requests vs failed requests, etc"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UPVBV34EL",
                    "U013ZLJARC7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "9d7acd36-b92f-459c-b38c-4d6f1dd543a2",
        "type": "message",
        "text": "pretty sure some advanced Java development setups allow for this kind of thing with remote debuggers running in prod, but it doesn't seem to have taken off",
        "user": "U016LEA3J1H",
        "ts": "1600964301.002100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FU1E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "pretty sure some advanced Java development setups allow for this kind of thing with remote debuggers running in prod, but it doesn't seem to have taken off"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "d691fb9c-0dd6-400b-90cd-5cd84e7d10b6",
        "type": "message",
        "text": "it really does sound nice to work with a medium that reveals all the variations it could be shaped into next or all the variations it used to be in the shape of, instead of just the current shape, but i also think maybe our feeble brains can't deal with yet another dimension of abstraction when working with code. the concreteness of the code in front of you, the lossiness might actually be valuable in service of making programming possible in the first place",
        "user": "U016LEA3J1H",
        "ts": "1600964486.002300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ec8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "it really does sound nice to work with a medium that reveals all the variations it could be shaped into next or all the variations it used to be in the shape of, instead of just the current shape, but i also think maybe our feeble brains can't deal with yet another dimension of abstraction when working with code. the concreteness of the code in front of you, the lossiness might actually be valuable in service of making programming possible in the first place"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "6370c258-e56a-45eb-bfed-01f128468339",
        "type": "message",
        "text": "One thing I've wished for is the ability to ask, \"do we have any tests where this variable has value ___?\" Often when I have a bugfix to add I'll first comment out existing business logic, just to figure out the best place to put the new test.",
        "user": "UCUSW7WVD",
        "ts": "1600965625.002600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7PJPn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing I've wished for is the ability to ask, \"do we have any tests where this variable has value ___?\" Often when I have a bugfix to add I'll first comment out existing business logic, just to figure out the best place to put the new test."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "980fbe4e-97a9-4305-89d2-55d6ebbff377",
        "type": "message",
        "text": "This is an area of I have thought a lot about. My own personal programming project is aimed to help with this. But I've also been white boarding through ideas on how to help with this in the current world. Not sure I could summarize well the ways I want to actually help this problem here, but I do want to at least contribute a few meta thoughts.\n\nFirst I think one really important thing to consider is if we can in fact recover the important parts of a programs history at all. Peter Naur in his paper \"Programming as Theory Building\" claims that re-establishing the theory of a dead program is strictly impossible. I'm sure so people might question this, but I think this is actually very important to consider. If we aim at trying to save a history, we have to consider our aims. If our goal is to recover the theory behind the program that could be a fools errand. Instead maybe we should be thinking about what parts of a programs history are important for helping us establish a new theory? Does that history have to be an actual history or could it be something like what is proposed in the talk \"Idealized Commit Logs\" (<https://www.youtube.com/watch?v=dSqLt8BgbRQ>)?\n\nSecond I think we actually should really consider learning more from historians, particular historians of artifacts (like art history). There is a great book on art history methodology called Patterns of Intention by Michael Baxandall. One of the points he makes is that when we are describing art, we are converting something visual to something linguistic. This is a lossy and biased format, one easy example he gives us that paintings don't actually a beginning and end point. We have to choose how to describe it and where to start. When we are studying art works, we are really studying them under some description of them. (He makes this much clearer for of us who are not artistically inclined by starting with a history of the forth bridge. His history of this artifacts asks as a really interesting example into what goes into an historical explanation.)\n\nI think these same things hold true for programs. In capturing a history, we can't just be recording facts in a database, we are interpreting those facts, selecting the relevant ones and determining an order. What sorts of facts, in what sorts of orders can help people gain a new theory? Will different interpretations click better with different people? What things do we exclude by selecting that facts in this way? Is the loss worth the pay off?\n\n&gt; What are some ways in which programming environments could help us record this info / answer these questions without requiring additional effort from the author?\nI think this is particularly interesting. We all know that getting people to provide documentation is hard. It is even harder to make that documentation good. Short of completely automatic though, what if we could make this easier? What if we could make it more part of your current flow? What if you didn't have to leave your editor, but you also didn't have to mess up the code by leaving some big huge long comment in the middle of things?\n\nWhat if you could decide that something was a good example for later and save it off with a single button press? What if you could make tours through your code bases, or document in those code bases various ways the data flows? What if you could make an interactive introduction to codebase.\n\nI think these are the sorts of starting points we should consider. Once we can make these things work and work well manually, then we can start plugging in automations, start making automatic curation.",
        "user": "UK3LH8CF5",
        "ts": "1600982822.003100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "\"Idealized Commit Logs: Code Simplification via Program Slicing\" by Alan Shreve",
                "title_link": "https://www.youtube.com/watch?v=dSqLt8BgbRQ",
                "author_name": "Strange Loop",
                "author_link": "https://www.youtube.com/channel/UC_QIfHvN9auy2CoOdSfMWDw",
                "thumb_url": "https://i.ytimg.com/vi/dSqLt8BgbRQ/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: \"Idealized Commit Logs: Code Simplification via Program Slicing\" by Alan Shreve",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/dSqLt8BgbRQ?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=dSqLt8BgbRQ",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=dSqLt8BgbRQ"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v1Wu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is an area of I have thought a lot about. My own personal programming project is aimed to help with this. But I've also been white boarding through ideas on how to help with this in the current world. Not sure I could summarize well the ways I want to actually help this problem here, but I do want to at least contribute a few meta thoughts.\n\nFirst I think one really important thing to consider is if we can in fact recover the important parts of a programs history at all. Peter Naur in his paper \"Programming as Theory Building\" claims that re-establishing the theory of a dead program is strictly impossible. I'm sure so people might question this, but I think this is actually very important to consider. If we aim at trying to save a history, we have to consider our aims. If our goal is to recover the theory behind the program that could be a fools errand. Instead maybe we should be thinking about what parts of a programs history are important for helping us establish a new theory? Does that history have to be an actual history or could it be something like what is proposed in the talk \"Idealized Commit Logs\" ("
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=dSqLt8BgbRQ"
                            },
                            {
                                "type": "text",
                                "text": ")?\n\nSecond I think we actually should really consider learning more from historians, particular historians of artifacts (like art history). There is a great book on art history methodology called Patterns of Intention by Michael Baxandall. One of the points he makes is that when we are describing art, we are converting something visual to something linguistic. This is a lossy and biased format, one easy example he gives us that paintings don't actually a beginning and end point. We have to choose how to describe it and where to start. When we are studying art works, we are really studying them under some description of them. (He makes this much clearer for of us who are not artistically inclined by starting with a history of the forth bridge. His history of this artifacts asks as a really interesting example into what goes into an historical explanation.)\n\nI think these same things hold true for programs. In capturing a history, we can't just be recording facts in a database, we are interpreting those facts, selecting the relevant ones and determining an order. What sorts of facts, in what sorts of orders can help people gain a new theory? Will different interpretations click better with different people? What things do we exclude by selecting that facts in this way? Is the loss worth the pay off?\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What are some ways in which programming environments could help us record this info / answer these questions without requiring additional effort from the author?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think this is particularly interesting. We all know that getting people to provide documentation is hard. It is even harder to make that documentation good. Short of completely automatic though, what if we could make this easier? What if we could make it more part of your current flow? What if you didn't have to leave your editor, but you also didn't have to mess up the code by leaving some big huge long comment in the middle of things?\n\nWhat if you could decide that something was a good example for later and save it off with a single button press? What if you could make tours through your code bases, or document in those code bases various ways the data flows? What if you could make an interactive introduction to codebase.\n\nI think these are the sorts of starting points we should consider. Once we can make these things work and work well manually, then we can start plugging in automations, start making automatic curation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UFB8STN7K",
                    "U013ZLJARC7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "d7a9ae43-c1f2-476b-8095-af404a46a365",
        "type": "message",
        "text": "in a big codebase there might be some utility in using ML. For example, applying frequent itemsets to change sets could identify chunks of code that are changed together more frequently than expected. This might be suggestive of risk, or of refactoring opportunities.",
        "user": "U01A1C2K8MP",
        "ts": "1600984191.007000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z0V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "in a big codebase there might be some utility in using ML. For example, applying frequent itemsets to change sets could identify chunks of code that are changed together more frequently than expected. This might be suggestive of risk, or of refactoring opportunities."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UPVBV34EL",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    }
]