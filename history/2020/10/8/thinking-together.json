[
    {
        "client_msg_id": "663b32f7-cfb1-4ed4-b778-f934a7e0f731",
        "type": "message",
        "text": "I find folding cumbersome due to a lack of mapped, memorized, and practiced keys for performing the higher level navigation actions I would want to execute.",
        "user": "UA14TGLTC",
        "ts": "1602124027.165900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "//Z3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find folding cumbersome due to a lack of mapped, memorized, and practiced keys for performing the higher level navigation actions I would want to execute."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602079126.163600",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "62C1C1CD-AD06-44B3-B5FD-6ECD7F188F19",
        "type": "message",
        "text": "Check out Grant\u2019s work: <https://constraint.systems> He does experimental design tools with a Vim vibe to it.",
        "user": "UDKTZSD6H",
        "ts": "1602170382.167500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Constraint Systems",
                "title_link": "https://constraint.systems/",
                "text": "Alternative interfaces for editing and creating images and text.",
                "fallback": "Constraint Systems",
                "image_url": "https://constraint.systems/images/desktop.png",
                "from_url": "https://constraint.systems/",
                "image_width": 444,
                "image_height": 250,
                "image_bytes": 1421413,
                "service_icon": "https://constraint.systems/favicon.png",
                "service_name": "constraint.systems",
                "id": 1,
                "original_url": "https://constraint.systems"
            }
        ],
        "thread_ts": "1602079126.163600",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "71b48de8-304e-4306-8a7e-aacf4a45d88b",
        "type": "message",
        "text": "<@UCUSW7WVD>\n\nReally interesting to hear more about the limitations with slicing. Not 100% sure I followed why data transformation causes an issue. But definitely agree that slices don't solve the whole problem.\n\nAs for the test suite idea, I definitely agree that it has some issues. I do think trying to take an existing test suite and applying this wouldn't be super useful. But you can imagine making your own test suite, specifically designed to exercise various parts of the system. You can imagine taking some lisp interpreter, feeding it simple expressions, getting the trace, and the moving on to more and more complex ones. Giving you in the end something that you can follow.\n\nI think your work on wart is really interesting and actually really aligns with what I was aiming at talking about. What we need is not a factual, uninterpreted history of how the program changed. We do in fact have the facts. They are recorded in source control. What we need is an interpretive, idealized history. You are providing exactly that in wart. Though I will say, I'm not sure it goes far enough, but that is mostly related to this:\n\n\n&gt; There's no way to understand programs efficiently when the author didn't design for it from the start. If a program had multiple authors, it's as easy to read as the author least interested in comprehensibility made it. Programs have to be designed for comprehensibility. So toss out the modern social organization and its incentives for creating programs primarily as black boxes for people to use.\nI'm tempted to agree. But I think the key word here is efficiently. I have worked in codebases that were clearly not meant to be understood (one was decompiled source). Where the code was absolutely insane. Understanding them was very very difficult and took a ton of work. But what I found in the end was that the tools I really needed to capture this information weren't there. I could of course write docs, and I did. But that wasn't enough.\n\nNor was my coming to an understanding of the code aided (much) by tools. Of course, a slice wouldn't have told me everything, but it would have helped me start with a simplified case. Being able to ask counterfactual questions of my program would have aided me in understanding. In general, I can think of a number of things that computers are fully capable of that would have made my journey of understanding condensed. And then, once understood, I could convey some of that to people, but helping them get into the right states where they too could repeat my learnings.\n\nDesigning programs with comprehensibility from the start is definitely a goal. But I just don't think it can be our end state.",
        "user": "UK3LH8CF5",
        "ts": "1602182809.167900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dHq+t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "\n\nReally interesting to hear more about the limitations with slicing. Not 100% sure I followed why data transformation causes an issue. But definitely agree that slices don't solve the whole problem.\n\nAs for the test suite idea, I definitely agree that it has some issues. I do think trying to take an existing test suite and applying this wouldn't be super useful. But you can imagine making your own test suite, specifically designed to exercise various parts of the system. You can imagine taking some lisp interpreter, feeding it simple expressions, getting the trace, and the moving on to more and more complex ones. Giving you in the end something that you can follow.\n\nI think your work on wart is really interesting and actually really aligns with what I was aiming at talking about. What we need is not a factual, uninterpreted history of how the program changed. We do in fact have the facts. They are recorded in source control. What we need is an interpretive, idealized history. You are providing exactly that in wart. Though I will say, I'm not sure it goes far enough, but that is mostly related to this:\n\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's no way to understand programs efficiently when the author didn't design for it from the start. If a program had multiple authors, it's as easy to read as the author least interested in comprehensibility made it. Programs have to be designed for comprehensibility. So toss out the modern social organization and its incentives for creating programs primarily as black boxes for people to use."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI'm tempted to agree. But I think the key word here is efficiently. I have worked in codebases that were clearly not meant to be understood (one was decompiled source). Where the code was absolutely insane. Understanding them was very very difficult and took a ton of work. But what I found in the end was that the tools I really needed to capture this information weren't there. I could of course write docs, and I did. But that wasn't enough.\n\nNor was my coming to an understanding of the code aided (much) by tools. Of course, a slice wouldn't have told me everything, but it would have helped me start with a simplified case. Being able to ask counterfactual questions of my program would have aided me in understanding. In general, I can think of a number of things that computers are fully capable of that would have made my journey of understanding condensed. And then, once understood, I could convey some of that to people, but helping them get into the right states where they too could repeat my learnings.\n\nDesigning programs with comprehensibility from the start is definitely a goal. But I just don't think it can be our end state."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "72b996c7-9888-40ff-a047-f2ec9714d5d3",
        "type": "message",
        "text": "This post resonates so much with me on how I feel working on a codebases. Thought others might enjoy.  (good despite it being on medium) <https://medium.com/@wm/the-generation-ship-model-of-software-development-5ef89a74854b>",
        "user": "UK3LH8CF5",
        "ts": "1602183008.168200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UK3LH8CF5",
            "ts": "1602183016.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mfww",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This post resonates so much with me on how I feel working on a codebases. Thought others might enjoy.  (good despite it being on medium) "
                            },
                            {
                                "type": "link",
                                "url": "https://medium.com/@wm/the-generation-ship-model-of-software-development-5ef89a74854b"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "U85HCL7JP"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "1988ff15-fbfb-4572-a807-7d3cc7b53f61",
        "type": "message",
        "text": "I realize you can put either side in the foreground, like a Necker cube:\n* Designing ahead of time for comprehensibility is definitely a start, but it can't be our end state.\n* Tooling for comprehension is definitely a start, but it can't be our end state.",
        "user": "UCUSW7WVD",
        "ts": "1602183208.168700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J7V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I realize you can put either side in the foreground, like a Necker cube:\n* Designing ahead of time for comprehensibility is definitely a start, but it can't be our end state.\n* Tooling for comprehension is definitely a start, but it can't be our end state."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UK3LH8CF5"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e863cd6d-8506-4d46-ae26-c920f42a5bcf",
        "type": "message",
        "text": "Also worth observing: we have no idea what program comprehension is or how it works. A theory of comprehension would likely be an essential component of designing for comprehension at the tool or program level.",
        "user": "UFB8STN7K",
        "ts": "1602183341.169000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RZe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also worth observing: we have no idea what program comprehension is or how it works. A theory of comprehension would likely be an essential component of designing for comprehension at the tool or program level."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "db4b4e9b-a0db-4a00-aa55-51431051355c",
        "type": "message",
        "text": "This is probably a subjective opinion, but I think we tend to do things first, and theories catch up over time as lots of people try out lots of things, and definitions converge last of all. Given that \"ready, fire, aim\" worldview, I try above all to focus on rewritability. If rewriting seems risky, that feels like the first problem to try to fix. That way the things you build can benefit from future theories, and you can be disrupted by yourself rather than external Johnny-come-latelies.",
        "user": "UCUSW7WVD",
        "ts": "1602183704.169200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1602183866.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=+LQW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is probably a subjective opinion, but I think we tend to do things first, and theories catch up over time as lots of people try out lots of things, and definitions converge last of all. Given that \"ready, fire, aim\" worldview, I try above all to focus on rewritability. If rewriting seems risky, that feels like the first problem to try to fix. That way the things you build can benefit from future theories, and you can be disrupted by yourself rather than external Johnny-come-latelies."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "54e77fbc-b4a7-470f-aa08-c8afc8509a62",
        "type": "message",
        "text": "Define emulator! Is a JVM implementation an emulator? Or a JavaScript engine? There are emulators written in Java and JavaScript.",
        "user": "UJBAJNFLK",
        "ts": "1602183878.169600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZAZL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Define emulator! Is a JVM implementation an emulator? Or a JavaScript engine? There are emulators written in Java and JavaScript."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1"
    },
    {
        "client_msg_id": "6076e9e4-fdca-4f35-a59b-26e354392430",
        "type": "message",
        "text": "Personally I think Naur's \"Programming as Theory Building\" and \"Intuition in Software Development\" are good starting points. In general, I think we have a lot that we could gain from including insights in philosophy into software development (I have a talk at splash this year advocating for exactly that). Something I think Naur does particularly well.\n\nI do agree with <@UCUSW7WVD>. Our practice generally outstrips our theories. But I think we can gain a lot by reflecting on practice and understanding. For example, as software engineers, we do a lot of what is called \"Conceptual Engineering\" in the philosophy world. Understanding what we do in light of that framework and how it relates to other things in the world can help us quite a bit.\n\n<https://www.amazon.com/Fixing-Language-Essay-Conceptual-Engineering/dp/0198814712>",
        "user": "UK3LH8CF5",
        "ts": "1602186249.169900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ReGY3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Personally I think Naur's \"Programming as Theory Building\" and \"Intuition in Software Development\" are good starting points. In general, I think we have a lot that we could gain from including insights in philosophy into software development (I have a talk at splash this year advocating for exactly that). Something I think Naur does particularly well.\n\nI do agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": ". Our practice generally outstrips our theories. But I think we can gain a lot by reflecting on practice and understanding. For example, as software engineers, we do a lot of what is called \"Conceptual Engineering\" in the philosophy world. Understanding what we do in light of that framework and how it relates to other things in the world can help us quite a bit.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.amazon.com/Fixing-Language-Essay-Conceptual-Engineering/dp/0198814712"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "7143cde2-cd5b-498d-a830-6f8a8e203410",
        "type": "message",
        "text": "Naur\u2019s article is a good worldview, but (IMO) the devil is in the details. We have no idea how programmers build theories, what the shape of those theories are, what language constructs promote or hinder theory construction, and so on. We\u2019ve had 50 years of distributed practice in programming, but I don\u2019t think that\u2019s been sufficient to meaningfully understand the psychological nature of programming beyond intuition. You can see this failure most acutely in intro to CS classes, where our top universities will fail to teach even the most basic skills like debugging or decomposition in a meaningful way.",
        "user": "UFB8STN7K",
        "ts": "1602186576.170100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "i2by",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Naur\u2019s article is a good worldview, but (IMO) the devil is in the details. We have no idea how programmers build theories, what the shape of those theories are, what language constructs promote or hinder theory construction, and so on. We\u2019ve had 50 years of distributed practice in programming, but I don\u2019t think that\u2019s been sufficient to meaningfully understand the psychological nature of programming beyond intuition. You can see this failure most acutely in intro to CS classes, where our top universities will fail to teach even the most basic skills like debugging or decomposition in a meaningful way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "b5e71a37-627b-45d6-95fb-743f9e4d6981",
        "type": "message",
        "text": "Curious <@UFB8STN7K> to hear your view of how we'd go about starting that project. Would we solve these issues by doing empirical studies and finding statistical results? Or would it be more a matter of reflecting and exploring our own processes?",
        "user": "UK3LH8CF5",
        "ts": "1602186783.170300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hYC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Curious "
                            },
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " to hear your view of how we'd go about starting that project. Would we solve these issues by doing empirical studies and finding statistical results? Or would it be more a matter of reflecting and exploring our own processes?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "3dee132b-a04a-42c4-83ed-40b5df52283d",
        "type": "message",
        "text": "This is the subject of my research, so my views evolve rapidly over time. But right now, my sense is: there\u2019s a lot of inspiration we can draw from cognitive psychologists up to anthropologists/sociologists on how to study human behavior, particularly for skilled tasks. There\u2019s a lot of theories that could be applied to programming (e.g. I\u2019ve been thinking about working memory recently, just submitted a paper to CHI about that). And there\u2019s a lot of methodologies that can be used to study programmers. For example, Barbara Tversky\u2019s book _Mind in Motion_ is a really good overview of how simple experiments can build a really rich model of how people build mental models of space and action, and how action informs perception.",
        "user": "UFB8STN7K",
        "ts": "1602187152.170500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uX3Ry",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is the subject of my research, so my views evolve rapidly over time. But right now, my sense is: there\u2019s a lot of inspiration we can draw from cognitive psychologists up to anthropologists/sociologists on how to study human behavior, particularly for skilled tasks. There\u2019s a lot of theories that could be applied to programming (e.g. I\u2019ve been thinking about working memory recently, just submitted a paper to CHI about that). And there\u2019s a lot of methodologies that can be used to study programmers. For example, Barbara Tversky\u2019s book "
                            },
                            {
                                "type": "text",
                                "text": "Mind in Motion",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a really good overview of how simple experiments can build a really rich model of how people build mental models of space and action, and how action informs perception."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "14da4532-94e5-40ca-96bb-cd47d99d625b",
        "type": "message",
        "text": "Theory-building inevitably involves both controlled lab experiments (whether protocol analyses of quantitative studies) and data mining (of software repositories, education statistics, etc). But I think an underexplored area is experiment design: what are interesting situations in which we can put programmers, and methods to observe them that reveal patterns in their behavior?",
        "user": "UFB8STN7K",
        "ts": "1602187253.170700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fss",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Theory-building inevitably involves both controlled lab experiments (whether protocol analyses of quantitative studies) and data mining (of software repositories, education statistics, etc). But I think an underexplored area is experiment design: what are interesting situations in which we can put programmers, and methods to observe them that reveal patterns in their behavior?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UKDM3GLAJ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f4988c0a-44d3-4d9a-8a0c-1cce340ef311",
        "type": "message",
        "text": "<@UK3LH8CF5> Naur's paper is one of my two or three \"anchor\" influences, so absolutely relevant. However, the \"theories\" in it are for understanding individual codebases or domains, as I recall. A general theory of comprehension is far more ambitious.",
        "user": "UCUSW7WVD",
        "ts": "1602193491.171000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1602193516.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=GM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": " Naur's paper is one of my two or three \"anchor\" influences, so absolutely relevant. However, the \"theories\" in it are for understanding individual codebases or domains, as I recall. A general theory of comprehension is far more ambitious."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "aa0dfbce-1eb2-4ffd-b234-1f370254a2ba",
        "type": "message",
        "text": "Yeah, but he was basing his work on Ryle and James who probably took themselves to have something like that more general theory. (I don't particularly agree with them) But yes I agree. I think naur offers constraints that have largely been ignored. I'd be interesting to know you other anchor influences.",
        "user": "UK3LH8CF5",
        "ts": "1602193660.171300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "af35",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, but he was basing his work on Ryle and James who probably took themselves to have something like that more general theory. (I don't particularly agree with them) But yes I agree. I think naur offers constraints that have largely been ignored. I'd be interesting to know you other anchor influences."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f65475ea-45b3-4088-b117-10879a7729c8",
        "type": "message",
        "text": "I'd say Christopher Alexander and Richard Gabriel (the latter for making the former accessible to me). But I have a longer list at the bottom of <https://github.com/akkartik/mu|https://github.com/akkartik/mu>",
        "user": "UCUSW7WVD",
        "ts": "1602193997.171500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "akkartik/mu",
                "title_link": "https://github.com/akkartik/mu",
                "text": "Soul of a tiny new machine. More thorough tests \u2192 More comprehensible and rewrite-friendly software \u2192 More resilient society. - akkartik/mu",
                "fallback": "GitHub: akkartik/mu",
                "thumb_url": "https://avatars3.githubusercontent.com/u/3161?s=400&v=4",
                "from_url": "https://github.com/akkartik/mu",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/akkartik/mu"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WBe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd say Christopher Alexander and Richard Gabriel (the latter for making the former accessible to me). But I have a longer list at the bottom of "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/akkartik/mu",
                                "text": "https://github.com/akkartik/mu"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1600909562.010100",
        "parent_user_id": "UFB8STN7K"
    }
]