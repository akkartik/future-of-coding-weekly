[
    {
        "client_msg_id": "a474fd8d-cf41-4ff8-a3fa-613ca07539f2",
        "type": "message",
        "text": "I'm not sure how to phrase this question. I've been thinking a lot about \"bit rot\" recently. For example, will we reach a point where there are no DVD players that can decode the disks?\n\nOr where there is no existing program to read PowerPoint presentations? \n\nIs this a likely eventuality for systems? Should everything be txt files to avoid this? \n\nAre we going to have our period of history with large gaps from this bit rot problem? \n\nCan we as programmers do anything to avoid this?",
        "user": "U019CPED6T1",
        "ts": "1601503724.095900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RMXz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure how to phrase this question. I've been thinking a lot about \"bit rot\" recently. For example, will we reach a point where there are no DVD players that can decode the disks?\n\nOr where there is no existing program to read PowerPoint presentations? \n\nIs this a likely eventuality for systems? Should everything be txt files to avoid this? \n\nAre we going to have our period of history with large gaps from this bit rot problem? \n\nCan we as programmers do anything to avoid this?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "reply_count": 6,
        "reply_users_count": 4,
        "latest_reply": "1601567010.120000",
        "reply_users": [
            "U01AD80KMLK",
            "UG0EL18H3",
            "U01A0KANUUU",
            "UJBAJNFLK"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "fa7a5943-9e9a-47f4-b97f-7ad0cf381e04",
        "type": "message",
        "text": "check the Internet Archive about this, the Long Now Foundation, and the thoughts that Project Gutenberg put into this. GLAMs (Galleries, Libraries, Archives and Museums) have thought about this a lot - you should be able to find papers and work on that topic.",
        "user": "U01AD80KMLK",
        "ts": "1601504471.096400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6uQW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "check the Internet Archive about this, the Long Now Foundation, and the thoughts that Project Gutenberg put into this. GLAMs (Galleries, Libraries, Archives and Museums) have thought about this a lot - you should be able to find papers and work on that topic."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1"
    },
    {
        "client_msg_id": "766a63e1-4264-49e4-9410-c6fb12dfd584",
        "type": "message",
        "text": "just one example, the work by Katherine Thornton at Yale",
        "user": "U01AD80KMLK",
        "ts": "1601504499.096600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A3Kc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "just one example, the work by Katherine Thornton at Yale"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "569ca978-7ac0-4f72-b680-6653e6caf560",
        "type": "message",
        "text": "<@UFZFETUH1> said\n&gt; I know some people say 'Haskell doesn't have side effects', and I know why they do: From the perspective of haskell's type system, haskell doesn't have side effects. However, in reality, you can write and read files in haskell, thus, it has side effects.\nA side effect is an _effect_ that happens _on the side_. I/O actions are effects. Haskell has effects, but it does not have side effects.",
        "user": "UJN1TAYEQ",
        "ts": "1601504545.096800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1h7d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFZFETUH1"
                            },
                            {
                                "type": "text",
                                "text": " said\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know some people say 'Haskell doesn't have side effects', and I know why they do: From the perspective of haskell's type system, haskell doesn't have side effects. However, in reality, you can write and read files in haskell, thus, it has side effects."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A side effect is an "
                            },
                            {
                                "type": "text",
                                "text": "effect",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that happens "
                            },
                            {
                                "type": "text",
                                "text": "on the side",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I/O actions are effects. Haskell has effects, but it does not have side effects."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UFZFETUH1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6c64c931-c26f-476e-8dc7-688a183beeed",
        "type": "message",
        "text": "Not to go too far down the rabbit hole, but yes, this is a very real issue! In fact, something to consider is the point at which the languages we use in this day and age are no longer understood. This is a particular challenge for anyone wishing to convey a message to folks thousands of years in the future: a use case for this might be to warn future generations about the dangers of buried nuclear waste, for instance: <https://www.currentaffairs.org/2019/07/what-nuclear-semiotics-are>",
        "user": "UG0EL18H3",
        "ts": "1601505379.097000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pKk9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not to go too far down the rabbit hole, but yes, this is a very real issue! In fact, something to consider is the point at which the languages we use in this day and age are no longer understood. This is a particular challenge for anyone wishing to convey a message to folks thousands of years in the future: a use case for this might be to warn future generations about the dangers of buried nuclear waste, for instance: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.currentaffairs.org/2019/07/what-nuclear-semiotics-are"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1"
    },
    {
        "client_msg_id": "281e1381-ca0b-4864-aef0-3a10ad73ba94",
        "type": "message",
        "text": "The passage that struck me the most in that article (and the reason I included it in my response), grapples with the question \u201ccan we as programmers/technologists do anything to avoid this?\u201c:\n\n```...from the perspective of our era\u2014when the humanities and social sciences are frequently defunded, dismissed, and derided\u2014it's surprising to see an unquestioned faith in the essential relationship between \"hard\" science and social science. The U.S. Department of Energy understood that the nuclear waste disposal problem could not be solved by technological innovation alone; no alloy or neat little locking mechanism would save us from our future selves. Only by examining human nature, and allowing ourselves to conceive of a world beyond all contemporary understanding, could we attempt to protect the planet from the magnitude of what we'd done to it. ```",
        "user": "UG0EL18H3",
        "ts": "1601505716.097200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UG0EL18H3",
            "ts": "1601505754.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J1BB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The passage that struck me the most in that article (and the reason I included it in my response), grapples with the question \u201ccan we as programmers/technologists do anything to avoid this?\u201c:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "...from the perspective of our era\u2014when the humanities and social sciences are frequently defunded, dismissed, and derided\u2014it's surprising to see an unquestioned faith in the essential relationship between \"hard\" science and social science. The U.S. Department of Energy understood that the nuclear waste disposal problem could not be solved by technological innovation alone; no alloy or neat little locking mechanism would save us from our future selves. Only by examining human nature, and allowing ourselves to conceive of a world beyond all contemporary understanding, could we attempt to protect the planet from the magnitude of what we'd done to it. "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1"
    },
    {
        "client_msg_id": "0409c664-80e8-4d62-a932-2e1961540bcb",
        "type": "message",
        "text": "I sympathize with what Mariano wrote:\n&gt; I don't like to write code full of side effects, hard to test, hard to reason about, hard to know all the edge cases. I also don't like mocks and doing dependency injection everywhere to be able to switch the side effect parts is a lot of work.\nOne of my hobby projects is to make a practical programming language that is easy to use, easy to understand, has a low barrier to entry, and has simple semantics. In my language, all functions are pure (function calls do not have side effects), and there is no shared mutable state, because that leads to simpler semantics and less cognitive load. I think my goals are different from functional programming researchers, because there, the focus is on complex type systems. Eg, Haskell is a very complex language with a steep learning curve. Whereas my language is dynamically typed.\n\nAs for \"the future of side effects\", I think there is a much larger design space for side-effect-free programming languages than what is currently explored by FP researchers focused on higher order type theory.",
        "user": "UJN1TAYEQ",
        "ts": "1601507115.097500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7Z72Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I sympathize with what Mariano wrote:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't like to write code full of side effects, hard to test, hard to reason about, hard to know all the edge cases. I also don't like mocks and doing dependency injection everywhere to be able to switch the side effect parts is a lot of work."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of my hobby projects is to make a practical programming language that is easy to use, easy to understand, has a low barrier to entry, and has simple semantics. In my language, all functions are pure (function calls do not have side effects), and there is no shared mutable state, because that leads to simpler semantics and less cognitive load. I think my goals are different from functional programming researchers, because there, the focus is on complex type systems. Eg, Haskell is a very complex language with a steep learning curve. Whereas my language is dynamically typed.\n\nAs for \"the future of side effects\", I think there is a much larger design space for side-effect-free programming languages than what is currently explored by FP researchers focused on higher order type theory."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "355841a9-114e-436c-8a36-6727c0f829ab",
        "type": "message",
        "text": "And of course there is an Alan Kay paper about that:\n<http://www.vpri.org/pdf/tr2015004_cuneiform.pdf>",
        "user": "U01A0KANUUU",
        "ts": "1601507486.097700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jXY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And of course there is an Alan Kay paper about that:\n"
                            },
                            {
                                "type": "link",
                                "url": "http://www.vpri.org/pdf/tr2015004_cuneiform.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1"
    },
    {
        "client_msg_id": "0b378223-4e86-4b96-b8af-196035027672",
        "type": "message",
        "text": "I was reading Fred Kjolstad\u2019s thesis (<http://fredrikbk.com/publications/kjolstad-thesis.pdf>) about compilers for sparse linear algebra. He says:\n\n&gt; The issue with libraries of hand-optimized functions boils down to our inability to easily build composable building blocks that perform well. Current sparse linear algebra libraries do not let us compose expressions, data structures, optimization strategies, and architectures without sacrificing performance. The first performance loss is from lost temporal locality\u2014a deficiency that is also present with dense operations. Second, sparse operations may operate on many different data structures, which are each designed to work well on one type of sparsity pattern. If two composed functions do not support the same data structure, then it becomes necessary to perform an expensive conversion between irregular data structures. But the most serious issue is that composing two sparse linear or tensor algebra functions may perform asymptotically worse than a fused function written to compute the entire expression at once.\nThis made me think more generally about the composability vs. performance trade-off.  Being able to compose black box abstractions at a high level is at the very foundation of software engineering, enabling programmers to eliminate boilerplate and more easily use others\u2019 work. Yet composition is the enemy of performance: a careful implementation that fuses two operations is often more efficient than a sequenced invocation of the two. However, most compilers today only offer `#[inline]` pragmas or other extremely shallow means of reducing abstraction/composition costs. Even the most advanced C++ template magic can\u2019t do the necessary code-reordering to achieve the optimal composition that Fred describes.\n\nSeveral programming systems have good ideas in this direction:\n\u2022 Zero-cost abstractions in programming languages (eg Rust <https://blog.rust-lang.org/2015/05/11/traits.html>)\n\u2022 Separating algorithm from schedule (eg Halide <http://halide-lang.org/>)\n\u2022 Using higher-order functions to express data parallelism (eg Spark <https://spark.apache.org/>)\nCurious to hear others\u2019 thoughts (how will we manage this trade-off in future langs/compilers?) and pointers to relevant work.",
        "user": "UFB8STN7K",
        "ts": "1601510649.105100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFB8STN7K",
            "ts": "1601511189.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HL=r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was reading Fred Kjolstad\u2019s thesis ("
                            },
                            {
                                "type": "link",
                                "url": "http://fredrikbk.com/publications/kjolstad-thesis.pdf"
                            },
                            {
                                "type": "text",
                                "text": ") about compilers for sparse linear algebra. He says:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The issue with libraries of hand-optimized functions boils down to our inability to easily build composable building blocks that perform well. Current sparse linear algebra libraries do not let us compose expressions, data structures, optimization strategies, and architectures without sacrificing performance. The first performance loss is from lost temporal locality\u2014a deficiency that is also present with dense operations. Second, sparse operations may operate on many different data structures, which are each designed to work well on one type of sparsity pattern. If two composed functions do not support the same data structure, then it becomes necessary to perform an expensive conversion between irregular data structures. But the most serious issue is that composing two sparse linear or tensor algebra functions may perform asymptotically worse than a fused function written to compute the entire expression at once."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis made me think more generally about the composability vs. performance trade-off.  Being able to compose black box abstractions at a high level is at the very foundation of software engineering, enabling programmers to eliminate boilerplate and more easily use others\u2019 work. Yet composition is the enemy of performance: a careful implementation that fuses two operations is often more efficient than a sequenced invocation of the two. However, most compilers today only offer "
                            },
                            {
                                "type": "text",
                                "text": "#[inline]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " pragmas or other extremely shallow means of reducing abstraction/composition costs. Even the most advanced C++ template magic can\u2019t do the necessary code-reordering to achieve the optimal composition that Fred describes.\n\nSeveral programming systems have good ideas in this direction:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Zero-cost abstractions in programming languages (eg Rust "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://blog.rust-lang.org/2015/05/11/traits.html"
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Separating algorithm from schedule (eg Halide "
                                    },
                                    {
                                        "type": "link",
                                        "url": "http://halide-lang.org/"
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Using higher-order functions to express data parallelism (eg Spark "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://spark.apache.org/"
                                    },
                                    {
                                        "type": "text",
                                        "text": ")"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCurious to hear others\u2019 thoughts (how will we manage this trade-off in future langs/compilers?) and pointers to relevant work."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601510649.105100",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1601517629.106100",
        "reply_users": [
            "UJN1TAYEQ"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U016VUZGUUQ",
                    "U015V233CFL",
                    "U01A57MG2HM",
                    "UDKTZSD6H"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "b462fba3-589d-4b06-9a23-3b67605f8249",
        "type": "message",
        "text": "Taichi addresses this problem, for sparse arrays on a GPU.\n<http://taichi.graphics/wp-content/uploads/2019/09/taichi_lang.pdf>\n<https://github.com/yuanming-hu/taichi>",
        "user": "UJN1TAYEQ",
        "ts": "1601517629.106100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1601517687.000000"
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "yuanming-hu/taichi",
                "title_link": "https://github.com/yuanming-hu/taichi",
                "text": "My fork of <https://github.com/taichi-dev/taichi>. Contribute to yuanming-hu/taichi development by creating an account on GitHub.",
                "fallback": "GitHub: yuanming-hu/taichi",
                "thumb_url": "https://avatars3.githubusercontent.com/u/6553256?s=400&v=4",
                "from_url": "https://github.com/yuanming-hu/taichi",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/yuanming-hu/taichi"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+3Gd4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Taichi addresses this problem, for sparse arrays on a GPU.\n"
                            },
                            {
                                "type": "link",
                                "url": "http://taichi.graphics/wp-content/uploads/2019/09/taichi_lang.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/yuanming-hu/taichi"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601510649.105100",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "69ddab96-83e6-46b4-87ed-cec0a8707e5a",
        "type": "message",
        "text": "The big advantage of Algebraic Effects seems to lie in the fact that it is a type system for old style imperative code, and functions with side effects, in which the type of a function includes its side effects. That seems like an incremental improvement to the current state of things, with backwards compatibility to the old coding style. Side effects are more visible and more controllable, giving at least some of the advantages of using a side effect free language.\n\nI'm not sure Algebraic Effects provides all the advantages of side-effect-free programming. If you've got a big web of shared mutable state, and you call a function that modifies some of that state as a side effect, AE can tell you that there are side effects but I don't see how it helps you understand what state is being modified. In side effect free programming, the connections are explicit, since you can't modify state that isn't passed as an argument.",
        "user": "UJN1TAYEQ",
        "ts": "1601520834.106600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z+=y",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The big advantage of Algebraic Effects seems to lie in the fact that it is a type system for old style imperative code, and functions with side effects, in which the type of a function includes its side effects. That seems like an incremental improvement to the current state of things, with backwards compatibility to the old coding style. Side effects are more visible and more controllable, giving at least some of the advantages of using a side effect free language.\n\nI'm not sure Algebraic Effects provides all the advantages of side-effect-free programming. If you've got a big web of shared mutable state, and you call a function that modifies some of that state as a side effect, AE can tell you that there are side effects but I don't see how it helps you understand what state is being modified. In side effect free programming, the connections are explicit, since you can't modify state that isn't passed as an argument."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "48A14917-7A2A-43E4-ADB5-6BDEC2366C3B",
        "type": "message",
        "text": "I think the _biggest_ assumption in this thread is that the Future of Coding even involves the concept of a \u201cfunction\u201d :innocent:. I encourage people to explore possible alternatives to \u201ccallable units of code\u201d \u2014 my planned (general purpose) language doesn\u2019t have it! Thus it\u2019s not even possible to talk about side effects.",
        "user": "UCGAK10LS",
        "ts": "1601552062.111900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TiqjL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the "
                            },
                            {
                                "type": "text",
                                "text": "biggest",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " assumption in this thread is that the Future of Coding even involves the concept of a \u201cfunction\u201d "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent"
                            },
                            {
                                "type": "text",
                                "text": ". I encourage people to explore possible alternatives to \u201ccallable units of code\u201d \u2014 my planned (general purpose) language doesn\u2019t have it! Thus it\u2019s not even possible to talk about side effects."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UE6EFEPTQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ed47487b-bb08-4681-b7fc-4d2c6c42121d",
        "type": "message",
        "text": "<@UCGAK10LS> In my planned language, there are two kinds of \"callable units of code\": functions and procedures. Functions are pure mathematical functions with no side effects, and they compute a value. Procedures perform an effect, such as an I/O effect.\n\nI don't do logic programming, so correct me if I'm wrong, but in Prolog, you don't have functions. You have facts, rules, predicates, and evaluation is logical deduction. I/O is done using magic I/O predicates that perform I/O as a side effect of deduction. So Prolog models I/O using side effects, even though it doesn't have functions. How does I/O work in your language?",
        "user": "UJN1TAYEQ",
        "ts": "1601555025.112200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1601560647.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PA7E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " In my planned language, there are two kinds of \"callable units of code\": functions and procedures. Functions are pure mathematical functions with no side effects, and they compute a value. Procedures perform an effect, such as an I/O effect.\n\nI don't do logic programming, so correct me if I'm wrong, but in Prolog, you don't have functions. You have facts, rules, predicates, and evaluation is logical deduction. I/O is done using magic I/O predicates that perform I/O as a side effect of deduction. So Prolog models I/O using side effects, even though it doesn't have functions. How does I/O work in your language?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "3ccccec2-2038-4b6d-92dd-b0aecf94e3e5",
        "type": "message",
        "text": "<@U01AD80KMLK> your project sounds like a form of knowledge representation, but one people can actually execute. is that right?\n\nThat would mean that one could write a wiki page referencing these functions and that page could potentially be executed to yield a result.\n\nI\u2019m curious if you\u2019ve envisioned a potential user flow in which this product is involved. how would it look like?\n\nalso, the job posting doesn\u2019t mention the project at all. what role would the developer play in this project?\n\nI\u2019m asking, because I\u2019ve been thinking about something similar. I\u2019ve been thinking of basing my knowledge representation system on lambda calculus. I don\u2019t know if you\u2019ve considered the same",
        "user": "UDQKHNP51",
        "ts": "1601557156.112400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Kn1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01AD80KMLK"
                            },
                            {
                                "type": "text",
                                "text": " your project sounds like a form of knowledge representation, but one people can actually execute. is that right?\n\nThat would mean that one could write a wiki page referencing these functions and that page could potentially be executed to yield a result.\n\nI\u2019m curious if you\u2019ve envisioned a potential user flow in which this product is involved. how would it look like?\n\nalso, the job posting doesn\u2019t mention the project at all. what role would the developer play in this project?\n\nI\u2019m asking, because I\u2019ve been thinking about something similar. I\u2019ve been thinking of basing my knowledge representation system on lambda calculus. I don\u2019t know if you\u2019ve considered the same"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601330319.057300",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "61a9c778-b735-43ea-b598-367ca40b232d",
        "type": "message",
        "text": "<@UDQKHNP51> I am having trouble with the term knowledge representation for this case, but this is really a terminological issue. To make it short, yes, it will be able to execute.\n\nSo one possible user flow could be: hey, what's the reverse of my text? I go to the page for reverting a string, there's a box where I can enter my text, I copy and paste into it, click on \"go\", and it shows me the result.\n\nThe job posting will be a full stack developer on the MediaWiki extension we are building to support the wiki of functions, and on the evaluation engine to run the functions for the users. We are a small team, and we plan to grow, but for now we only have one engineer, and we need more. We will specialize later with more engineers, but for now we need someone who can help with everything, if that makes sense :slightly_smiling_face:\n\nRegarding the lambda calculus, yes, take a look at this walkthrough through an earlier prototype, where in fact everything was built on lambda calculus: <https://github.com/google/abstracttext/blob/master/eneyj/docs/walkthrough.md>",
        "user": "U01AD80KMLK",
        "ts": "1601564039.112700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "google/abstracttext",
                "title_link": "https://github.com/google/abstracttext/blob/master/eneyj/docs/walkthrough.md",
                "text": "MediaWiki extension to handle multilingual abstract content - google/abstracttext",
                "fallback": "GitHub: google/abstracttext",
                "thumb_url": "https://avatars0.githubusercontent.com/u/1342004?s=400&v=4",
                "from_url": "https://github.com/google/abstracttext/blob/master/eneyj/docs/walkthrough.md",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/google/abstracttext/blob/master/eneyj/docs/walkthrough.md"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yF99",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQKHNP51"
                            },
                            {
                                "type": "text",
                                "text": " I am having trouble with the term knowledge representation for this case, but this is really a terminological issue. To make it short, yes, it will be able to execute.\n\nSo one possible user flow could be: hey, what's the reverse of my text? I go to the page for reverting a string, there's a box where I can enter my text, I copy and paste into it, click on \"go\", and it shows me the result.\n\nThe job posting will be a full stack developer on the MediaWiki extension we are building to support the wiki of functions, and on the evaluation engine to run the functions for the users. We are a small team, and we plan to grow, but for now we only have one engineer, and we need more. We will specialize later with more engineers, but for now we need someone who can help with everything, if that makes sense "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": "\n\nRegarding the lambda calculus, yes, take a look at this walkthrough through an earlier prototype, where in fact everything was built on lambda calculus: "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/google/abstracttext/blob/master/eneyj/docs/walkthrough.md"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601330319.057300",
        "parent_user_id": "U01AD80KMLK"
    },
    {
        "client_msg_id": "76076114-878C-47B4-8AD9-12CA2859F067",
        "type": "message",
        "text": "This is a very real issue already right now. I have tapes with scientific data written on a Cray X/MP in the 1990s. There are no tape readers for that format any more. For my DDS backup tapes, readers probably still exist somewhere, but I don\u201dt have access to them. And my Apple Keynote files from 2006 are unreadable with today\u2019s Keynote. It tells me to convert them using Keynote \u201809 - which is no longer available.\nI have moved all my important data to non-proprietary formats over the last years. That\u2019s no guarantee for preservation, but chances are much better.",
        "user": "UJBAJNFLK",
        "ts": "1601567010.120000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1601567072.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AKlW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a very real issue already right now. I have tapes with scientific data written on a Cray X/MP in the 1990s. There are no tape readers for that format any more. For my DDS backup tapes, readers probably still exist somewhere, but I don\u201dt have access to them. And my Apple Keynote files from 2006 are unreadable with today\u2019s Keynote. It tells me to convert them using Keynote \u201809 - which is no longer available.\nI have moved all my important data to non-proprietary formats over the last years. That\u2019s no guarantee for preservation, but chances are much better."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601503724.095900",
        "parent_user_id": "U019CPED6T1",
        "reactions": [
            {
                "name": "disappointed",
                "users": [
                    "U019CPED6T1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d448861a-c4b6-4986-a5d5-7e1b031161c3",
        "type": "message",
        "text": "<@UJN1TAYEQ> in the paper I linked, Algebraic Effects are applied in a functional language (and can express a purity much stronger than Haskell's). They can be arbitrarily fine-grained, and the calling context has full control over how the effects are expressed (so yes, you can tell what state is modified ;) ). It's semantically very close to returning actions, but with friendlier control flow.",
        "user": "U016VUZGUUQ",
        "ts": "1601578120.120600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u4E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " in the paper I linked, Algebraic Effects are applied in a functional language (and can express a purity much stronger than Haskell's). They can be arbitrarily fine-grained, and the calling context has full control over how the effects are expressed (so yes, you can tell what state is modified ;) ). It's semantically very close to returning actions, but with friendlier control flow."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1601468992.070500",
        "parent_user_id": "UBN9AFS0N"
    }
]