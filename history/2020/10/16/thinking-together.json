[
    {
        "client_msg_id": "4F6C7E37-78A3-466C-A733-91D9AF19A1E7",
        "type": "message",
        "text": "Totally agree with the above point about difficulty navigating layout you don\u2019t control with the keyboard. In general navigation seems to be the trickiest bit of making an application keyboard centric. On the keyboard the basic movement is really only (up, down, left, right) and if the layout makes it unclear where those directions will take you it\u2019s hard to make it feel really good/be usable. Fixed layout ui\u2019s can get away with some navigation that doesn\u2019t make as much sense since the user can gain familiarity.\n\nFluid layouts like a flowchart editor inherently dont have natural up/down/left/right navigation that will be quick and intuitive. I think the interaction model of jumping around to the nodes and edges of the flowchart is just not well suited to the keyboard as an input device. \n\nFor flowcharts + keyboard maybe the right approach is going with the \u2018grain\u2019 of the keyboard and build a really good graphviz (or graphviz like language) editor with augmented text as the primary interaction mode. And then have mouse manipulation as a secondary interaction for smaller layout tweaks. That way you could assemble graphs as fast as you can type. Another route would be to build on a different input device better suited to the task of flowchart construction like ipad",
        "user": "UBM0S2AN4",
        "ts": "1602826560.240200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBM0S2AN4",
            "ts": "1602826694.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lizg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally agree with the above point about difficulty navigating layout you don\u2019t control with the keyboard. In general navigation seems to be the trickiest bit of making an application keyboard centric. On the keyboard the basic movement is really only (up, down, left, right) and if the layout makes it unclear where those directions will take you it\u2019s hard to make it feel really good/be usable. Fixed layout ui\u2019s can get away with some navigation that doesn\u2019t make as much sense since the user can gain familiarity.\n\nFluid layouts like a flowchart editor inherently dont have natural up/down/left/right navigation that will be quick and intuitive. I think the interaction model of jumping around to the nodes and edges of the flowchart is just not well suited to the keyboard as an input device. \n\nFor flowcharts + keyboard maybe the right approach is going with the \u2018grain\u2019 of the keyboard and build a really good graphviz (or graphviz like language) editor with augmented text as the primary interaction mode. And then have mouse manipulation as a secondary interaction for smaller layout tweaks. That way you could assemble graphs as fast as you can type. Another route would be to build on a different input device better suited to the task of flowchart construction like ipad"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602079126.163600",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "a4a921ee-41c8-4fb3-8c2a-7cf7657bda36",
        "type": "message",
        "text": "I'm in the middle of writing an assembler for uCISC in uCISC assembly (bootstrapping a language is fun). I'm happy with the progress I'm making, but a few things are standing out. 1) structuring the code is challenging since I don't yet have the higher level language paradigms (don't even have function syntax sugar at the level I'm at right now). 2) stack counting is tedious and I constantly get it wrong. I'm wondering if there are any resources, techniques or ideas on how to structure assembly code effectively. I feel like this may be a bit of a lost art.",
        "user": "U015902ESJC",
        "ts": "1602828387.247700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o6aJp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm in the middle of writing an assembler for uCISC in uCISC assembly (bootstrapping a language is fun). I'm happy with the progress I'm making, but a few things are standing out. 1) structuring the code is challenging since I don't yet have the higher level language paradigms (don't even have function syntax sugar at the level I'm at right now). 2) stack counting is tedious and I constantly get it wrong. I'm wondering if there are any resources, techniques or ideas on how to structure assembly code effectively. I feel like this may be a bit of a lost art."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "reply_count": 7,
        "reply_users_count": 4,
        "latest_reply": "1602873028.260400",
        "reply_users": [
            "U015902ESJC",
            "UCUSW7WVD",
            "UUQ2EQW21",
            "UJN1TAYEQ"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "533c0f6c-9d23-41d5-b5b5-70e2f5e78074",
        "type": "message",
        "text": "Taking it a step further, I also realize that large computer systems need large complex structures to manage them. I'm wondering if, at some level, the complex structures in our higher level languages are only needed because of the large systems they were designed to enable.",
        "user": "U015902ESJC",
        "ts": "1602828417.247800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U015902ESJC",
            "ts": "1602828488.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=Dea",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Taking it a step further, I also realize that large computer systems need large complex structures to manage them. I'm wondering if, at some level, the complex structures in our higher level languages are only needed because of the large systems they were designed to enable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    },
    {
        "client_msg_id": "2ddbb268-39c5-4a77-b995-4bfdcfeef0e9",
        "type": "message",
        "text": "How many registers do you have at this point?\n\nWith 6 general-purpose registers (excluding stack management), I almost never had to use variables directly from the stack.",
        "user": "UCUSW7WVD",
        "ts": "1602832945.248100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8ChNN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How many registers do you have at this point?\n\nWith 6 general-purpose registers (excluding stack management), I almost never had to use variables directly from the stack."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    },
    {
        "client_msg_id": "f23d1203-e872-4389-af5d-32a9a3e42520",
        "type": "message",
        "text": "A left-field suggestion: Human Resource Machine winds up broadening your Assembly language skills.  I found I learned a lot of things I'd forgotten; and it's fun to play :wink: <https://tomorrowcorporation.com/humanresourcemachine>\nRegarding your stack problem, I'm wondering if you could write some helper subroutines to manage the stack?  A call to store the contents of the A register on the stack, for example, and one to retrieve it.  You could store a stack count and inc/dec it.  At the least you could error when you pop too far off the stack, etc.",
        "user": "UUQ2EQW21",
        "ts": "1602833461.248300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UUQ2EQW21",
            "ts": "1602833468.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xn5h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A left-field suggestion: Human Resource Machine winds up broadening your Assembly language skills.  I found I learned a lot of things I'd forgotten; and it's fun to play "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https://tomorrowcorporation.com/humanresourcemachine"
                            },
                            {
                                "type": "text",
                                "text": "\nRegarding your stack problem, I'm wondering if you could write some helper subroutines to manage the stack?  A call to store the contents of the A register on the stack, for example, and one to retrieve it.  You could store a stack count and inc/dec it.  At the least you could error when you pop too far off the stack, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UBSMEUXAA"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "48a4ac2e-f4f3-4793-80a8-1fc1bbf00545",
        "type": "message",
        "text": "Back in the old days, assembly languages were intended for use by human programmers, and they were more sophisticated than those of today, which are really only intended for compiler code generation. Macro assemblers allowed you to write and use macros such as IF, SWITCH, FOR, WHILE, PROC, CALL. Expression-oriented assemblers allowed you to write more than one arithmetic opcode on the same line, using a syntax similar to arithmetic expressions. Try googling \"macro assembler\" or \"high level assembler\". Consider adding macros or high level features to the uCISC assembler.",
        "user": "UJN1TAYEQ",
        "ts": "1602866455.249200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4frf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Back in the old days, assembly languages were intended for use by human programmers, and they were more sophisticated than those of today, which are really only intended for compiler code generation. Macro assemblers allowed you to write and use macros such as IF, SWITCH, FOR, WHILE, PROC, CALL. Expression-oriented assemblers allowed you to write more than one arithmetic opcode on the same line, using a syntax similar to arithmetic expressions. Try googling \"macro assembler\" or \"high level assembler\". Consider adding macros or high level features to the uCISC assembler."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    },
    {
        "client_msg_id": "ab565ad5-d363-4c61-9c3e-bc4ac1c98d3f",
        "type": "message",
        "text": "I've been starting to feel the need for macros in Mu, just because of the constraint that addresses can't escape functions.",
        "user": "UCUSW7WVD",
        "ts": "1602867094.249400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DL8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been starting to feel the need for macros in Mu, just because of the constraint that addresses can't escape functions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    },
    {
        "client_msg_id": "0A710165-9E99-4E7E-A58C-BE2E82CB76C6",
        "type": "message",
        "text": "<@UCUSW7WVD> I technically have 6 general purpose registers, but 3 are used for device access by convention. My guess is that I will end up being able to use 4 GP registers, one of which is the SP so an effective 3. One of the places I\u2019m finding challenging is the function call boundaries. I recently ended up with a method that eats 1 position off the stack somewhere, but the function works perfectly if you don\u2019t count the side effects. Then again, maybe I\u2019m just doing it wrong :thinking_face:.",
        "user": "U015902ESJC",
        "ts": "1602872638.256900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yOFg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " I technically have 6 general purpose registers, but 3 are used for device access by convention. My guess is that I will end up being able to use 4 GP registers, one of which is the SP so an effective 3. One of the places I\u2019m finding challenging is the function call boundaries. I recently ended up with a method that eats 1 position off the stack somewhere, but the function works perfectly if you don\u2019t count the side effects. Then again, maybe I\u2019m just doing it wrong "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    },
    {
        "client_msg_id": "A3861AD3-946D-44D0-A096-D271FE12F31F",
        "type": "message",
        "text": "<@UUQ2EQW21> <@UJN1TAYEQ> sounds like I just need to do the work for some macro basics. The lack of CALL macros in particular is tedious because there are a couple of boiler plate instructions needed to call a function and if I forget one, I just messed up my stack. Thanks for the tips. I\u2019ll check out the game for fun and profit and google macro assembler.",
        "user": "U015902ESJC",
        "ts": "1602873028.260400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U0sxe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UUQ2EQW21"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " sounds like I just need to do the work for some macro basics. The lack of CALL macros in particular is tedious because there are a couple of boiler plate instructions needed to call a function and if I forget one, I just messed up my stack. Thanks for the tips. I\u2019ll check out the game for fun and profit and google macro assembler."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1602828387.247700",
        "parent_user_id": "U015902ESJC"
    }
]