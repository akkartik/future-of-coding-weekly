[
    {
        "client_msg_id": "866053c4-49e5-44a6-bb54-3a2123d85fcb",
        "type": "message",
        "text": "I like everything except the relationship with typescript. But maybe that won't be as much of an issue in practice as I fear in theory.",
        "user": "UC2A2ARPT",
        "ts": "1590792529.274200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jCMX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like everything except the relationship with typescript. But maybe that won't be as much of an issue in practice as I fear in theory."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590787615.273300",
        "parent_user_id": "UFLN9JFRT"
    },
    {
        "client_msg_id": "83146895-241e-4ceb-be64-0e3c23bff43c",
        "type": "message",
        "text": "It has a lot of excellent improvements but historically, when there\u2019s \u201cthe thing that everyone uses\u201d versus \u201cthe thing that\u2019s pretty similar with incremental improvements\u201d, it\u2019s really hard for the 2nd thing to get traction",
        "user": "UETFVV24Q",
        "ts": "1590793906.274400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2FU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It has a lot of excellent improvements but historically, when there\u2019s \u201cthe thing that everyone uses\u201d versus \u201cthe thing that\u2019s pretty similar with incremental improvements\u201d, it\u2019s really hard for the 2nd thing to get traction"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590787615.273300",
        "parent_user_id": "UFLN9JFRT"
    },
    {
        "client_msg_id": "564d1ae2-fb83-427f-b41b-ec64735ede23",
        "type": "message",
        "text": "But Deno has a lot of good attention so maybe it will work out",
        "user": "UETFVV24Q",
        "ts": "1590793931.274600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4W05",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But Deno has a lot of good attention so maybe it will work out"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590787615.273300",
        "parent_user_id": "UFLN9JFRT"
    },
    {
        "client_msg_id": "2fce92b0-a909-4bce-ac00-7ff38108c046",
        "type": "message",
        "text": "dataflow programming tool built on top of the openFramework ecosystem:\u00a0<https://mosaic.d3cod3.org>",
        "user": "UES04SML7",
        "ts": "1590794965.275100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Mosaic",
                "title": "Mosaic, an openFrameworks based Visual Patching Creative-Coding Platform",
                "title_link": "https://mosaic.d3cod3.org/",
                "text": "Mosaic is an open source multi-platform (osx, linux, windows) live coding and visual programming application, based on openFrameworks.",
                "fallback": "Mosaic: Mosaic, an openFrameworks based Visual Patching Creative-Coding Platform",
                "thumb_url": "https://mosaic.d3cod3.org/images/mosaicLogo.png",
                "from_url": "https://mosaic.d3cod3.org/",
                "thumb_width": 128,
                "thumb_height": 128,
                "service_icon": "https://mosaic.d3cod3.org/images/apple-touch-icon.png",
                "id": 1,
                "original_url": "https://mosaic.d3cod3.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TXk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "dataflow programming tool built on top of the openFramework ecosystem:\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://mosaic.d3cod3.org"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U013HU44GLS",
                    "UBSMEUXAA"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "eb4c4fb9-4b5e-4f0f-846d-d706d2f53e10",
        "type": "message",
        "text": "sucks that building simple things to use is so hard these days",
        "user": "UES04SML7",
        "ts": "1590817865.275900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k0V/f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "sucks that building simple things to use is so hard these days"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590522102.229200",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "ae258cb8-4d77-4b31-bfc0-556d36efb0f2",
        "type": "message",
        "text": "dude\u2019s entire blog is full of gems",
        "user": "UES04SML7",
        "ts": "1590817937.276200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f4x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "dude\u2019s entire blog is full of gems"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590774956.270400",
        "parent_user_id": "U71PMQ1V0"
    },
    {
        "client_msg_id": "db394551-29f1-44f3-8f55-633b9178795f",
        "type": "message",
        "text": "<https://twitter.com/ocornut/status/1266416887082221568> that last note seems really crucial. i feel like programming tools developers have a ton to learn from game engine people",
        "user": "UES04SML7",
        "ts": "1590817980.277200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/ocornut|@ocornut>: There's an interesting look coming from many contents made in Dreams, which isn't only due to the great rendering engine (and lack of hard edges) but also the process of modeling with tools tightly designed around its tech. <https://twitter.com/edhargrave/status/1266407273657663494>",
                "ts": 1590772289,
                "author_name": "Omar",
                "author_link": "https://twitter.com/ocornut/status/1266416887082221568",
                "author_icon": "https://pbs.twimg.com/profile_images/622944390600732672/S6g469rf_normal.jpg",
                "author_subname": "@ocornut",
                "text": "There's an interesting look coming from many contents made in Dreams, which isn't only due to the great rendering engine (and lack of hard edges) but also the process of modeling with tools tightly designed around its tech. <https://twitter.com/edhargrave/status/1266407273657663494>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/ocornut/status/1266416887082221568",
                "id": 1,
                "original_url": "https://twitter.com/ocornut/status/1266416887082221568",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            },
            {
                "fallback": "<https://twitter.com/edhargrave|@edhargrave>: Sky squids, shields &amp; smartbombs #MadeInDreams #PS4share\n\n<https://store.playstation.com/#!/en-gb/tid=CUSA04301_00> <https://pbs.twimg.com/ext_tw_video_thumb/1266406966676643841/pu/img/ZYd0tYueo800IhC8.jpg>",
                "ts": 1590769997,
                "author_name": "ed",
                "author_link": "https://twitter.com/edhargrave/status/1266407273657663494",
                "author_icon": "https://pbs.twimg.com/profile_images/1247256130994257921/D9jhxKxK_normal.jpg",
                "author_subname": "@edhargrave",
                "text": "Sky squids, shields &amp; smartbombs #MadeInDreams #PS4share\n\n<https://store.playstation.com/#!/en-gb/tid=CUSA04301_00>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/edhargrave/status/1266407273657663494",
                "thumb_url": "https://pbs.twimg.com/ext_tw_video_thumb/1266406966676643841/pu/img/ZYd0tYueo800IhC8.jpg",
                "thumb_width": 1200,
                "thumb_height": 675,
                "video_html_width": 1200,
                "video_html_height": 675,
                "video_html": "<video controls poster=\"https://pbs.twimg.com/ext_tw_video_thumb/1266406966676643841/pu/img/ZYd0tYueo800IhC8.jpg\" width=\"1200\" height=\"675\"><source type=\"video/mp4\" src=\"https://video.twimg.com/ext_tw_video/1266406966676643841/pu/vid/1280x720/S2q_VRPBf3PrGGby.mp4?tag=10\"></video>",
                "indent": true,
                "color": "32BBF3",
                "id": 2,
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cuzO2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://twitter.com/ocornut/status/1266416887082221568"
                            },
                            {
                                "type": "text",
                                "text": " that last note seems really crucial. i feel like programming tools developers have a ton to learn from game engine people"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817980.277200",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1590892832.282500",
        "reply_users": [
            "UHWC9PXBL",
            "UEQ6M68H0"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL",
                    "UD31LGQKB"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "418c6a95-a80a-4053-8b64-4471d9d7f269",
        "type": "message",
        "text": "<@UCUSW7WVD> Yes, gensym for infix operators was what I was thinking of. But there is more:\n`(let ((fn (make-symbol \"foo-bar\")))`\n `(eval `(progn (defun ,fn () nil)`\n               `(,fn)))`\nThis must raise an error at some point - but where? Do you disallow making mixed symbols? Using them as function names? Calling the misnamed function?\n\nMy point is that in a language with Lisp-style meta-programming, any constraint on syntax percolates down to lower layers, with hard to foresee consequences. And that's why s-expressions are so hard to replace, in my opinion.",
        "user": "UJBAJNFLK",
        "ts": "1590823456.277400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1590823705.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yPef3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " Yes, gensym for infix operators was what I was thinking of. But there is more:\n"
                            },
                            {
                                "type": "text",
                                "text": "(let ((fn (make-symbol \"foo-bar\")))",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": " (eval `(progn (defun ,fn () nil)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "               (,fn)))",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nThis must raise an error at some point - but where? Do you disallow making mixed symbols? Using them as function names? Calling the misnamed function?\n\nMy point is that in a language with Lisp-style meta-programming, any constraint on syntax percolates down to lower layers, with hard to foresee consequences. And that's why s-expressions are so hard to replace, in my opinion."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "a92a1f60-174c-4cea-ae2a-1db7ca5fda62",
        "type": "message",
        "text": "<@UJN1TAYEQ> You can certainly define `[ ... ]`  as an alternative for `'( ... )`  and use it in printing. That leaves symbols requiring an explicit quote. But with the new list syntax, you have also broken homoiconicity a bit. Suppose you construct a list which you then turn into code by feeding it to `eval` : your list constructor now has a different aspect than code written by hand.",
        "user": "UJBAJNFLK",
        "ts": "1590823867.277800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M/H4I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " You can certainly define "
                            },
                            {
                                "type": "text",
                                "text": "[ ... ]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  as an alternative for "
                            },
                            {
                                "type": "text",
                                "text": "'( ... )",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  and use it in printing. That leaves symbols requiring an explicit quote. But with the new list syntax, you have also broken homoiconicity a bit. Suppose you construct a list which you then turn into code by feeding it to "
                            },
                            {
                                "type": "text",
                                "text": "eval",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " : your list constructor now has a different aspect than code written by hand."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "944f33b9-37a1-4100-ace7-cabb6402b2b2",
        "type": "message",
        "text": "There's no error there. It's just more inconvenient to call. If you create the symbol using `make-symbol` (or `sym` in Wart), you have to also refer to it the same way.\n```(eval `(def (foo a b) (let ,(sym \"a-b\") 34 ,(sym \"a-b\"))))\n(foo 8 9)\n=&gt; 34  # args are ignored```\nDoes this seem like a big problem? I've learned to expect that metaprogramming is a sharp tool that can get one in trouble.",
        "user": "UCUSW7WVD",
        "ts": "1590824797.278100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k=4s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's no error there. It's just more inconvenient to call. If you create the symbol using "
                            },
                            {
                                "type": "text",
                                "text": "make-symbol",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (or "
                            },
                            {
                                "type": "text",
                                "text": "sym",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in Wart), you have to also refer to it the same way.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(eval `(def (foo a b) (let ,(sym \"a-b\") 34 ,(sym \"a-b\"))))\n(foo 8 9)\n=> 34  # args are ignored"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nDoes this seem like a big problem? I've learned to expect that metaprogramming is a sharp tool that can get one in trouble."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "2ae94285-a97a-453d-bca8-ae84d4cf3e35",
        "type": "message",
        "text": "Can confirm.",
        "user": "UA14TGLTC",
        "ts": "1590838636.278400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Z61",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can confirm."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590774956.270400",
        "parent_user_id": "U71PMQ1V0"
    },
    {
        "client_msg_id": "50d24f0b-4ab6-4767-9e19-0f8ce2d7b24e",
        "type": "message",
        "text": "The rationale for Sweet-Expressions begins with \"Many software developers find Lisp s-expression notation inconvenient and unpleasant to read.\" And continues with \"Mainstream adoption will, however, always be curtailed by the syntax.\". I think that Sweet-Expressions fails at the goal of finding a syntax that makes Lisp acceptable to the mainstream, and I think this failure is due in part to not having a full understanding of what the problems are with Lisp syntax (from a mainstream perspective). The proposal's author boils down the issues to (1) a lack of infix notation, and (2) too many parentheses, which can be fixed by indentation as syntax. This is not the complete set: the Philip Wadler paper I cited earlier discusses additional issues.",
        "user": "UJN1TAYEQ",
        "ts": "1590850519.278700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AI8Ku",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The rationale for Sweet-Expressions begins with \"Many software developers find Lisp s-expression notation inconvenient and unpleasant to read.\" And continues with \"Mainstream adoption will, however, always be curtailed by the syntax.\". I think that Sweet-Expressions fails at the goal of finding a syntax that makes Lisp acceptable to the mainstream, and I think this failure is due in part to not having a full understanding of what the problems are with Lisp syntax (from a mainstream perspective). The proposal's author boils down the issues to (1) a lack of infix notation, and (2) too many parentheses, which can be fixed by indentation as syntax. This is not the complete set: the Philip Wadler paper I cited earlier discusses additional issues."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "9e9c229c-2419-4038-9aa3-8dd706662ce7",
        "type": "message",
        "text": "One of the problems with Lisp syntax is in the way values are printed. Mainstream languages print values as constructor expressions. Lisp prints values as the code that would be executed by the evaluator, if the value was passed to `eval`. When I suggested how to fix Lisp, <@UJBAJNFLK> replied that \"you have broken homoiconicity a bit\". So this is a tradeoff in syntax design. Lisp syntax is designed to make metaprogramming easier, *at the expense of* making ordinary, non-metaprogramming more difficult.",
        "user": "UJN1TAYEQ",
        "ts": "1590850920.278900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UQEr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of the problems with Lisp syntax is in the way values are printed. Mainstream languages print values as constructor expressions. Lisp prints values as the code that would be executed by the evaluator, if the value was passed to "
                            },
                            {
                                "type": "text",
                                "text": "eval",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". When I suggested how to fix Lisp, "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " replied that \"you have broken homoiconicity a bit\". So this is a tradeoff in syntax design. Lisp syntax is designed to make metaprogramming easier, "
                            },
                            {
                                "type": "text",
                                "text": "at the expense of",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " making ordinary, non-metaprogramming more difficult."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "C8D8C36A-5853-4FD3-9A95-3D8AA2D0DAC3",
        "type": "message",
        "text": "the sound design is SO GOOD in that example. amazing how holistic the tooling is ",
        "user": "UHWC9PXBL",
        "ts": "1590852790.280000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AKR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the sound design is SO GOOD in that example. amazing how holistic the tooling is "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817980.277200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "d5e90876-7066-4a56-844b-4e0663c2143b",
        "type": "message",
        "text": "<@UCUSW7WVD> So how do you print those symbols then? As (sym \"a-b\") as well?",
        "user": "UJBAJNFLK",
        "ts": "1590864211.280200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PKTo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " So how do you print those symbols then? As (sym \"a-b\") as well?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "ce3786eb-d837-4fef-8ec3-f8ea9a2e7970",
        "type": "message",
        "text": "No, they print as `a-b`. Construction happens after the read phase. Infix expansion happens during the read phase.",
        "user": "UCUSW7WVD",
        "ts": "1590864265.280400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BBa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No, they print as "
                            },
                            {
                                "type": "text",
                                "text": "a-b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Construction happens after the read phase. Infix expansion happens during the read phase."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "8619112b-89d0-49e6-a109-c68e41b19dc1",
        "type": "message",
        "text": "<@UJN1TAYEQ> That sounds like a good summary of the trade-off. I doubt it was a conscious decision for Lisp, more like a tacit priority.",
        "user": "UJBAJNFLK",
        "ts": "1590864268.280600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kLFr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " That sounds like a good summary of the trade-off. I doubt it was a conscious decision for Lisp, more like a tacit priority."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "c8b80b01-5db9-4f5c-ab8d-970f2ac2aaef",
        "type": "message",
        "text": "<@UCUSW7WVD> OK, so you accept to print notation that cannot be read. Fair enough.",
        "user": "UJBAJNFLK",
        "ts": "1590864322.280800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sW4YY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " OK, so you accept to print notation that cannot be read. Fair enough."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN",
        "reactions": [
            {
                "name": "slightly_smiling_face",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7ce4be43-55a5-4836-ae65-1e85093c32f5",
        "type": "message",
        "text": "I see. Cross-talk between Doug's goals and mine. Thank you!",
        "user": "UCUSW7WVD",
        "ts": "1590864434.281100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ruey",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I see. Cross-talk between Doug's goals and mine. Thank you!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "fb68fff8-2a80-4baa-a282-ebeb5d7691b9",
        "type": "message",
        "text": "On the topic of arithmetic and infix operators: I spent a lot of time researching this for my Leibniz project, which is all about mathematics, with lots of operators. Any identifier can be used as an infix operators. Initially, I followed APL and Smalltalk in adopting a no-precedence left-to-right evaluation (APL is right-to-left). But then Shriram Krishnamurthi pointed me to the approach he had taken in his Pycket language (designed for teaching), which I adopted immediately and so far without regrets.\nThe rule is simple: an expression with more than one infix operator requires parentheses for disambiguation. So, no precedence, nor left-to-right. The one exception is a chain of identical infix operators. So you can write `2 + 3 + 4 + 4` , which is parsed left-to-right. The net outcome is that you can read expressions as if they used traditional maths rules, but you don't need to remember precedence rules. And due to the same-operator exception, the number of parentheses remains very reasonable.",
        "user": "UJBAJNFLK",
        "ts": "1590864965.281300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DpWHa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the topic of arithmetic and infix operators: I spent a lot of time researching this for my Leibniz project, which is all about mathematics, with lots of operators. Any identifier can be used as an infix operators. Initially, I followed APL and Smalltalk in adopting a no-precedence left-to-right evaluation (APL is right-to-left). But then Shriram Krishnamurthi pointed me to the approach he had taken in his Pycket language (designed for teaching), which I adopted immediately and so far without regrets.\nThe rule is simple: an expression with more than one infix operator requires parentheses for disambiguation. So, no precedence, nor left-to-right. The one exception is a chain of identical infix operators. So you can write "
                            },
                            {
                                "type": "text",
                                "text": "2 + 3 + 4 + 4",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " , which is parsed left-to-right. The net outcome is that you can read expressions as if they used traditional maths rules, but you don't need to remember precedence rules. And due to the same-operator exception, the number of parentheses remains very reasonable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c1896266-483e-47c3-b56a-854b00f559a7",
        "type": "message",
        "text": "That is indeed clean and easy to explain.",
        "user": "UCUSW7WVD",
        "ts": "1590865332.281600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KJ+Ck",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is indeed clean and easy to explain."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "fca87066-bd39-43f6-a66d-230949598f17",
        "type": "message",
        "text": "Thanks Konrad. I'm looking at Leibnitz right now (<http://khinsen.net/leibniz/>). A small correction: Leibnitz borrows its infix precedence rules from *Pyret* (<http://pyret.org|pyret.org>), not Pycket.",
        "user": "UJN1TAYEQ",
        "ts": "1590868774.281800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rdF6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks Konrad. I'm looking at Leibnitz right now ("
                            },
                            {
                                "type": "link",
                                "url": "http://khinsen.net/leibniz/"
                            },
                            {
                                "type": "text",
                                "text": "). A small correction: Leibnitz borrows its infix precedence rules from "
                            },
                            {
                                "type": "text",
                                "text": "Pyret",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ("
                            },
                            {
                                "type": "link",
                                "url": "http://pyret.org",
                                "text": "pyret.org"
                            },
                            {
                                "type": "text",
                                "text": "), not Pycket."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    }
]