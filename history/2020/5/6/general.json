[
    {
        "client_msg_id": "4b635211-e5fe-44d1-b6bb-4b8b336c8ad6",
        "type": "message",
        "text": "Also, vertical tabs. Also, diagonal tabs.",
        "user": "UC2A2ARPT",
        "ts": "1588716626.052600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Oq9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, vertical tabs. Also, diagonal tabs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "star-struck",
                "users": [
                    "UMWF81HTP",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0045d7e7-25c7-4968-9845-b510d5d76468",
        "type": "message",
        "text": "I vertically-align my code cos I've got a touch of OCD. Plus it's easier to read :smile:",
        "user": "UE6EFEPTQ",
        "ts": "1588720223.052900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UiH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I vertically-align my code cos I've got a touch of OCD. Plus it's easier to read "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "eca935bc-cc8f-497f-a2f7-efa265109541",
        "type": "message",
        "text": "<@UKDM3GLAJ> yes, an object graph!  Though <@UTG9XLGKZ> is driving at a canonical spanning tree and the idea of zooming parts of it more than others.",
        "user": "UA14TGLTC",
        "ts": "1588735074.053400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uY/XZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " yes, an object graph!  Though "
                            },
                            {
                                "type": "user",
                                "user_id": "UTG9XLGKZ"
                            },
                            {
                                "type": "text",
                                "text": " is driving at a canonical spanning tree and the idea of zooming parts of it more than others."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588677125.006200",
        "parent_user_id": "UTG9XLGKZ"
    },
    {
        "client_msg_id": "3563187a-a475-4f4c-8ae4-25ec35923487",
        "type": "message",
        "text": "Tabs inline so that\n```x              = f(whatever)\nx_             = g(x)\nsomething_else = q(x, x_)```\nlines up nicely.  :wolf:",
        "user": "UA14TGLTC",
        "ts": "1588735337.053800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k=a0Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Tabs inline so that\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "x              = f(whatever)\nx_             = g(x)\nsomething_else = q(x, x_)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "lines up nicely.  "
                            },
                            {
                                "type": "emoji",
                                "name": "wolf"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "8338785d-4846-4f47-94bd-58a7b2053816",
        "type": "message",
        "text": "Folks we need a tabs v spaces channel.",
        "user": "U8A5MS6R1",
        "ts": "1588735721.054000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vu4QP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Folks we need a tabs v spaces channel."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "tada",
                "users": [
                    "UA14TGLTC",
                    "UJ6LDMMN0",
                    "UHWC9PXBL"
                ],
                "count": 3
            },
            {
                "name": "boom",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0b0db85a-f718-48cc-b279-63ceafabbb2b",
        "type": "message",
        "text": "On spaces vs tabs: how about neither? I'd prefer a projectional editor that automatically formats my program to fit the current window width. Word processors can do this, and more: you can even insert diagrams and images into a document. Imagine the possibilities if we could use this 1980's technology for writing code, instead of editing virtual punch-card decks on our 4K retina displays.",
        "user": "UJN1TAYEQ",
        "ts": "1588737602.054300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E7D",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On spaces vs tabs: how about neither? I'd prefer a projectional editor that automatically formats my program to fit the current window width. Word processors can do this, and more: you can even insert diagrams and images into a document. Imagine the possibilities if we could use this 1980's technology for writing code, instead of editing virtual punch-card decks on our 4K retina displays."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U5STGTB3J",
                    "U79HM6726",
                    "UA14TGLTC",
                    "UKDM3GLAJ",
                    "UHWC9PXBL",
                    "U85HCL7JP"
                ],
                "count": 6
            }
        ]
    },
    {
        "client_msg_id": "aea8ba67-87c0-441d-b636-df3f153c1e20",
        "type": "message",
        "text": "Totally on board with projectional editing! Inline diagram and image 'literals' sound pretty good to me.",
        "user": "U8A5MS6R1",
        "ts": "1588738070.054500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OLSO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Totally on board with projectional editing! Inline diagram and image 'literals' sound pretty good to me."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "478d9d57-0316-4cba-aee7-983090487ab1",
        "type": "message",
        "text": "I am planning for the world of proportional fonts. Fixed Width is archaic, however, there is no default OS font that is proportional that is any good with punctuation.",
        "user": "UEQ6M68H0",
        "ts": "1588738913.054700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PqTqc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am planning for the world of proportional fonts. Fixed Width is archaic, however, there is no default OS font that is proportional that is any good with punctuation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U79HM6726",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e6e14087-f84d-4b5a-b5c0-6fab018e3343",
        "type": "message",
        "text": "I think to be fair to Chis Lattner, he did say quite early on that he wanted Swift to be \"everywhere\", so Swift may be bad, but at least it is holding true to it's promise of \"trying\" to be everywhere. The same could be said about alot of other languages which are ubiquitous and have accumulated alot of junk over the years. I guess languages are like all software products. Everyone uses only 20% of the features, but it is always a different 20% than everyone else, so the software \"appears\" to gain bloat",
        "user": "UFLN9JFRT",
        "ts": "1588741173.068900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFLN9JFRT",
            "ts": "1588741314.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ktf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think to be fair to Chis Lattner, he did say quite early on that he wanted Swift to be \"everywhere\", so Swift may be bad, but at least it is holding true to it's promise of \"trying\" to be everywhere. The same could be said about alot of other languages which are ubiquitous and have accumulated alot of junk over the years. I guess languages are like all software products. Everyone uses only 20% of the features, but it is always a different 20% than everyone else, so the software \"appears\" to gain bloat"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588464075.440000",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "85ffa104-cd8c-4de0-a199-bb6047d68654",
        "type": "message",
        "text": "I'd like it to be possible to program in Hest without seeing any text whatsoever. That's one reason why it's a drawing tool.",
        "user": "UC2A2ARPT",
        "ts": "1588741357.071900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1vNU9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd like it to be possible to program in Hest without seeing any text whatsoever. That's one reason why it's a drawing tool."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "0d208720-2c48-41f8-aead-cc7c59cda426",
        "type": "message",
        "text": "Warning: shower thoughts lie ahead.\n\nI've been struck with the nagging thought that maybe \"FoC\" general-purpose languages (targeting extreme accessibility) have to be designed in such a way that they can run on (modern) GPUs rather than just CPUs. Even integrated GPUs nowadays have a minimum of 200-400 general purpose cores (albeit with a slant towards certain operations). We don't really know how to use those cores effectively for general purpose tasks because we're normally trying to program them using a C dialect (e.g. via CUDA, OpenCL, GLSL...). It's the same problem we have with multicore CPUs: writing massively-parallelizable code in an imperative language is (too) challenging, and we've known for decades that we'll need to solve the problem eventually, since parallelization is the only way to scale computation once we're building circuits out of individual atoms.\n\nOnly languages based on constructs that are implicitly parallelizable are going to be able to target GPUs effectively whilst remaining highly accessible. The alternative is to ask the user to explicitly divide their computation up into parallelizable work units (threads/actors), which is an immediate complexity trap. Programmer-led task division doesn't scale, and it's a deep rabbit hole that can require a PhD to be done effectively.\n\nSome people might argue that parallelization is a performance optimization and that most end-user apps don't need it, but I think there are many occasions where the ceiling of what's possible is just too low to offer a bright future. There are always occasions where someone comes up with a need like \"I want to process this entire spreadsheet / note collection / webpage\" or \"I want to make a picture\" or \"I want to do a simulation / animation of my idea\", and they want that processing to be interactive (implying instantaneous), at which point most serial languages can't handle what's being asked for.\n\nSo, must a new generation of accessible programming languages be based on implicitly parallelizable constructs and 400 cores? The hardware APIs we need (Vulkan, WebGPU...) are finally becoming available. We just need to utilize them half-decently.",
        "user": "UCGAK10LS",
        "ts": "1588742541.079700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6ov3M",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Warning: shower thoughts lie ahead.\n\nI've been struck with the nagging thought that maybe \"FoC\" general-purpose languages (targeting extreme accessibility) have to be designed in such a way that they can run on (modern) GPUs rather than just CPUs. Even integrated GPUs nowadays have a minimum of 200-400 general purpose cores (albeit with a slant towards certain operations). We don't really know how to use those cores effectively for general purpose tasks because we're normally trying to program them using a C dialect (e.g. via CUDA, OpenCL, GLSL...). It's the same problem we have with multicore CPUs: writing massively-parallelizable code in an imperative language is (too) challenging, and we've known for decades that we'll need to solve the problem eventually, since parallelization is the only way to scale computation once we're building circuits out of individual atoms.\n\nOnly languages based on constructs that are implicitly parallelizable are going to be able to target GPUs effectively whilst remaining highly accessible. The alternative is to ask the user to explicitly divide their computation up into parallelizable work units (threads/actors), which is an immediate complexity trap. Programmer-led task division doesn't scale, and it's a deep rabbit hole that can require a PhD to be done effectively.\n\nSome people might argue that parallelization is a performance optimization and that most end-user apps don't need it, but I think there are many occasions where the ceiling of what's possible is just too low to offer a bright future. There are always occasions where someone comes up with a need like \"I want to process this entire spreadsheet / note collection / webpage\" or \"I want to make a picture\" or \"I want to do a simulation / animation of my idea\", and they want that processing to be interactive (implying instantaneous), at which point most serial languages can't handle what's being asked for.\n\nSo, must a new generation of accessible programming languages be based on implicitly parallelizable constructs and 400 cores? The hardware APIs we need (Vulkan, WebGPU...) are finally becoming available. We just need to utilize them half-decently."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "reply_count": 57,
        "reply_users_count": 11,
        "latest_reply": "1588951016.250700",
        "reply_users": [
            "UCGAK10LS",
            "U8A5MS6R1",
            "UA14TGLTC",
            "U5STGTB3J",
            "UE6EFEPTQ",
            "UJN1TAYEQ",
            "U71PMQ1V0",
            "UBSMEUXAA",
            "UHWC9PXBL",
            "UD6EXQVM0",
            "UAVCC2X70"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UUK6Y29R8",
                    "UFLN9JFRT"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UJN1TAYEQ",
                    "UFLN9JFRT",
                    "UAVCC2X70",
                    "UNV27TUKA"
                ],
                "count": 4
            },
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "UBSMEUXAA"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d8c8f8ee-b4ba-478f-9c97-52d9d5e9dd6f",
        "type": "message",
        "text": "Non-parallelizable language constructs include call stacks/top-down recursion, and hierarchical data structures (anything based on unidirectional pointers and singular access paths).",
        "user": "UCGAK10LS",
        "ts": "1588742811.079800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1588742960.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5Qc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Non-parallelizable language constructs include call stacks/top-down recursion, and hierarchical data structures (anything based on unidirectional pointers and singular access paths)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "type": "message",
        "text": "Without text complex expressions will be harder to understand. There are limits to comprehension without text. We learned this in the old days, because we had our trusty IBM flowcharting templates, and their pads of flowcharting paper, and once the program got past a certain point of complexity, the flowchart became fairly useless. They tried making FORTRAN auto-flowcharters, but it became what a tangle of wires. Scratch shows that you can avoid textual forms, but once programs get larger Scratch isn't so great. I do think with zooming and encapsulation of sub-areas a reasonable compromise can be reached.  I had this template. So classy, with the sleeve and all, and the legend on the back. There has never been a classier company than IBM to my knowledge. HP was very good, but IBM at its peak is the pinnacle of technological excellence in the smallest details.",
        "files": [
            {
                "id": "F013AF6PGVA",
                "created": 1588743669,
                "timestamp": 1588743669,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UEQ6M68H0",
                "editable": false,
                "size": 4956128,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F013AF6PGVA/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F013AF6PGVA/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 268,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 358,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 537,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 596,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 716,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F013AF6PGVA-4837cb408c/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 763,
                "original_w": 2000,
                "original_h": 1491,
                "thumb_tiny": "AwAjADC7IyiXDZ6dqYGTDH5vanSbvOypAOO9NAJDLvAGec96RIEjYAA240jsONhI9c07c5AYuuRnAoKDIbeMk/lQAhdONu4+vNPiyspUnOVzSP8AeX96PrjpSW4+cnOSR+VAxssjC5C5GOOMVOAP7oqCdgblFxyCOanFEgQ1cFQSB+VKQApOB0pE+4OKc33T9KQCAAgfKKcAA3AApq/dHHanD7woGVJv+P0fUVaqrN/x+j6irVORK6gn3RSH7p+lKv3RQehqSgH3R9KUfeFIPuj6Uo+8KOoH/9k=",
                "permalink": "https://futureofcoding.slack.com/files/UEQ6M68H0/F013AF6PGVA/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F013AF6PGVA-52abf63566",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z6F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Without text complex expressions will be harder to understand. There are limits to comprehension without text. We learned this in the old days, because we had our trusty IBM flowcharting templates, and their pads of flowcharting paper, and once the program got past a certain point of complexity, the flowchart became fairly useless. They tried making FORTRAN auto-flowcharters, but it became what a tangle of wires. Scratch shows that you can avoid textual forms, but once programs get larger Scratch isn't so great. I do think with zooming and encapsulation of sub-areas a reasonable compromise can be reached.  I had this template. So classy, with the sleeve and all, and the legend on the back. There has never been a classier company than IBM to my knowledge. HP was very good, but IBM at its peak is the pinnacle of technological excellence in the smallest details."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UEQ6M68H0",
        "display_as_bot": false,
        "ts": "1588743680.080200",
        "client_msg_id": "0724900f-4ae0-4fdf-960c-cab80a06a147",
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "3d8bf18e-2a5c-44cc-b620-7abb02680da2",
        "type": "message",
        "text": "I agree. One problem we have is our languages end up expressing a lot more than we need to. E.g. sequential imperative langs specify the order of execution even when it is not necessary (and then compliers get more complicated trying to unravel the data flow to optimize). Even with parallelelizable constructs, I think we'd want to minimize the inter 'cell' communication for practical reasons.",
        "user": "U8A5MS6R1",
        "ts": "1588743798.080600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iPnx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree. One problem we have is our languages end up expressing a lot more than we need to. E.g. sequential imperative langs specify the order of execution even when it is not necessary (and then compliers get more complicated trying to unravel the data flow to optimize). Even with parallelelizable constructs, I think we'd want to minimize the inter 'cell' communication for practical reasons."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS",
                    "UA14TGLTC",
                    "UC2A2ARPT",
                    "UBSMEUXAA"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "120f5993-e5d5-4c6e-9535-f27e71734933",
        "type": "message",
        "text": "I think the problem is often trying to extract a graphical model from a textual one. It might be interesting to see what we get if we start with a graphical canvas and visuals and see what kinds of things can be expressed (graphical first). I'm not particularly against text but I'm interested to see where Hest goes. I like hybrid models which is text arranged in various ways outside the 'linear sequence file' limitation. A good example is Subtext 2 - the 'table' layout is much neater and easier to follow than a long series of nested conditionals.",
        "user": "U8A5MS6R1",
        "ts": "1588744225.080800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MiXW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the problem is often trying to extract a graphical model from a textual one. It might be interesting to see what we get if we start with a graphical canvas and visuals and see what kinds of things can be expressed (graphical first). I'm not particularly against text but I'm interested to see where Hest goes. I like hybrid models which is text arranged in various ways outside the 'linear sequence file' limitation. A good example is Subtext 2 - the 'table' layout is much neater and easier to follow than a long series of nested conditionals."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UVCBBRG3G",
                    "UC2A2ARPT",
                    "UHWC9PXBL"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "87c36719-7c59-4c25-939e-12d75d38bb7d",
        "type": "message",
        "text": "&gt; One giant tree can hold all your data\n<@UTG9XLGKZ> yes, this! I call it a multidimensional tree, but this is what my project is all about, one single tree that is connected back and forth to all - tho having it directly circular like the example means you\u2019ll have a hard time serializing it and updating it. the  real structure in the backing should not be circular by reference like that but its more or less it. Great to see people thinking similarly!",
        "user": "UNBPP291C",
        "ts": "1588746166.081000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Asl",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One giant tree can hold all your data"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UTG9XLGKZ"
                            },
                            {
                                "type": "text",
                                "text": " yes, this! I call it a multidimensional tree, but this is what my project is all about, one single tree that is connected back and forth to all - tho having it directly circular like the example means you\u2019ll have a hard time serializing it and updating it. the  real structure in the backing should not be circular by reference like that but its more or less it. Great to see people thinking similarly!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588677125.006200",
        "parent_user_id": "UTG9XLGKZ"
    },
    {
        "client_msg_id": "edea55e4-541b-497d-b8b2-b2bc8e5c7709",
        "type": "message",
        "text": "Yeah, sequences of instructions are a non-starter. I'm skeptical of the concept of \"cells\" too, though I'm not sure what you're thinking of. Cells = objects = actors (executing independently) are a form of explicit parallelization, even if you can justify them as representing parts of the problem domain (as OOP has always tried to do).",
        "user": "UCGAK10LS",
        "ts": "1588746733.081300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1588746964.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q4E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, sequences of instructions are a non-starter. I'm skeptical of the concept of \"cells\" too, though I'm not sure what you're thinking of. Cells = objects = actors (executing independently) are a form of explicit parallelization, even if you can justify them as representing parts of the problem domain (as OOP has always tried to do)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b2ba794e-6210-4f05-ba5c-813d501ea147",
        "type": "message",
        "text": "I'll agree, but maybe for a funny reason.  With at the level of most FoC projects, the execution model of hardware isn't of primary concern.  Most of us aren't aiming for portable assembly, rather something confluent with people's ways of thinking about problems.  Many things we want to express are non-strict: you want the computer to help you figure out something, but you don't care the order it computes things in so long as it remains responsive while working.",
        "user": "UA14TGLTC",
        "ts": "1588747754.081700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hYY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll agree, but maybe for a funny reason.  With at the level of most FoC projects, the execution model of hardware isn't of primary concern.  Most of us aren't aiming for portable assembly, rather something confluent with people's ways of thinking about problems.  Many things we want to express are non-strict: you want the computer to help you figure out something, but you don't care the order it computes things in so long as it remains responsive while working."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cfe26799-b192-41ab-b6a9-f2726166e4f8",
        "type": "message",
        "text": "My perspective is: you can't be confluent with someone's way of thinking if you're asking them to express their thinking in terms of 400 parallelizable units (in order for their idea to be feasible to execute).",
        "user": "UCGAK10LS",
        "ts": "1588747939.081900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WoDlg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My perspective is: you can't be confluent with someone's way of thinking if you're asking them to express their thinking in terms of 400 parallelizable units (in order for their idea to be feasible to execute)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ad347f3d-add7-4249-bdc1-6c95a74a8fbf",
        "type": "message",
        "text": "On the other hand, there are domains where you are describing a step-by-step process: be it card games or an assembly line.  However, in this these cases.  The domain specific imperative steps probably should not line up with some sort of CPU threaded execution mechanism.",
        "user": "UA14TGLTC",
        "ts": "1588747965.082100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t9xG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the other hand, there are domains where you are describing a step-by-step process: be it card games or an assembly line.  However, in this these cases.  The domain specific imperative steps probably should not line up with some sort of CPU threaded execution mechanism."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b3ccb0e5-6cfc-4702-afc7-a25d42128b09",
        "type": "message",
        "text": "<@UCGAK10LS> the kinds of things that I've done which parallelize to 400 units are all of the form, \"check all the combinations and tell me the best fit.\"  And you don't even want the computers to check all the combinations because there's way too many.",
        "user": "UA14TGLTC",
        "ts": "1588748097.082300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/0cyo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " the kinds of things that I've done which parallelize to 400 units are all of the form, \"check all the combinations and tell me the best fit.\"  And you don't even want the computers to check all the combinations because there's way too many."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0a17d2ad-1d53-40f7-86e0-bcae2d6071b3",
        "type": "message",
        "text": "I mean to *actually* check them all.",
        "user": "UA14TGLTC",
        "ts": "1588748118.082500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IpAUg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mean to "
                            },
                            {
                                "type": "text",
                                "text": "actually",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " check them all."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6045202D-AB58-489C-B88C-F6409C8E736B",
        "type": "message",
        "text": "<@UCGAK10LS> Why do you see the solution to this problem at the language design and not on the library level?",
        "user": "U5STGTB3J",
        "ts": "1588750144.084000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k1gV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " Why do you see the solution to this problem at the language design and not on the library level?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "72999F6E-B261-429F-972C-70E750E523C3",
        "type": "message",
        "text": "<@U5STGTB3J> What\u2019s the difference between a library and a language? If the library is offering parallel computation, then the library will need to offer a language (API) to express the computation. Libraries don\u2019t help solve the problem.",
        "user": "UCGAK10LS",
        "ts": "1588750377.086900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QfR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " What\u2019s the difference between a library and a language? If the library is offering parallel computation, then the library will need to offer a language (API) to express the computation. Libraries don\u2019t help solve the problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "D7685124-DD9D-4B27-933A-8F0BCB064B42",
        "type": "message",
        "text": "Also, libraries are usually designed to solve a specific problem (e.g. graphics, or matrix multiplication). If you want your arbitrary domain problems to be parallelised, you need to express them in terms of more general constructs. Those constructs are something a programming language is supposed to provide.",
        "user": "UCGAK10LS",
        "ts": "1588750494.091500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1588752783.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "h7J4b",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, libraries are usually designed to solve a specific problem (e.g. graphics, or matrix multiplication). If you want your arbitrary domain problems to be parallelised, you need to express them in terms of more general constructs. Those constructs are something a programming language is supposed to provide."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "89F99AFC-C752-4BC0-95AB-617DCC655C9A",
        "type": "message",
        "text": "Hmm\u2026 not sure I can follow. How can you solve an arbitrary problem with parallelization? Wouldn\u2019t you have to know enough about it so it becomes domain-specific? At least specific enough to know if it makes sense to run it on GPU cores such that the setup costs are amortized?",
        "user": "U5STGTB3J",
        "ts": "1588751284.102400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TjAP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm\u2026 not sure I can follow. How can you solve an arbitrary problem with parallelization? Wouldn\u2019t you have to know enough about it so it becomes domain-specific? At least specific enough to know if it makes sense to run it on GPU cores such that the setup costs are amortized?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7C960576-353B-45B8-B31D-28233B267DC4",
        "type": "message",
        "text": "There are libraries today that do exactly that transparently based on context like the amount of data to be crunched, so you as the developer don\u2019t have to make that distinction\u2026 so I guess my question is \u2014 slightly reworded \u2014 what benefits would a language offer over a library for an already existing language? It seems a lot of work to invent a new language if you can just import a library\u2026",
        "user": "U5STGTB3J",
        "ts": "1588751563.107700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "semw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There are libraries today that do exactly that transparently based on context like the amount of data to be crunched, so you as the developer don\u2019t have to make that distinction\u2026 so I guess my question is \u2014 slightly reworded \u2014 what benefits would a language offer over a library for an already existing language? It seems a lot of work to invent a new language if you can just import a library\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6a73b0c8-73ca-4ff4-8b6b-ba8e5a554aec",
        "type": "message",
        "text": "If you run a whole app on the GPU then setup costs are less of a problem (from what I know). Setup costs are a problem when you try and do some tasks on the GPU and some on the CPU, and they have to constantly communicate. Setup costs are also higher in outdated APIs like OpenGL, and very low in newer APIs since the GPU program is compiled at app startup rather than mid-frame.",
        "user": "UCGAK10LS",
        "ts": "1588751772.108000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F3z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you run a whole app on the GPU then setup costs are less of a problem (from what I know). Setup costs are a problem when you try and do some tasks on the GPU and some on the CPU, and they have to constantly communicate. Setup costs are also higher in outdated APIs like OpenGL, and very low in newer APIs since the GPU program is compiled at app startup rather than mid-frame."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0F9640D2-4E5A-4BFC-9122-E08752681833",
        "type": "message",
        "text": "Or at program compile time even. \nSo do I understand you correctly that you want a programming language that does everything on the GPU?",
        "user": "U5STGTB3J",
        "ts": "1588752031.109700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=AC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Or at program compile time even. \nSo do I understand you correctly that you want a programming language that does everything on the GPU?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0c2e456a-d3e6-4759-b4f4-7acdfbbe021f",
        "type": "message",
        "text": "To have everyday computations be massively parallelizable they firstly need to be large enough that it matters. If your app is just a digital clock (incrementing a counter), then yeah, it can't be parallelized and it doesn't need to be.\nOnce you have a computation large enough to be worth parallelizing, then automatic parallelization depends on having the problem expressed in a form that does not introduce artificial sequentiality (i.e. avoids instruction sequences, top-down recursion, and hierarchical data structures). What these constructs should be is an open problem. I have a hunch that relational/logic languages provide a good foundation and we need some novel ideas atop that foundation. That's what I've been focusing on for the last six months. I'm hoping to be able to share more at some point, if I find a promising path.",
        "user": "UCGAK10LS",
        "ts": "1588752032.109900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1588752226.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "alCz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To have everyday computations be massively parallelizable they firstly need to be large enough that it matters. If your app is just a digital clock (incrementing a counter), then yeah, it can't be parallelized and it doesn't need to be.\nOnce you have a computation large enough to be worth parallelizing, then automatic parallelization depends on having the problem expressed in a form that does not introduce artificial sequentiality (i.e. avoids instruction sequences, top-down recursion, and hierarchical data structures). What these constructs should be is an open problem. I have a hunch that relational/logic languages provide a good foundation and we need some novel ideas atop that foundation. That's what I've been focusing on for the last six months. I'm hoping to be able to share more at some point, if I find a promising path."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "065f9cea-24af-44a0-b019-4ed793aa5707",
        "type": "message",
        "text": "Yes, I want to _consider_ a language that does everything on the GPU that is possible with today's hardware.",
        "user": "UCGAK10LS",
        "ts": "1588752145.110300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p2U=6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, I want to "
                            },
                            {
                                "type": "text",
                                "text": "consider",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a language that does everything on the GPU that is possible with today's hardware."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "00B8E376-D0BF-4D72-97BC-B3562E2ABCA0",
        "type": "message",
        "text": "&gt; What these constructs should be is an open problem.\n&gt; \nSounds like the distinction between applicative functors and monads might be relevant to your investigations.",
        "user": "U5STGTB3J",
        "ts": "1588752355.112500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Dt5X0",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What these constructs should be is an open problem.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSounds like the distinction between applicative functors and monads might be relevant to your investigations."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ed523a78-38a4-4525-bebc-ed04cc8b21c1",
        "type": "message",
        "text": "<@UE0ETTCG7> That is a good point, I would also say people prefer learning new stuff to writing their own helper tools.\n\nBut except for branding, I think there is another big factor: learning is easier then creating something. While learning I read the materials, follow the instructions and play with the tech. No hard decisions, and I know I am doing something good, I am improving myself and I am following instructions, I am making myself more valuable on the job market.\n\nCreating a tool / writing a script, on the other hand, means I have to make a lot of decisions (how will it work, how will I do it), I have to do research on my own without clear guidance, and finally, I don't know what the outcome will be, I might fail in building it, and I am not really sure what will the impact on my value on the job market be.\n\nNot to mention that if you are working in well developed ecosystem, the \"easy\" tools are usually already there and present, so you feel the need to build tools less, and what is left to be done is harder and more complex, maybe so much that you don't think it can/should be solved.",
        "user": "UUB7RA7PF",
        "ts": "1588752451.113200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iDzc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UE0ETTCG7"
                            },
                            {
                                "type": "text",
                                "text": " That is a good point, I would also say people prefer learning new stuff to writing their own helper tools.\n\nBut except for branding, I think there is another big factor: learning is easier then creating something. While learning I read the materials, follow the instructions and play with the tech. No hard decisions, and I know I am doing something good, I am improving myself and I am following instructions, I am making myself more valuable on the job market.\n\nCreating a tool / writing a script, on the other hand, means I have to make a lot of decisions (how will it work, how will I do it), I have to do research on my own without clear guidance, and finally, I don't know what the outcome will be, I might fail in building it, and I am not really sure what will the impact on my value on the job market be.\n\nNot to mention that if you are working in well developed ecosystem, the \"easy\" tools are usually already there and present, so you feel the need to build tools less, and what is left to be done is harder and more complex, maybe so much that you don't think it can/should be solved."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588674308.005200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "2a05df00-579a-4a63-8a85-bd99e151ac86",
        "type": "message",
        "text": "I've been down the route of FP, and I know about those concepts, but I don't think they're applicable in any substantial way (pun intended).",
        "user": "UCGAK10LS",
        "ts": "1588752489.113500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3U0B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been down the route of FP, and I know about those concepts, but I don't think they're applicable in any substantial way (pun intended)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6c53ec8b-3e71-4dfe-bd64-963e8927f781",
        "type": "message",
        "text": "In Onex I have 2D layout with nested boxes for the outside structure of things, then inside the boxes there is text for labels, values and rewrite rules, which themselves are nested lists that can/will be rendered as nested boxes (that bit I haven't done yet) So you end up with text only being used for single values or identifiers or symbols in the language. Everything else is structured as nested boxes.",
        "user": "UE6EFEPTQ",
        "ts": "1588753090.121600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S/fC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Onex I have 2D layout with nested boxes for the outside structure of things, then inside the boxes there is text for labels, values and rewrite rules, which themselves are nested lists that can/will be rendered as nested boxes (that bit I haven't done yet) So you end up with text only being used for single values or identifiers or symbols in the language. Everything else is structured as nested boxes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "a67f2a22-efb2-4e2d-8b04-dfa01437d2d2",
        "type": "message",
        "text": "It's all saved and transmitted as normal structured text",
        "user": "UE6EFEPTQ",
        "ts": "1588753147.123000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SJD+o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's all saved and transmitted as normal structured text"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "FF20799A-5965-4CA8-9F9D-2A077BE16568",
        "type": "message",
        "text": "I was more talking about math than FP here, but it seems that might just make it even less attractive to you\u2026\n\nRegardless, there are (imperative) languages that take advantage of the programmer specifying something as applicative, ie. \u201csequence of operation not important\u201d to run them in parallel. And at the call site it looks just like your usual map over an array, just that it runs faster.\n\nOn the other hand I do think a functional language like Haskell is a good example to see what design questions are raised when a language restricts specifying operations where order is important in general, and only allows that with additional effort in form of monads and syntactic sugar like do-notation.\n\nI\u2019m genuinely interested in what you are thinking about and look forward to learn more about what you\u2019ve been working on.",
        "user": "U5STGTB3J",
        "ts": "1588753212.123800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p/Jl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was more talking about math than FP here, but it seems that might just make it even less attractive to you\u2026\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "Regardless, there are (imperative) languages that take advantage of the programmer specifying something as applicative, ie. \u201csequence of operation not important\u201d to run them in parallel. And at the call site it looks just like your usual map over an array, just that it runs faster.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "On the other hand I do think a functional language like Haskell is a good example to see what design questions are raised when a language restricts specifying operations where order is important in general, and only allows that with additional effort in form of monads and syntactic sugar like do-notation.\n"
                            },
                            {
                                "type": "text",
                                "text": "\nI\u2019m genuinely interested in what you are thinking about and look forward to learn more about what you\u2019ve been working on."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7c0b6088-a606-486e-aef4-25073ed83a0b",
        "type": "message",
        "text": "My focus is on building graphical models from textual ones; but I am certainly interested in the reverse process, and thinking about it actively. <@UE6EFEPTQ> are you planning on doing a 2 minute week video?",
        "user": "UUQ2EQW21",
        "ts": "1588753419.124100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o1r",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My focus is on building graphical models from textual ones; but I am certainly interested in the reverse process, and thinking about it actively. "
                            },
                            {
                                "type": "user",
                                "user_id": "UE6EFEPTQ"
                            },
                            {
                                "type": "text",
                                "text": " are you planning on doing a 2 minute week video?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "dc3669a5-c584-4d67-8116-91ec89f5dda1",
        "type": "message",
        "text": "It's definitely necessary to exploit associativity and commutativity of operations for parallelization, which I think covers what you're referring to.",
        "user": "UCGAK10LS",
        "ts": "1588753427.124500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "m6e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's definitely necessary to exploit associativity and commutativity of operations for parallelization, which I think covers what you're referring to."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "318195A1-0123-4744-9EB9-95B41A18E48F",
        "type": "message",
        "text": "Yeah we need more non-binary input besides mouse position (e.g. keypresd is binary)",
        "user": "USUMN6XLH",
        "ts": "1588753458.125500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vPM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah we need more non-binary input besides mouse position (e.g. keypresd is binary)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588677125.006200",
        "parent_user_id": "UTG9XLGKZ"
    },
    {
        "client_msg_id": "aba27366-f912-40b7-8b26-46e38d1ac315",
        "type": "message",
        "text": "Haskell isn't really orderless. It's built atop a foundation of recursion and hierarchical data structures. Even if its operations aren't specified as a strict sequence (a total order), those constructs impose (inessential) order.",
        "user": "UCGAK10LS",
        "ts": "1588753540.125700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1588753888.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S5tue",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Haskell isn't really orderless. It's built atop a foundation of recursion and hierarchical data structures. Even if its operations aren't specified as a strict sequence (a total order), those constructs impose (inessential) order."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ce8c13a0-0f07-42d6-b357-78d45c686fa2",
        "type": "message",
        "text": "Thank you :slightly_smiling_face: I'll be reporting progress when I think I have a story to tell! (will try <#C0120A3L30R|two-minute-week> at some point too).",
        "user": "UCGAK10LS",
        "ts": "1588753607.125900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PssI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thank you "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " I'll be reporting progress when I think I have a story to tell! (will try "
                            },
                            {
                                "type": "channel",
                                "channel_id": "C0120A3L30R"
                            },
                            {
                                "type": "text",
                                "text": " at some point too)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U5STGTB3J",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "4cf0d595-48c1-49f7-9baf-4909f9293215",
        "type": "message",
        "text": "In Onex there are two forms of parallelism that can be exploited. There's the coarse grained parallelism that you'd probably understand as the actors or agents or live objects. And there's the finer term reduction familiar to FP folk, where you can reduce a tree by rewriting many branches at once.\n\nNeither of which the programmer needs to be conscious of!\n\nI mean, they will get the sense that the coarse objects seem to have their own animation, but that's what they'd expect given that that's how reality also works!",
        "user": "UE6EFEPTQ",
        "ts": "1588753687.126300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/PX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Onex there are two forms of parallelism that can be exploited. There's the coarse grained parallelism that you'd probably understand as the actors or agents or live objects. And there's the finer term reduction familiar to FP folk, where you can reduce a tree by rewriting many branches at once.\n\nNeither of which the programmer needs to be conscious of!\n\nI mean, they will get the sense that the coarse objects seem to have their own animation, but that's what they'd expect given that that's how reality also works!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "26196c4e-0da9-4b5f-801c-18ad76cd5c6c",
        "type": "message",
        "text": "So to return to your point, Onex programs can be parallelised without end user involvement, including on GPUs",
        "user": "UE6EFEPTQ",
        "ts": "1588753792.126500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W/z3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So to return to your point, Onex programs can be parallelised without end user involvement, including on GPUs"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d93c312b-cdfa-4c6a-9ea1-b49a3439f19d",
        "type": "message",
        "text": "Oh, and I use Vulkan but haven't got a clue what I'm doing.. :smile:",
        "user": "UE6EFEPTQ",
        "ts": "1588753838.126700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1588753866.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Hrp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, and I use Vulkan but haven't got a clue what I'm doing.. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ce7f5912-0dd8-4551-b3c9-f4b5be41f548",
        "type": "message",
        "text": "Have you actually got it (the whole language) running on GPUs? GPUs don't handle tree-like data very well, from what I know.",
        "user": "UCGAK10LS",
        "ts": "1588753991.127100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SyGK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Have you actually got it (the whole language) running on GPUs? GPUs don't handle tree-like data very well, from what I know."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7aad8d83-813b-4884-a788-b05ad8e383e6",
        "type": "message",
        "text": "Of course, but I'm not quite ready yet, plus I haven't ported my language from Java to C yet! So that may be a while. I can show the Object Network navigation GUI at least",
        "user": "UE6EFEPTQ",
        "ts": "1588753995.127300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JcYe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Of course, but I'm not quite ready yet, plus I haven't ported my language from Java to C yet! So that may be a while. I can show the Object Network navigation GUI at least"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "7e6384f2-4f41-4080-b6f8-87f4e0595339",
        "type": "message",
        "text": "Soz I meant I use Vulkan for the UI so in theory it would be easy to use the API for processing but that's a long way off..",
        "user": "UE6EFEPTQ",
        "ts": "1588754053.127500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EN6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Soz I meant I use Vulkan for the UI so in theory it would be easy to use the API for processing but that's a long way off.."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "26c7e210-eb8d-4174-a754-e81ad30f5491",
        "type": "message",
        "text": "Seems like a stretch to say that you can compute on GPUs then :slightly_smiling_face:. Let me know if you make progress in that direction.",
        "user": "UCGAK10LS",
        "ts": "1588754161.127700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CbQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Seems like a stretch to say that you can compute on GPUs then "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". Let me know if you make progress in that direction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a112c6e5-58e2-4840-8d0f-8469e92d50ef",
        "type": "message",
        "text": "OK, I'll look forward to it.  My focus is on giving live coders visual feedback/information on the music/graphics that they are generating in code; hopefully to help understand why certain inputs give certain outputs, and enable greater creativity.  But a logical next step is to let users tweak the visual representation of their code and have the full feedback loop.",
        "user": "UUQ2EQW21",
        "ts": "1588754211.127900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "59tT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "OK, I'll look forward to it.  My focus is on giving live coders visual feedback/information on the music/graphics that they are generating in code; hopefully to help understand why certain inputs give certain outputs, and enable greater creativity.  But a logical next step is to let users tweak the visual representation of their code and have the full feedback loop."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "bda97063-041a-4e34-9485-1a1114897a6f",
        "type": "message",
        "text": "Adding a depth sensor to trackpad would be fun, getting an extra dimension in work.",
        "user": "UNBPP291C",
        "ts": "1588754552.128100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nvn+k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Adding a depth sensor to trackpad would be fun, getting an extra dimension in work."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588677125.006200",
        "parent_user_id": "UTG9XLGKZ"
    },
    {
        "client_msg_id": "9186e844-bdc4-43a6-81c2-259aa8073a33",
        "type": "message",
        "text": "I think some already have a pressure sensor, or you mean more project soli? <https://www.youtube.com/watch?v=Db9nDOCahO0>",
        "user": "UBN9AFS0N",
        "ts": "1588754930.128300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Project Soli out of the Lab and into #Smartphones as Motion Sense",
                "title_link": "https://www.youtube.com/watch?v=Db9nDOCahO0",
                "author_name": "Sergio M\u00e9ndez Conferencista / The Future of Work",
                "author_link": "https://www.youtube.com/channel/UCqMJm9sLse24ycJ_BRw33Ww",
                "thumb_url": "https://i.ytimg.com/vi/Db9nDOCahO0/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Project Soli out of the Lab and into #Smartphones as Motion Sense",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/Db9nDOCahO0?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=Db9nDOCahO0",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=Db9nDOCahO0"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nw9UA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think some already have a pressure sensor, or you mean more project soli? "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=Db9nDOCahO0"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588677125.006200",
        "parent_user_id": "UTG9XLGKZ"
    },
    {
        "client_msg_id": "0e0f6ec3-de59-4b23-b032-2016400e93c8",
        "type": "message",
        "text": "I have seen live coding generating music and even though it's an amazing skill I always thought a graphical UI should make more sense!",
        "user": "UE6EFEPTQ",
        "ts": "1588759043.129000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ulxkw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have seen live coding generating music and even though it's an amazing skill I always thought a graphical UI should make more sense!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "0857024a-ecf1-4b74-ae11-197cff5711ed",
        "type": "message",
        "text": "Friends, let's be clear about the old difference between parallelism (doing two things at once) and concurrency (coordinating activities that are happening at about the same time).",
        "user": "UA14TGLTC",
        "ts": "1588761063.129200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UA14TGLTC",
            "ts": "1588761125.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SUtJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Friends, let's be clear about the old difference between parallelism (doing two things at once) and concurrency (coordinating activities that are happening at about the same time)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "bbeaec81-b145-4126-975a-722f3ebd5ef7",
        "type": "message",
        "text": "There's been a lot of activity over the past few years in defining high level GPU languages that address these issues.\n\u2022 co-dfns is a data-parallel and functional dialect of APL that runs on GPUs. What blew my mind is that the compiler itself is written in co-dfns, and so you can compile your co-dfns programs into GPU code using the GPU. Prior to seeing this, I did not think that a compiler was the kind of program suitable for parallel execution on a GPU. Turns out that the choice of data structures is very important.\n\u2022 Taichi is a DSL for defining fixed-height hierarchical data structures (which behave like sparse arrays). Thousands of lines of CUDA that only one guy in your organization understands can be replaced by tens of lines of taichi code. It's very instructive to look at the GPU-specific data types and compiler optimizations exposed by the Taichi language.\n\u2022 TensorFlow is implemented as a library that you call from C++ or Python. Using this library, you construct what is essentially a parse tree for a program using APL-like data parallel operations. The library compiles this parse tree into GPU code and executes it. Stefan asked why this is a language issue, not a library issue. Well, it's easier to write code directly in a language, than to use a library interface that consumes source code written in another language and compiles it.",
        "user": "UJN1TAYEQ",
        "ts": "1588770069.130100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4ln6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's been a lot of activity over the past few years in defining high level GPU languages that address these issues.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "co-dfns is a data-parallel and functional dialect of APL that runs on GPUs. What blew my mind is that the compiler itself is written in co-dfns, and so you can compile your co-dfns programs into GPU code using the GPU. Prior to seeing this, I did not think that a compiler was the kind of program suitable for parallel execution on a GPU. Turns out that the choice of data structures is very important."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Taichi is a DSL for defining fixed-height hierarchical data structures (which behave like sparse arrays). Thousands of lines of CUDA that only one guy in your organization understands can be replaced by tens of lines of taichi code. It's very instructive to look at the GPU-specific data types and compiler optimizations exposed by the Taichi language."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "TensorFlow is implemented as a library that you call from C++ or Python. Using this library, you construct what is essentially a parse tree for a program using APL-like data parallel operations. The library compiles this parse tree into GPU code and executes it. Stefan asked why this is a language issue, not a library issue. Well, it's easier to write code directly in a language, than to use a library interface that consumes source code written in another language and compiles it."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL",
                    "UCGAK10LS"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "c8964f30-74d7-4f55-9ede-8e352cc2f06f",
        "type": "message",
        "text": "My Curv language already compiles into GPU code, but it's not general enough to do everything I want. Support for hierarchical data structures is the next big thing (along with the ability to automatically generate compute shader pipelines). The use case will involve hundreds of cores traversing the same hierarchical data structure in parallel.",
        "user": "UJN1TAYEQ",
        "ts": "1588770333.130300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LbD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My Curv language already compiles into GPU code, but it's not general enough to do everything I want. Support for hierarchical data structures is the next big thing (along with the ability to automatically generate compute shader pipelines). The use case will involve hundreds of cores traversing the same hierarchical data structure in parallel."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5B3C748F-DEC6-425F-ABBC-CB6FF339018C",
        "type": "message",
        "text": "I\u2019m still working my way through _Crafting Interpreters_ and just came across a nice piece of content that many here might get a kick out of: at the end of chapter 23 hides a design note, which is a fascinatingly deep critique of Dijkstra\u2019s _Goto considered harmful_. There\u2019s nothing really surprising or substantially new in there, but I really like how Bob Nystrom argues about the complexities that hide in a paper that practically ended a certain language feature. \nIt\u2019s relatively short and you don\u2019t need to read any other part of the book; it totally stands on its own. Here\u2019s a teaser: \n\n&gt; _I guess what I really don\u2019t like is that we\u2019re making language design and engineering decisions today based on fear. Few people today have any subtle understanding of the problems and benefits of goto. Instead, we just think it\u2019s \u201cconsidered harmful\u201d. Personally, I\u2019ve never found dogma a good starting place for quality creative work._\n&gt; \n<http://craftinginterpreters.com/jumping-back-and-forth.html#design-note|http://craftinginterpreters.com/jumping-back-and-forth.html#design-note>",
        "user": "U5STGTB3J",
        "ts": "1588771688.136100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y56",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m still working my way through "
                            },
                            {
                                "type": "text",
                                "text": "Crafting Interpreters",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and just came across a nice piece of content that many here might get a kick out of: at the end of chapter 23 hides a design note, which is a fascinatingly deep critique of Dijkstra\u2019s "
                            },
                            {
                                "type": "text",
                                "text": "Goto considered harmful",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". There\u2019s nothing really surprising or substantially new in there, but I really like how Bob Nystrom argues about the complexities that hide in a paper that practically ended a certain language feature. \nIt\u2019s relatively short and you don\u2019t need to read any other part of the book; it totally stands on its own. Here\u2019s a teaser: \n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess what I really don\u2019t like is that we\u2019re making language design and engineering decisions today based on fear. Few people today have any subtle understanding of the problems and benefits of goto. Instead, we just think it\u2019s \u201cconsidered harmful\u201d. Personally, I\u2019ve never found dogma a good starting place for quality creative work.",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://craftinginterpreters.com/jumping-back-and-forth.html#design-note",
                                "text": "http://craftinginterpreters.com/jumping-back-and-forth.html#design-note"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "reply_count": 11,
        "reply_users_count": 7,
        "latest_reply": "1588810982.176200",
        "reply_users": [
            "UDQBTJ211",
            "UA14TGLTC",
            "UCUSW7WVD",
            "UUB7RA7PF",
            "U010328JA1E",
            "U71PMQ1V0",
            "UHWC9PXBL"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UKDM3GLAJ",
                    "URDRJEWS0",
                    "UA14TGLTC",
                    "UUB7RA7PF",
                    "UC2A2ARPT",
                    "UML4ZEKDK"
                ],
                "count": 6
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "F7FDAE79-431B-4DEA-B631-CB19FD24A82A",
        "type": "message",
        "text": "<@UJN1TAYEQ> co-dfns looks super interesting \u2014 thanks for sharing that! I hadn\u2019t heard about it, although Raph Levien\u2019s _A taste of GPU compute_ is sitting at the top spot of my to-watch list and it seems I would\u2019ve picked it up there soon\u2026 fascinating. I\u2019d love to dig deeper into the data structures part \u2014 why is it that every project you\u2019re currently not working on looks more attractive than the one you are working on?",
        "user": "U5STGTB3J",
        "ts": "1588772151.140100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fMO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " co-dfns looks super interesting \u2014 thanks for sharing that! I hadn\u2019t heard about it, although Raph Levien\u2019s "
                            },
                            {
                                "type": "text",
                                "text": "A taste of GPU compute",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is sitting at the top spot of my to-watch list and it seems I would\u2019ve picked it up there soon\u2026 fascinating. I\u2019d love to dig deeper into the data structures part \u2014 why is it that every project you\u2019re currently not working on looks more attractive than the one you are working on?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "8E8B8F04-18AB-437A-8794-6692850B67AC",
        "type": "message",
        "text": "I also have a feeling that the C++ superset approach used for Apple\u2019s Metal Shading Language isn\u2019t the end of that story\u2026",
        "user": "U5STGTB3J",
        "ts": "1588772334.142400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nd/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also have a feeling that the C++ superset approach used for Apple\u2019s Metal Shading Language isn\u2019t the end of that story\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0c49ec5a-375f-44b2-9d3e-2043e7034261",
        "type": "message",
        "text": "For imperative languages with side effects, a gosub is often clearer and more \"honest\" than function calls. There's some value in distinguishing at language level between \"instruction reuse\" (sub routine), and \"abstracted calculation\" (pure function).\n\nI've never considered a labelled goto as an anti pattern. Unlabeled line jumps on the other hand are definitely less clear.",
        "user": "UDQBTJ211",
        "ts": "1588772554.142600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9RGx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For imperative languages with side effects, a gosub is often clearer and more \"honest\" than function calls. There's some value in distinguishing at language level between \"instruction reuse\" (sub routine), and \"abstracted calculation\" (pure function).\n\nI've never considered a labelled goto as an anti pattern. Unlabeled line jumps on the other hand are definitely less clear."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "db9d04c9-70ea-4227-a956-51d0e2df048b",
        "type": "message",
        "text": "\"one of our tribe\u2019s ancestral songs\" \u2014 I often reflect on \"Goto Considered Harmful\" for the part: have the code of the program match the concept of what the program does, and the particular example of structured code (sequential statements, conditionals, and loops) for imperative (step-by-step) programs.\n\nI think of that part so much, in fact, that I forget about the part that mentions GOTO at all.  And in view of the GOTO bit, I suppose callbacks are more harmful in that you are now making the structure dynamic.  (To say nothing of continuations.)",
        "user": "UA14TGLTC",
        "ts": "1588776487.143100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qf3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"one of our tribe\u2019s ancestral songs\" \u2014 I often reflect on \"Goto Considered Harmful\" for the part: have the code of the program match the concept of what the program does, and the particular example of structured code (sequential statements, conditionals, and loops) for imperative (step-by-step) programs.\n\nI think of that part so much, in fact, that I forget about the part that mentions GOTO at all.  And in view of the GOTO bit, I suppose callbacks are more harmful in that you are now making the structure dynamic.  (To say nothing of continuations.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8d82b2a7-2db2-4de9-bce2-3be584d26509",
        "type": "message",
        "text": "Great points about learning and the career-boosting potential of learning languages and frameworks. I definitely agree those are major factors, I'd say you're right and the career boosting potential is probably the #1 reason developers learn new languages and frameworks.\n\nAbout \"creating a tool / writing a script\", I'm not really talking about projects that are the size and scope of what you're talking about. E.g., there's pretty clear progression for learning to automate:\n\n1. You might learn about Bash aliases, customizable keyboard shortcuts in an IDE/text editor, using a macro utility like Keyboard Maestro on macOS, install a shell utility like ripgrep or rupa z.\n2. You start writing your own Bash scripts and functions, maybe write something with AppleScript or Automator on macOS.\n3. You write your own text editor extension, browser extension, or shell program.\n\nThe problems you're talking about only start to show up in #3, whereas in my experience, the majority of developers never even do #1.",
        "user": "UE0ETTCG7",
        "ts": "1588776755.143300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE0ETTCG7",
            "ts": "1588776770.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BJW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great points about learning and the career-boosting potential of learning languages and frameworks. I definitely agree those are major factors, I'd say you're right and the career boosting potential is probably the #1 reason developers learn new languages and frameworks.\n\nAbout \"creating a tool / writing a script\", I'm not really talking about projects that are the size and scope of what you're talking about. E.g., there's pretty clear progression for learning to automate:\n\n1. You might learn about Bash aliases, customizable keyboard shortcuts in an IDE/text editor, using a macro utility like Keyboard Maestro on macOS, install a shell utility like ripgrep or rupa z.\n2. You start writing your own Bash scripts and functions, maybe write something with AppleScript or Automator on macOS.\n3. You write your own text editor extension, browser extension, or shell program.\n\nThe problems you're talking about only start to show up in #3, whereas in my experience, the majority of developers never even do #1."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588674308.005200",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "c2f59f98-4d6c-4749-beb6-74196bf5059d",
        "type": "message",
        "text": "This was great. Dijkstra's paper makes a reasonable case, but on balance may have actually done more harm than good with the flood of imitators and style guides seeking to ban language features purely out of fear. Many of the imitators even copied the 'considered harmful' phrasing, as an offering to be taken more seriously by the masses.\n\nThen again, maybe I'm being unfair. Ever were humans prone to following rules without understanding why they exist. If it wasn't Dijkstra we'd find someone else to imitate.\n\nHere's a little case I made for goto a few years ago: <http://akkartik.name/post/swamp|http://akkartik.name/post/swamp>",
        "user": "UCUSW7WVD",
        "ts": "1588778541.143700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sls",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This was great. Dijkstra's paper makes a reasonable case, but on balance may have actually done more harm than good with the flood of imitators and style guides seeking to ban language features purely out of fear. Many of the imitators even copied the 'considered harmful' phrasing, as an offering to be taken more seriously by the masses.\n\nThen again, maybe I'm being unfair. Ever were humans prone to following rules without understanding why they exist. If it wasn't Dijkstra we'd find someone else to imitate.\n\nHere's a little case I made for goto a few years ago: "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/swamp",
                                "text": "http://akkartik.name/post/swamp"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "dd792ea2-fbda-4e50-ad6c-b2055a25e988",
        "type": "message",
        "text": "Ah I see what you mean <@UE0ETTCG7>! You are right, I was actually thinking more about #3 as you nicely analyzed it.\nI actually thought that many/most devs do stuff from #1 and #2, but now that I think about it I realize my examples are from a limited circle of people and probably not representative. One thing I did notice with people I worked with is they are not using advanced keybinding system like those that emacs or especially vim offer, which I always feel is a shame since they are so fun/cool/productive, but ok, I assume that is due to the learning curve + perception that vim and emacs are old and so are the keybindings hm.",
        "user": "UUB7RA7PF",
        "ts": "1588781641.144100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UUB7RA7PF",
            "ts": "1588781664.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FCI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah I see what you mean "
                            },
                            {
                                "type": "user",
                                "user_id": "UE0ETTCG7"
                            },
                            {
                                "type": "text",
                                "text": "! You are right, I was actually thinking more about #3 as you nicely analyzed it.\nI actually thought that many/most devs do stuff from #1 and #2, but now that I think about it I realize my examples are from a limited circle of people and probably not representative. One thing I did notice with people I worked with is they are not using advanced keybinding system like those that emacs or especially vim offer, which I always feel is a shame since they are so fun/cool/productive, but ok, I assume that is due to the learning curve + perception that vim and emacs are old and so are the keybindings hm."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588674308.005200",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UE0ETTCG7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "771a6b83-95fd-4fa5-99f0-b72b4f6e1a0b",
        "type": "message",
        "text": "While I agree that we shouldn't blindly forbid language features / programming techniques and therefore limit ourselves, it is great to have this kind of pointers / style guides when you are a beginner in programming and need some kind of instructions how to behave. Reasonable defaults / restrictions, so it is harder to hurt yourself.\nOn the other hand, I would be very surprised to see experienced developer that is still convinced that all those rules are untouchable -&gt; naturally, as you grow, you start testing those boundaries and reevaluating them. I think it us up to us to learn to question everything, from time to time, at least a little bit.",
        "user": "UUB7RA7PF",
        "ts": "1588782191.144400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LELiT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While I agree that we shouldn't blindly forbid language features / programming techniques and therefore limit ourselves, it is great to have this kind of pointers / style guides when you are a beginner in programming and need some kind of instructions how to behave. Reasonable defaults / restrictions, so it is harder to hurt yourself.\nOn the other hand, I would be very surprised to see experienced developer that is still convinced that all those rules are untouchable -> naturally, as you grow, you start testing those boundaries and reevaluating them. I think it us up to us to learn to question everything, from time to time, at least a little bit."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "27f2d0d8-56c0-4dbc-90a0-a26a86db0f5f",
        "type": "message",
        "text": "I highly recommend Knuth's \"response\" \"Structured Programming with\u00a0*go to*\u00a0Statements\" which I find a way better piece than Dijkstra's. About dogma, fascinating how things could be different if Niklaus Wirth (!) hadn't change the title from \"A case against the goto statement\" towards publication.",
        "user": "U010328JA1E",
        "ts": "1588783583.144800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JfxG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I highly recommend Knuth's \"response\" \"Structured Programming with\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "go to",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u00a0Statements\" which I find a way better piece than Dijkstra's. About dogma, fascinating how things could be different if Niklaus Wirth (!) hadn't change the title from \"A case against the goto statement\" towards publication."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "744aa4cd-ffb0-461a-b152-961c8cb272b4",
        "type": "message",
        "text": "Dijkstra himself wrote something like (paraphrase): \"regrettably, it became the cornerstone of my fame even just by the article's title\". But imo, I don't think he was bothered too much about it :slightly_smiling_face:",
        "user": "U010328JA1E",
        "ts": "1588783715.145000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U010328JA1E",
            "ts": "1588783726.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vYgXF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Dijkstra himself wrote something like (paraphrase): \"regrettably, it became the cornerstone of my fame even just by the article's title\". But imo, I don't think he was bothered too much about it "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "768da6fa-397e-4f37-a8c1-deca59c48384",
        "type": "message",
        "text": "&gt; Without text complex expressions will be harder to understand. There are limits to comprehension without text. We learned this in the old days\nI think there's a good reason that _real_ engineering disciplines, like mechanical or electrical engineering, use symbol-based schematic diagrams to design and document their systems. In programming, the systems we design are universally small and simple (once you take out the 99.9% accidental complexity), so we should be able to get by with doing all our coding as static 2d colorless drawings on a drafting table. We should then be able to submit those programs to a compiler or archivist labeled, of course, using colored tabs.",
        "user": "UC2A2ARPT",
        "ts": "1588783793.145300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1588783836.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ne85",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Without text complex expressions will be harder to understand. There are limits to comprehension without text. We learned this in the old days"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI think there's a good reason that "
                            },
                            {
                                "type": "text",
                                "text": "real",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " engineering disciplines, like mechanical or electrical engineering, use symbol-based schematic diagrams to design and document their systems. In programming, the systems we design are universally small and simple (once you take out the 99.9% accidental complexity), so we should be able to get by with doing all our coding as static 2d colorless drawings on a drafting table. We should then be able to submit those programs to a compiler or archivist labeled, of course, using colored tabs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U5STGTB3J",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "7A4398FB-6457-44B7-8E3F-DE0781DFE5FF",
        "type": "message",
        "text": "It\u2019s just symbols, whether text or schematic diagrams (or mathematical formulas). I\u2019d wager that which kinds of symbols are used within which community has a lot more to do with environmental factors like who gets to tell the stories and build the products that become popular and what sets of tools are available than with any property of the symbols themselves.",
        "user": "U5STGTB3J",
        "ts": "1588787020.155400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1588787123.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lcOh/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s just symbols, whether text or schematic diagrams (or mathematical formulas). I\u2019d wager that which kinds of symbols are used within which community has a lot more to do with environmental factors like who gets to tell the stories and build the products that become popular and what sets of tools are available than with any property of the symbols themselves."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588700944.049400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "A881D388-BE76-447C-976A-E43DC0AAF82F",
        "type": "message",
        "text": "This seems to have the potential for quite some impact on the future of coding, doesn\u2019t it? What do you think?\n<https://github.com/features/codespaces|https://github.com/features/codespaces>",
        "user": "U5STGTB3J",
        "ts": "1588787721.156700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "25n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This seems to have the potential for quite some impact on the future of coding, doesn\u2019t it? What do you think?\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/features/codespaces",
                                "text": "https://github.com/features/codespaces"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "reply_count": 17,
        "reply_users_count": 6,
        "latest_reply": "1589006803.277300",
        "reply_users": [
            "UE0ETTCG7",
            "UJBAJNFLK",
            "UCUSW7WVD",
            "U012WT6NP2N",
            "UBN9AFS0N",
            "UJN1TAYEQ"
        ],
        "subscribed": true,
        "last_read": "1589006803.277300"
    },
    {
        "client_msg_id": "41F81D32-ADB3-4C3A-A92A-640DBA1EBAC9",
        "type": "message",
        "text": "Frankly, it\u2019s seeming more and more by the day that local development environments are living on borrowed time.",
        "user": "UE0ETTCG7",
        "ts": "1588790171.157900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sgMp2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Frankly, it\u2019s seeming more and more by the day that local development environments are living on borrowed time."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "F6774515-A5DE-47C7-A3B9-24C8CF2AE954",
        "type": "message",
        "text": "Obviously still a long ways to go, but movement in that direction seems to picking up speed.",
        "user": "UE0ETTCG7",
        "ts": "1588790208.159000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kN=a/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Obviously still a long ways to go, but movement in that direction seems to picking up speed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "9f6b4e11-563b-411a-9604-3ff17a4d510b",
        "type": "message",
        "text": "I wonder how much of a dependency on GitHub this new feature introduces. Can you still work 100% outside of GitHub on your projects? After all, GitHub could close down in a a few years, like others did in the past.",
        "user": "UJBAJNFLK",
        "ts": "1588792222.160300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9ix",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder how much of a dependency on GitHub this new feature introduces. Can you still work 100% outside of GitHub on your projects? After all, GitHub could close down in a a few years, like others did in the past."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "60947f46-f453-479c-be5a-908e784eda3d",
        "type": "message",
        "text": "Database folks have been attacking sql-on-gpu for a long time but there are no real successes yet. The core problem at the moment is memory bandwidth and latency. Getting data in and out of gpus is slow, and gpus aren't very good at branchy workloads so you inevitably need to do some stuff on the cpu. Often the result is that actual query execution is somewhat faster but the speedup is dwarfed by the time spent fetching the data.\n\nLooking at games gives a good idea of the division of work - game programmers are among the most experienced at writing gpu-friendly code but they still typically choose to put game logic, AI, pathing etc on the cpu.\n\nAlso modern cpus are actually pretty wide if you write code that is friendly to out-of-order execution and memory pre-fetching, but modern high-level languages go almost out of their way to be hostile to both. My bet is that designing a language to reduce false data dependencies and allow for more sequential memory access is a more viable target than designing a general purpose language for the gpu.\n\nThis might change though in the next decade as new gpu designs offer to share general memory with the cpu, so switching back and forth becomes more practical.",
        "user": "U71PMQ1V0",
        "ts": "1588793483.160500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U71PMQ1V0",
            "ts": "1588793563.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JtO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Database folks have been attacking sql-on-gpu for a long time but there are no real successes yet. The core problem at the moment is memory bandwidth and latency. Getting data in and out of gpus is slow, and gpus aren't very good at branchy workloads so you inevitably need to do some stuff on the cpu. Often the result is that actual query execution is somewhat faster but the speedup is dwarfed by the time spent fetching the data.\n\nLooking at games gives a good idea of the division of work - game programmers are among the most experienced at writing gpu-friendly code but they still typically choose to put game logic, AI, pathing etc on the cpu.\n\nAlso modern cpus are actually pretty wide if you write code that is friendly to out-of-order execution and memory pre-fetching, but modern high-level languages go almost out of their way to be hostile to both. My bet is that designing a language to reduce false data dependencies and allow for more sequential memory access is a more viable target than designing a general purpose language for the gpu.\n\nThis might change though in the next decade as new gpu designs offer to share general memory with the cpu, so switching back and forth becomes more practical."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "57a32db3-038c-43e1-88a1-91f301095a15",
        "type": "message",
        "text": "Labelled continue/break are basically goto anyway and trying to fit certain control flows into that pattern just ends up being harder to read than a real goto.\n\nI like Julia's approach of allowing labelled goto but only within a function.",
        "user": "U71PMQ1V0",
        "ts": "1588793737.161000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RdB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Labelled continue/break are basically goto anyway and trying to fit certain control flows into that pattern just ends up being harder to read than a real goto.\n\nI like Julia's approach of allowing labelled goto but only within a function."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "CF4BD758-2723-4D0B-9C5D-7C220530E8F8",
        "type": "message",
        "text": "While I agree 100% that that\u2019s something worth worrying about, it also seems to me that the market in general has decided that they don\u2019t care about that kind of risk.",
        "user": "UE0ETTCG7",
        "ts": "1588793924.163300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zDXiJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While I agree 100% that that\u2019s something worth worrying about, it also seems to me that the market in general has decided that they don\u2019t care about that kind of risk."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "aa13aa92-b380-4fab-836b-d7c520d1ced1",
        "type": "message",
        "text": "One thing is many programming models that are friendly for GPU also run significantly faster in CPUs",
        "user": "UBSMEUXAA",
        "ts": "1588795616.164000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JAH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing is many programming models that are friendly for GPU also run significantly faster in CPUs"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "e3a1a3e5-22df-48b6-9ea0-ff1e4207bc48",
        "type": "message",
        "text": "Game code runs on CPUs, sure, but if you look at what Unity is doing with DOTS, or ISPC, you'll see that on CPU you can get orders of magnitude better performance, most game code doesn't run on the GPU because the GPU is budgeted for graphics work, but more and more graphics (culling, sorting) and graphics adjacent (animation, VFX) work that traditionally happened on the CPU is happening on the GPU",
        "user": "UBSMEUXAA",
        "ts": "1588795972.164300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+n0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Game code runs on CPUs, sure, but if you look at what Unity is doing with DOTS, or ISPC, you'll see that on CPU you can get orders of magnitude better performance, most game code doesn't run on the GPU because the GPU is budgeted for graphics work, but more and more graphics (culling, sorting) and graphics adjacent (animation, VFX) work that traditionally happened on the CPU is happening on the GPU"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588742541.079700",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b6e36686-53bd-447d-a3b2-ed8cd35e5f7e",
        "type": "message",
        "text": "Is there any extant language that allows goto another function? Even C has that guardrail. Which makes it hard for us moderns to appreciate just what Dijkstra was arguing against.\n\nPersonally I think labeled break/continue is great! Is there any pattern it doesn't support?",
        "user": "UCUSW7WVD",
        "ts": "1588796327.164500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=/U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is there any extant language that allows goto another function? Even C has that guardrail. Which makes it hard for us moderns to appreciate just what Dijkstra was arguing against.\n\nPersonally I think labeled break/continue is great! Is there any pattern it doesn't support?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "0c5da0db-8a25-4965-8ad1-b1dd3c89b4e8",
        "type": "message",
        "text": "The market is made of people. All of us get a vote! And we get to change it as much as we want. So it's certainly worth discussing scenarios, so that we can influence and be influenced by each other's adoption.",
        "user": "UCUSW7WVD",
        "ts": "1588797048.165000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OgqgG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The market is made of people. All of us get a vote! And we get to change it as much as we want. So it's certainly worth discussing scenarios, so that we can influence and be influenced by each other's adoption."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UE0ETTCG7",
                    "UFLN9JFRT",
                    "UM5B0U84E"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "011ae9f7-416f-478d-a7d6-79bdead977cc",
        "type": "message",
        "text": "Quickly checked <https://riptutorial.com/julia-lang/example/15206/input-validation>\n\nStates: \"Although both examples do the same thing, the second (with recursion as opposed to GoTo) is easier to understand.\"\n\nBut I find it to be completely opposite and I'd think to beginners as well. What do y'all think?",
        "user": "U010328JA1E",
        "ts": "1588797390.165300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U010328JA1E",
            "ts": "1588797525.000000"
        },
        "attachments": [
            {
                "title": "Julia Language - Input validation | julia-lang Tutorial",
                "title_link": "https://riptutorial.com/julia-lang/example/15206/input-validation",
                "text": "julia-lang documentation: Input validation",
                "fallback": "Julia Language - Input validation | julia-lang Tutorial",
                "from_url": "https://riptutorial.com/julia-lang/example/15206/input-validation",
                "service_icon": "https://riptutorial.com/Images/logo_rip.png",
                "service_name": "riptutorial.com",
                "id": 1,
                "original_url": "https://riptutorial.com/julia-lang/example/15206/input-validation"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+SO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Quickly checked "
                            },
                            {
                                "type": "link",
                                "url": "https://riptutorial.com/julia-lang/example/15206/input-validation"
                            },
                            {
                                "type": "text",
                                "text": "\n\nStates: \"Although both examples do the same thing, the second (with recursion as opposed to GoTo) is easier to understand.\"\n\nBut I find it to be completely opposite and I'd think to beginners as well. What do y'all think?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588771688.136100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "5fd2225b-019d-440f-b1b9-2660e12b7617",
        "type": "message",
        "text": "Yeah, I'm definitely basing my points anecdotally on my particular circle of colleagues as well.",
        "user": "UE0ETTCG7",
        "ts": "1588800082.165700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LFp6k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I'm definitely basing my points anecdotally on my particular circle of colleagues as well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588674308.005200",
        "parent_user_id": "UBN9AFS0N"
    }
]