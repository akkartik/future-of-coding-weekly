[
    {
        "client_msg_id": "dbdef38a-3b35-46e7-a0fd-62cb6c5091b7",
        "type": "message",
        "text": "Sorry i posted only a partially uploaded file. This is a corrected version. Thanks to <@UA14TGLTC> for catching that.\nHere is a short video showing how to build a temperature control. You proceed directly from a sketch to a final shippable product using Beads, with no prototyping necessary. A lot of wasted work happens in our industry by using wireframing tools that can't be executed. You are better off with a crude-looking working product than a fake but pretty demo. It saves time, when the final shapes are all worked out from the running product, then you apply the final polish.\n Beads is rare among languages in that it carries at runtime physical units of measurement (by creating a new datatype which carries the unit exponent array and magnitude of the value), and has pre-programmed all the common conversions, such as degrees Kelvin to degrees Centigrade, etc. In this example i also show how you can have two interlinked controls on the screen, and whichever one changes the model the other control tracks its value, all without any additional code.  <https://youtu.be/JmmwmisRd2g>",
        "user": "UEQ6M68H0",
        "ts": "1589079026.313600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Beads language Ep 005, building a dual scale temperature control",
                "title_link": "https://youtu.be/JmmwmisRd2g",
                "author_name": "Edward De Jong",
                "author_link": "https://www.youtube.com/channel/UCiBO5hr2IVsYK8wiLznImTQ",
                "thumb_url": "https://i.ytimg.com/vi/JmmwmisRd2g/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Beads language Ep 005, building a dual scale temperature control",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/JmmwmisRd2g?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://youtu.be/JmmwmisRd2g",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://youtu.be/JmmwmisRd2g"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nhv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sorry i posted only a partially uploaded file. This is a corrected version. Thanks to "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " for catching that.\nHere is a short video showing how to build a temperature control. You proceed directly from a sketch to a final shippable product using Beads, with no prototyping necessary. A lot of wasted work happens in our industry by using wireframing tools that can't be executed. You are better off with a crude-looking working product than a fake but pretty demo. It saves time, when the final shapes are all worked out from the running product, then you apply the final polish.\n Beads is rare among languages in that it carries at runtime physical units of measurement (by creating a new datatype which carries the unit exponent array and magnitude of the value), and has pre-programmed all the common conversions, such as degrees Kelvin to degrees Centigrade, etc. In this example i also show how you can have two interlinked controls on the screen, and whichever one changes the model the other control tracks its value, all without any additional code.  "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/JmmwmisRd2g"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1589079026.313600",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1589131905.315600",
        "reply_users": [
            "UBN9AFS0N",
            "UEQ6M68H0"
        ],
        "subscribed": true,
        "last_read": "1589131905.315600",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ead4f08d-e80a-49e6-9ea6-012187320bba",
        "type": "message",
        "text": "great demo! one question, the track expression is tracking all events on all elements of the app or you specify which ones to track somehow? if all, how does it scale and how do you know which is the target?",
        "user": "UBN9AFS0N",
        "ts": "1589105357.314500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hcM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "great demo! one question, the track expression is tracking all events on all elements of the app or you specify which ones to track somehow? if all, how does it scale and how do you know which is the target?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1589079026.313600",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "c13e4641-b8b7-4e52-ac04-b0ce50e44f00",
        "type": "message",
        "text": "It's very interesting to think of the curves as _defining_ time. When you pull a point off it's going _outside of time_. Moving time backwards no longer includes that point. It's like it never existed. Whoa. An editable undo tree. What else could it be good for?",
        "user": "UCUSW7WVD",
        "ts": "1589131603.315400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NTL0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's very interesting to think of the curves as "
                            },
                            {
                                "type": "text",
                                "text": "defining",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " time. When you pull a point off it's going "
                            },
                            {
                                "type": "text",
                                "text": "outside of time",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Moving time backwards no longer includes that point. It's like it never existed. Whoa. An editable undo tree. What else could it be good for?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588802632.228900",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "8f2d4a0a-5911-4374-a1d4-7c5383a2247e",
        "type": "message",
        "text": "When you are handed a big code base to learn, one of the hardest things to understand is which code is going to absorb a given event? When you have code that adds and subtracts listeners all over the place it can be very puzzling. So in Beads i made the design choice to force the author to put event tracking for each UI element right after the draw code. So each rectangular section of the screen has its draw chunk, and the tracking logic code must be put right afterwards. In the case of a mouse event, the runtime looks for the topmost overlapping rectangle, and gives the topmost handler the chance to look at the event and process it. If the tracking code returns Y the event is absorbed and disappears, but if the tracking code doesn't absorb the next chunk that handles that event gets a chance to absorb. All incoming events whether they be keystrokes, network events, synthetic events, or finger taps, are fed through a serialized event model i call the Loom. The overall goal is to allow post mortem debugging with visualization of the screen as time is run backwards.",
        "user": "UEQ6M68H0",
        "ts": "1589131905.315600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2iWa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you are handed a big code base to learn, one of the hardest things to understand is which code is going to absorb a given event? When you have code that adds and subtracts listeners all over the place it can be very puzzling. So in Beads i made the design choice to force the author to put event tracking for each UI element right after the draw code. So each rectangular section of the screen has its draw chunk, and the tracking logic code must be put right afterwards. In the case of a mouse event, the runtime looks for the topmost overlapping rectangle, and gives the topmost handler the chance to look at the event and process it. If the tracking code returns Y the event is absorbed and disappears, but if the tracking code doesn't absorb the next chunk that handles that event gets a chance to absorb. All incoming events whether they be keystrokes, network events, synthetic events, or finger taps, are fed through a serialized event model i call the Loom. The overall goal is to allow post mortem debugging with visualization of the screen as time is run backwards."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1589079026.313600",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1::skin-tone-4",
                "users": [
                    "UBN9AFS0N",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    }
]