[
    {
        "client_msg_id": "9ad33f50-93bb-4c9a-b61c-f3574a6f9fe7",
        "type": "message",
        "text": "<@UC21F8Q48> Thanks for the spreadsheet analogy. Although watching the video, I didn't see see the equivalent of \"editing the equation\".\n\nCan you suggest related work that I should look at? I'm trying to understand these ideas well enough to implement them in a system for creating 3D models using pure functional programming.",
        "user": "UJN1TAYEQ",
        "ts": "1588374012.412300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QVyl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC21F8Q48"
                            },
                            {
                                "type": "text",
                                "text": " Thanks for the spreadsheet analogy. Although watching the video, I didn't see see the equivalent of \"editing the equation\".\n\nCan you suggest related work that I should look at? I'm trying to understand these ideas well enough to implement them in a system for creating 3D models using pure functional programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "65729632-bc47-41d8-8ce6-a9cf3ebb9c33",
        "type": "message",
        "text": "<@UKDM3GLAJ> Nope, I can't find it either. I remember it was part of a collection of proposed extensions aiming to un-hardcode some of the lower levels of the web.",
        "user": "U71PMQ1V0",
        "ts": "1588375177.412500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vm+ox",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " Nope, I can't find it either. I remember it was part of a collection of proposed extensions aiming to un-hardcode some of the lower levels of the web."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588186429.337500",
        "parent_user_id": "UKDM3GLAJ"
    },
    {
        "client_msg_id": "0b3c991c-cfe8-45c9-964d-2683db4688f2",
        "type": "message",
        "text": "Well there\u2019s no text editing in Conal\u2019s Eros as originally conceived so you\u2019re right to wonder where it is. But Eros and spreadsheets both display values more prominently than code and invite manipulation on those values.",
        "user": "UC21F8Q48",
        "ts": "1588381473.412700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u=O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well there\u2019s no text editing in Conal\u2019s Eros as originally conceived so you\u2019re right to wonder where it is. But Eros and spreadsheets both display values more prominently than code and invite manipulation on those values."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "504d8524-def9-43cf-a4b2-6a3252070a7e",
        "type": "message",
        "text": "<@UC2A2ARPT> \u201cI think it\u2019s no secret that a lot of folks here aren\u2019t making programming tools in the traditional sense. Eg: I\u2019m making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: \u201coh, code!\u201c\u201d\n\nRight, and that might be appropriate for your problem, but I\u2019m suggesting that evaluation/code may not be needed for many/most of the tools which would allow people to do the things they are currently hiring programmers to do.\n\nThat is, the range of the things people typically want to make may be small enough for them to build from a well abstracted set of primitives in a no code way.",
        "user": "ULM3U6275",
        "ts": "1588386741.412900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jqike",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " \u201cI think it\u2019s no secret that a lot of folks here aren\u2019t making programming tools in the traditional sense. Eg: I\u2019m making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: \u201coh, code!\u201c\u201d\n\nRight, and that might be appropriate for your problem, but I\u2019m suggesting that evaluation/code may not be needed for many/most of the tools which would allow people to do the things they are currently hiring programmers to do.\n\nThat is, the range of the things people typically want to make may be small enough for them to build from a well abstracted set of primitives in a no code way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588262541.361600",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3458486d-f79d-4a35-8875-ede31569836b",
        "type": "message",
        "text": "Value-based programming has some niches where it makes sense, like audio/video signal processing where the work product are data streams, and there is often a continuous flow to these streams you don't stop and think about them and wait for some input from the user. In graphical interactive software you have a lot of state, lots of widgets, and management of 500 things on the screen at the same time becomes a major chore. Even the portfolio management system i worked on in FORTRAN back in the day on mainframes did batch processing that included a fair amount of state as we were always accumulating numbers into buckets for sorting and categorizing purposes. None of the projects i have worked on would be convenient at all inside a data centric world. I understand Doug's art generation language would benefit from this, but i consider this area a very specialized niche.\n\nI think of a spreadsheet as a poor-man's database. It is fundamentally a 3.5 dimension system; you have a 2D sheet, which you can break into sub-rectangles, so i call that 2.5 dimensions, and the 3rd dimension is the array of named sheets you can have. As long as your data can fit into that dimensionality it works okay; especially since MS beefed up Excel to support about a million rows. But showing the data and hiding all the formulas makes most spreadsheets unauditable  black magic systems, and really quite dangerous. It is a well known thing in business consulting to find out that some part of a company's fundamental processes have been automated via Excel. There is no question in my mind that a very robust data editor coupled with a graph database could give  Excel a run for its money, but going up against the MS machine is an expensive process. Just like IBM they use the F.U.D. technique for suppressing competition.",
        "user": "UEQ6M68H0",
        "ts": "1588400904.413300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1588406343.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M9h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Value-based programming has some niches where it makes sense, like audio/video signal processing where the work product are data streams, and there is often a continuous flow to these streams you don't stop and think about them and wait for some input from the user. In graphical interactive software you have a lot of state, lots of widgets, and management of 500 things on the screen at the same time becomes a major chore. Even the portfolio management system i worked on in FORTRAN back in the day on mainframes did batch processing that included a fair amount of state as we were always accumulating numbers into buckets for sorting and categorizing purposes. None of the projects i have worked on would be convenient at all inside a data centric world. I understand Doug's art generation language would benefit from this, but i consider this area a very specialized niche.\n\nI think of a spreadsheet as a poor-man's database. It is fundamentally a 3.5 dimension system; you have a 2D sheet, which you can break into sub-rectangles, so i call that 2.5 dimensions, and the 3rd dimension is the array of named sheets you can have. As long as your data can fit into that dimensionality it works okay; especially since MS beefed up Excel to support about a million rows. But showing the data and hiding all the formulas makes most spreadsheets unauditable  black magic systems, and really quite dangerous. It is a well known thing in business consulting to find out that some part of a company's fundamental processes have been automated via Excel. There is no question in my mind that a very robust data editor coupled with a graph database could give  Excel a run for its money, but going up against the MS machine is an expensive process. Just like IBM they use the F.U.D. technique for suppressing competition."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "2fac2ce1-4579-40d7-a81f-96a5a4f0c653",
        "type": "message",
        "text": "And honestly Excel doesn't scale so well.  As for the MS machine, I did not learn until visiting Microsoft (a good many years back now) how they had a real value proposition in supporting business seemingly separate from their role as a pedler of, iffy to my eyes, software.",
        "user": "UA14TGLTC",
        "ts": "1588404594.413600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q=v2e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And honestly Excel doesn't scale so well.  As for the MS machine, I did not learn until visiting Microsoft (a good many years back now) how they had a real value proposition in supporting business seemingly separate from their role as a pedler of, iffy to my eyes, software."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "5e7494cb-a7ba-460b-9304-0fee1ae43a76",
        "type": "message",
        "text": "<@ULM3U6275> I love it, \"oh, code!\"  That's perfect.  Definitely modeling tools give me a feel of \"fuck it: take the cartesian closure of this and call it a day.\"  (The reference here is to category theory where a Cartesian Closed Category is, basically, one with structures, unions, and functions.)  For example, you add a little bit of parametric modeling.  You think it would be nice to nest these so that parameters to a big model can be passed into its parts.  Then the next thing you know, you want to be able pass models as parameters.  Why not?",
        "user": "UA14TGLTC",
        "ts": "1588405005.413900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Ug",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " I love it, \"oh, code!\"  That's perfect.  Definitely modeling tools give me a feel of \"fuck it: take the cartesian closure of this and call it a day.\"  (The reference here is to category theory where a Cartesian Closed Category is, basically, one with structures, unions, and functions.)  For example, you add a little bit of parametric modeling.  You think it would be nice to nest these so that parameters to a big model can be passed into its parts.  Then the next thing you know, you want to be able pass models as parameters.  Why not?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588262541.361600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "751b3e03-0ada-47e7-aede-3bf70a22e24d",
        "type": "message",
        "text": "At $12 a month per person, for an Office 365 license, MS has an almost insurmountable advantage. Google has been doing their best to cut off their air supply by gradually beefing up Google Sheets, and it is having some effect, but as a programming system once you go beyond simple stuff Excel is pretty ugly. But fully understand why people stay in Excel, because the current popular programming stack, HTML/CSS/JS/Frameworks is more than 10x the effort to learn.",
        "user": "UEQ6M68H0",
        "ts": "1588406629.414200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eQtvS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At $12 a month per person, for an Office 365 license, MS has an almost insurmountable advantage. Google has been doing their best to cut off their air supply by gradually beefing up Google Sheets, and it is having some effect, but as a programming system once you go beyond simple stuff Excel is pretty ugly. But fully understand why people stay in Excel, because the current popular programming stack, HTML/CSS/JS/Frameworks is more than 10x the effort to learn."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "324a6303-6ecf-4888-ba53-d41faf056430",
        "type": "message",
        "text": "<@UPMFG2571> I love this vision. It's something I've wanted for a while too: a comprehensive description of a whole stack, simulated in media, approachable from very basic knowledge with a smooth path to global understanding.",
        "user": "UMWF81HTP",
        "ts": "1588414994.414600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N1D+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UPMFG2571"
                            },
                            {
                                "type": "text",
                                "text": " I love this vision. It's something I've wanted for a while too: a comprehensive description of a whole stack, simulated in media, approachable from very basic knowledge with a smooth path to global understanding."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588307376.386900",
        "parent_user_id": "UMWF81HTP",
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "UPMFG2571"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "subtype": "thread_broadcast",
        "text": "<@UEQ6M68H0> Imperative programming (and shared mutable state) was a reasonable idea in the 1950's, 60's and 70's, when programs were small, processors had a single core, and internet-related security holes were not a concern. But imperative programming doesn't scale. The legacy of imperative and shared-mutable-state programming is responsible for our current software crisis. The future of coding is pure functional programming and immutable values.\n\nLarge programs with shared mutable state can't be fully understood or debugged. This problem becomes much worse with multiple cores. The imperative programming community's response to multi-core programming was mutable state shared between threads and processor cores, guarded by mutexes. This is a catastrophically bad programming model. You can't understand or debug the code. The solution is to eliminate shared mutable state.\n\nImperative programming doesn't scale to large numbers of cores--mutual exclusion mechanisms steal most of your performance. The solution is to eliminate shared mutable state. Machine learning with TensorFlow is an important example of massively multi-core programming. What makes it possible is that TensorFlow is a pure functional language. Unfortunately it has to be embedded in Python, because we don't have a mainstream pure functional language yet.\n\nAs an aside, I find it tragic that my personal computer has a 1000 cores (most in the GPU), and most of these cores must remain idle because my system software and apps are written in weak, stone age imperative languages that don't provide a simple and efficient way to distribute computation across a huge number of cores.\n\nImperative programming is a catastrophy for software security. In the imperative model, any function call can change any state in the entire system. This is the root cause of most security flaws. A sort function can encrypt all your files, display a ransom message, and phone home to an internet malware server. And we are seeing these kinds of exploits in supply chain attacks on open source software repositories. Pure functional programming puts security first: functions cannot have side effects, and functions have no access to data that isn't passed as an argument. The type system can trivially guarantee that a sort function will not intentionally spawn a bitcoin miner, or accidently corrupt shared mutable state outside of the array that you are sorting. A common response to the inherent insecurity of imperative code is sandboxing. It's a backwards approach. What if architects built buildings out of contact-sensitive explosive materials, then attempted to mitigate the resulting safety issues using a complex system of nested blast barriers. Imperative programming is inherently insecure, and pure functional programming is the answer.",
        "user": "UJN1TAYEQ",
        "ts": "1588422527.414900",
        "thread_ts": "1588341505.403500",
        "root": {
            "client_msg_id": "c4befa80-cd3d-4c0e-afc3-656607ac3d0a",
            "type": "message",
            "text": "Tangible Functional Programming by Conal Elliott\n\u2022 apps are user-friendly (usable, concrete, visual) but limit functionality, aren't composable\n\u2022 software libraries are programmer-friendly (composable, abstract, syntactic)\nThe dream is: unlimited access to functionality, usably and composably. How?\n\u2022 Unix pipes are a composable text-mode UI, but we lose the GUI.\n\u2022 A Tangible Value is a typed value (model) paired with a GUI (view, controller). GUIs are composable whenever their underlying values are composable: eg unix-like pipelines, function composition.\n<http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability>",
            "user": "UJN1TAYEQ",
            "ts": "1588341505.403500",
            "team": "T5TCAFTA9",
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "fUr",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Tangible Functional Programming by Conal Elliott\n"
                                }
                            ]
                        },
                        {
                            "type": "rich_text_list",
                            "elements": [
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "apps are user-friendly (usable, concrete, visual) but limit functionality, aren't composable"
                                        }
                                    ]
                                },
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "software libraries are programmer-friendly (composable, abstract, syntactic)"
                                        }
                                    ]
                                }
                            ],
                            "style": "bullet",
                            "indent": 0
                        },
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "The dream is: unlimited access to functionality, usably and composably. How?\n"
                                }
                            ]
                        },
                        {
                            "type": "rich_text_list",
                            "elements": [
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "Unix pipes are a composable text-mode UI, but we lose the GUI."
                                        }
                                    ]
                                },
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "A Tangible Value is a typed value (model) paired with a GUI (view, controller). GUIs are composable whenever their underlying values are composable: eg unix-like pipelines, function composition."
                                        }
                                    ]
                                }
                            ],
                            "style": "bullet",
                            "indent": 0
                        },
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "link",
                                    "url": "http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability"
                                }
                            ]
                        }
                    ]
                }
            ],
            "thread_ts": "1588341505.403500",
            "reply_count": 11,
            "reply_users_count": 5,
            "latest_reply": "1588436154.415700",
            "reply_users": [
                "UJN1TAYEQ",
                "UC21F8Q48",
                "UEQ6M68H0",
                "UA14TGLTC",
                "U010328JA1E"
            ],
            "subscribed": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fP2e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " Imperative programming (and shared mutable state) was a reasonable idea in the 1950's, 60's and 70's, when programs were small, processors had a single core, and internet-related security holes were not a concern. But imperative programming doesn't scale. The legacy of imperative and shared-mutable-state programming is responsible for our current software crisis. The future of coding is pure functional programming and immutable values.\n\nLarge programs with shared mutable state can't be fully understood or debugged. This problem becomes much worse with multiple cores. The imperative programming community's response to multi-core programming was mutable state shared between threads and processor cores, guarded by mutexes. This is a catastrophically bad programming model. You can't understand or debug the code. The solution is to eliminate shared mutable state.\n\nImperative programming doesn't scale to large numbers of cores--mutual exclusion mechanisms steal most of your performance. The solution is to eliminate shared mutable state. Machine learning with TensorFlow is an important example of massively multi-core programming. What makes it possible is that TensorFlow is a pure functional language. Unfortunately it has to be embedded in Python, because we don't have a mainstream pure functional language yet.\n\nAs an aside, I find it tragic that my personal computer has a 1000 cores (most in the GPU), and most of these cores must remain idle because my system software and apps are written in weak, stone age imperative languages that don't provide a simple and efficient way to distribute computation across a huge number of cores.\n\nImperative programming is a catastrophy for software security. In the imperative model, any function call can change any state in the entire system. This is the root cause of most security flaws. A sort function can encrypt all your files, display a ransom message, and phone home to an internet malware server. And we are seeing these kinds of exploits in supply chain attacks on open source software repositories. Pure functional programming puts security first: functions cannot have side effects, and functions have no access to data that isn't passed as an argument. The type system can trivially guarantee that a sort function will not intentionally spawn a bitcoin miner, or accidently corrupt shared mutable state outside of the array that you are sorting. A common response to the inherent insecurity of imperative code is sandboxing. It's a backwards approach. What if architects built buildings out of contact-sensitive explosive materials, then attempted to mitigate the resulting safety issues using a complex system of nested blast barriers. Imperative programming is inherently insecure, and pure functional programming is the answer."
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "a4f35e67-7b15-4ba1-b7e8-642f770f0bff",
        "reactions": [
            {
                "name": "thread-please",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6a0082c3-379a-4585-ba2a-04119737917d",
        "type": "message",
        "text": "<@UA14TGLTC> In what ways do you think Excel doesn't scale? Thinking of 1) Having all values at all times on the screen, 2) Obfuscation and debuggability of logic 3) 1 million rows limit 4) Slow updates for big files. ...?",
        "user": "U010328JA1E",
        "ts": "1588428967.415300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=Dj=Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " In what ways do you think Excel doesn't scale? Thinking of 1) Having all values at all times on the screen, 2) Obfuscation and debuggability of logic 3) 1 million rows limit 4) Slow updates for big files. ...?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "d779bd6b-a8c5-40c1-87c0-e26e4c3cd083",
        "type": "message",
        "text": "<@U010328JA1E> (4) is what I had in mind though having just opened a 400,000 row file I happened to have handy to time some operations, I find Excel laggy but less laggy than remembered.  (Could be new hardware or some performance improvement with tables.  This is macOS mind you.)",
        "user": "UA14TGLTC",
        "ts": "1588436154.415700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4=KgF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U010328JA1E"
                            },
                            {
                                "type": "text",
                                "text": " (4) is what I had in mind though having just opened a 400,000 row file I happened to have handy to time some operations, I find Excel laggy but less laggy than remembered.  (Could be new hardware or some performance improvement with tables.  This is macOS mind you.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ",
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "U010328JA1E",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "b872e490-7284-4d65-b461-f91f50405023",
        "type": "message",
        "text": "<@UA14TGLTC> :)\n\n<@ULM3U6275> We're making the same point, I think. Excel is an \"Oh, code\" tool. So is Factorio. So is Zapier. These are things that don't look like \"programming\", but it turns out you use them to build dynamic, logical systems. You're doing programming, there's still evaluation, but it's an experience that's been designed for _you_, not for _programmers_ (eww).\n\nMy beef with \"no code\" (well, one of my beefs) is that many of these tools are just... frustratingly superficial non-textual programming environments. Given that the distinction between \"coding\" and \"programming\" colloquially is basically nil, it feels like \"non-fat\" all over again \u2014\u00a0sure, you've removed the text-code, but you've substituted it with something much worse! What you really want is ~good fat~ a full &amp; rich programming environment, but created for non-programmers.\n\nAside: The name of this community is a poor fit, and that's probably just going to have to be a meme that we relish in.",
        "user": "UC2A2ARPT",
        "ts": "1588444835.416100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w5laJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " :)\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " We're making the same point, I think. Excel is an \"Oh, code\" tool. So is Factorio. So is Zapier. These are things that don't look like \"programming\", but it turns out you use them to build dynamic, logical systems. You're doing programming, there's still evaluation, but it's an experience that's been designed for "
                            },
                            {
                                "type": "text",
                                "text": "you",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", not for "
                            },
                            {
                                "type": "text",
                                "text": "programmers",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (eww).\n\nMy beef with \"no code\" (well, one of my beefs) is that many of these tools are just... frustratingly superficial non-textual programming environments. Given that the distinction between \"coding\" and \"programming\" colloquially is basically nil, it feels like \"non-fat\" all over again \u2014\u00a0sure, you've removed the text-code, but you've substituted it with something much worse! What you really want is "
                            },
                            {
                                "type": "text",
                                "text": "good fat",
                                "style": {
                                    "strike": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a full & rich programming environment, but created for non-programmers.\n\nAside: The name of this community is a poor fit, and that's probably just going to have to be a meme that we relish in."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588262541.361600",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UE0ETTCG7",
                    "UA14TGLTC",
                    "UHWC9PXBL",
                    "UML4ZEKDK",
                    "UFV8P4472"
                ],
                "count": 6
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UML4ZEKDK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0b18ecf8-4c72-4c69-8fe3-73a40ecaefd7",
        "type": "message",
        "text": "<@UJN1TAYEQ> Spending most of my day every day dealing with 100 million intrusion attempts each 24 hours, i am only too familiar with internet security flaws. However, it is the basic protocols of the internet that are at fault, not how they are implemented. It is a fact that the early internet had zero concern with security, given that it ran on private leased lines between the universities.  I remember visiting MIT at the dawn of the internet, and there was a terminal hooked between boston and berkeley. You could chat back and forth; it was fairly useless until the WWW came along.\n\nYou are perhaps not familiar with Modula-2 which was Prof. Wirth's 10 year later sequel to Pascal. In Modula-2 you can specify whether or not a called function has access to modify data, and along with other clever and simple features you can make rock solid programs that are as tight as it can be. And to claim that pure functional program is the answer to anything is not factual. If you are building a Chess game program, the state of the board is going to change, and any attempt to evade changing the state of the board is merely hiding the state changes somewhere. Minimizing the number of state variables, and making sure there is no redundancy (which is the source of many errors) is a virtue, but to pursue utter purity in avoiding state makes your program unable to do any useful work. John Backus who invented FP, who gave a lecture i attended in 1973 on his Functional language called Red at the time, was unable to finish his work, and his prior creation FORTRAN did battle with COBOL (and losing to an inferior language). He had the goal of interchangeable parts, but did not achieve it.\n\nThere is little evidence that FP is bringing about an era of interchangable parts, and making it easier to maintain large programs, two of the most important unsolved problems in computer engineering. My own project revolves around using deduction, something nearly forgotten as it was last seen in the 70's in PROLOG. Since all programs must eventually map their syntax into the underlying instructions of the Intel or ARM processors, the only difference between 2 languages can be the convenience, conciseness, shareability, and maintainability of the notation. There are languages like FORTH that trade everything for brevity, but nobody programs in FORTH because it is unmaintainable. The ability to share components in the FP languages I have seen is not exemplary. The idiocy of having millions of programmers reinvent the same programs over and over is quite absurd. Look at Google's code pile; they must be close to 10 billion lines, it is ridiculous. I can't recall a time when i found some nice chunk of code on Github and was able to use it. There are billions of lines there, but it is all disorganized, full of dependencies i don't want to carry, and of unknown quality and reliability. So to ensure things work i end up writing almost everything myself. People like me are part of the problem, but i don't have access to a marketplace of nice little widgets like Apple's iTunes App Store has for full apps. That would be a really useful thing.",
        "user": "UEQ6M68H0",
        "ts": "1588448354.425100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1588459359.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gtU1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Spending most of my day every day dealing with 100 million intrusion attempts each 24 hours, i am only too familiar with internet security flaws. However, it is the basic protocols of the internet that are at fault, not how they are implemented. It is a fact that the early internet had zero concern with security, given that it ran on private leased lines between the universities.  I remember visiting MIT at the dawn of the internet, and there was a terminal hooked between boston and berkeley. You could chat back and forth; it was fairly useless until the WWW came along.\n\nYou are perhaps not familiar with Modula-2 which was Prof. Wirth's 10 year later sequel to Pascal. In Modula-2 you can specify whether or not a called function has access to modify data, and along with other clever and simple features you can make rock solid programs that are as tight as it can be. And to claim that pure functional program is the answer to anything is not factual. If you are building a Chess game program, the state of the board is going to change, and any attempt to evade changing the state of the board is merely hiding the state changes somewhere. Minimizing the number of state variables, and making sure there is no redundancy (which is the source of many errors) is a virtue, but to pursue utter purity in avoiding state makes your program unable to do any useful work. John Backus who invented FP, who gave a lecture i attended in 1973 on his Functional language called Red at the time, was unable to finish his work, and his prior creation FORTRAN did battle with COBOL (and losing to an inferior language). He had the goal of interchangeable parts, but did not achieve it.\n\nThere is little evidence that FP is bringing about an era of interchangable parts, and making it easier to maintain large programs, two of the most important unsolved problems in computer engineering. My own project revolves around using deduction, something nearly forgotten as it was last seen in the 70's in PROLOG. Since all programs must eventually map their syntax into the underlying instructions of the Intel or ARM processors, the only difference between 2 languages can be the convenience, conciseness, shareability, and maintainability of the notation. There are languages like FORTH that trade everything for brevity, but nobody programs in FORTH because it is unmaintainable. The ability to share components in the FP languages I have seen is not exemplary. The idiocy of having millions of programmers reinvent the same programs over and over is quite absurd. Look at Google's code pile; they must be close to 10 billion lines, it is ridiculous. I can't recall a time when i found some nice chunk of code on Github and was able to use it. There are billions of lines there, but it is all disorganized, full of dependencies i don't want to carry, and of unknown quality and reliability. So to ensure things work i end up writing almost everything myself. People like me are part of the problem, but i don't have access to a marketplace of nice little widgets like Apple's iTunes App Store has for full apps. That would be a really useful thing."
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UFLN9JFRT",
                    "UC21F8Q48"
                ],
                "count": 3
            },
            {
                "name": "thread-please",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "D46ED12D-637A-4842-9B18-42446D9EEC94",
        "type": "message",
        "text": "If you\u2019re not yet locked in to either side of the imperative-vs.-functional debate, this podcast interview might have some thought-provoking ideas about where modern programming languages are headed: \n<https://www.swiftbysundell.com/podcast/71/|https://www.swiftbysundell.com/podcast/71/>",
        "user": "U5STGTB3J",
        "ts": "1588452793.429100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Swift by Sundell",
                "title": "71: \u201cPolymorphic interfaces\u201d, with special guest Dave Abrahams | Swift by Sundell",
                "title_link": "https://www.swiftbysundell.com/podcast/71/",
                "text": "Dave Abrahams joins John to talk about Protocol-Oriented Programming and how to make the most out of the Swift Standard Library. Also, discussions on Swift\u2019s overall design, why it puts such a strong emphasis on value types and protocols, and how it\u2019s been influenced by other languages.",
                "fallback": "Swift by Sundell: 71: \u201cPolymorphic interfaces\u201d, with special guest Dave Abrahams | Swift by Sundell",
                "image_url": "https://www.swiftbysundell.com/images/podcast/71.png",
                "from_url": "https://www.swiftbysundell.com/podcast/71/",
                "image_width": 500,
                "image_height": 250,
                "image_bytes": 342048,
                "service_icon": "https://www.swiftbysundell.com/images/favicon.png",
                "id": 1,
                "original_url": "https://www.swiftbysundell.com/podcast/71/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WIN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you\u2019re not yet locked in to either side of the imperative-vs.-functional debate, this podcast interview might have some thought-provoking ideas about where modern programming languages are headed: \n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.swiftbysundell.com/podcast/71/",
                                "text": "https://www.swiftbysundell.com/podcast/71/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588452793.429100",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1588453561.434500",
        "reply_users": [
            "U5STGTB3J"
        ],
        "subscribed": false
    },
    {
        "type": "message",
        "text": "As Kevlin Henney likes to point out in many of his presentations, a fundamental problem is mutable shared state. Sure, pure functions are one solution to this and they are extremely useful, but there are other ways that can be useful too. Better ways to handle value and reference semantics, for instance. I\u2019m excited for what is being explored in Swift and Rust (and C++).",
        "files": [
            {
                "id": "F012RL60B3Q",
                "created": 1588453203,
                "timestamp": 1588453203,
                "name": "Image from iOS.jpg",
                "title": "Image from iOS",
                "mimetype": "image/jpeg",
                "filetype": "jpg",
                "pretty_type": "JPEG",
                "user": "U5STGTB3J",
                "editable": false,
                "size": 44940,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F012RL60B3Q/image_from_ios.jpg",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F012RL60B3Q/download/image_from_ios.jpg",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_64.jpg",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_80.jpg",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_360.jpg",
                "thumb_360_w": 360,
                "thumb_360_h": 203,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_480.jpg",
                "thumb_480_w": 480,
                "thumb_480_h": 271,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_160.jpg",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_720.jpg",
                "thumb_720_w": 720,
                "thumb_720_h": 406,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_800.jpg",
                "thumb_800_w": 800,
                "thumb_800_h": 451,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_960.jpg",
                "thumb_960_w": 960,
                "thumb_960_h": 542,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F012RL60B3Q-3394c416a2/image_from_ios_1024.jpg",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 578,
                "original_w": 1099,
                "original_h": 620,
                "thumb_tiny": "AwAbADCnS7T6Gkp4ILAZUZ7k1qIaFOQCDk9KcRgkc5FKFG8HenX1pWA3t86dT3pXHYZRSsAMfMpz6GkyPWqTENp+4f5FMopAOByw6lQewpxIy3XBJI4qOiiwDmbI4P6U2iigD//Z",
                "permalink": "https://futureofcoding.slack.com/files/U5STGTB3J/F012RL60B3Q/image_from_ios.jpg",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F012RL60B3Q-75a67661e0",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XMyV/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As Kevlin Henney likes to point out in many of his presentations, a fundamental problem is mutable shared state. Sure, pure functions are one solution to this and they are extremely useful, but there are other ways that can be useful too. Better ways to handle value and reference semantics, for instance. I\u2019m excited for what is being explored in Swift and Rust (and C++)."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "U5STGTB3J",
        "display_as_bot": false,
        "ts": "1588453561.434500",
        "client_msg_id": "780E4A87-20A4-477C-9208-37FC79562AE0",
        "thread_ts": "1588452793.429100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    }
]