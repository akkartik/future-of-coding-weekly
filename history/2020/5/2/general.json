[
    {
        "client_msg_id": "9ad33f50-93bb-4c9a-b61c-f3574a6f9fe7",
        "type": "message",
        "text": "<@UC21F8Q48> Thanks for the spreadsheet analogy. Although watching the video, I didn't see see the equivalent of \"editing the equation\".\n\nCan you suggest related work that I should look at? I'm trying to understand these ideas well enough to implement them in a system for creating 3D models using pure functional programming.",
        "user": "UJN1TAYEQ",
        "ts": "1588374012.412300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QVyl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC21F8Q48"
                            },
                            {
                                "type": "text",
                                "text": " Thanks for the spreadsheet analogy. Although watching the video, I didn't see see the equivalent of \"editing the equation\".\n\nCan you suggest related work that I should look at? I'm trying to understand these ideas well enough to implement them in a system for creating 3D models using pure functional programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "65729632-bc47-41d8-8ce6-a9cf3ebb9c33",
        "type": "message",
        "text": "<@UKDM3GLAJ> Nope, I can't find it either. I remember it was part of a collection of proposed extensions aiming to un-hardcode some of the lower levels of the web.",
        "user": "U71PMQ1V0",
        "ts": "1588375177.412500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vm+ox",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " Nope, I can't find it either. I remember it was part of a collection of proposed extensions aiming to un-hardcode some of the lower levels of the web."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588186429.337500",
        "parent_user_id": "UKDM3GLAJ"
    },
    {
        "client_msg_id": "0b3c991c-cfe8-45c9-964d-2683db4688f2",
        "type": "message",
        "text": "Well there\u2019s no text editing in Conal\u2019s Eros as originally conceived so you\u2019re right to wonder where it is. But Eros and spreadsheets both display values more prominently than code and invite manipulation on those values.",
        "user": "UC21F8Q48",
        "ts": "1588381473.412700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u=O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well there\u2019s no text editing in Conal\u2019s Eros as originally conceived so you\u2019re right to wonder where it is. But Eros and spreadsheets both display values more prominently than code and invite manipulation on those values."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "504d8524-def9-43cf-a4b2-6a3252070a7e",
        "type": "message",
        "text": "<@UC2A2ARPT> \u201cI think it\u2019s no secret that a lot of folks here aren\u2019t making programming tools in the traditional sense. Eg: I\u2019m making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: \u201coh, code!\u201c\u201d\n\nRight, and that might be appropriate for your problem, but I\u2019m suggesting that evaluation/code may not be needed for many/most of the tools which would allow people to do the things they are currently hiring programmers to do.\n\nThat is, the range of the things people typically want to make may be small enough for them to build from a well abstracted set of primitives in a no code way.",
        "user": "ULM3U6275",
        "ts": "1588386741.412900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jqike",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " \u201cI think it\u2019s no secret that a lot of folks here aren\u2019t making programming tools in the traditional sense. Eg: I\u2019m making a 2d/3d modelling tool for artists, that conveniently just so happens to have a notion of evaluation. Sneaking code in through the back door, as it were. Perhaps we need a name for that stuff: \u201coh, code!\u201c\u201d\n\nRight, and that might be appropriate for your problem, but I\u2019m suggesting that evaluation/code may not be needed for many/most of the tools which would allow people to do the things they are currently hiring programmers to do.\n\nThat is, the range of the things people typically want to make may be small enough for them to build from a well abstracted set of primitives in a no code way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588262541.361600",
        "parent_user_id": "UE0ETTCG7",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3458486d-f79d-4a35-8875-ede31569836b",
        "type": "message",
        "text": "Value-based programming has some niches where it makes sense, like audio/video signal processing where the work product are data streams, and there is often a continuous flow to these streams you don't stop and think about them and wait for some input from the user. In graphical interactive software you have a lot of state, lots of widgets, and management of 500 things on the screen at the same time becomes a major chore. Even the portfolio management system i worked on in FORTRAN back in the day on mainframes did batch processing that included a fair amount of state as we were always accumulating numbers into buckets for sorting and categorizing purposes. None of the projects i have worked on would be convenient at all inside a data centric world. I understand Doug's art generation language would benefit from this, but i consider this area a very specialized niche.\n\nI think of a spreadsheet as a poor-man's database. It is fundamentally a 3.5 dimension system; you have a 2D sheet, which you can break into sub-rectangles, so i call that 2.5 dimensions, and the 3rd dimension is the array of named sheets you can have. As long as your data can fit into that dimensionality it works okay; especially since MS beefed up Excel to support about a million rows. But showing the data and hiding all the formulas makes most spreadsheets unauditable  black magic systems, and really quite dangerous. It is a well known thing in business consulting to find out that some part of a company's fundamental processes have been automated via Excel. There is no question in my mind that a very robust data editor coupled with a graph database could give  Excel a run for its money, but going up against the MS machine is an expensive process. Just like IBM they use the F.U.D. technique for suppressing competition.",
        "user": "UEQ6M68H0",
        "ts": "1588400904.413300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1588406343.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M9h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Value-based programming has some niches where it makes sense, like audio/video signal processing where the work product are data streams, and there is often a continuous flow to these streams you don't stop and think about them and wait for some input from the user. In graphical interactive software you have a lot of state, lots of widgets, and management of 500 things on the screen at the same time becomes a major chore. Even the portfolio management system i worked on in FORTRAN back in the day on mainframes did batch processing that included a fair amount of state as we were always accumulating numbers into buckets for sorting and categorizing purposes. None of the projects i have worked on would be convenient at all inside a data centric world. I understand Doug's art generation language would benefit from this, but i consider this area a very specialized niche.\n\nI think of a spreadsheet as a poor-man's database. It is fundamentally a 3.5 dimension system; you have a 2D sheet, which you can break into sub-rectangles, so i call that 2.5 dimensions, and the 3rd dimension is the array of named sheets you can have. As long as your data can fit into that dimensionality it works okay; especially since MS beefed up Excel to support about a million rows. But showing the data and hiding all the formulas makes most spreadsheets unauditable  black magic systems, and really quite dangerous. It is a well known thing in business consulting to find out that some part of a company's fundamental processes have been automated via Excel. There is no question in my mind that a very robust data editor coupled with a graph database could give  Excel a run for its money, but going up against the MS machine is an expensive process. Just like IBM they use the F.U.D. technique for suppressing competition."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "2fac2ce1-4579-40d7-a81f-96a5a4f0c653",
        "type": "message",
        "text": "And honestly Excel doesn't scale so well.  As for the MS machine, I did not learn until visiting Microsoft (a good many years back now) how they had a real value proposition in supporting business seemingly separate from their role as a pedler of, iffy to my eyes, software.",
        "user": "UA14TGLTC",
        "ts": "1588404594.413600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q=v2e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And honestly Excel doesn't scale so well.  As for the MS machine, I did not learn until visiting Microsoft (a good many years back now) how they had a real value proposition in supporting business seemingly separate from their role as a pedler of, iffy to my eyes, software."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "5e7494cb-a7ba-460b-9304-0fee1ae43a76",
        "type": "message",
        "text": "<@ULM3U6275> I love it, \"oh, code!\"  That's perfect.  Definitely modeling tools give me a feel of \"fuck it: take the cartesian closure of this and call it a day.\"  (The reference here is to category theory where a Cartesian Closed Category is, basically, one with structures, unions, and functions.)  For example, you add a little bit of parametric modeling.  You think it would be nice to nest these so that parameters to a big model can be passed into its parts.  Then the next thing you know, you want to be able pass models as parameters.  Why not?",
        "user": "UA14TGLTC",
        "ts": "1588405005.413900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Ug",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " I love it, \"oh, code!\"  That's perfect.  Definitely modeling tools give me a feel of \"fuck it: take the cartesian closure of this and call it a day.\"  (The reference here is to category theory where a Cartesian Closed Category is, basically, one with structures, unions, and functions.)  For example, you add a little bit of parametric modeling.  You think it would be nice to nest these so that parameters to a big model can be passed into its parts.  Then the next thing you know, you want to be able pass models as parameters.  Why not?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588262541.361600",
        "parent_user_id": "UE0ETTCG7"
    },
    {
        "client_msg_id": "751b3e03-0ada-47e7-aede-3bf70a22e24d",
        "type": "message",
        "text": "At $12 a month per person, for an Office 365 license, MS has an almost insurmountable advantage. Google has been doing their best to cut off their air supply by gradually beefing up Google Sheets, and it is having some effect, but as a programming system once you go beyond simple stuff Excel is pretty ugly. But fully understand why people stay in Excel, because the current popular programming stack, HTML/CSS/JS/Frameworks is more than 10x the effort to learn.",
        "user": "UEQ6M68H0",
        "ts": "1588406629.414200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eQtvS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At $12 a month per person, for an Office 365 license, MS has an almost insurmountable advantage. Google has been doing their best to cut off their air supply by gradually beefing up Google Sheets, and it is having some effect, but as a programming system once you go beyond simple stuff Excel is pretty ugly. But fully understand why people stay in Excel, because the current popular programming stack, HTML/CSS/JS/Frameworks is more than 10x the effort to learn."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588341505.403500",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "324a6303-6ecf-4888-ba53-d41faf056430",
        "type": "message",
        "text": "<@UPMFG2571> I love this vision. It's something I've wanted for a while too: a comprehensive description of a whole stack, simulated in media, approachable from very basic knowledge with a smooth path to global understanding.",
        "user": "UMWF81HTP",
        "ts": "1588414994.414600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N1D+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UPMFG2571"
                            },
                            {
                                "type": "text",
                                "text": " I love this vision. It's something I've wanted for a while too: a comprehensive description of a whole stack, simulated in media, approachable from very basic knowledge with a smooth path to global understanding."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588307376.386900",
        "parent_user_id": "UMWF81HTP"
    },
    {
        "type": "message",
        "subtype": "thread_broadcast",
        "text": "<@UEQ6M68H0> Imperative programming (and shared mutable state) was a reasonable idea in the 1950's, 60's and 70's, when programs were small, processors had a single core, and internet-related security holes were not a concern. But imperative programming doesn't scale. The legacy of imperative and shared-mutable-state programming is responsible for our current software crisis. The future of coding is pure functional programming and immutable values.\n\nLarge programs with shared mutable state can't be fully understood or debugged. This problem becomes much worse with multiple cores. The imperative programming community's response to multi-core programming was mutable state shared between threads and processor cores, guarded by mutexes. This is a catastrophically bad programming model. You can't understand or debug the code. The solution is to eliminate shared mutable state.\n\nImperative programming doesn't scale to large numbers of cores--mutual exclusion mechanisms steal most of your performance. The solution is to eliminate shared mutable state. Machine learning with TensorFlow is an important example of massively multi-core programming. What makes it possible is that TensorFlow is a pure functional language. Unfortunately it has to be embedded in Python, because we don't have a mainstream pure functional language yet.\n\nAs an aside, I find it tragic that my personal computer has a 1000 cores (most in the GPU), and most of these cores must remain idle because my system software and apps are written in weak, stone age imperative languages that don't provide a simple and efficient way to distribute computation across a huge number of cores.\n\nImperative programming is a catastrophy for software security. In the imperative model, any function call can change any state in the entire system. This is the root cause of most security flaws. A sort function can encrypt all your files, display a ransom message, and phone home to an internet malware server. And we are seeing these kinds of exploits in supply chain attacks on open source software repositories. Pure functional programming puts security first: functions cannot have side effects, and functions have no access to data that isn't passed as an argument. The type system can trivially guarantee that a sort function will not intentionally spawn a bitcoin miner, or accidently corrupt shared mutable state outside of the array that you are sorting. A common response to the inherent insecurity of imperative code is sandboxing. It's a backwards approach. What if architects built buildings out of contact-sensitive explosive materials, then attempted to mitigate the resulting safety issues using a complex system of nested blast barriers. Imperative programming is inherently insecure, and pure functional programming is the answer.",
        "user": "UJN1TAYEQ",
        "ts": "1588422527.414900",
        "thread_ts": "1588341505.403500",
        "root": {
            "client_msg_id": "c4befa80-cd3d-4c0e-afc3-656607ac3d0a",
            "type": "message",
            "text": "Tangible Functional Programming by Conal Elliott\n\u2022 apps are user-friendly (usable, concrete, visual) but limit functionality, aren't composable\n\u2022 software libraries are programmer-friendly (composable, abstract, syntactic)\nThe dream is: unlimited access to functionality, usably and composably. How?\n\u2022 Unix pipes are a composable text-mode UI, but we lose the GUI.\n\u2022 A Tangible Value is a typed value (model) paired with a GUI (view, controller). GUIs are composable whenever their underlying values are composable: eg unix-like pipelines, function composition.\n<http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability>",
            "user": "UJN1TAYEQ",
            "ts": "1588341505.403500",
            "team": "T5TCAFTA9",
            "blocks": [
                {
                    "type": "rich_text",
                    "block_id": "fUr",
                    "elements": [
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "Tangible Functional Programming by Conal Elliott\n"
                                }
                            ]
                        },
                        {
                            "type": "rich_text_list",
                            "elements": [
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "apps are user-friendly (usable, concrete, visual) but limit functionality, aren't composable"
                                        }
                                    ]
                                },
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "software libraries are programmer-friendly (composable, abstract, syntactic)"
                                        }
                                    ]
                                }
                            ],
                            "style": "bullet",
                            "indent": 0
                        },
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "text",
                                    "text": "The dream is: unlimited access to functionality, usably and composably. How?\n"
                                }
                            ]
                        },
                        {
                            "type": "rich_text_list",
                            "elements": [
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "Unix pipes are a composable text-mode UI, but we lose the GUI."
                                        }
                                    ]
                                },
                                {
                                    "type": "rich_text_section",
                                    "elements": [
                                        {
                                            "type": "text",
                                            "text": "A Tangible Value is a typed value (model) paired with a GUI (view, controller). GUIs are composable whenever their underlying values are composable: eg unix-like pipelines, function composition."
                                        }
                                    ]
                                }
                            ],
                            "style": "bullet",
                            "indent": 0
                        },
                        {
                            "type": "rich_text_section",
                            "elements": [
                                {
                                    "type": "link",
                                    "url": "http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability"
                                }
                            ]
                        }
                    ]
                }
            ],
            "thread_ts": "1588341505.403500",
            "reply_count": 10,
            "reply_users_count": 4,
            "latest_reply": "1588422527.414900",
            "reply_users": [
                "UJN1TAYEQ",
                "UEQ6M68H0",
                "UC21F8Q48",
                "UA14TGLTC"
            ],
            "subscribed": false
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fP2e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " Imperative programming (and shared mutable state) was a reasonable idea in the 1950's, 60's and 70's, when programs were small, processors had a single core, and internet-related security holes were not a concern. But imperative programming doesn't scale. The legacy of imperative and shared-mutable-state programming is responsible for our current software crisis. The future of coding is pure functional programming and immutable values.\n\nLarge programs with shared mutable state can't be fully understood or debugged. This problem becomes much worse with multiple cores. The imperative programming community's response to multi-core programming was mutable state shared between threads and processor cores, guarded by mutexes. This is a catastrophically bad programming model. You can't understand or debug the code. The solution is to eliminate shared mutable state.\n\nImperative programming doesn't scale to large numbers of cores--mutual exclusion mechanisms steal most of your performance. The solution is to eliminate shared mutable state. Machine learning with TensorFlow is an important example of massively multi-core programming. What makes it possible is that TensorFlow is a pure functional language. Unfortunately it has to be embedded in Python, because we don't have a mainstream pure functional language yet.\n\nAs an aside, I find it tragic that my personal computer has a 1000 cores (most in the GPU), and most of these cores must remain idle because my system software and apps are written in weak, stone age imperative languages that don't provide a simple and efficient way to distribute computation across a huge number of cores.\n\nImperative programming is a catastrophy for software security. In the imperative model, any function call can change any state in the entire system. This is the root cause of most security flaws. A sort function can encrypt all your files, display a ransom message, and phone home to an internet malware server. And we are seeing these kinds of exploits in supply chain attacks on open source software repositories. Pure functional programming puts security first: functions cannot have side effects, and functions have no access to data that isn't passed as an argument. The type system can trivially guarantee that a sort function will not intentionally spawn a bitcoin miner, or accidently corrupt shared mutable state outside of the array that you are sorting. A common response to the inherent insecurity of imperative code is sandboxing. It's a backwards approach. What if architects built buildings out of contact-sensitive explosive materials, then attempted to mitigate the resulting safety issues using a complex system of nested blast barriers. Imperative programming is inherently insecure, and pure functional programming is the answer."
                            }
                        ]
                    }
                ]
            }
        ],
        "client_msg_id": "a4f35e67-7b15-4ba1-b7e8-642f770f0bff"
    }
]