[
    {
        "client_msg_id": "e8bcd43c-adca-470f-937a-d7d394d04fc8",
        "type": "message",
        "text": "I use github, but I am wary of being tightly coupled to it. My project doesn't have a wiki, it has a 'docs' directory. It also has an 'issues' directory, although casual users are free to create github issues. For many years, I have done 'development from anywhere' by either bringing along a laptop with a dev environment, or by ssh-ing into my main dev machine from anywhere. If github were to instantly vanish with no warning, I would be fine, and that's due to the distributed nature of git, and the fact that my dev environment contains a local copy of all my code. Github would surely benefit by turning into a walled garden with so much crucial functionality that only exists in their servers, not on your local machine, that you are locked in and cannot escape. The more it looks like Github is heading in this direction, the more that some people in the dev community will resist, create alternatives, and migrate elsewhere. My personal future of coding is decentralized. Git is an amazing decentralized tool, but more can be done.",
        "user": "UJN1TAYEQ",
        "ts": "1588991352.256000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "q65f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I use github, but I am wary of being tightly coupled to it. My project doesn't have a wiki, it has a 'docs' directory. It also has an 'issues' directory, although casual users are free to create github issues. For many years, I have done 'development from anywhere' by either bringing along a laptop with a dev environment, or by ssh-ing into my main dev machine from anywhere. If github were to instantly vanish with no warning, I would be fine, and that's due to the distributed nature of git, and the fact that my dev environment contains a local copy of all my code. Github would surely benefit by turning into a walled garden with so much crucial functionality that only exists in their servers, not on your local machine, that you are locked in and cannot escape. The more it looks like Github is heading in this direction, the more that some people in the dev community will resist, create alternatives, and migrate elsewhere. My personal future of coding is decentralized. Git is an amazing decentralized tool, but more can be done."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "UE0ETTCG7"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "9e21e6bd-6578-475d-b827-fc603b886ef3",
        "type": "message",
        "text": "Is anyone aware of a programming language or library that efficiently solves the problem of incremental reactive recalculations involving collections? I'm a fan of libraries that support reactive updates, such as Assisticant, KnockoutJS, MobX, Vue.js and SwiftUI, but I don't know of one that contains the algorithm I want. I'll explain the problem by example. Suppose you have:\n\n1. an \"observable\" list of a million items, and you insert or remove an item somewhere in the list\n2. a filtered list based on the million items showing perhaps a thousand of the items\n3. a projection of the filtered list (map/select)\nSo, when you insert or remove the item, the library should efficiently (and automatically!) propagate the change through the filtered list to the projected list. If the new or removed item is filtered out anyway, propagation should stop so the projected list is not notified of a change. Ideally, change notifications should be deferred in some way so that if several changes are made to the same list item in rapid succession, the derived items (2 and 3) would only be notified once.",
        "user": "UD6EXQVM0",
        "ts": "1588994003.263900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1588994210.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+TeR/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is anyone aware of a programming language or library that efficiently solves the problem of incremental reactive recalculations involving collections? I'm a fan of libraries that support reactive updates, such as Assisticant, KnockoutJS, MobX, Vue.js and SwiftUI, but I don't know of one that contains the algorithm I want. I'll explain the problem by example. Suppose you have:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "an \"observable\" list of a million items, and you insert or remove an item somewhere in the list"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "a filtered list based on the million items showing perhaps a thousand of the items"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "a projection of the filtered list (map/select)"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSo, when you insert or remove the item, the library should efficiently (and automatically!) propagate the change through the filtered list to the projected list. If the new or removed item is filtered out anyway, propagation should stop so the projected list is not notified of a change. Ideally, change notifications should be deferred in some way so that if several changes are made to the same list item in rapid succession, the derived items (2 and 3) would only be notified once."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "reply_count": 18,
        "reply_users_count": 9,
        "latest_reply": "1589112214.295900",
        "reply_users": [
            "ULK0Z4MPV",
            "UT9TWSZB5",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "UC2A2ARPT",
            "UAVCC2X70",
            "UD6EXQVM0",
            "U71PMQ1V0",
            "UA14TGLTC"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "100",
                "users": [
                    "ULK0Z4MPV"
                ],
                "count": 1
            },
            {
                "name": "thinking_face",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "BA2C1479-61CA-491D-A8CA-2436D143C6FB",
        "type": "message",
        "text": "I\u2019m trying to solve this exact problem right now! I\u2019m very close to trying to roll my own solution. I\u2019m thinking of shifting from observables to a more decoupled event system. I find they are creating unintended side effects and are difficult to debug (and I need events for undo functionality). Anyway, let me know if you find a solution - or would like to help build one!",
        "user": "ULK0Z4MPV",
        "ts": "1588994861.271000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ICC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m trying to solve this exact problem right now! I\u2019m very close to trying to roll my own solution. I\u2019m thinking of shifting from observables to a more decoupled event system. I find they are creating unintended side effects and are difficult to debug (and I need events for undo functionality). Anyway, let me know if you find a solution - or would like to help build one!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UD6EXQVM0",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "64FD361D-769F-4CCA-AFA9-866908149E9B",
        "type": "message",
        "text": "Are you looking for something in-memory or a database?",
        "user": "UT9TWSZB5",
        "ts": "1588997342.273200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BlUV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are you looking for something in-memory or a database?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "4aff010a-175f-40e7-96fd-81a32b4ca24e",
        "type": "message",
        "text": "Recording's up now. The question starts here: <https://youtu.be/1ql__-f4rB4?t=2235>",
        "user": "U8A5MS6R1",
        "ts": "1588997445.273400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1588997451.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T+8O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Recording's up now. The question starts here: "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/1ql__-f4rB4?t=2235"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588873457.213000",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "719AFAB7-1D31-4F8C-8ADD-C5EAD18EA183",
        "type": "message",
        "text": "In memory ",
        "user": "ULK0Z4MPV",
        "ts": "1588998972.274000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mVQG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In memory "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "6e1ea29c-3a87-40da-a65c-98032b40b658",
        "type": "message",
        "text": "I am sure that in Excel which can handle about a million rows before it tops out, that they are using some paginated system, whereby if something changes in a chunk the whole chunk is rebuilt but otherwise intermediate chunks with their subtotals is maintained. A lot of the code in Excel is about handling the scale of the databases that people are throwing at Excel. The lower scale functionality is pretty easy, having written a spreadsheet before. Very important to cluster the data otherwise your CPU will almost come to a halt. This is a very tricky area that takes lots of testing to verify that your algorithm interacts well with the CPU. Since you have a very specific set of requirements you will need to roll your own; the conventional systems are not built for this kind of load.",
        "user": "UEQ6M68H0",
        "ts": "1589006569.274200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uug5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am sure that in Excel which can handle about a million rows before it tops out, that they are using some paginated system, whereby if something changes in a chunk the whole chunk is rebuilt but otherwise intermediate chunks with their subtotals is maintained. A lot of the code in Excel is about handling the scale of the databases that people are throwing at Excel. The lower scale functionality is pretty easy, having written a spreadsheet before. Very important to cluster the data otherwise your CPU will almost come to a halt. This is a very tricky area that takes lots of testing to verify that your algorithm interacts well with the CPU. Since you have a very specific set of requirements you will need to roll your own; the conventional systems are not built for this kind of load."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "A75A2767-FD34-4291-89A0-2C30E310977F",
        "type": "message",
        "text": "The best tool for a local-first approach is probably Fossil, which keeps issues in the repository itself, and therefore in every local copy. But being non-git, it will probably remain a niche tool.",
        "user": "UJBAJNFLK",
        "ts": "1589006803.277300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3j7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The best tool for a local-first approach is probably Fossil, which keeps issues in the repository itself, and therefore in every local copy. But being non-git, it will probably remain a niche tool."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588787721.156700",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "0df4288c-0691-48ee-9672-7df4694e5524",
        "type": "message",
        "text": "I'm starting to investigate the use of Lenses to address this problem, but I don't have any concrete solutions yet. I just discovered this week the existence of a long running \"bx\" community (bidirectional transformation) who work on these problems. EDIT: I checked, and the BX people mostly use Haskell, so their code probably won't help you, due to their library dependencies.",
        "user": "UJN1TAYEQ",
        "ts": "1589024801.278100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1589027545.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2fj0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm starting to investigate the use of Lenses to address this problem, but I don't have any concrete solutions yet. I just discovered this week the existence of a long running \"bx\" community (bidirectional transformation) who work on these problems. EDIT: I checked, and the BX people mostly use Haskell, so their code probably won't help you, due to their library dependencies."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0",
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UAJ9DV971"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "078504F3-24DD-4A44-BE36-5B9D75F39B31",
        "type": "message",
        "text": "I believe transducers in Clojure were designed to allow you to build data structures and operations that can be composed in this way.\n\nBut if perf is your main concern, it probably should be easy enough to roll your own in any language. Us front end devs have to do very similar things to efficiently render large table views in the browser.",
        "user": "UC2A2ARPT",
        "ts": "1589036571.279900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1589036796.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E=AJ6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I believe transducers in Clojure were designed to allow you to build data structures and operations that can be composed in this way.\n\nBut if perf is your main concern, it probably should be easy enough to roll your own in any language. Us front end devs have to do very similar things to efficiently render large table views in the browser."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "46e9539e-400a-4266-a1fd-94c167ca15e6",
        "type": "message",
        "text": "In BV's \"Future of Programming\", he talks about how memory and processors are made of the same material (transistors), so eventually it should all just be a bunch of processors.\n\nI think this is the kind of application where something like that would work: where a bunch of units are constantly a function of others. So like if you could allocate arbitrary chunks of memory and \"assign\" an operation relative to some other chunk.\n\nMaybe that's more like PLA than a bunch of \"processors\", but maybe that's the goal: being able to reduce pure functional operations down to programmed logic on the hardware that's constantly updating, without all having to be cycled single-file through a CPU.",
        "user": "UAVCC2X70",
        "ts": "1589037901.280400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BmW5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In BV's \"Future of Programming\", he talks about how memory and processors are made of the same material (transistors), so eventually it should all just be a bunch of processors.\n\nI think this is the kind of application where something like that would work: where a bunch of units are constantly a function of others. So like if you could allocate arbitrary chunks of memory and \"assign\" an operation relative to some other chunk.\n\nMaybe that's more like PLA than a bunch of \"processors\", but maybe that's the goal: being able to reduce pure functional operations down to programmed logic on the hardware that's constantly updating, without all having to be cycled single-file through a CPU."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "7ede554d-3b00-4074-9aa9-712f601429de",
        "type": "message",
        "text": "<@UC2A2ARPT> If it's easy enough, could you enlighten us? I've been thinking about this problem occasionally for several years and never fully cracked it",
        "user": "UD6EXQVM0",
        "ts": "1589041273.280700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a6fS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " If it's easy enough, could you enlighten us? I've been thinking about this problem occasionally for several years and never fully cracked it"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "a64ef43c-5367-4597-a5ef-b4fdb9d8d3d1",
        "type": "message",
        "text": "transducers in Clojure are unidirectional. In David's context, you can transform the model to the view, but you cannot modify the view and propagate the changes back to the model.\n\nLenses are like transducers, except that they are bidirectional, which is needed for David's \"reactive updates\". That's why I was talking about \"bx\" or bidirectional transformation.\n\nLenses look easy enough (I'm going to try my first implementation of them soon enough). But the requirement is for efficient bidirectional transformation of a million items. Surely that requires more thought than the usual simple Lens implementation?",
        "user": "UJN1TAYEQ",
        "ts": "1589044812.280900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ODdM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "transducers in Clojure are unidirectional. In David's context, you can transform the model to the view, but you cannot modify the view and propagate the changes back to the model.\n\nLenses are like transducers, except that they are bidirectional, which is needed for David's \"reactive updates\". That's why I was talking about \"bx\" or bidirectional transformation.\n\nLenses look easy enough (I'm going to try my first implementation of them soon enough). But the requirement is for efficient bidirectional transformation of a million items. Surely that requires more thought than the usual simple Lens implementation?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "5c589c58-3099-4188-a595-6c06a8db2b33",
        "type": "message",
        "text": "I mocked something out that should effectively do what you're looking for:\n```\ntype Paper = {\n\tid: string\n\tsubject: string\n\tdate: string // ISO\n}\n\nconst collection: Record&lt;string, Paper&gt; = {}\n\n// This is the query I want to index:\n// Filter for nutrition items this year, range 20-40.\nObject.values(collection)\n\t.filter((item) =&gt; item.subject === \"Nutrition\" &amp;&amp; item.date &gt; \"2020-01-01\")\n\t.slice(20, 40)\n\n// First, lets translate this into a composite index.\nconst filterIndex: Array&lt;[string, string, string]&gt; = [] // [subject, date, id]\nfor (const item of Object.values(collection)) {\n\t// uses binary search to insert in sorted order.\n\taddToIndex(filterIndex, [item.subject, item.date])\n}\n\n// Translate your query into subscriptions.\nconst subscriptions = [\n\t[\n\t\t\"date\",\n\t\t\"2020-01-01\",\n\t\t() =&gt; {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n\t[\n\t\t\"filterIndex\",\n\t\t20,\n\t\t40,\n\t\t() =&gt; {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n\t[\n\t\t\"subject\",\n\t\t\"Nutrition\",\n\t\t() =&gt; {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n]\n\nfunction updateItem(id: string, update: Partial&lt;Paper&gt;) {\n\t// Emit on the old key-value because this will be removed from result set.\n\tfor (const key in update) {\n\t\tsubscriptions\n\t\t\t.filter(([a, b]) =&gt; a === key &amp;&amp; b === collection[id][key])\n\t\t\t.forEach(([_a, _b, callback]) =&gt; callback())\n\t}\n\n\tconst beforeIndex = removeFromIndex(filterIndex, collection[id])\n\tObject.assign(collection[id], update)\n\tconst afterIndex = addToIndex(filterIndex, collection[id])\n\n\t// Emit on the new key value because this will be added to result set.\n\tfor (const key in update) {\n\t\tsubscriptions\n\t\t\t.filter(([a, b]) =&gt; a === key &amp;&amp; b === collection[id][key])\n\t\t\t.forEach(([_a, _b, callback]) =&gt; callback())\n\t}\n\n\tif (beforeIndex !== afterIndex) {\n\t\t// Emit an update for all listeners on filterIndex between before and after.\n\t}\n}```",
        "user": "UT9TWSZB5",
        "ts": "1589049514.281600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0+cKT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mocked something out that should effectively do what you're looking for:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\ntype Paper = {\n\tid: string\n\tsubject: string\n\tdate: string // ISO\n}\n\nconst collection: Record<string, Paper> = {}\n\n// This is the query I want to index:\n// Filter for nutrition items this year, range 20-40.\nObject.values(collection)\n\t.filter((item) => item.subject === \"Nutrition\" && item.date > \"2020-01-01\")\n\t.slice(20, 40)\n\n// First, lets translate this into a composite index.\nconst filterIndex: Array<[string, string, string]> = [] // [subject, date, id]\nfor (const item of Object.values(collection)) {\n\t// uses binary search to insert in sorted order.\n\taddToIndex(filterIndex, [item.subject, item.date])\n}\n\n// Translate your query into subscriptions.\nconst subscriptions = [\n\t[\n\t\t\"date\",\n\t\t\"2020-01-01\",\n\t\t() => {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n\t[\n\t\t\"filterIndex\",\n\t\t20,\n\t\t40,\n\t\t() => {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n\t[\n\t\t\"subject\",\n\t\t\"Nutrition\",\n\t\t() => {\n\t\t\t/* Update callback */\n\t\t},\n\t],\n]\n\nfunction updateItem(id: string, update: Partial<Paper>) {\n\t// Emit on the old key-value because this will be removed from result set.\n\tfor (const key in update) {\n\t\tsubscriptions\n\t\t\t.filter(([a, b]) => a === key && b === collection[id][key])\n\t\t\t.forEach(([_a, _b, callback]) => callback())\n\t}\n\n\tconst beforeIndex = removeFromIndex(filterIndex, collection[id])\n\tObject.assign(collection[id], update)\n\tconst afterIndex = addToIndex(filterIndex, collection[id])\n\n\t// Emit on the new key value because this will be added to result set.\n\tfor (const key in update) {\n\t\tsubscriptions\n\t\t\t.filter(([a, b]) => a === key && b === collection[id][key])\n\t\t\t.forEach(([_a, _b, callback]) => callback())\n\t}\n\n\tif (beforeIndex !== afterIndex) {\n\t\t// Emit an update for all listeners on filterIndex between before and after.\n\t}\n}"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0",
        "reactions": [
            {
                "name": "confused",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a420c848-6a6b-4acf-aafd-a6b3af736ce5",
        "type": "message",
        "text": "This pattern is something I discovered when I was building a datalog prototype. Using reified indexes on your queries makes subscriptions a lot easier.",
        "user": "UT9TWSZB5",
        "ts": "1589049571.281800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "euX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This pattern is something I discovered when I was building a datalog prototype. Using reified indexes on your queries makes subscriptions a lot easier."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "bdeb6dae-2613-4191-a36e-fc05360046d1",
        "type": "message",
        "text": "<https://github.com/ccorcos/datalog-prototype/tree/master/src/shared/database>",
        "user": "UT9TWSZB5",
        "ts": "1589049574.282000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UT9TWSZB5",
            "ts": "1589049576.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n9Wlm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://github.com/ccorcos/datalog-prototype/tree/master/src/shared/database"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1588994003.263900",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "client_msg_id": "f45cc5c8-84e8-4ca4-8f63-c1d6d03181bf",
        "type": "message",
        "text": "Hmm, anyone else here always forget the syntax of INSERT and UPDATE because they are so different from each other? Doesn't seem like great attention to human factors in that case.",
        "user": "UD6EXQVM0",
        "ts": "1589053332.282800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UD6EXQVM0",
            "ts": "1589053378.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lVl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm, anyone else here always forget the syntax of INSERT and UPDATE because they are so different from each other? Doesn't seem like great attention to human factors in that case."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587147667.485000",
        "parent_user_id": "U85HCL7JP"
    },
    {
        "client_msg_id": "125C0E4F-A493-4282-A122-23836A1358F8",
        "type": "message",
        "text": "Yes! I\u2019d be curious to know why they are different.",
        "user": "UFEQUBNNT",
        "ts": "1589060108.283500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zLqpA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes! I\u2019d be curious to know why they are different."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1587147667.485000",
        "parent_user_id": "U85HCL7JP"
    }
]