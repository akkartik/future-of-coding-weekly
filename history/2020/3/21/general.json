[
    {
        "client_msg_id": "76b0e3c8-1eb2-4098-9114-f3bdf8e2ad08",
        "type": "message",
        "text": "I agree that Begriffsschrift laid some foundations that were important in the development of programming languages. But Frege himself didn't want to create a mere programming language (which is just symbol manipulation system, executed by a machine). He wanted to create a human language for precisely and unambiguously reasoning about the real world. Some quotes:\n\u2022 \"My intention was not to represent an abstract logic in formulas, but to express a content through written signs in a more precise and clear way than it is possible to do through words. In fact, what I wanted to create was not a mere calculus ratiocinator but a lingua characterica in Leibniz's sense\". [I interpret \"calculus ratiocinator\" as meaning formal language or programming language.]\n\u2022 I called what alone mattered to me the conceptual content. Hence this definition must always be kept in mind if one wishes to gain a proper understanding of what my formula language is. That, too, is what led me to the name \"Begriffsschrift\". Since I confined myself for the time being to expressing relations that are independent of the particular characteristics of objects, I was also able to use the expression \"formula language for pure thought\". That it is modeled upon the formula language of arithmetic, as I indicated in the title, has to do with fundamental ideas rather than with details of execution. Any effort to create an artificial similarity by regarding a concept as the sum of its marks was entirely alien to my thought.",
        "user": "UJN1TAYEQ",
        "ts": "1584749482.458800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RxOmH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree that Begriffsschrift laid some foundations that were important in the development of programming languages. But Frege himself didn't want to create a mere programming language (which is just symbol manipulation system, executed by a machine). He wanted to create a human language for precisely and unambiguously reasoning about the real world. Some quotes:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\"My intention was not to represent an abstract logic in formulas, but to express a content through written signs in a more precise and clear way than it is possible to do through words. In fact, what I wanted to create was not a mere calculus ratiocinator but a lingua characterica in Leibniz's sense\". [I interpret \"calculus ratiocinator\" as meaning formal language or programming language.]"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I called what alone mattered to me the conceptual content. Hence this definition must always be kept in mind if one wishes to gain a proper understanding of what my formula language is. That, too, is what led me to the name \"Begriffsschrift\". Since I confined myself for the time being to expressing relations that are independent of the particular characteristics of objects, I was also able to use the expression \"formula language for pure thought\". That it is modeled upon the formula language of arithmetic, as I indicated in the title, has to do with fundamental ideas rather than with details of execution. Any effort to create an artificial similarity by regarding a concept as the sum of its marks was entirely alien to my thought."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "3b3c1d4d-004b-4403-959d-badfb2655951",
        "type": "message",
        "text": "It's true that his goal was more specific than just a  symbol manipulation system, but so are our programming languages themselves. While Frege's language maps to logical thought, our programming languages map to API usage, hardware communication, and data generation. Note also how he talks about it being the glue for more specific systems that might be invented in the future.",
        "user": "UP54KN8TX",
        "ts": "1584750028.459000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BEX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's true that his goal was more specific than just a  symbol manipulation system, but so are our programming languages themselves. While Frege's language maps to logical thought, our programming languages map to API usage, hardware communication, and data generation. Note also how he talks about it being the glue for more specific systems that might be invented in the future."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "6c391e2d-273a-40cc-93e8-8177d0f1ab4e",
        "type": "message",
        "text": "The analogy I like to make is with literacy. Not everyone can write novels, but a large fraction of the population today can _read_ novels, comprehend them, compare and contrast similarities and differences between two novels, and so on. That seems like a useful bar to aim for for software, and it seems like a very high priority. If aiming for it breaks copyright, I say we need to rethink copyright. If it creates liability, I say we need to rethink liability. (Though free software has no liability today. There's no reason we can't keep doing that. This law has no teeth at the moment.)",
        "user": "UCUSW7WVD",
        "ts": "1584750700.459300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HPy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The analogy I like to make is with literacy. Not everyone can write novels, but a large fraction of the population today can "
                            },
                            {
                                "type": "text",
                                "text": "read",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " novels, comprehend them, compare and contrast similarities and differences between two novels, and so on. That seems like a useful bar to aim for for software, and it seems like a very high priority. If aiming for it breaks copyright, I say we need to rethink copyright. If it creates liability, I say we need to rethink liability. (Though free software has no liability today. There's no reason we can't keep doing that. This law has no teeth at the moment.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF",
        "reactions": [
            {
                "name": "clap",
                "users": [
                    "UAVCC2X70",
                    "UA14TGLTC",
                    "U8A5MS6R1"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "3493e94c-3ad8-474d-9726-a3f6c033a123",
        "type": "message",
        "text": "There is another goal that programming languages can have, and that is to communicate ideas to other humans. My project, Curv, is a language for describing geometric shapes. Ideally, I would like to keep the language \"pure\", and omit any features that are not needed for the purpose of describing shapes in an abstract, mathematical way. For example, the language has numbers, but for the pure purpose of describing mathematical relationships to another human being, I just need the abstract concept of numbers. To execute code efficiently on a GPU, I need to introduce concepts like 'int32', 'float32', 'float64', and so on, which adds a lot of extra complexity. This tension in my language is one thing that came to mind when I was reading Frege.",
        "user": "UJN1TAYEQ",
        "ts": "1584756326.459800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VMmV1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is another goal that programming languages can have, and that is to communicate ideas to other humans. My project, Curv, is a language for describing geometric shapes. Ideally, I would like to keep the language \"pure\", and omit any features that are not needed for the purpose of describing shapes in an abstract, mathematical way. For example, the language has numbers, but for the pure purpose of describing mathematical relationships to another human being, I just need the abstract concept of numbers. To execute code efficiently on a GPU, I need to introduce concepts like 'int32', 'float32', 'float64', and so on, which adds a lot of extra complexity. This tension in my language is one thing that came to mind when I was reading Frege."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "8129650C-CFB7-4AE7-A43F-D2E52628CABC",
        "type": "message",
        "text": "Thanks for sharing. I knew of the Begriffsschrift for inventing first order logic but I\u2019ve never read it before. I was surprised he brought up Leibniz\u2019s ratiocinator which also is somewhat similar to the goals of this community. ",
        "user": "UFPRPSA4S",
        "ts": "1584756981.465700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+sVb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for sharing. I knew of the Begriffsschrift for inventing first order logic but I\u2019ve never read it before. I was surprised he brought up Leibniz\u2019s ratiocinator which also is somewhat similar to the goals of this community. "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "707c1e26-0be1-4658-8e17-aec2fcccd6a6",
        "type": "message",
        "text": "Firstly, I think you're not the only one on here building a language-agonistic editor. Someone described an generic AST editor of some sort? If you could all find each other, you might be able to form a collaboration.",
        "user": "UAVCC2X70",
        "ts": "1584757194.466300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rL9AQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Firstly, I think you're not the only one on here building a language-agonistic editor. Someone described an generic AST editor of some sort? If you could all find each other, you might be able to form a collaboration."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U01003H81UM"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d8bb7c1e-0905-4920-b0fd-b24ca9425373",
        "type": "message",
        "text": "Some hopefully not too random questions: How do you regard it as the first programming language? What makes something a programming language. I usually don't think of first order logic as a programming language wheras the lambda calculus could be a programming language (why is this, can anyone say?). What is the relation between formal languages, programming languages, and languages for the purpose of thinking and communicating?",
        "user": "UFPRPSA4S",
        "ts": "1584758397.466500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d1+lk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some hopefully not too random questions: How do you regard it as the first programming language? What makes something a programming language. I usually don't think of first order logic as a programming language wheras the lambda calculus could be a programming language (why is this, can anyone say?). What is the relation between formal languages, programming languages, and languages for the purpose of thinking and communicating?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "e130b04c-f101-4838-a872-b16a5fb7ee30",
        "type": "message",
        "text": "A program is not a passive thing like a book. A book is created by the author, and you the user run through the book at your own speed, but every word you are going to read is pre-determined, fixed, and unchanging. Software by its nature is interactive both from a data point of view, and also by the operation of the various options and commands. The more flexible and changeable the commands are, the more you will call it \"malleable\". Just like people add accessories to cars, there are software products most notably Photoshop, which enables thousands of plug-ins to achieve additional function.\n\nThere is no reason why isolated apps have to stay isolated. We can (gasp) attempt to standardize on a protected arithmetic, and universal data interchange that is more robust than stupid JSON, which is a terribly weak interchange standard. Microsoft and Apple both put a lot of effort into intra-application communication, but unfortunately, Google and other web companies have spent most of their waking minutes trying to starve Apple, Adobe, and MS of their air supply by offering free versions of their core software with the goal of undermining their economic foundations.  In essence, Google maintains a near monopoly on search and advertising revenue, and with their vast surpluses engages in predatory attacks on traditional companies, all under the banner of \"Free! Free! Free!\".  Free until you want to get clicks for your company or service, then you find out how dear those clicks are.\n\nAnd now we have Amazon becoming a dominant player in cloud hosting, taking its vast surplus from selling to government extremely expensive secure racks that somehow are mandated by security regulations, and predating upon the data center market. In a recent visit to my racks in Fremont at a smaller competitor, it was half empty. I calculated that Amazon is more than 10x more expensive than doing it yourself, but now Amazon is proliferating options, and configuration tools that lock you in. So when you say malleable software, what part is malleable?  It practically takes 1000 hours now just to understand Amazon's catalog.\n\nThe overwhelming thrust of the current market is to increase complexity to such a ridiculous level that opening up a piece of software may not be that helpful, if you have to not only understand the code you are looking at, but also understand this tall tower of supporting tools and remote services.\n\nMy point is that a dramatic simplification is the first order of business, then you can make things very malleable, and have more flexible, personally customized products. There is indeed no good reason why things can't evolve towards more malleability, but i am asserting we are heading in the opposite direction at present inadvertently due to the complexification.",
        "user": "UEQ6M68H0",
        "ts": "1584758646.466700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sze6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A program is not a passive thing like a book. A book is created by the author, and you the user run through the book at your own speed, but every word you are going to read is pre-determined, fixed, and unchanging. Software by its nature is interactive both from a data point of view, and also by the operation of the various options and commands. The more flexible and changeable the commands are, the more you will call it \"malleable\". Just like people add accessories to cars, there are software products most notably Photoshop, which enables thousands of plug-ins to achieve additional function.\n\nThere is no reason why isolated apps have to stay isolated. We can (gasp) attempt to standardize on a protected arithmetic, and universal data interchange that is more robust than stupid JSON, which is a terribly weak interchange standard. Microsoft and Apple both put a lot of effort into intra-application communication, but unfortunately, Google and other web companies have spent most of their waking minutes trying to starve Apple, Adobe, and MS of their air supply by offering free versions of their core software with the goal of undermining their economic foundations.  In essence, Google maintains a near monopoly on search and advertising revenue, and with their vast surpluses engages in predatory attacks on traditional companies, all under the banner of \"Free! Free! Free!\".  Free until you want to get clicks for your company or service, then you find out how dear those clicks are.\n\nAnd now we have Amazon becoming a dominant player in cloud hosting, taking its vast surplus from selling to government extremely expensive secure racks that somehow are mandated by security regulations, and predating upon the data center market. In a recent visit to my racks in Fremont at a smaller competitor, it was half empty. I calculated that Amazon is more than 10x more expensive than doing it yourself, but now Amazon is proliferating options, and configuration tools that lock you in. So when you say malleable software, what part is malleable?  It practically takes 1000 hours now just to understand Amazon's catalog.\n\nThe overwhelming thrust of the current market is to increase complexity to such a ridiculous level that opening up a piece of software may not be that helpful, if you have to not only understand the code you are looking at, but also understand this tall tower of supporting tools and remote services.\n\nMy point is that a dramatic simplification is the first order of business, then you can make things very malleable, and have more flexible, personally customized products. There is indeed no good reason why things can't evolve towards more malleability, but i am asserting we are heading in the opposite direction at present inadvertently due to the complexification."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF"
    },
    {
        "client_msg_id": "53d848ee-fccc-4a89-9ca1-a19443a61091",
        "type": "message",
        "text": "I'll explain what I'm building in phases, because it's not about the specific tool, but the process that it enables:\n\nI'm building a tool in which code and data can be edited and interacted with as live objects on a canvas. Code and data are made of the same \"building blocks\" (structural representation) that can be inspected, edited, and executed (interpreted) directly from the live structure.\n\nAll the LIVE code for the tool itself -- including the user interface and the interpreter -- is also exposed for live editing through the same interface. You can use the tool, to completely change itself (down to the metal if you like) to work completely differently. This entire transformation can happen at runtime, without the tool ever \"stopping\".\n\nWhat I'm making is much more about this self-bootstrapping ability/ process, than it is about a specific tool that works a specific way. Building a specific tool is only necessary in the first place, just to bootstrap this ability into existence. So the initial \"tool\" just has to be minimally capable, even if it sucks -- and from there, I'll evolve it into something better through direct manipulation.\n\nImagine a robot capable of physically modifying itself, and programmed to improve itself. Even if it's not great at that, it could improve it's ability to improve itself, or even it's criteria for reasoning about what that means. If you can somehow make that initial robot _at all_, no matter how crappy, then you've succeeded in bootstrapping arbitrarily better robots. That's what I'm trying to do, but with software &amp; programming.\n\nThere's more to it than that, which is my philosophy on \"programming language\" not needing to be a solidly defined thing, or perhaps not even a thing at all! What is a compiler or interpreter, other than just code that operates on code? Why not put THAT code and YOUR code all in the same bucket? Instead of code + compiler, you have code (in whatever form makes sense for the context) + other code that executes or translates that code?\n\nHere is where the line blurs between programming language, and having code that iterates over a hardcoded list to avoid having to repeat a bunch of code that differs only by specific values. That's as much of a \"language\" as the one your code is written in!\n\nNow take that to the extreme, but think of being able to customize your own visual representation and / or editor for whatever makes sense for a given context. Imagine if \"code\" could contain instructions that told your IDE how to behave? That's the same as putting your code and the code OF the IDE in the same codebase. Just like I described for removing the separation between compiler + code.\n\nOne (example) vision I have is that \"code\" for something is not a text file that you open in another tool, but a self-contained executable program that, when you run it, presents you with a custom interface / model for \"the code\", including the code of the whole running program &amp; interface that it presents. No more dependency on some other interface! It's the same idea (in a sense) as infrastructure as code, or HATEOS\n\nBut what's that? you need a Java program? Fine, click a button, and it spits out a compiled-to-Java equivalent of \"just the product code\". Any code in any language or for any system, has a structure, and there's no reason that cannot be stored and executed as a _live_ structural representation, prior to generating the actual \"compiled\" built product from it.\n\nWhat's that? Execution in the tool is not the same as execution in the JVM (or whatever other target)? Well, the tool is written \"in itself\", and you already made a generate-the-equivalent-Java-code functionality; use that on the tool itself, and bootstrap the tool right into the JVM (or what have you). That's one perk of having just some generic code model with self contained rules for execution or translation.\n\nThere are so so many things and approaches and models for what \"code\" could be and how to model or visualize it, how it can be edited or projected, and what to even DO with the code (e.g. translate it) ... a tool like this would make it very easy to explore that space.\n\nWhat if the representation I choose is not great? What if the tools and process I provide for molding better tools and processes, really sucks? Well, then I mold better things for molding better things.\n\nSoftware is not just made of levers; it's made of levers for making levers. And I want to put that power in everyone's hands. This makes sense not just for programmers, but also for everyone else: What the heck does it even mean to have the power of a computer in your hand, without actually having any power of a computer in your hand? What a joke!\n\nBut what if people suck at computer stuff, though? Well gosh, if only they had the power of a computer to assist with using the power of a computer...",
        "user": "UAVCC2X70",
        "ts": "1584764693.467400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584833735.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ueu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll explain what I'm building in phases, because it's not about the specific tool, but the process that it enables:\n\nI'm building a tool in which code and data can be edited and interacted with as live objects on a canvas. Code and data are made of the same \"building blocks\" (structural representation) that can be inspected, edited, and executed (interpreted) directly from the live structure.\n\nAll the LIVE code for the tool itself -- including the user interface and the interpreter -- is also exposed for live editing through the same interface. You can use the tool, to completely change itself (down to the metal if you like) to work completely differently. This entire transformation can happen at runtime, without the tool ever \"stopping\".\n\nWhat I'm making is much more about this self-bootstrapping ability/ process, than it is about a specific tool that works a specific way. Building a specific tool is only necessary in the first place, just to bootstrap this ability into existence. So the initial \"tool\" just has to be minimally capable, even if it sucks -- and from there, I'll evolve it into something better through direct manipulation.\n\nImagine a robot capable of physically modifying itself, and programmed to improve itself. Even if it's not great at that, it could improve it's ability to improve itself, or even it's criteria for reasoning about what that means. If you can somehow make that initial robot "
                            },
                            {
                                "type": "text",
                                "text": "at all",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", no matter how crappy, then you've succeeded in bootstrapping arbitrarily better robots. That's what I'm trying to do, but with software & programming.\n\nThere's more to it than that, which is my philosophy on \"programming language\" not needing to be a solidly defined thing, or perhaps not even a thing at all! What is a compiler or interpreter, other than just code that operates on code? Why not put THAT code and YOUR code all in the same bucket? Instead of code + compiler, you have code (in whatever form makes sense for the context) + other code that executes or translates that code?\n\nHere is where the line blurs between programming language, and having code that iterates over a hardcoded list to avoid having to repeat a bunch of code that differs only by specific values. That's as much of a \"language\" as the one your code is written in!\n\nNow take that to the extreme, but think of being able to customize your own visual representation and / or editor for whatever makes sense for a given context. Imagine if \"code\" could contain instructions that told your IDE how to behave? That's the same as putting your code and the code OF the IDE in the same codebase. Just like I described for removing the separation between compiler + code.\n\nOne (example) vision I have is that \"code\" for something is not a text file that you open in another tool, but a self-contained executable program that, when you run it, presents you with a custom interface / model for \"the code\", including the code of the whole running program & interface that it presents. No more dependency on some other interface! It's the same idea (in a sense) as infrastructure as code, or HATEOS\n\nBut what's that? you need a Java program? Fine, click a button, and it spits out a compiled-to-Java equivalent of \"just the product code\". Any code in any language or for any system, has a structure, and there's no reason that cannot be stored and executed as a "
                            },
                            {
                                "type": "text",
                                "text": "live",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " structural representation, prior to generating the actual \"compiled\" built product from it.\n\nWhat's that? Execution in the tool is not the same as execution in the JVM (or whatever other target)? Well, the tool is written \"in itself\", and you already made a generate-the-equivalent-Java-code functionality; use that on the tool itself, and bootstrap the tool right into the JVM (or what have you). That's one perk of having just some generic code model with self contained rules for execution or translation.\n\nThere are so so many things and approaches and models for what \"code\" could be and how to model or visualize it, how it can be edited or projected, and what to even DO with the code (e.g. translate it) ... a tool like this would make it very easy to explore that space.\n\nWhat if the representation I choose is not great? What if the tools and process I provide for molding better tools and processes, really sucks? Well, then I mold better things for molding better things.\n\nSoftware is not just made of levers; it's made of levers for making levers. And I want to put that power in everyone's hands. This makes sense not just for programmers, but also for everyone else: What the heck does it even mean to have the power of a computer in your hand, without actually having any power of a computer in your hand? What a joke!\n\nBut what if people suck at computer stuff, though? Well gosh, if only they had the power of a computer to assist with using the power of a computer..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT",
                    "U01003H81UM"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e9ab59fb-ffb8-4eb4-8a85-6d55ec496e06",
        "type": "message",
        "text": "Also, most software is horrendously more complex than it needs to be. The level of \"intrinsic complexity\" of software IS NOT what many software professionals claim it to be. I blame the layers of language and tools and frameworks, and not having good visibility / representation of \"a program\", so much so that it's just freaking hard to be and to even think about it very well if you just have layers and layers of code. (As Bret Victor says, the role of programming language in most cases is that of a user interface -- and in that regard, it's a _terrible_ interface)\n\nI think a tool like this could get a lot of that junk or if the way, and a program that \"does x y and z\" would look like whatever the most immediately way to humanly depict that in simple terms would be. Which may be code, or a diagram, or whatever.",
        "user": "UAVCC2X70",
        "ts": "1584766787.468900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584766931.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eLVy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, most software is horrendously more complex than it needs to be. The level of \"intrinsic complexity\" of software IS NOT what many software professionals claim it to be. I blame the layers of language and tools and frameworks, and not having good visibility / representation of \"a program\", so much so that it's just freaking hard to be and to even think about it very well if you just have layers and layers of code. (As Bret Victor says, the role of programming language in most cases is that of a user interface -- and in that regard, it's a "
                            },
                            {
                                "type": "text",
                                "text": "terrible",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " interface)\n\nI think a tool like this could get a lot of that junk or if the way, and a program that \"does x y and z\" would look like whatever the most immediately way to humanly depict that in simple terms would be. Which may be code, or a diagram, or whatever."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "client_msg_id": "e8a2081f-e707-4412-b871-77ccec11a2b1",
        "type": "message",
        "text": "<@U01003H81UM>  - Regarding discussing our projects / goals -- see my comments above.",
        "user": "UAVCC2X70",
        "ts": "1584767029.469300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584767230.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "P5u3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01003H81UM"
                            },
                            {
                                "type": "text",
                                "text": "  - Regarding discussing our projects / goals -- see my comments above."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "client_msg_id": "86172fcf-b55d-4e70-b5af-5dfb41e48771",
        "type": "message",
        "text": "I would argue that a foundation of malleability encourages simplification. If I am choosing between two software offerings, and I open one up and see it\u2019s spaghetti that I have no hopes of interacting with, and I open the other up and see clean architecture, good documentation and sane abstractions, I\u2019m going to pick the latter one. If I can\u2019t look inside, though, I\u2019m going to pick whichever one has a better looking website.",
        "user": "UKDM3GLAJ",
        "ts": "1584796175.477400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pJy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would argue that a foundation of malleability encourages simplification. If I am choosing between two software offerings, and I open one up and see it\u2019s spaghetti that I have no hopes of interacting with, and I open the other up and see clean architecture, good documentation and sane abstractions, I\u2019m going to pick the latter one. If I can\u2019t look inside, though, I\u2019m going to pick whichever one has a better looking website."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC",
                    "UCKRZS3DZ"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "ee810e9c-498c-497c-a9fa-f71d6c3d61bb",
        "type": "message",
        "text": "One of the design principles of my Curv language is that it has simple, compositional semantics. The meaning of a compound expression is determined by the meanings of the subexpressions and by the rules used to combine them, in a simple way, with a minimum of \"spooky action at a distance\". This supports \"local reasoning\": you shouldn't need a mental model of the execution semantics or type inference semantics of a large chunk of the program, in order to understand the meaning of a small program fragment. The goal is to have semantics that are an order of magnitude simpler and easier to understand than in conventional programming languages.\n\nI got this idea from Denotational Semantics, but according to Wikipedia, this is called the Principal of Compositionality, and it was invented by Frege. If we look at a more reliable source than Wikipedia (<https://plato.stanford.edu/entries/compositionality/#FregContPrin>), we can find this principle in section 60 of the _Foundations of Arithmetic_ (1884).",
        "user": "UJN1TAYEQ",
        "ts": "1584804157.477600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8sy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of the design principles of my Curv language is that it has simple, compositional semantics. The meaning of a compound expression is determined by the meanings of the subexpressions and by the rules used to combine them, in a simple way, with a minimum of \"spooky action at a distance\". This supports \"local reasoning\": you shouldn't need a mental model of the execution semantics or type inference semantics of a large chunk of the program, in order to understand the meaning of a small program fragment. The goal is to have semantics that are an order of magnitude simpler and easier to understand than in conventional programming languages.\n\nI got this idea from Denotational Semantics, but according to Wikipedia, this is called the Principal of Compositionality, and it was invented by Frege. If we look at a more reliable source than Wikipedia ("
                            },
                            {
                                "type": "link",
                                "url": "https://plato.stanford.edu/entries/compositionality/#FregContPrin"
                            },
                            {
                                "type": "text",
                                "text": "), we can find this principle in section 60 of the "
                            },
                            {
                                "type": "text",
                                "text": "Foundations of Arithmetic",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (1884)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "E5EB15C0-7539-4FF3-86F5-B332D5D1DA7D",
        "type": "message",
        "text": "Indeed, but it\u2019s not just the legacy of the teletype, it\u2019s also the constraints of computers shared by several users. Smalltalk and the Lisp machine were designed for high-powered personal desktop machines, which were expensive luxury items. Today\u2019s powerful PCs slowly grew out of yesterday\u2019s low-power PCs, not out of Lisp machines or Altos.",
        "user": "UJBAJNFLK",
        "ts": "1584805084.483000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ONzIQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Indeed, but it\u2019s not just the legacy of the teletype, it\u2019s also the constraints of computers shared by several users. Smalltalk and the Lisp machine were designed for high-powered personal desktop machines, which were expensive luxury items. Today\u2019s powerful PCs slowly grew out of yesterday\u2019s low-power PCs, not out of Lisp machines or Altos."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584544384.396000",
        "parent_user_id": "USH01JEDQ"
    },
    {
        "client_msg_id": "92840519-1bb8-4954-8333-1d2dd1b0fadd",
        "type": "message",
        "text": "<https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3|https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3>",
        "user": "UBSMEUXAA",
        "ts": "1584806326.483400",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Sci-Hub: \u0443\u0441\u0442\u0440\u0430\u043d\u044f\u044f \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u044b \u043d\u0430 \u043f\u0443\u0442\u0438 \u0440\u0430\u0441\u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u043d\u0438\u0439",
                "title_link": "https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3",
                "text": "\u041f\u0435\u0440\u0432\u044b\u0439 \u0432 \u043c\u0438\u0440\u0435 \u043f\u0438\u0440\u0430\u0442\u0441\u043a\u0438\u0439 \u0440\u0435\u0441\u0443\u0440\u0441, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0442\u043a\u0440\u044b\u043b \u043c\u0430\u0441\u0441\u043e\u0432\u044b\u0439 \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u0434\u0435\u0441\u044f\u0442\u043a\u0430\u043c \u043c\u0438\u043b\u043b\u0438\u043e\u043d\u043e\u0432 \u043d\u0430\u0443\u0447\u043d\u044b\u0445 \u0441\u0442\u0430\u0442\u0435\u0439",
                "fallback": "Sci-Hub: \u0443\u0441\u0442\u0440\u0430\u043d\u044f\u044f \u043f\u0440\u0435\u0433\u0440\u0430\u0434\u044b \u043d\u0430 \u043f\u0443\u0442\u0438 \u0440\u0430\u0441\u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u043d\u0438\u0439",
                "image_url": "https://sci-hub.tw/misc/img/logo_1.png",
                "from_url": "https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3",
                "image_width": 675,
                "image_height": 137,
                "image_bytes": 15009,
                "service_icon": "https://sci-hub.tw/favicon.ico",
                "service_name": "sci-hub.tw",
                "id": 1,
                "original_url": "https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TNddT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3",
                                "text": "https://sci-hub.tw/https://doi.org/10.1016/S1045-926X(05)80016-3"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584806326.483400",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1584842357.495000",
        "reply_users": [
            "UBSMEUXAA",
            "UCGAK10LS"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b2b59d83-394b-464b-a288-cfd49f0446ee",
        "type": "message",
        "text": "Interesting Soviet visual programming environment",
        "user": "UBSMEUXAA",
        "ts": "1584806529.483600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fmzR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting Soviet visual programming environment"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584806326.483400",
        "parent_user_id": "UBSMEUXAA"
    },
    {
        "client_msg_id": "dbdd5b00-1a33-4a32-b90d-ef52486d58e3",
        "type": "message",
        "text": "I do think that malleability and simplicity both encourage each other, whichever end you start from. And I agree with with Edward that the current momentum of software is very at odds with how simple &amp; malleable it COULD be.\n\n(Which is also to say that _most of the complexity of software is NOT intrinsic!_ The software world just really sucks at knowing how to keep it simple. Kay made an OS in ~20K LOC!)\n\nCode is malleable by default, because it's made of composable units (functions, classes, modules, services, abstractions, etc.). And exposing those units for inspection and composition by the user, would result in malleable _software_.\n\nBut the status quo of most software is that those units interdepend on each other and create a tangled mess that's impossible to reason about. That has nothing to do with the intrinsic nature of software, but everything to do with a general lack of knowledge/discipline of developers as to how to create clean (aka reasonably sane) software architecture. But these are fundamental basics that any professional developer should know!\n\nBut it's the horrendous failure for this stuff to taught, enforced, practiced, or even _reasonably expected,_ that keeps software complex and fragile, and what causes many software folks to be adamantly (but very falsely) convinced that most of this complexity is just intrinsic to software.\n\nThis is maddening because it's being allowed to ruin the fabric that society now runs on (users have now come to +expect+ a crappy and bug-ridden experience -- hey, that's +just+ how software is!), and ruin the potential for software to be something more amazing than it is (composable, etc.), and making my career about dealing with this nonsense that takes 10x the time and effort (and 100x the code) than is actually necessary to do anything, rather than spending that time doing amazing things for the company and our customers and our own teams.\n\nSo the \"inability\" for software (at _least_ at a code level) to be malleable and composable is very telling problem, because software is already that by nature! But we _as an industry / profession_ have just mucked it up really bad!\n\nSoftware is a _made of_ software-levers! That's it's defining feature / what that makes it _soft_ware!",
        "user": "UAVCC2X70",
        "ts": "1584808638.483800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1584894464.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5VxDJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do think that malleability and simplicity both encourage each other, whichever end you start from. And I agree with with Edward that the current momentum of software is very at odds with how simple & malleable it COULD be.\n\n(Which is also to say that "
                            },
                            {
                                "type": "text",
                                "text": "most of the complexity of software is NOT intrinsic!",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " The software world just really sucks at knowing how to keep it simple. Kay made an OS in ~20K LOC!)\n\nCode is malleable by default, because it's made of composable units (functions, classes, modules, services, abstractions, etc.). And exposing those units for inspection and composition by the user, would result in malleable "
                            },
                            {
                                "type": "text",
                                "text": "software",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nBut the status quo of most software is that those units interdepend on each other and create a tangled mess that's impossible to reason about. That has nothing to do with the intrinsic nature of software, but everything to do with a general lack of knowledge/discipline of developers as to how to create clean (aka reasonably sane) software architecture. But these are fundamental basics that any professional developer should know!\n\nBut it's the horrendous failure for this stuff to taught, enforced, practiced, or even "
                            },
                            {
                                "type": "text",
                                "text": "reasonably expected, ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "that keeps software complex and fragile, and what causes many software folks to be adamantly (but very falsely) convinced that most of this complexity is just intrinsic to software.\n\nThis is maddening because it's being allowed to ruin the fabric that society now runs on (users have now come to +expect+ a crappy and bug-ridden experience -- hey, that's +just+ how software is!), and ruin the potential for software to be something more amazing than it is (composable, etc.), and making my career about dealing with this nonsense that takes 10x the time and effort (and 100x the code) than is actually necessary to do anything, rather than spending that time doing amazing things for the company and our customers and our own teams.\n\nSo the \"inability\" for software (at "
                            },
                            {
                                "type": "text",
                                "text": "least",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " at a code level) to be malleable and composable is very telling problem, because software is already that by nature! But we "
                            },
                            {
                                "type": "text",
                                "text": "as an industry / profession",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have just mucked it up really bad!\n\nSoftware is a "
                            },
                            {
                                "type": "text",
                                "text": "made of",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " software-levers! That's it's defining feature / what that makes it "
                            },
                            {
                                "type": "text",
                                "text": "soft",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "ware!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UML4ZEKDK",
                    "UA14TGLTC",
                    "UKDM3GLAJ"
                ],
                "count": 3
            },
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "08ba3fb1-7e5f-4d67-9470-53d6f914715b",
        "type": "message",
        "text": "This interview with Arthur Whitney (creator of the K language) deals with simplicity and malleability, a lot. I was fascinated to learn that Whitney reimplements the K language from scratch every 3-4 years, making the code shorter, faster, easier to understand on each iteration. <https://queue.acm.org/detail.cfm?id=1531242>",
        "user": "UJN1TAYEQ",
        "ts": "1584813566.485000",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "A Conversation with Arthur Whitney - ACM Queue",
                "title_link": "https://queue.acm.org/detail.cfm?id=1531242",
                "text": "When it comes to programming languages, Arthur Whitney is a man of few words. The languages he has designed, such as A, K, and Q, are known for their terse, often cryptic syntax and tendency to use single ASCII characters instead of reserved words. While these languages may mystify those used to wordier languages such as Java, their speed and efficiency has made them popular with engineers on Wall Street.",
                "fallback": "A Conversation with Arthur Whitney - ACM Queue",
                "from_url": "https://queue.acm.org/detail.cfm?id=1531242",
                "service_icon": "https://queue.acm.org/favicon.ico",
                "service_name": "queue.acm.org",
                "id": 1,
                "original_url": "https://queue.acm.org/detail.cfm?id=1531242"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Of0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This interview with Arthur Whitney (creator of the K language) deals with simplicity and malleability, a lot. I was fascinated to learn that Whitney reimplements the K language from scratch every 3-4 years, making the code shorter, faster, easier to understand on each iteration. "
                            },
                            {
                                "type": "link",
                                "url": "https://queue.acm.org/detail.cfm?id=1531242"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF"
    },
    {
        "client_msg_id": "66ec87a4-b53c-4110-9230-945df628f58e",
        "type": "message",
        "text": "Whitney's statements about iteratively rewriting the same code fragment 8 or 10 times until no more improvements are possible, reminded me of recent statements by Elon Musk, explaining how Space-X is able to achieve things that are far beyond the grasp of NASA and the big aerospace contractors. Musk said: progress = the number of iterations * the progress in each iteration. So you have to design your entire engineering process around the idea of fast iteration. Musk is rebuilding the StarShip from scratch multiple times per year, improving the ship design and the engineering process on each iteration.",
        "user": "UJN1TAYEQ",
        "ts": "1584814759.485300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wVzR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Whitney's statements about iteratively rewriting the same code fragment 8 or 10 times until no more improvements are possible, reminded me of recent statements by Elon Musk, explaining how Space-X is able to achieve things that are far beyond the grasp of NASA and the big aerospace contractors. Musk said: progress = the number of iterations * the progress in each iteration. So you have to design your entire engineering process around the idea of fast iteration. Musk is rebuilding the StarShip from scratch multiple times per year, improving the ship design and the engineering process on each iteration."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584718837.435500",
        "parent_user_id": "UF1ATC4RF",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UAVCC2X70",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "sunglasses",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "34239c59-f643-4fb2-a893-2c165de45a84",
        "type": "message",
        "text": "From what I've heard of Curv, I would say that it falls under the category of data generation. In this case, the data being generated is the shape on the GPU. But keep in mind I don't think that there is an end-all written description to tell what is and isn't a programing language. It's my belief that definitions are products of deeper, more enigmatic understandings and not the other way around.",
        "user": "UP54KN8TX",
        "ts": "1584818857.485500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9Mp=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "From what I've heard of Curv, I would say that it falls under the category of data generation. In this case, the data being generated is the shape on the GPU. But keep in mind I don't think that there is an end-all written description to tell what is and isn't a programing language. It's my belief that definitions are products of deeper, more enigmatic understandings and not the other way around."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "50cc40a2-3f9d-4e37-8eb3-b085ee759ae9",
        "type": "message",
        "text": "Curv doesn't use data (triangle meshes) to describe shapes, it uses signed distance functions. These functions are executed on the GPU, and a form of ray tracing is used to render the geometry on the monitor. So Curv is a language for defining pure mathematical functions.\n\nI brought up the principle of compositionality because it's the key idea underlying denotational semantics, and I'm trying to see how Frege's work relates to programming languages. I think that the Begriffsschrift was the first predicate calculus. A calculus is a formal language; expressions written in a calculus can be transformed using rules of symbol manipulation, and that is how reasoning works within such a formal system. Another example is the lambda calculus. Since expressions written in a calculus can be transformed mechanically, that provides a justification for calling a calculus a \"programming language\". So I think that whether the Begriffsschrift was the first programming language depends on whether it was the first calculus. I guess it would also depend on what things can be expressed by earlier calculi (whether they are Turing complete).\n\nAda Lovelace is sometimes credited as being the first computer programmer. She wrote a program to compute Berboulli Numbers in 1843, 36 years before the Begriffsschrift was published. Wasn't the language that Lovelace wrote her code in (Difference Engine assembly language) a \"programming language\"? Yes, but this language was surely lacking in the abstraction mechanisms we associate with modern programming languages.",
        "user": "UJN1TAYEQ",
        "ts": "1584821951.485700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "el=+G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Curv doesn't use data (triangle meshes) to describe shapes, it uses signed distance functions. These functions are executed on the GPU, and a form of ray tracing is used to render the geometry on the monitor. So Curv is a language for defining pure mathematical functions.\n\nI brought up the principle of compositionality because it's the key idea underlying denotational semantics, and I'm trying to see how Frege's work relates to programming languages. I think that the Begriffsschrift was the first predicate calculus. A calculus is a formal language; expressions written in a calculus can be transformed using rules of symbol manipulation, and that is how reasoning works within such a formal system. Another example is the lambda calculus. Since expressions written in a calculus can be transformed mechanically, that provides a justification for calling a calculus a \"programming language\". So I think that whether the Begriffsschrift was the first programming language depends on whether it was the first calculus. I guess it would also depend on what things can be expressed by earlier calculi (whether they are Turing complete).\n\nAda Lovelace is sometimes credited as being the first computer programmer. She wrote a program to compute Berboulli Numbers in 1843, 36 years before the Begriffsschrift was published. Wasn't the language that Lovelace wrote her code in (Difference Engine assembly language) a \"programming language\"? Yes, but this language was surely lacking in the abstraction mechanisms we associate with modern programming languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "client_msg_id": "dddd3003-8654-45bc-826f-b1e69e1d9193",
        "type": "message",
        "text": "Again, refining my written definition of programming language through the socratic method is the last thing that I want to do. \n\nIf Curv were purely mathematical it would not be coupled to the GPU. It's a case of applied mathematics. Curv doesn't need to output polygons to generate data, signed distance functions accomplish the same thing.\n\nAs for Turing-Completeness, many people consider HTML and Markdown to be programming languages. Others do not consider assembly and machine languages to be programming languages.\n\nPersonally, when I want to talk about LaTeX or HTML I would say \"Markup Language\", and when referring to some assembly language for architecture X I would say \"X assembly language\". However, I wouldn't see it necessary to correct someone who called Intel x86 Assembly a programming language.",
        "user": "UP54KN8TX",
        "ts": "1584824128.486500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "g/qHH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Again, refining my written definition of programming language through the socratic method is the last thing that I want to do. \n\nIf Curv were purely mathematical it would not be coupled to the GPU. It's a case of applied mathematics. Curv doesn't need to output polygons to generate data, signed distance functions accomplish the same thing.\n\nAs for Turing-Completeness, many people consider HTML and Markdown to be programming languages. Others do not consider assembly and machine languages to be programming languages.\n\nPersonally, when I want to talk about LaTeX or HTML I would say \"Markup Language\", and when referring to some assembly language for architecture X I would say \"X assembly language\". However, I wouldn't see it necessary to correct someone who called Intel x86 Assembly a programming language."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1584743125.448400",
        "parent_user_id": "UP54KN8TX"
    },
    {
        "type": "message",
        "text": "<@UAVCC2X70> fuck yes; so much this",
        "user": "U01003H81UM",
        "ts": "1584829437.487200",
        "team": "T5TCAFTA9",
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "type": "message",
        "text": "re: our earlier DMs, yeah, i think we're very much in agreement and we're 90% in viewpoint overlap",
        "user": "U01003H81UM",
        "ts": "1584829484.487400",
        "team": "T5TCAFTA9",
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    },
    {
        "type": "message",
        "text": "(for others: my personal notes are up on a notion: <https://www.notion.so/kitelightning/Guiding-Principles-3d817ee6c71c4ee19e9e3497fbdabb2d>)",
        "user": "U01003H81UM",
        "ts": "1584829498.487600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "KiteLightning on Notion",
                "title": "Guiding Principles",
                "title_link": "https://www.notion.so/kitelightning/Guiding-Principles-3d817ee6c71c4ee19e9e3497fbdabb2d",
                "text": "Meta",
                "fallback": "KiteLightning on Notion: Guiding Principles",
                "from_url": "https://www.notion.so/kitelightning/Guiding-Principles-3d817ee6c71c4ee19e9e3497fbdabb2d",
                "id": 1,
                "original_url": "https://www.notion.so/kitelightning/Guiding-Principles-3d817ee6c71c4ee19e9e3497fbdabb2d"
            }
        ],
        "thread_ts": "1584235196.324400",
        "parent_user_id": "U01003H81UM"
    }
]