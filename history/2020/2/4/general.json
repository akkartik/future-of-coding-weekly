[
    {
        "client_msg_id": "0a17af32-77ab-41f0-81a5-93e655868f24",
        "type": "message",
        "text": "Suggestive! Not sure it's related but in a projectional editing context I increasingly think of exposing configuration as choosing some projection of the source implementation admitting bidirectional transformation.",
        "user": "UD31LGQKB",
        "ts": "1580777008.489700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qyRS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Suggestive! Not sure it's related but in a projectional editing context I increasingly think of exposing configuration as choosing some projection of the source implementation admitting bidirectional transformation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580762349.483300",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "e02b04e3-de60-41c1-89d4-8b50fe1b5042",
        "type": "message",
        "text": "I don't agree with Ivan's definition of complexity.\n\nThe first sentence of Out Of The Tar Pit is \"Complexity is the single major difficulty in the successful development of large-scale software systems.\"\n\nThe goal of this paper is to explore ways of reducing complexity, so as to make software engineering less difficult.\n\nIvan said \"Ivan: abstractions are incidental complexity. Again, they're an affordance for thought that isn't strictly necessary.\"\n\nThat can't be right. Programming without abstractions is virtually impossible. The only \"programming languages\" that lack abstraction mechanisms are mathematical formalisms like Turing machines and the SKI combinator calculus, and a few esoteric languages like Brainfuck.\n\nIf you eliminate Ivan's kind of complexity from programming, then you are reduced to programming in Brainfuck. Brainfuck programs are not less complex than, say, well written Lisp programs, in any way that I can see. They are actually far *more* complicated, using any reasonable metric for measuring the complexity of a program.\n\nAbstractions are our principle tool in eliminating complexity from software. Tar Pit advocates the use of functional programming and the relational model to reduce complexity, and these are methodologies for constructing software abstractions.\n\nWhatever complexity Ivan is talking about, it's not the kind of complexity that Tar Pit is teaching us to eliminate from software.",
        "user": "UJN1TAYEQ",
        "ts": "1580778870.489900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XBRMZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't agree with Ivan's definition of complexity.\n\nThe first sentence of Out Of The Tar Pit is \"Complexity is the single major difficulty in the successful development of large-scale software systems.\"\n\nThe goal of this paper is to explore ways of reducing complexity, so as to make software engineering less difficult.\n\nIvan said \"Ivan: abstractions are incidental complexity. Again, they're an affordance for thought that isn't strictly necessary.\"\n\nThat can't be right. Programming without abstractions is virtually impossible. The only \"programming languages\" that lack abstraction mechanisms are mathematical formalisms like Turing machines and the SKI combinator calculus, and a few esoteric languages like Brainfuck.\n\nIf you eliminate Ivan's kind of complexity from programming, then you are reduced to programming in Brainfuck. Brainfuck programs are not less complex than, say, well written Lisp programs, in any way that I can see. They are actually far "
                            },
                            {
                                "type": "text",
                                "text": "more",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " complicated, using any reasonable metric for measuring the complexity of a program.\n\nAbstractions are our principle tool in eliminating complexity from software. Tar Pit advocates the use of functional programming and the relational model to reduce complexity, and these are methodologies for constructing software abstractions.\n\nWhatever complexity Ivan is talking about, it's not the kind of complexity that Tar Pit is teaching us to eliminate from software."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "2c720bd6-3531-4be0-bfa2-c51b5a140517",
        "type": "message",
        "text": "Episode #44 \u2014 Making Your Own Tools: Devine Lu Linvega\n\n<https://futureofcoding.org/episodes/044>",
        "user": "UC2A2ARPT",
        "ts": "1580780491.490500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dFa/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Episode #44 \u2014 Making Your Own Tools: Devine Lu Linvega\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.org/episodes/044"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "reply_count": 14,
        "reply_users_count": 7,
        "latest_reply": "1581199614.053900",
        "reply_users": [
            "UMWF81HTP",
            "UC2A2ARPT",
            "UBN9AFS0N",
            "UA14TGLTC",
            "USUMN6XLH",
            "U8A5MS6R1",
            "UMPQ9A65N"
        ],
        "subscribed": true,
        "last_read": "1581238074.085900",
        "reactions": [
            {
                "name": "tada",
                "users": [
                    "UD31LGQKB",
                    "UE3KC0VK6",
                    "UGLSY9X3J",
                    "UA14TGLTC",
                    "UMWF81HTP",
                    "UP00ZLX6G",
                    "UMPQ9A65N",
                    "UFPRPSA4S",
                    "U8A5MS6R1",
                    "UBSMEUXAA",
                    "U85HCL7JP"
                ],
                "count": 11
            }
        ]
    },
    {
        "client_msg_id": "9964d333-4594-4085-9acb-d7d32e52bf64",
        "type": "message",
        "text": "Ok, I guess it was a bad idea in this case to say, \"responses in thread plz\" :smile:\n\nThis idea is basically at the heart of everything I write or do about Mu. Typically we tend to emphasize interfaces, identify them with 'good practice' and therefore they become a means of signalling among programmers. But at the start a new sub-system often has just one caller. Even if it's a function, it doesn't necessarily form a good abstraction. You often don't have a sense for what other callers may need yet. Prematurely thinking of it as an interface makes us reluctant to modify it, because that would signal that we didn't know what we were doing before. (This is particularly true if we also packaged up the function prematurely into a 'package'. Now signature changes require incrementing the major version, which is more visible to others.)\n\nThe alternative, better approach is to admit up front that we're all fools together and think of functions at the start as just loose bags of implementation rather than an interface. Then we're more willing to modify it, less likely to package it. As a result the interface has a chance to change. It gets time to grow into what it needs to be. And it stabilizes when it makes sense for it to stabilize.\n\nAbstractions should be names for algorithms so we don't have to think about the details all the time. Abstractions should rarely turn into frozen interfaces that we pass on to others so they _never_ have to think about the details. That turns a useful technical idea into a social artifact. We need to be _a lot_ less promiscuous about getting into social counterparty relationships.\n\n(I wrote about this long ago: <http://akkartik.name/post/libraries>, <http://akkartik.name/post/libraries2>. Hopefully I've gotten better at describing it over the years.)",
        "user": "UCUSW7WVD",
        "ts": "1580784726.491000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "096H8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ok, I guess it was a bad idea in this case to say, \"responses in thread plz\" "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThis idea is basically at the heart of everything I write or do about Mu. Typically we tend to emphasize interfaces, identify them with 'good practice' and therefore they become a means of signalling among programmers. But at the start a new sub-system often has just one caller. Even if it's a function, it doesn't necessarily form a good abstraction. You often don't have a sense for what other callers may need yet. Prematurely thinking of it as an interface makes us reluctant to modify it, because that would signal that we didn't know what we were doing before. (This is particularly true if we also packaged up the function prematurely into a 'package'. Now signature changes require incrementing the major version, which is more visible to others.)\n\nThe alternative, better approach is to admit up front that we're all fools together and think of functions at the start as just loose bags of implementation rather than an interface. Then we're more willing to modify it, less likely to package it. As a result the interface has a chance to change. It gets time to grow into what it needs to be. And it stabilizes when it makes sense for it to stabilize.\n\nAbstractions should be names for algorithms so we don't have to think about the details all the time. Abstractions should rarely turn into frozen interfaces that we pass on to others so they "
                            },
                            {
                                "type": "text",
                                "text": "never",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have to think about the details. That turns a useful technical idea into a social artifact. We need to be "
                            },
                            {
                                "type": "text",
                                "text": "a lot",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " less promiscuous about getting into social counterparty relationships.\n\n(I wrote about this long ago: "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/libraries"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/libraries2"
                            },
                            {
                                "type": "text",
                                "text": ". Hopefully I've gotten better at describing it over the years.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580762349.483300",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UD31LGQKB",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "cb5a151c-8edc-453c-8101-5fd16086c300",
        "type": "message",
        "text": "Here's how I think about complexity.\n\nHow many different ideas do you need to know in order to understand what a program does?\n\nThe second-least complex way to write a piece of software would be to push a button and have the exact program you need be spit out. You hardly need to know any ideas in that case \u2014 push button, get program that magically does what you want. All the baggage and pain and coordination and effort of software development is gone, like magic.\n\nEvery time you introduce a new idea that needs to be understood \u2014 whether it's functions, function composition, currying, partial application, the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does \u2014 you add an additional complexity that you, the programmer, need to deal with to work on this program, which you wouldn't need to deal with in the magical example above. _All_ of this is incidental complexity.\n\nMy whole point is that Out of the Tar Pit is wrong. They say that reducing incidental complexity is crucially important. I say that it's not \u2014 instead, you want to be empowered to choose exactly what incidental complexity you need to deal with.\n\nWhen you draw a line and say \"These ideas are incidental complexity because they meet criteria X, and these ideas are not because they don't,\" you're making a value judgment. When you read Tar Pit with that lens, is painfully clear what values the authors hold (\"Mutable state is evil\"), and they of course base their _what is incidental_ selection criteria on those values. Hogwash. Incidental complexity, by their own definition, is broad enough to include mutable state, immutability, any even the purely theoretical notion that state, and change, are concepts that exist.\n\n(The absolutely least complex way to write a piece of software is to not have to do anything. Hat tip to Steve Jobs, paraphrased _the line of code that has the least bugs, runs the fastest, requires the least documentation, etc etc is the line you never wrote._)",
        "user": "UC2A2ARPT",
        "ts": "1580789094.491400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1580789353.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e5K5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's how I think about complexity.\n\nHow many different ideas do you need to know in order to understand what a program does?\n\nThe second-least complex way to write a piece of software would be to push a button and have the exact program you need be spit out. You hardly need to know any ideas in that case \u2014 push button, get program that magically does what you want. All the baggage and pain and coordination and effort of software development is gone, like magic.\n\nEvery time you introduce a new idea that needs to be understood \u2014 whether it's functions, function composition, currying, partial application, the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does \u2014 you add an additional complexity that you, the programmer, need to deal with to work on this program, which you wouldn't need to deal with in the magical example above. "
                            },
                            {
                                "type": "text",
                                "text": "All",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of this is incidental complexity.\n\nMy whole point is that Out of the Tar Pit is wrong. They say that reducing incidental complexity is crucially important. I say that it's not \u2014 instead, you want to be empowered to choose exactly what incidental complexity you need to deal with.\n\nWhen you draw a line and say \"These ideas are incidental complexity because they meet criteria X, and these ideas are not because they don't,\" you're making a value judgment. When you read Tar Pit with that lens, is painfully clear what values the authors hold (\"Mutable state is evil\"), and they of course base their "
                            },
                            {
                                "type": "text",
                                "text": "what is incidental",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " selection criteria on those values. Hogwash. Incidental complexity, by their own definition, is broad enough to include mutable state, immutability, any even the purely theoretical notion that state, and change, are concepts that exist.\n\n(The absolutely least complex way to write a piece of software is to not have to do anything. Hat tip to Steve Jobs, paraphrased "
                            },
                            {
                                "type": "text",
                                "text": "the line of code that has the least bugs, runs the fastest, requires the least documentation, etc etc is the line you never wrote.",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "69b1cbf6-fc12-48a7-a6a7-1996231eb930",
        "type": "message",
        "text": "This was a great episode. Beyond my general fascination with Devine's work, I really liked the sonic flairs you added, I think it adds a lot of personality and a hand-crafted feel to the podcast(reminds me a bit of Radiolab's production!)",
        "user": "UMWF81HTP",
        "ts": "1580790264.491900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cepoZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This was a great episode. Beyond my general fascination with Devine's work, I really liked the sonic flairs you added, I think it adds a lot of personality and a hand-crafted feel to the podcast(reminds me a bit of Radiolab's production!)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "381f57ed-046a-4b0f-b7ab-9a523aa49f17",
        "type": "message",
        "text": "I'm rereading Tar Pit for the umpteenth time. Never liked it, and jeez it has more italics than a Robert Ludlum novel.",
        "user": "UCUSW7WVD",
        "ts": "1580790725.492100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "23+fR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm rereading Tar Pit for the umpteenth time. Never liked it, and jeez it has more italics than a Robert Ludlum novel."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "e83f16db-e21a-4df6-bbaf-0388de5bb3c8",
        "type": "message",
        "text": "That means a lot. Thank you. It's going to take me a while to hone-in on exactly how this show should sound, but it's something I'm going to keep exploring. I'm sure there will be plenty of cases where I get it wrong, but that's the price you have to pay to eventually get it right.",
        "user": "UC2A2ARPT",
        "ts": "1580793328.492300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0QKjq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That means a lot. Thank you. It's going to take me a while to hone-in on exactly how this show should sound, but it's something I'm going to keep exploring. I'm sure there will be plenty of cases where I get it wrong, but that's the price you have to pay to eventually get it right."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U5STGTB3J",
                    "UMWF81HTP",
                    "UA14TGLTC",
                    "U85HCL7JP"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "d844f5f5-97ba-48b9-9cee-9febde85b97d",
        "type": "message",
        "text": "That rings quite true in my experience. It's one of the reasons I'm so happy to be the only programmer on my team, and one with a strong case of NIH at that \u2014 all my interfaces are as permeable as I want them to be, since I own all code inside and out.",
        "user": "UC2A2ARPT",
        "ts": "1580794095.492500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x5bW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That rings quite true in my experience. It's one of the reasons I'm so happy to be the only programmer on my team, and one with a strong case of NIH at that \u2014 all my interfaces are as permeable as I want them to be, since I own all code inside and out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580762349.483300",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5b6fc6c2-0688-4a80-b87f-68cc63212996",
        "type": "message",
        "text": "On my cynical days I think interfaces were invented by hired-gun programmers to spread responsibility around so that screwups can't have accountability or consequences.",
        "user": "UCUSW7WVD",
        "ts": "1580795956.493300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w+8P",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On my cynical days I think interfaces were invented by hired-gun programmers to spread responsibility around so that screwups can't have accountability or consequences."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580762349.483300",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "7f831447-3c14-42cf-b7a4-cb94d3dac653",
        "type": "message",
        "text": "<@UC2A2ARPT> My _a priori_ biases are very similar to yours. However when I read your last comment my first reaction was, \"that's not what they mean by incidental complexity.\" So I went back to reread the paper.\n\nYou're right, they do say \"accidental complexity is all the rest\" except the essence of the problem as seen by users. Which is identical to what I was saying above, and opens them up to your interpretation. And that seems like the most acute criticism I've seen so far of this paper: the terms are so broad that they're very open to interpretation, and the authors' interpretation serves only to reveal their biases.\n\nThe authors' \"ideal world\" is one where computation has no cost, but social structures remain unchanged, with \"users\" having \"requirements\". _But_ the users are all mathematical enough to want formal requirements. They don't seem to notice that the arrow in \"Informal requirements -&gt; Formal requirements\" may indicate that formal requirements are _themselves_ accidental complexity.",
        "user": "UCUSW7WVD",
        "ts": "1580796314.493500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1580796337.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TMY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " My "
                            },
                            {
                                "type": "text",
                                "text": "a priori",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " biases are very similar to yours. However when I read your last comment my first reaction was, \"that's not what they mean by incidental complexity.\" So I went back to reread the paper.\n\nYou're right, they do say \"accidental complexity is all the rest\" except the essence of the problem as seen by users. Which is identical to what I was saying above, and opens them up to your interpretation. And that seems like the most acute criticism I've seen so far of this paper: the terms are so broad that they're very open to interpretation, and the authors' interpretation serves only to reveal their biases.\n\nThe authors' \"ideal world\" is one where computation has no cost, but social structures remain unchanged, with \"users\" having \"requirements\". "
                            },
                            {
                                "type": "text",
                                "text": "But",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the users are all mathematical enough to want formal requirements. They don't seem to notice that the arrow in \"Informal requirements -> Formal requirements\" may indicate that formal requirements are "
                            },
                            {
                                "type": "text",
                                "text": "themselves",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " accidental complexity."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT",
                    "UKJGU23KP",
                    "U8A5MS6R1",
                    "UHWC9PXBL"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "1a7b0474-50f9-4ced-a199-fac30f5be652",
        "type": "message",
        "text": "To push back one tiny part of your comment, though:\n\n&gt; Every time you introduce a new idea that needs to be understood \u2014 whether it's functions, function composition, currying, partial application, ...\nThese seem like accidental complexity for a music-creation app, but essential complexity for a programming language.\n\n&gt; ...the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does \u2014 you add an additional  complexity that you, the programmer, need to deal with to work on this program...\nThese seem like accidental complexity for the users of a program, but potentially essential complexity for someone working with it given our current context (the world already exists, the codebase already exists in the world, etc.)\n\nSo the context seems crucial here. What is the system under consideration, who is the target audience, all this affects where the line is.\n\nThe further to one extreme you draw the line, the less useful the distinction becomes.",
        "user": "UCUSW7WVD",
        "ts": "1580797713.493800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1580797749.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bVlv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To push back one tiny part of your comment, though:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Every time you introduce a new idea that needs to be understood \u2014 whether it's functions, function composition, currying, partial application, ..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "These seem like accidental complexity for a music-creation app, but essential complexity for a programming language.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "...the existence of one particular function in your codebase, the history of that function and previous issues it had that are now avoided by doing things in a slightly surprising way, the syntax for the documentation explaining that change, the fact that the change was made to bring the resulting program closer in line with the end user expectations for what this program does \u2014 you add an additional  complexity that you, the programmer, need to deal with to work on this program..."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThese seem like accidental complexity for the users of a program, but potentially essential complexity for someone working with it given our current context (the world already exists, the codebase already exists in the world, etc.)\n\nSo the context seems crucial here. What is the system under consideration, who is the target audience, all this affects where the line is.\n\nThe further to one extreme you draw the line, the less useful the distinction becomes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d289e3cd-7d64-4342-801f-fa8f4458a96b",
        "type": "message",
        "text": "Perhaps my fundamental criticism of this whole dichotomy is that it treats \"users\" as immutable rather than capable of learning. As <@UJN1TAYEQ> points out, if you treat the user's goals as gospel (say that they want to make this one specific app), then maybe teaching them programming shouldn't include functions. The insanity of that proposition puts this whole framing in sharp relief for me. To some extent someone wanting to do something in a new area needs to learn from its traditions.",
        "user": "UCUSW7WVD",
        "ts": "1580798329.494100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6sOq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps my fundamental criticism of this whole dichotomy is that it treats \"users\" as immutable rather than capable of learning. As "
                            },
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " points out, if you treat the user's goals as gospel (say that they want to make this one specific app), then maybe teaching them programming shouldn't include functions. The insanity of that proposition puts this whole framing in sharp relief for me. To some extent someone wanting to do something in a new area needs to learn from its traditions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "b4ff7ffa-fd7a-4f08-8e86-228bb064c370",
        "type": "message",
        "text": "My personal bias is that JBlow doesn't really know what he's talking about and is ranting about the same things I ranted about before I got schooled. Or in other words, when all my experience was game dev I had a similar opinions (GC is shit, memory allocation should be avoided at all costs, languages far from the metal suck, ...)  and that it took getting out of game dev to accept that each thing has their place.\n\nAs one example back when JAI (his language) started he mentioned he didn't care about memory errors because he doesn't make those kinds of bugs. I nodded in agreement when I read that. But, thinking about it more I'm just guessing most games he worked on first off have to only deal with a limited number of situations compared to many other apps, and are coded by a fairly small team. Compare say to Chrome which in 2013 had at least 700 programmers working on it. You just can't expected 700 programmers to all know exactly what assumptions each other were making. You arguably need the language to help you find, prevent, enforce the very issues he doens't care about.\n\nAs another example he doesn't care about security what so ever AFAICT. About bad data allowing an app to be compromised, About sandboxing and all the things needed to make an app/os safe from exploitation. He probably uses very few 3rd party libraries and those few he does use are *probably* trustworth. But, aruably most devs throw libs together and many of those libs do bad things (install hooks for analytics, report data they shouldn't, ...). Mobile apps on both iOS and Android seem to be full of those issues from 3rd party libs.\n\nOther examples include hating on GC and yet 10s of 1000s of games have shipped via Unity with GC (and Unreal has GC as well). That includes hit 60fps action games. Maybe you could argue hating on load times (I hate load times) but it's never affected Valve's old games all of which have horrible load pauses (Half Life, Half Life 2, Portal, etc... basically all Source Engine games)\n\nHe sees browsers as bloated (and I'm not saying they aren't to some degree) but before I worked on one I had no idea all the issues they have to deal with that I never had to deal with in games. Threats from all levels. Untrusted data everywhere, bad videos, bad jpegs, bad network requests, bad code, handling every language on the planet and many other things.\n\nHe had a rant speech someone else posted here once and in it he had these conflicting rants. He ranted that he was upset that each platform has a different GPU API. But at the same time he wants his own engine. He doesn't want to use Unreal or Unity. To put it another way, he's upset that different people have different ideas for how you should access the GPU and thinks there should be just one way but there shouldn't be just one way to make a game engine. I'd argue the 2 go hand in hand. There are muliple game engines because their are different opinions on what is best. Similarly there are mulitple GPU APIs because their are different opinions on what is best. To have one of either would require commitees to argue forever about what the one true way is and stifle innovation. By having multiple of each different teams can advance faster by not having to coordinate. Microsoft doesn't have to wait for some committee to approve a new feature. They just add what they want to DirectX and the others play catch-up. Apple doesn't have to wait for anyone else to add stuff to Metal.\n\nI could go on, like on the ridiculousness of comparing 8bit computers booting up instantly to today's machines. Yes my Atari 800, Apple II and C64 turned on immediately. They didn't connect to hard drives, sd cards, network storage. They had a 320x240 screen with max 4 bits of color. They didn't draw 100k+ international characters, didn't support infinite input devices, multiple monitors, virtual monitors over a network. They didn't multitask. Taking a step up to 80s PCs we no longer have to run QEMM to optimize how are memory is used or set dip switches on our PCI cards to allocate interrupts. That's not to say things couldn't be more optimized if you started from scratch but if you start digging through all the pieces you'll uncover why they are the way they are. Why for example it's better that there is a full computer in your hard drive and it's not just a dumb device run by your PC and why there is a negotiation for how to talk to it etc... as just one example of why todays machines are not comparible to 8bit computers and to see some kind of ideal as more like the 80s is to not really think deeply about the issue.\n\nAnyway I liked the idea of JAI optimizing for programmer joy but I don't know if JAI will actually be joyful except for people who drink his kool-aid.",
        "user": "UC6997THT",
        "ts": "1580802925.494500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC6997THT",
            "ts": "1580804174.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "02r=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My personal bias is that JBlow doesn't really know what he's talking about and is ranting about the same things I ranted about before I got schooled. Or in other words, when all my experience was game dev I had a similar opinions (GC is shit, memory allocation should be avoided at all costs, languages far from the metal suck, ...)  and that it took getting out of game dev to accept that each thing has their place.\n\nAs one example back when JAI (his language) started he mentioned he didn't care about memory errors because he doesn't make those kinds of bugs. I nodded in agreement when I read that. But, thinking about it more I'm just guessing most games he worked on first off have to only deal with a limited number of situations compared to many other apps, and are coded by a fairly small team. Compare say to Chrome which in 2013 had at least 700 programmers working on it. You just can't expected 700 programmers to all know exactly what assumptions each other were making. You arguably need the language to help you find, prevent, enforce the very issues he doens't care about.\n\nAs another example he doesn't care about security what so ever AFAICT. About bad data allowing an app to be compromised, About sandboxing and all the things needed to make an app/os safe from exploitation. He probably uses very few 3rd party libraries and those few he does use are "
                            },
                            {
                                "type": "text",
                                "text": "probably",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " trustworth. But, aruably most devs throw libs together and many of those libs do bad things (install hooks for analytics, report data they shouldn't, ...). Mobile apps on both iOS and Android seem to be full of those issues from 3rd party libs.\n\nOther examples include hating on GC and yet 10s of 1000s of games have shipped via Unity with GC (and Unreal has GC as well). That includes hit 60fps action games. Maybe you could argue hating on load times (I hate load times) but it's never affected Valve's old games all of which have horrible load pauses (Half Life, Half Life 2, Portal, etc... basically all Source Engine games)\n\nHe sees browsers as bloated (and I'm not saying they aren't to some degree) but before I worked on one I had no idea all the issues they have to deal with that I never had to deal with in games. Threats from all levels. Untrusted data everywhere, bad videos, bad jpegs, bad network requests, bad code, handling every language on the planet and many other things.\n\nHe had a rant speech someone else posted here once and in it he had these conflicting rants. He ranted that he was upset that each platform has a different GPU API. But at the same time he wants his own engine. He doesn't want to use Unreal or Unity. To put it another way, he's upset that different people have different ideas for how you should access the GPU and thinks there should be just one way but there shouldn't be just one way to make a game engine. I'd argue the 2 go hand in hand. There are muliple game engines because their are different opinions on what is best. Similarly there are mulitple GPU APIs because their are different opinions on what is best. To have one of either would require commitees to argue forever about what the one true way is and stifle innovation. By having multiple of each different teams can advance faster by not having to coordinate. Microsoft doesn't have to wait for some committee to approve a new feature. They just add what they want to DirectX and the others play catch-up. Apple doesn't have to wait for anyone else to add stuff to Metal.\n\nI could go on, like on the ridiculousness of comparing 8bit computers booting up instantly to today's machines. Yes my Atari 800, Apple II and C64 turned on immediately. They didn't connect to hard drives, sd cards, network storage. They had a 320x240 screen with max 4 bits of color. They didn't draw 100k+ international characters, didn't support infinite input devices, multiple monitors, virtual monitors over a network. They didn't multitask. Taking a step up to 80s PCs we no longer have to run QEMM to optimize how are memory is used or set dip switches on our PCI cards to allocate interrupts. That's not to say things couldn't be more optimized if you started from scratch but if you start digging through all the pieces you'll uncover why they are the way they are. Why for example it's better that there is a full computer in your hard drive and it's not just a dumb device run by your PC and why there is a negotiation for how to talk to it etc... as just one example of why todays machines are not comparible to 8bit computers and to see some kind of ideal as more like the 80s is to not really think deeply about the issue.\n\nAnyway I liked the idea of JAI optimizing for programmer joy but I don't know if JAI will actually be joyful except for people who drink his kool-aid."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580480732.286100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "UD6EXQVM0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8ba96b92-fa41-4007-b942-37e8458316be",
        "type": "message",
        "text": "<https://www.loom.com/share/cab62c8172404c39bebc4c511a60a389>\n\n&gt; I've been hacking on a little tool lately that's kinda relevant to this... At 3:10 in this demo video, I drag select multiple listings on a website, and bulk perform an action on them. How much time would be saved by \"bulk ___\" anywhere on the web??",
        "user": "UBN9AFS0N",
        "ts": "1580805810.495100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Loom",
                "service_url": "https://www.loom.com",
                "title": "Customizing Airbnb with a spreadsheet",
                "title_link": "https://www.loom.com/share/cab62c8172404c39bebc4c511a60a389",
                "thumb_url": "https://cdn.loom.com/sessions/thumbnails/cab62c8172404c39bebc4c511a60a389-00001.gif",
                "thumb_width": 1024,
                "thumb_height": 640,
                "fallback": "Loom Video: Customizing Airbnb with a spreadsheet",
                "video_html": "<iframe src=\"https://www.loom.com/embed/cab62c8172404c39bebc4c511a60a389?autoplay=1\" frameborder=\"0\" width=\"1152\" height=\"864\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>",
                "video_html_width": 1152,
                "video_html_height": 864,
                "from_url": "https://www.loom.com/share/cab62c8172404c39bebc4c511a60a389",
                "id": 1,
                "original_url": "https://www.loom.com/share/cab62c8172404c39bebc4c511a60a389"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KTPRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.loom.com/share/cab62c8172404c39bebc4c511a60a389"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been hacking on a little tool lately that's kinda relevant to this... At 3:10 in this demo video, I drag select multiple listings on a website, and bulk perform an action on them. How much time would be saved by \"bulk ___\" anywhere on the web??"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UMWF81HTP"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UP6G25H35",
                    "UE0ETTCG7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d908a146-ed82-4df6-8562-171b0a59ad18",
        "type": "message",
        "text": "Is someone hiring here? Or should we have a job channel...",
        "user": "URUHW0TB3",
        "ts": "1580805965.495900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IosX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is someone hiring here? Or should we have a job channel..."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "client_msg_id": "3a1b0068-333f-4f5c-9f93-3f6701a99cf5",
        "type": "message",
        "text": "there's a <#CGMJ7323Z|jobs> channel",
        "user": "UBN9AFS0N",
        "ts": "1580806097.496100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VE0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "there's a "
                            },
                            {
                                "type": "channel",
                                "channel_id": "CGMJ7323Z"
                            },
                            {
                                "type": "text",
                                "text": " channel"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "client_msg_id": "9eaf2bb2-902f-41bc-8c3e-dad7543c86b7",
        "type": "message",
        "text": "I like how you added some corrections (during edition it seems) that feel like you listening to it and saying it out loud :slightly_smiling_face:",
        "user": "UBN9AFS0N",
        "ts": "1580807963.496300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OMxu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like how you added some corrections (during edition it seems) that feel like you listening to it and saying it out loud "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "dff9bc8d-d536-443b-8345-f60a767f0ff9",
        "type": "message",
        "text": "like an explicit \"I've should have said X\"",
        "user": "UBN9AFS0N",
        "ts": "1580807981.496500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FcF2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "like an explicit \"I've should have said X\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "a45384a4-7b7a-4775-865e-09411bf11db6",
        "type": "message",
        "text": "feels more real than editing it to try to make it look like it didn't happened or adding corrections somewhere else like in the show notes",
        "user": "UBN9AFS0N",
        "ts": "1580808020.496700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5d6+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "feels more real than editing it to try to make it look like it didn't happened or adding corrections somewhere else like in the show notes"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "21cf8080-671c-4a9e-a3ce-39f28fd681b0",
        "type": "message",
        "text": "<@UC6997THT> Yeah, that rant talk isn't Blow's finest.  Jai has a niche, and the 700 person team let alone the wide web is not that.",
        "user": "UA14TGLTC",
        "ts": "1580825813.497200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OjQh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC6997THT"
                            },
                            {
                                "type": "text",
                                "text": " Yeah, that rant talk isn't Blow's finest.  Jai has a niche, and the 700 person team let alone the wide web is not that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580480732.286100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "01dd94f0-3b87-4fb6-a0e7-344e88d82553",
        "type": "message",
        "text": "15 minutes in and very impressed.  Strongly agree with <@UBN9AFS0N>.  The occasional in-place note (I've only hit the first one) gives the podcast a unique feel without being heavy.",
        "user": "UA14TGLTC",
        "ts": "1580826819.497600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WBRT4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "15 minutes in and very impressed.  Strongly agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UBN9AFS0N"
                            },
                            {
                                "type": "text",
                                "text": ".  The occasional in-place note (I've only hit the first one) gives the podcast a unique feel without being heavy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "40b58d5b-f054-4e01-a4f9-7b017e591c2b",
        "type": "message",
        "text": "thanks for your perspective <@UC6997THT> I think there are a few key kernels / threads to JBlow\u2019s thinking:\n\n\u2022 I want to make a language for games, for advanced programmers to really push the boundaries of software / hardware. He rails on other dev contexts (like browsers or the web) but I think that\u2019s not as important. \n\u2022 JBlow, Alan Kay, and many others dislike the bloat that modern software + hardware interfaces have. In some areas of computing, we\u2019ve figured out how to have a common building / mental block but support a wide range of configurations and use cases. In areas like talking to the GPU though \u2026 I do feel like JBlow may be right about this. Also, more generally \u2026 I think JBlow, Alan Kay, and others go back to first principles and are really interested in \u201cWTF is a computer fundamentally about\u201d? What are the barriers in the way to just doing computation that are human, cultural, and arbitrary. GPU drivers / interfaces feel like that to be honest! \nUnreal / Unity are engineering hacks IMO that create an intermediate layer that\u2019s imperfect to deal with the current situation. But \u2026 things could be better! Regardless of JBlow\u2019s specific points \u2026 I feel like outside Computer Science, there\u2019s more push to try new things, see wha works, and then radically replace what doesn\u2019t work. In computing, we\u2019re the exact opposite. *We keep bad ideas around FOREVER b/c of the switching cost. I think this is the key thread in Blow\u2019s talks, putting aside his specific rants / points.*",
        "user": "UGLSY9X3J",
        "ts": "1580827643.497900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iea",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "thanks for your perspective "
                            },
                            {
                                "type": "user",
                                "user_id": "UC6997THT"
                            },
                            {
                                "type": "text",
                                "text": " I think there are a few key kernels / threads to JBlow\u2019s thinking:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I want to make a language for games, for advanced programmers to really push the boundaries of software / hardware. He rails on other dev contexts (like browsers or the web) but I think that\u2019s not as important. "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "JBlow, Alan Kay, and many others dislike the bloat that modern software + hardware interfaces have. In some areas of computing, we\u2019ve figured out how to have a common building / mental block but support a wide range of configurations and use cases. In areas like talking to the GPU though \u2026 I do feel like JBlow may be right about this. Also, more generally \u2026 I think JBlow, Alan Kay, and others go back to first principles and are really interested in \u201cWTF is a computer fundamentally about\u201d? What are the barriers in the way to just doing computation that are human, cultural, and arbitrary. GPU drivers / interfaces feel like that to be honest! "
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nUnreal / Unity are engineering hacks IMO that create an intermediate layer that\u2019s imperfect to deal with the current situation. But \u2026 things could be better! Regardless of JBlow\u2019s specific points \u2026 I feel like outside Computer Science, there\u2019s more push to try new things, see wha works, and then radically replace what doesn\u2019t work. In computing, we\u2019re the exact opposite. "
                            },
                            {
                                "type": "text",
                                "text": "We keep bad ideas around FOREVER b/c of the switching cost. I think this is the key thread in Blow\u2019s talks, putting aside his specific rants / points.",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580480732.286100",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "f8833f21-245e-458c-bcb5-cbea2da8c5b2",
        "type": "message",
        "text": "Trying to wrap my head around the different perspectives. Consider 'writing' and 'science'. Is writing essential for science? Is it accidental complexity? Lets break it apart a bit more.. it's not just the written form, but what the form represents - some abstract ideas (formulae, functions) - are these abstractions essential?\n\nIf *I am the science itself* then I wouldn't need to understand it, I'd just be it. But I'm not science. There is something out there and science gives me a model to grasp that external something (presumably) and fit it internally - something I can understand. This gap is covered by a series of 'mediums' and 'messages' for lack of better words. 'Symbols' are one primitive medium (the idea that 'signifiers represent the signified'), we learn this medium very early in childhood. A message in this medium is 'tree' (doesn't look like a tree, but makes you think of one). The 'written medium' is quite useful too - signs themselves now have physical forms. Sentences are perhaps the next level of medium (a composition of symbols that represents a composite idea). Further, from maths we have variables, propositions, formulae, functions - these are all higher level mediums. We express science in these mediums (e.g. `f=ma` is a message that requires us to *become the medium* first and then absorb its meaning).\n\nWhat is the end goal in this endeavor? We're trying to predict something perhaps, or design something for a purpose - these are our goals, our vision of the purpose.\n\nNow a twist: how do we represent our purpose? _The purpose is just another medium_. When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context.\n\nI think what Ivan is saying is that there are multiple alternative paths of medium/message stacks to get to our goals. All of these are 'incidental complexity'. The simplest solution is having the button with 'my goal' on it, that I push. (Well technically that still has incidental complexity because you'd have to grasp the _medium of buttons_ - push, cause, effect etc.) But anything else on this path from the vision of purpose to purpose fulfillment is incidental.\n\nI've taken the position that 'programs' are a red herring. I think it's based on the fundamental position that all these abstractions, ideas, mediums and messages of thought are incidental and we can choose different ones.",
        "user": "U8A5MS6R1",
        "ts": "1580841634.499100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1580842179.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qyzr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Trying to wrap my head around the different perspectives. Consider 'writing' and 'science'. Is writing essential for science? Is it accidental complexity? Lets break it apart a bit more.. it's not just the written form, but what the form represents - some abstract ideas (formulae, functions) - are these abstractions essential?\n\nIf "
                            },
                            {
                                "type": "text",
                                "text": "I am the science itself",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " then I wouldn't need to understand it, I'd just be it. But I'm not science. There is something out there and science gives me a model to grasp that external something (presumably) and fit it internally - something I can understand. This gap is covered by a series of 'mediums' and 'messages' for lack of better words. 'Symbols' are one primitive medium (the idea that 'signifiers represent the signified'), we learn this medium very early in childhood. A message in this medium is 'tree' (doesn't look like a tree, but makes you think of one). The 'written medium' is quite useful too - signs themselves now have physical forms. Sentences are perhaps the next level of medium (a composition of symbols that represents a composite idea). Further, from maths we have variables, propositions, formulae, functions - these are all higher level mediums. We express science in these mediums (e.g. "
                            },
                            {
                                "type": "text",
                                "text": "f=ma",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a message that requires us to "
                            },
                            {
                                "type": "text",
                                "text": "become the medium",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " first and then absorb its meaning).\n\nWhat is the end goal in this endeavor? We're trying to predict something perhaps, or design something for a purpose - these are our goals, our vision of the purpose.\n\nNow a twist: how do we represent our purpose? "
                            },
                            {
                                "type": "text",
                                "text": "The purpose is just another medium",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context.\n\nI think what Ivan is saying is that there are multiple alternative paths of medium/message stacks to get to our goals. All of these are 'incidental complexity'. The simplest solution is having the button with 'my goal' on it, that I push. (Well technically that still has incidental complexity because you'd have to grasp the "
                            },
                            {
                                "type": "text",
                                "text": "medium of buttons",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - push, cause, effect etc.) But anything else on this path from the vision of purpose to purpose fulfillment is incidental.\n\nI've taken the position that 'programs' are a red herring. I think it's based on the fundamental position that all these abstractions, ideas, mediums and messages of thought are incidental and we can choose different ones."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "UC2A2ARPT",
                    "UHWC9PXBL"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "30f62364-ff8b-43ab-a305-6a3353773cac",
        "type": "message",
        "text": "<@UC2A2ARPT> \"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand. They theoretically let you compute anything. We don't do it because it doesn't scale to build entire programs.\n\nI understand where you're coming from. There are a lot of bad and over-engineered abstractions out there that are often unnecessary to solve the problem. There is also an advantage of having no learning curve when approaching a new program.\n\nIt's really a fundamental question of design.\n\n1) Do I put together existing (familiar) building blocks and end-up with a codebase that is easy to understand locally but bigger than the other option and not necessarily easier to understand in its totality.\n\n2) Or do I create more appropriate building-blocks (not necessary familiar) to solve my problem and end up with a smaller codebase which might have a steeper learning curve but which will pay-off later.\n\nYou can easily err on either sides. But overall as a discipline, I think we're erring towards the first approach.\n\nI'm also in disagreement with the second part when you say that an idea is either incidental or essential complexity. It doesn't make sense to me because whether something is incidental or accidental depends on the problem. An idea X can be incidental to solve problem A and essential to solve problem B.",
        "user": "UHZUS56SV",
        "ts": "1580845199.499500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0hd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " \"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand. They theoretically let you compute anything. We don't do it because it doesn't scale to build entire programs.\n\nI understand where you're coming from. There are a lot of bad and over-engineered abstractions out there that are often unnecessary to solve the problem. There is also an advantage of having no learning curve when approaching a new program.\n\nIt's really a fundamental question of design.\n\n1) Do I put together existing (familiar) building blocks and end-up with a codebase that is easy to understand locally but bigger than the other option and not necessarily easier to understand in its totality.\n\n2) Or do I create more appropriate building-blocks (not necessary familiar) to solve my problem and end up with a smaller codebase which might have a steeper learning curve but which will pay-off later.\n\nYou can easily err on either sides. But overall as a discipline, I think we're erring towards the first approach.\n\nI'm also in disagreement with the second part when you say that an idea is either incidental or essential complexity. It doesn't make sense to me because whether something is incidental or accidental depends on the problem. An idea X can be incidental to solve problem A and essential to solve problem B."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c63b30cb-97e3-45ae-b2a9-dce6626f94a4",
        "type": "message",
        "text": "&gt; \u201cHow many different ideas do you need to know in order to understand what a program does?\u201d If that was a good description of complexity then we would all be programming with turing machines.\nI don\u2019t think that\u2019s true. I don\u2019t think a human could be presented with a complex program expressed as a turing machine and understand what it does without developing, either internally or externally, abstractions over those operations. I think it may still be a useful description of complexity if we take into account that limited humans are the ones doing the understanding.",
        "user": "UKDM3GLAJ",
        "ts": "1580847517.499800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cd2",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\u201cHow many different ideas do you need to know in order to understand what a program does?\u201d If that was a good description of complexity then we would all be programming with turing machines."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don\u2019t think that\u2019s true. I don\u2019t think a human could be presented with a complex program expressed as a turing machine and understand what it does without developing, either internally or externally, abstractions over those operations. I think it may still be a useful description of complexity if we take into account that limited humans are the ones doing the understanding."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "f06e2a05-9711-464e-8920-e334b3de9690",
        "type": "message",
        "text": "I think we agree. The goal should not be to reduce the number of ideas but coming up with the ideas that make the problem understandable/solvable.",
        "user": "UHZUS56SV",
        "ts": "1580847963.000000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MT13",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think we agree. The goal should not be to reduce the number of ideas but coming up with the ideas that make the problem understandable/solvable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "02f0262e-8fff-4d44-8a15-de2cbd6cefbb",
        "type": "message",
        "text": "&gt;  \"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines.\nBut programming with Turing machines is complicated and programming with programming languages is easier? So maybe there is a cost/benefit aspect to each new idea? Each abstraction/concept has a cost and a benefit. The deeper question is this: is there any concept that is *fundamentally essential* to the problem being solved? E.g. are pure functions fundamentally essential and stateful objects fundamentally unessential to programming the game of Pong? My interpretation of Ivan's position is that _it's all incidental complexity_ - and computing is a game of choose your poison.",
        "user": "U8A5MS6R1",
        "ts": "1580849895.000200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1580853456.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CZr1",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " \"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "But programming with Turing machines is complicated and programming with programming languages is easier? So maybe there is a cost/benefit aspect to each new idea? Each abstraction/concept has a cost and a benefit. The deeper question is this: is there any concept that is "
                            },
                            {
                                "type": "text",
                                "text": "fundamentally essential",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to the problem being solved? E.g. are pure functions fundamentally essential and stateful objects fundamentally unessential to programming the game of Pong? My interpretation of Ivan's position is that "
                            },
                            {
                                "type": "text",
                                "text": "it's all incidental complexity",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - and computing is a game of choose your poison."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8b067285-b8bc-46d0-afde-05b86e80aac4",
        "type": "message",
        "text": "I think you mean \"fundamentally essential\" in the sense that you could not solve your problem without it. If so, this is the realm of the theory of computation/universality... But the terms essential/accidental are in the realm of software engineering (made by humans). A lot of our languages (abstractions) are universal and this is totally fine. This is not accidental complexity. You have many languages to understand and solve different kinds of problems. The same way you have many sciences to understand different parts of the world. Should physicists tell biologists to stop creating their own abstractions because physics is \"enough\" to explain biology?",
        "user": "UHZUS56SV",
        "ts": "1580851645.000600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "w7a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think you mean \"fundamentally essential\" in the sense that you could not solve your problem without it. If so, this is the realm of the theory of computation/universality... But the terms essential/accidental are in the realm of software engineering (made by humans). A lot of our languages (abstractions) are universal and this is totally fine. This is not accidental complexity. You have many languages to understand and solve different kinds of problems. The same way you have many sciences to understand different parts of the world. Should physicists tell biologists to stop creating their own abstractions because physics is \"enough\" to explain biology?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "087f0d6a-7762-4f86-8e9c-28522b02ba3c",
        "type": "message",
        "text": "I wanted to comment also on the idea of pushing a button to solve a problem. I understand it is an extreme example but it illustrates exactly the same point regarding scaling. Yes of course if you want to solve only one problem the push button is the simplest approach. The reality is that people don't have only one problem to solve. And if they had to learn the location of a button for each problem they have it becomes extremely complex. And if they don't have the button they will need to ask a programmer to make it for them. If instead you provide this user with building blocks they can rearrange to solve a wide range of problems then you design a robust and simple solutions. The problems for end users are exactly the same as for the programmers. And the state of UX (regarding building blocks) is even worse :slightly_smiling_face:",
        "user": "UHZUS56SV",
        "ts": "1580852475.000800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UHZUS56SV",
            "ts": "1580853041.000000"
        },
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "a0f82872-0154-466e-9b02-b0b76d770186",
        "type": "message",
        "text": "<@UHZUS56SV> I think you took my argument the wrong way \u2014 but we are both agreeing on the conclusion.\n\n&gt; \"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand.\nI'm not advocating that we should be _minimizing_ the number of different ideas. I'm just trying to establish that the _number of ideas_ is how you measure complexity. Take that together with my overall assertion that _complexity isn't evil_, and you'll see that I don't think we should be programming with Turing machines. I think we should have richer, more complex programming machinery than we have today.\n\n---\n\nYou win \u2014 surpassing Out of the Tar Pit \u2014 when you recognize that inessential complexity is not binary. It's not even scalar. There are different _flavors_ of incidental complexity. What kind of incidental complexity you want, or don't want, depends on a lot of factors. It depends on the essential complexity of the problem you're solving. It depends on what ideas you and the people around you know and can work with.\n\n<@U8A5MS6R1>\u2019s comment that starts \"Trying to wrap my head around the different perspectives\" absolutely nails it. This is not just about software engineering. This is about epistemology.",
        "user": "UC2A2ARPT",
        "ts": "1580854036.001600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1580857062.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AlT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UHZUS56SV"
                            },
                            {
                                "type": "text",
                                "text": " I think you took my argument the wrong way \u2014 but we are both agreeing on the conclusion.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"How many different ideas do you need to know in order to understand what a program does?\" If that was a good description of complexity then we would all be programming with turing machines. You have very few ideas in a turing machine and they're very easy to understand."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not advocating that we should be "
                            },
                            {
                                "type": "text",
                                "text": "minimizing",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the number of different ideas. I'm just trying to establish that the "
                            },
                            {
                                "type": "text",
                                "text": "number of ideas",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is how you measure complexity. Take that together with my overall assertion that "
                            },
                            {
                                "type": "text",
                                "text": "complexity isn't evil",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", and you'll see that I don't think we should be programming with Turing machines. I think we should have richer, more complex programming machinery than we have today.\n\n---\n\nYou win \u2014 surpassing Out of the Tar Pit \u2014 when you recognize that inessential complexity is not binary. It's not even scalar. There are different "
                            },
                            {
                                "type": "text",
                                "text": "flavors",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of incidental complexity. What kind of incidental complexity you want, or don't want, depends on a lot of factors. It depends on the essential complexity of the problem you're solving. It depends on what ideas you and the people around you know and can work with.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": "\u2019s comment that starts \"Trying to wrap my head around the different perspectives\" absolutely nails it. This is not just about software engineering. This is about epistemology."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "4d97a58f-268d-4c0c-9f7b-7c15748807ae",
        "type": "message",
        "text": "I think one point that has come up repeatedly though, is that what is inessential is a matter of context. I suspect that what is being thought of as useful or good inessential complexity is just essential complexity from a different context.",
        "user": "UKDM3GLAJ",
        "ts": "1580854343.002100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d3S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think one point that has come up repeatedly though, is that what is inessential is a matter of context. I suspect that what is being thought of as useful or good inessential complexity is just essential complexity from a different context."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "32b5e4f3-3a76-422e-beac-f124a4738674",
        "type": "message",
        "text": "Yes, though I think it's better if you say it the other way around: What is being thought of as essential complexity is just useful or good inessential complexity from a different context.\n\nAll complexity is only as essential as your context requires \u2014 and from a gods-eye view, you have total control your context.\n\nAlso \u2014 I really want to avoid conflating _essential_ and _good_. I think the good stuff should be called _preferential complexity_, because then it feels selected to suit on your context, and not imposed by the universe.\n\nFor instance, there's great harm in making your starting position, \"I am a programmer,\" because that includes a whole boatload of unchecked assumptions about what your context is. (This is the sin that Out of the Tar Pit commits.) If you disavow yourself of that perspective, you'll do a better job of seeing certain bad inessential complexity that might otherwise be seen as essential, and you'll be better equipped to figure out what preferential complexity you should be working with.\n\nAgain, <@U8A5MS6R1> nailed it:\n\n&gt; Now a twist: how do we represent our purpose? The purpose is just another medium. When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context.\nand\n\n&gt; computing is a game of choose your poison.\nSo, I have 2 beefs with the Tar Pit.\n\n1) \"Incidental / accidental complexity is bad and should be reduced to the absolute minimum\" \u2014\u00a0this breaks down as soon as you ask questions like, \"Is my type system essential or incidental?\"\n\n2) \"Essential complexity is that which remains when you strip a problem to its most minimal essence\" \u2014\u00a0this breaks down when the above breaks down, because as you approach the most minimal essence of a problem, stripping away complexity after complexity, it's going to look wildly different depending on who does the stripping \u2014 and you won't reach truly the most minimal essence until you've reduced the problem to total black nonexistent nothingness.",
        "user": "UC2A2ARPT",
        "ts": "1580854506.002400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1580856005.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "55es",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, though I think it's better if you say it the other way around: What is being thought of as essential complexity is just useful or good inessential complexity from a different context.\n\nAll complexity is only as essential as your context requires \u2014 and from a gods-eye view, you have total control your context.\n\nAlso \u2014 I really want to avoid conflating "
                            },
                            {
                                "type": "text",
                                "text": "essential",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "good",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I think the good stuff should be called "
                            },
                            {
                                "type": "text",
                                "text": "preferential complexity",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", because then it feels selected to suit on your context, and not imposed by the universe.\n\nFor instance, there's great harm in making your starting position, \"I am a programmer,\" because that includes a whole boatload of unchecked assumptions about what your context is. (This is the sin that Out of the Tar Pit commits.) If you disavow yourself of that perspective, you'll do a better job of seeing certain bad inessential complexity that might otherwise be seen as essential, and you'll be better equipped to figure out what preferential complexity you should be working with.\n\nAgain, "
                            },
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " nailed it:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Now a twist: how do we represent our purpose? The purpose is just another medium. When I put pen to paper, I'm using the physical medium to affect the written medium. Is pen and paper incidental? Yes, ideally I'd just think the words and they'd appear on paper. But follow that chain - why am I creating the written words anyway - maybe I'm distributing an idea across. So writing is just incidental - the greater purpose is distributing the idea. Indeed I could make a video instead. (So why spread an idea.. the chain keeps growing) So what's incidental depends entirely on where we 'cut off' our context."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "computing is a game of choose your poison."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So, I have 2 beefs with the Tar Pit.\n\n1) \"Incidental / accidental complexity is bad and should be reduced to the absolute minimum\" \u2014\u00a0this breaks down as soon as you ask questions like, \"Is my type system essential or incidental?\"\n\n2) \"Essential complexity is that which remains when you strip a problem to its most minimal essence\" \u2014\u00a0this breaks down when the above breaks down, because as you approach the most minimal essence of a problem, stripping away complexity after complexity, it's going to look wildly different depending on who does the stripping \u2014 and you won't reach truly the most minimal essence until you've reduced the problem to total black nonexistent nothingness."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b5fa5d91-2acc-4c52-b030-a7237c9f93c8",
        "type": "message",
        "text": "If your type system gets in the way and prevent you to do certain things. You will have to go around it, this is accidental complexity. You didn't need to solve those extra problems caused by the type system to solve the original problem. But if your type system works and help you then it is not a complexity at all. We do not have to put everything in either bucket.\n\nI think the point of accidental/incidental complexity is to figure out whether the problems you're having are related to the actual problem or caused by your tools. I don't see why you would want to try to have problems caused by your tools. So saying \"there are certain kinds of inessential complexity that are good\" seems to me to be a contradiction in terms.",
        "user": "UHZUS56SV",
        "ts": "1580856793.004300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bvDFE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If your type system gets in the way and prevent you to do certain things. You will have to go around it, this is accidental complexity. You didn't need to solve those extra problems caused by the type system to solve the original problem. But if your type system works and help you then it is not a complexity at all. We do not have to put everything in either bucket.\n\nI think the point of accidental/incidental complexity is to figure out whether the problems you're having are related to the actual problem or caused by your tools. I don't see why you would want to try to have problems caused by your tools. So saying \"there are certain kinds of inessential complexity that are good\" seems to me to be a contradiction in terms."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580751504.462400",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "9C66EA47-17FB-4B66-8D3B-3CD32A628445",
        "type": "message",
        "text": "Loved the episode. It\u2019s asking a lot but it would be nice if the player can hover over as the page goes down, so that you can read the transcript as you listen/interact with controls",
        "user": "USUMN6XLH",
        "ts": "1580856952.006700",
        "team": "T5TCAFTA9",
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "17907473-298F-47E8-A48F-1C53BF0F19A7",
        "type": "message",
        "text": "On that note, is the website open-sourced?",
        "user": "USUMN6XLH",
        "ts": "1580856963.007200",
        "team": "T5TCAFTA9",
        "thread_ts": "1580780491.490500",
        "parent_user_id": "UC2A2ARPT"
    }
]