[
    {
        "client_msg_id": "7e60845a-4ad1-466f-956f-ddd3734ab4eb",
        "type": "message",
        "text": "Idea - use software applications to design programming languages.  I think we should be taking existing software applications and working backward to work out how to create better programming languages and development tool. So the output of a programming language is a software application, it is easy to find valuable software applications. So if we were to work backward from a collection of software applications to create new programming languages, we could measure if the new language was better or not. We could measure the number of code statements, we could estimate code complexity and development time of different languages. I feel we have the Microsoft Excel problem at the moment, we spend a lot of time arguing about different language innovations, developers in Microsoft famously got distracted by spending a lot of time talking about feature ideas they could add to Excel. Microsoft eventually solved this problem by watching people use Excel. They discovered that most of the debates they had been having were a waste of time and often of near zero value to end users. Microsoft, almost overnight, switched to assessing innovation ideas against current end user solutions. ... Interestingly, we already have current end user solutions available to us, in the form of software applications.  ...  This is a random idea I had, have not spent much time checking the feasibility. ... Thoughts, feedback welcome.",
        "user": "UP6G25H35",
        "ts": "1580606860.029700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BP3/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Idea - use software applications to design programming languages.  I think we should be taking existing software applications and working backward to work out how to create better programming languages and development tool. So the output of a programming language is a software application, it is easy to find valuable software applications. So if we were to work backward from a collection of software applications to create new programming languages, we could measure if the new language was better or not. We could measure the number of code statements, we could estimate code complexity and development time of different languages. I feel we have the Microsoft Excel problem at the moment, we spend a lot of time arguing about different language innovations, developers in Microsoft famously got distracted by spending a lot of time talking about feature ideas they could add to Excel. Microsoft eventually solved this problem by watching people use Excel. They discovered that most of the debates they had been having were a waste of time and often of near zero value to end users. Microsoft, almost overnight, switched to assessing innovation ideas against current end user solutions. ... Interestingly, we already have current end user solutions available to us, in the form of software applications.  ...  This is a random idea I had, have not spent much time checking the feasibility. ... Thoughts, feedback welcome."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "reply_count": 20,
        "reply_users_count": 9,
        "latest_reply": "1585004552.083800",
        "reply_users": [
            "UC21F8Q48",
            "UCUSW7WVD",
            "UC2A2ARPT",
            "UEQ6M68H0",
            "UP6G25H35",
            "UEQ7QL15F",
            "UA14TGLTC",
            "UE0ETTCG7",
            "UAVCC2X70"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC",
                    "UEQ7QL15F"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UAVCC2X70",
                    "UCKRZS3DZ"
                ],
                "count": 2
            },
            {
                "name": "100",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7b987ec6-904f-46a6-b681-d8dd0163d421",
        "type": "message",
        "text": "On measurement, see <https://twitter.com/brianhempel/status/1098617985768570883>",
        "user": "UC21F8Q48",
        "ts": "1580609689.029800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/brianhempel|@brianhempel>: How do you evaluate the contribution of a system that's too complex to meaningfully exercise in 1-2hr user study sessions? Dan Olsen Jr. (UIST 2007) suggests claims one might make in leu of usability tests. I made a 1-page summary to post on my wall. PDF: <https://people.cs.uchicago.edu/~brianhempel/Evaluating%20User%20Interface%20Systems%20Research%20-%20Graphical%20Summary.pdf> <https://pbs.twimg.com/media/Dz8OLkpXQAEiu-u.jpg>",
                "ts": 1550765913,
                "author_name": "Brian Hempel",
                "author_link": "https://twitter.com/brianhempel/status/1098617985768570883",
                "author_icon": "https://pbs.twimg.com/profile_images/744065437554577409/9aOaF7Ch_normal.jpg",
                "author_subname": "@brianhempel",
                "text": "How do you evaluate the contribution of a system that's too complex to meaningfully exercise in 1-2hr user study sessions? Dan Olsen Jr. (UIST 2007) suggests claims one might make in leu of usability tests. I made a 1-page summary to post on my wall. PDF: <https://people.cs.uchicago.edu/~brianhempel/Evaluating%20User%20Interface%20Systems%20Research%20-%20Graphical%20Summary.pdf> <https://pbs.twimg.com/media/Dz8OLkpXQAEiu-u.jpg>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/brianhempel/status/1098617985768570883",
                "image_url": "https://pbs.twimg.com/media/Dz8OLkpXQAEiu-u.jpg",
                "image_width": 927,
                "image_height": 1200,
                "image_bytes": 301607,
                "id": 1,
                "original_url": "https://twitter.com/brianhempel/status/1098617985768570883",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TVd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On measurement, see "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/brianhempel/status/1098617985768570883"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJ6LDMMN0"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2cfbd338-0d74-4698-84a9-1376590b0d9c",
        "type": "message",
        "text": "and <https://twitter.com/brianhempel/status/1163807830031425536>",
        "user": "UC21F8Q48",
        "ts": "1580609705.030100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/brianhempel|@brianhempel>: <https://twitter.com/prathyvsh|@prathyvsh> A PL variant of this is Clayton Lewis's argument against quantitative measurement in PL evaluation, because the real landscape is too big to meaningfully sample. \"Methods in User Oriented Design of Programming Languages\" (PPIG 2017) <http://ppig.org/sites/ppig.org/files/2017-PPIG-28th-lewis.pdf> <https://pbs.twimg.com/media/ECatC6GXYAATLZW.jpg>",
                "ts": 1566308383,
                "author_name": "Brian Hempel",
                "author_link": "https://twitter.com/brianhempel/status/1163807830031425536",
                "author_icon": "https://pbs.twimg.com/profile_images/744065437554577409/9aOaF7Ch_normal.jpg",
                "author_subname": "@brianhempel",
                "text": "<https://twitter.com/prathyvsh|@prathyvsh> A PL variant of this is Clayton Lewis's argument against quantitative measurement in PL evaluation, because the real landscape is too big to meaningfully sample. \"Methods in User Oriented Design of Programming Languages\" (PPIG 2017) <http://ppig.org/sites/ppig.org/files/2017-PPIG-28th-lewis.pdf> <https://pbs.twimg.com/media/ECatC6GXYAATLZW.jpg>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/brianhempel/status/1163807830031425536",
                "image_url": "https://pbs.twimg.com/media/ECatC6GXYAATLZW.jpg",
                "image_width": 1200,
                "image_height": 1055,
                "image_bytes": 117894,
                "id": 1,
                "original_url": "https://twitter.com/brianhempel/status/1163807830031425536",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EwfG4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/brianhempel/status/1163807830031425536"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UJ6LDMMN0"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UP6G25H35"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2620b2bf-8733-4e4e-b5e1-f3f57069c6a9",
        "type": "message",
        "text": "Yeah this feels well known. For example, a stated reason for implementing languages in themselves is dogfooding. A compiler may not seem realistic, but it's at least showing that people care about testing on real programs.\n\nArc Lisp was built like this, coevolved with HN.\n\nOn this group <@UEQ6M68H0> seems to be evaluating his language with simple apps on an ongoing basis.\n\nThe challenge is to avoid over-training on the first few programs you and your initial community happen to build. That is kinda why programming seems to have an in-group.",
        "user": "UCUSW7WVD",
        "ts": "1580610756.030400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1580611033.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0AHR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah this feels well known. For example, a stated reason for implementing languages in themselves is dogfooding. A compiler may not seem realistic, but it's at least showing that people care about testing on real programs.\n\nArc Lisp was built like this, coevolved with HN.\n\nOn this group "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " seems to be evaluating his language with simple apps on an ongoing basis.\n\nThe challenge is to avoid over-training on the first few programs you and your initial community happen to build. That is kinda why programming seems to have an in-group."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "f0a6edd2-3199-4038-9cac-f1ce5ee52dd4",
        "type": "message",
        "text": "on in-group formation: it\u2019s also the OS problem that all programming systems are walled gardens because the OS makes interop so difficult",
        "user": "UC21F8Q48",
        "ts": "1580610997.030600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC21F8Q48",
            "ts": "1580611160.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LW/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "on in-group formation: it\u2019s also the OS problem that all programming systems are walled gardens because the OS makes interop so difficult"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "9316710c-af4d-4445-a318-ece4213939d8",
        "type": "message",
        "text": "On the visual languages front, a few people seem to be taking an approach that _rhymes_ with what you're asking for, <@UP6G25H35> \u2014 looking at the kind of user interaction/experience they want to have, and working backward from that toward the language. In my case, I want programming to feel like a video game, so I'm working backward from that feeling to the GUI of my visual language, and then working backward from the GUI to the language constructs itself. Similar to \"documentation driven development\", and some of the [in]famous stories out of Apple (like Steve Jobs walking into a planning meeting for their DVD burning software \u2014 full of people who were apparently excited about making a very full-featured product \u2014 drawing a single window with a single \"Burn\" button on the whiteboard, and telling the team \"build that\" and walking out.)",
        "user": "UC2A2ARPT",
        "ts": "1580619088.031300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1580619181.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T2iKZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On the visual languages front, a few people seem to be taking an approach that "
                            },
                            {
                                "type": "text",
                                "text": "rhymes",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with what you're asking for, "
                            },
                            {
                                "type": "user",
                                "user_id": "UP6G25H35"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 looking at the kind of user interaction/experience they want to have, and working backward from that toward the language. In my case, I want programming to feel like a video game, so I'm working backward from that feeling to the GUI of my visual language, and then working backward from the GUI to the language constructs itself. Similar to \"documentation driven development\", and some of the [in]famous stories out of Apple (like Steve Jobs walking into a planning meeting for their DVD burning software \u2014 full of people who were apparently excited about making a very full-featured product \u2014 drawing a single window with a single \"Burn\" button on the whiteboard, and telling the team \"build that\" and walking out.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "31c0f53b-c6eb-4adb-9377-7d2a8db6422e",
        "type": "message",
        "text": "<@UP6G25H35> Working backwards from an existing set of applications to a syntax is a very effective way of designing something. To that end, I have been building a progression of sample programs, starting from the humble clock, through the classic easy games of tic-tac-toe, snake, leading up to chess. Have tried to get people to implement the same program in a variety of languages like Red, Beads, Python, etc. Then you can compare the two languages closely, and see the difference. I am working on much larger examples now which are an even better test. The people who claim PL can't be measured effectively are being dogmatic/pedantic, and dodging a critical issue. Within a fixed range of application types, one can certainly compare languages quantitatively. You can measure word count, depth of nesting, number of IF statements used, percentage of punctuation vs words, # of API calls used, # of API's that could have been used, number of variables, ability to adapt to different screen sizes, availability of sample code, documentation quantity/quality, ability to recreate customer reported problems, etc.\n\nOn projects with a very small team size, i seek the maximum productivity out of the language/toolchain. For those projects i don't care about how many other people are using the language; i want leverage, and lesser known but powerful languages are how a small team can compete against larger entities with vast resources.\n\nEvery language has its platform limitations (embedded / realtime / mobile / desktop/ bigdata / 2D vs 3D, etc.), so one must qualify the evaluation for the range of applications one is pursuing.",
        "user": "UEQ6M68H0",
        "ts": "1580629277.031800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+olc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP6G25H35"
                            },
                            {
                                "type": "text",
                                "text": " Working backwards from an existing set of applications to a syntax is a very effective way of designing something. To that end, I have been building a progression of sample programs, starting from the humble clock, through the classic easy games of tic-tac-toe, snake, leading up to chess. Have tried to get people to implement the same program in a variety of languages like Red, Beads, Python, etc. Then you can compare the two languages closely, and see the difference. I am working on much larger examples now which are an even better test. The people who claim PL can't be measured effectively are being dogmatic/pedantic, and dodging a critical issue. Within a fixed range of application types, one can certainly compare languages quantitatively. You can measure word count, depth of nesting, number of IF statements used, percentage of punctuation vs words, # of API calls used, # of API's that could have been used, number of variables, ability to adapt to different screen sizes, availability of sample code, documentation quantity/quality, ability to recreate customer reported problems, etc.\n\nOn projects with a very small team size, i seek the maximum productivity out of the language/toolchain. For those projects i don't care about how many other people are using the language; i want leverage, and lesser known but powerful languages are how a small team can compete against larger entities with vast resources.\n\nEvery language has its platform limitations (embedded / realtime / mobile / desktop/ bigdata / 2D vs 3D, etc.), so one must qualify the evaluation for the range of applications one is pursuing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1580606860.029700",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6199b693-96ce-4423-923a-932634c8fdac",
        "type": "message",
        "text": "Hi! Operon 0.5.0 is out, find it from <https://operon.io|https://operon.io> (Java-binary and pdf-booklet). It is also the first public release and I'm hoping for feedback on the most rudimentary things; did you get the queries running (if you had a chance to try)? What was your initial impression on the language? Did you encounter anything illogical or that you could consider as possible design flaw? I have not yet documented everything, so there's more to come on later releases. Also none of the components were yet released, so it is just the core that is out now. Love to hear back from you! :grin:",
        "user": "USJSL2NVB",
        "ts": "1580674741.033000",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "operon.io - Build things faster",
                "title_link": "https://operon.io/",
                "text": "Operon is the state of the art JSON query, transformation and integration language.",
                "fallback": "operon.io - Build things faster",
                "from_url": "https://operon.io/",
                "service_name": "operon.io",
                "id": 1,
                "original_url": "https://operon.io"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X9N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi! Operon 0.5.0 is out, find it from "
                            },
                            {
                                "type": "link",
                                "url": "https://operon.io",
                                "text": "https://operon.io"
                            },
                            {
                                "type": "text",
                                "text": " (Java-binary and pdf-booklet). It is also the first public release and I'm hoping for feedback on the most rudimentary things; did you get the queries running (if you had a chance to try)? What was your initial impression on the language? Did you encounter anything illogical or that you could consider as possible design flaw? I have not yet documented everything, so there's more to come on later releases. Also none of the components were yet released, so it is just the core that is out now. Love to hear back from you! "
                            },
                            {
                                "type": "emoji",
                                "name": "grin"
                            }
                        ]
                    }
                ]
            }
        ]
    }
]