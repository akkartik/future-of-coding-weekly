[
    {
        "client_msg_id": "a05ad36f-e366-4143-965d-8e21353dd42c",
        "type": "message",
        "text": "<@U016LEA3J1H> \n\nIt seems what your talking about is presenting the  probabilities. Which is a much more honest way of viewing reality. It's also one we humans are terrible at, a result that has been repeatedly shown in studies.\n\nMost customers are much happier to see that there is one shirt in their size vs some function that accounts for the chance someone else purchased it by the time they get this message.\n\nNothing about the storage of observations at a given time effects presenting a more robust model though. It just needs to justify itself against the cognitive overhead it causes.",
        "user": "UJNJQD2AC",
        "ts": "1598568152.171900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJNJQD2AC",
            "ts": "1598568324.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "18tq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016LEA3J1H"
                            },
                            {
                                "type": "text",
                                "text": " \n\nIt seems what your talking about is presenting the  probabilities. Which is a much more honest way of viewing reality. It's also one we humans are terrible at, a result that has been repeatedly shown in studies.\n\nMost customers are much happier to see that there is one shirt in their size vs some function that accounts for the chance someone else purchased it by the time they get this message.\n\nNothing about the storage of observations at a given time effects presenting a more robust model though. It just needs to justify itself against the cognitive overhead it causes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "6186FA28-9959-41F0-A7AE-D3597F4D05BD",
        "type": "message",
        "text": "it\u2019s almost like state is the ur-impurity\u2014in the same way that functional programming languages still have to eventually interact with the outside world, the vast majority of user applications etc are only useful insofar as they modify or save some state (eg: a word document). the thing that frustrates me personally is that they never go so far as to eliminate state entirely. as in: a word document is a function of character and mouse presses. your saved file happens to be a snapshot of the result of running that function at with the timeline of inputs as it\u2019s only parameter. if you really want to be data blind please go all the way\n\non the other hand, i really sympathize with this idea. most of what i want to do personally is get really good at modifying ASTs so i can write code quickly in a flow state. the bottom of all programming is a state change from no program source to more program source",
        "user": "UHWC9PXBL",
        "ts": "1598570195.180200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1598637297.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2+Q9o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "it\u2019s almost like state is the ur-impurity\u2014in the same way that functional programming languages still have to eventually interact with the outside world, the vast majority of user applications etc are only useful insofar as they modify or save some state (eg: a word document). the thing that frustrates me personally is that they never go so far as to eliminate state entirely. as in: a word document is a function of character and mouse presses. your saved file happens to be a snapshot of the result of running that function at with the timeline of inputs as it\u2019s only parameter. if you really want to be data blind please go all the way\n\non the other hand, i really sympathize with this idea. most of what i want to do personally is get really good at modifying ASTs so i can write code quickly in a flow state. the bottom of all programming is a state change from no program source to more program source"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "5d1444f8-8ddd-4798-9bd4-a8dd35796d00",
        "type": "message",
        "text": "fwiw I was thinking reproducible more as in \"reproducible builds\" than as \"replicable experiment\". The idea is that papers should come with their artifacts: a \"one click\" implementation that process some provided example inputs and produces some example outputs, as described in the paper.\n\nThis is maybe independent of the conversation of whether the learner should build their own version from scratch or not (personally I do think \"building from scratch\" is the best way to learn). Even when building from scratch, comparing against a reference implementation is incredible useful as a learning tool.",
        "user": "UN9SCH5RD",
        "ts": "1598595636.180900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+Kdl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "fwiw I was thinking reproducible more as in \"reproducible builds\" than as \"replicable experiment\". The idea is that papers should come with their artifacts: a \"one click\" implementation that process some provided example inputs and produces some example outputs, as described in the paper.\n\nThis is maybe independent of the conversation of whether the learner should build their own version from scratch or not (personally I do think \"building from scratch\" is the best way to learn). Even when building from scratch, comparing against a reference implementation is incredible useful as a learning tool."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598125322.060600",
        "parent_user_id": "U01661S9F34",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U01661S9F34"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3b6136b9-5f89-4c84-8148-0568e84d6de2",
        "type": "message",
        "text": "Both because it's germane to this topic and because Tristan asked me to share it with anyone who might be interested, here's a trailer for an upcoming Netflix film that's trying to spread the good word about the dangers of the attention economy paperclip maximizer:\n<https://www.youtube.com/watch?v=uaaC57tcci0>",
        "user": "U013ZLJARC7",
        "ts": "1598600333.181200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "The Social Dilemma | Official Trailer | Netflix",
                "title_link": "https://www.youtube.com/watch?v=uaaC57tcci0",
                "author_name": "Netflix",
                "author_link": "https://www.youtube.com/user/NewOnNetflix",
                "thumb_url": "https://i.ytimg.com/vi/uaaC57tcci0/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: The Social Dilemma | Official Trailer | Netflix",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/uaaC57tcci0?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=uaaC57tcci0",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=uaaC57tcci0"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6nh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Both because it's germane to this topic and because Tristan asked me to share it with anyone who might be interested, here's a trailer for an upcoming Netflix film that's trying to spread the good word about the dangers of the attention economy paperclip maximizer:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=uaaC57tcci0"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595686084.036400",
        "parent_user_id": "U014WA16VNJ",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U014WA16VNJ",
                    "UJFN50C00"
                ],
                "count": 2
            },
            {
                "name": "point_up_2",
                "users": [
                    "UJFN50C00"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ef78da54-e059-44be-bcab-e7189aa8d2b6",
        "type": "message",
        "text": "<@U016LEA3J1H> It's interesting to see the phrase \"alternative model of embracing state and change\" when that's exactly what Rich is presenting in his various projects, relative to the normative approach taken by (say) most Java or C++ programs. I wonder if there's a better way to communicate that perspective. :thinking_face:\n\nSome of the problems here are a consequence of the kind of universe in which we happen to live: there's no central clock and all observations are local to the observer. Lambda calculus is a great way to model computation, but it is serial and operates within a single frame of reference. When we want to compute with multiple observers, which we very often do in a networked/multicore world, additional theory is needed to make things sensible.\n\nMost approaches one encounters at the end of that road start to look more like biology, where there are -- using the terms in quotes because they're familiar, though not exactly correct -- \"objects\" with local \"threads\" that communicate via \"messages\". This can look like the <https://en.wikipedia.org/wiki/Actor_model|Actor model>, <https://dspace.mit.edu/handle/1721.1/44215|propagators>, <https://en.wikipedia.org/wiki/\u03a0-calculus|\u03c0-calculus>, or any number of other things, but they all share the idea that we're performing dataflow between \"processors\". (N.B. Nodes in a dataflow system can be thought of as lazy functions from inputs to outputs, possibly with local state, called incrementally by whatever execution engine is at work.)",
        "user": "U013ZLJARC7",
        "ts": "1598601869.181500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GLGIN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016LEA3J1H"
                            },
                            {
                                "type": "text",
                                "text": " It's interesting to see the phrase \"alternative model of embracing state and change\" when that's exactly what Rich is presenting in his various projects, relative to the normative approach taken by (say) most Java or C++ programs. I wonder if there's a better way to communicate that perspective. "
                            },
                            {
                                "type": "emoji",
                                "name": "thinking_face"
                            },
                            {
                                "type": "text",
                                "text": "\n\nSome of the problems here are a consequence of the kind of universe in which we happen to live: there's no central clock and all observations are local to the observer. Lambda calculus is a great way to model computation, but it is serial and operates within a single frame of reference. When we want to compute with multiple observers, which we very often do in a networked/multicore world, additional theory is needed to make things sensible.\n\nMost approaches one encounters at the end of that road start to look more like biology, where there are -- using the terms in quotes because they're familiar, though not exactly correct -- \"objects\" with local \"threads\" that communicate via \"messages\". This can look like the "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Actor_model",
                                "text": "Actor model"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "https://dspace.mit.edu/handle/1721.1/44215",
                                "text": "propagators"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/\u03a0-calculus",
                                "text": "\u03c0-calculus"
                            },
                            {
                                "type": "text",
                                "text": ", or any number of other things, but they all share the idea that we're performing dataflow between \"processors\". (N.B. Nodes in a dataflow system can be thought of as lazy functions from inputs to outputs, possibly with local state, called incrementally by whatever execution engine is at work.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6CC41FCD-1AF2-46F6-B8A3-46EFEE4FB4FB",
        "type": "message",
        "text": "I\u2019m sure there\u2019s some zen-like state(!) of enlightenment one can eventually reach, where it becomes totally obvious that computation and state are one and the same. Something like the particle-wave duality in physics or so\u2026",
        "user": "U5STGTB3J",
        "ts": "1598609512.184100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kPDA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m sure there\u2019s some zen-like state(!) of enlightenment one can eventually reach, where it becomes totally obvious that computation and state are one and the same. Something like the particle-wave duality in physics or so\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "00aa5755-9529-4988-a1ff-19cb697cf6c9",
        "type": "message",
        "text": "My favorite way to think about this is data-phobia as a symptom/consequence of our tools. Rich also once noted that prog lang and database designers are rarely the same people. Any major programming language has next to no definition of real-world-state, meaning that beyond mutable variables and data-structures ideas about persistence, querying data etc are missing. Arguably every programming language transforms data but it rarely has a rich idea of where this data comes from and where it will go? Real-world information is an afterthought for all major programming languages and if we buy into the medium being the message notion then the medium, code, only ever transforms some data that we usually can't see, because it's maybe to big to see or it's in format that we can't (usually) see in our tools (images, video, animation). Beyond that code is static. It transforms data but data can not be seen being transformed so again the tool, the language carries an implicit motivator for the programmer to write transformation code, not visualizations or comprehension tools.",
        "user": "U019W8A1884",
        "ts": "1598636311.184900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eCy7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My favorite way to think about this is data-phobia as a symptom/consequence of our tools. Rich also once noted that prog lang and database designers are rarely the same people. Any major programming language has next to no definition of real-world-state, meaning that beyond mutable variables and data-structures ideas about persistence, querying data etc are missing. Arguably every programming language transforms data but it rarely has a rich idea of where this data comes from and where it will go? Real-world information is an afterthought for all major programming languages and if we buy into the medium being the message notion then the medium, code, only ever transforms some data that we usually can't see, because it's maybe to big to see or it's in format that we can't (usually) see in our tools (images, video, animation). Beyond that code is static. It transforms data but data can not be seen being transformed so again the tool, the language carries an implicit motivator for the programmer to write transformation code, not visualizations or comprehension tools."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H",
        "reactions": [
            {
                "name": "crying_cat_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "70080196-D953-42C0-AB68-E1F9907FA495",
        "type": "message",
        "text": "Pondering: how important is it for a making environment to be made from the same medium you\u2019re making with if your main goal isn\u2019t making interfaces?  The Jupyter ecosystem has come quite far despite relatively few people using it to write JS: <https://twitter.com/cmastication/status/1299366037402587137?s=21|https://twitter.com/cmastication/status/1299366037402587137?s=21>",
        "user": "US370TRJA",
        "ts": "1598649949.189300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/CMastication|@CMastication>: Observation from Jupyter Land: The Jupyter ecosystem has a big headwind because the initial target audience for the tool (Julia, Python, R) has a small overlap with the tool/skills needed to expand the ecosystem, namely Javascript. \n\nThat's not a criticism, just an observation.",
                "ts": 1598627979,
                "author_name": "JD Long",
                "author_link": "https://twitter.com/CMastication/status/1299366037402587137",
                "author_icon": "https://pbs.twimg.com/profile_images/1197275015160442880/0XWPnVtS_normal.jpg",
                "author_subname": "@CMastication",
                "text": "Observation from Jupyter Land: The Jupyter ecosystem has a big headwind because the initial target audience for the tool (Julia, Python, R) has a small overlap with the tool/skills needed to expand the ecosystem, namely Javascript. \n\nThat's not a criticism, just an observation.",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/cmastication/status/1299366037402587137?s=21",
                "id": 1,
                "original_url": "https://twitter.com/cmastication/status/1299366037402587137?s=21",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qfI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pondering: how important is it for a making environment to be made from the same medium you\u2019re making with if your main goal isn\u2019t making interfaces?  The Jupyter ecosystem has come quite far despite relatively few people using it to write JS: "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/cmastication/status/1299366037402587137?s=21",
                                "text": "https://twitter.com/cmastication/status/1299366037402587137?s=21"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598649949.189300",
        "reply_count": 9,
        "reply_users_count": 7,
        "latest_reply": "1598780069.000300",
        "reply_users": [
            "US370TRJA",
            "UC2A2ARPT",
            "USH01JEDQ",
            "U013ZLJARC7",
            "UA14TGLTC",
            "U018LAH5QCT",
            "UJBAJNFLK"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "1BE6C190-7F99-47EA-A3E2-B0A2909B2DE8",
        "type": "message",
        "text": "People have gone quite far with making r/python libs to generate JavaScript, eg streamlit/Plotly/shiny  (for r)",
        "user": "US370TRJA",
        "ts": "1598650156.191200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9ZidD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "People have gone quite far with making r/python libs to generate JavaScript, eg streamlit/Plotly/shiny  (for r)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598649949.189300",
        "parent_user_id": "US370TRJA"
    },
    {
        "client_msg_id": "27f88e29-0a64-4a26-9f78-30e298f29b40",
        "type": "message",
        "text": "I'm not entirely sure what meaning you have for \"made from the same medium\". If it helps, some of the specific terms of art for _making the thing in itself_ are: meta-circularity (which is where a compiler is written in the language it compiles, like ClojureScript and gcc) and bootstrapping (which is, IIRC, where an interactive system is implemented entirely using things that can be edited from within that system at runtime, like some Smalltalk implementations). I'm going to assume you're referring to that sort of thing, perhaps in a slightly broader sense, which in my mind would include Jupyter being used to edit the same language it's implemented in.\n\nAs for how important it is \u2014 I would say it depends on what the goals of the environment are. It's a tradeoff.\n\nWithout knowing for sure what sense of \"interfaces\" you mean (GUIs? FFIs?), there are plenty of good reasons to do it, like the one mentioned in the tweet, or like wanting to prove that the system you're building is expressive enough to express itself (eg: if Jupyter could only handle ASCII, that would be a lack of expressive power needed to be a general JavaScript editor). On the other hand, there are a ton of reasons _not_ to do it \u2014 perf, often being the #1 cited reason I've seen, but also simplicity, in that you might not want to spend the effort to make your environment so expressive that it can express itself.",
        "user": "UC2A2ARPT",
        "ts": "1598651532.191400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1598652341.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wP0c0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not entirely sure what meaning you have for \"made from the same medium\". If it helps, some of the specific terms of art for "
                            },
                            {
                                "type": "text",
                                "text": "making the thing in itself",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " are: meta-circularity (which is where a compiler is written in the language it compiles, like ClojureScript and gcc) and bootstrapping (which is, IIRC, where an interactive system is implemented entirely using things that can be edited from within that system at runtime, like some Smalltalk implementations). I'm going to assume you're referring to that sort of thing, perhaps in a slightly broader sense, which in my mind would include Jupyter being used to edit the same language it's implemented in.\n\nAs for how important it is \u2014 I would say it depends on what the goals of the environment are. It's a tradeoff.\n\nWithout knowing for sure what sense of \"interfaces\" you mean (GUIs? FFIs?), there are plenty of good reasons to do it, like the one mentioned in the tweet, or like wanting to prove that the system you're building is expressive enough to express itself (eg: if Jupyter could only handle ASCII, that would be a lack of expressive power needed to be a general JavaScript editor). On the other hand, there are a ton of reasons "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to do it \u2014 perf, often being the #1 cited reason I've seen, but also simplicity, in that you might not want to spend the effort to make your environment so expressive that it can express itself."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598649949.189300",
        "parent_user_id": "US370TRJA",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL",
                    "US370TRJA"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    }
]