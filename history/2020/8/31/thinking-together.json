[
    {
        "client_msg_id": "e7c81335-ec6f-4607-902b-4d6f2c961a8e",
        "type": "message",
        "text": "I didn't have RSI.",
        "user": "UP3FH4CLU",
        "ts": "1598825893.000100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pQF1p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't have RSI."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598432237.114700",
        "parent_user_id": "UL5AX4G2H"
    },
    {
        "client_msg_id": "08C75B0C-2D2C-4C17-9147-F68FC77F584B",
        "type": "message",
        "text": "This is such a complicated and cool question and I have so many thoughts I don\u2019t even know where to begin. I remember watching your talk about the thing you\u2019re making and I think you mentioned something along these lines being one of the big problems. I was surprised you wanted to be able to prove theorems in this system because of course a visual environment and proofs have this tension. I\u2019m curious what kind of proofs you would have in this system. In the video you mentioned a theorem in quantum computing(?) but I couldn\u2019t find it. As an elementary but nontrivial example how would you prove the Pythagorean theorem? I think you would have to do this abstractly, but as long as it is \u201cconstructive\u201d you can unfold the abstract proof at various stages and apply it to specific vectors to visualize it.  Also, if you are doing proofs I imagine these would be \u201cformal proofs\u201d and isn\u2019t that a really tough problem? Or do I misunderstand or is there some way to get around it? eg just have a more expressive and dynamic means to write informal proofs. Anyway I certainly wouldn\u2019t shy away from general variables as long as you have a means to move up and down the ladder of abstraction :wink:. ",
        "user": "UFPRPSA4S",
        "ts": "1598836831.020800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FVgk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is such a complicated and cool question and I have so many thoughts I don\u2019t even know where to begin. I remember watching your talk about the thing you\u2019re making and I think you mentioned something along these lines being one of the big problems. I was surprised you wanted to be able to prove theorems in this system because of course a visual environment and proofs have this tension. I\u2019m curious what kind of proofs you would have in this system. In the video you mentioned a theorem in quantum computing(?) but I couldn\u2019t find it. As an elementary but nontrivial example how would you prove the Pythagorean theorem? I think you would have to do this abstractly, but as long as it is \u201cconstructive\u201d you can unfold the abstract proof at various stages and apply it to specific vectors to visualize it.  Also, if you are doing proofs I imagine these would be \u201cformal proofs\u201d and isn\u2019t that a really tough problem? Or do I misunderstand or is there some way to get around it? eg just have a more expressive and dynamic means to write informal proofs. Anyway I certainly wouldn\u2019t shy away from general variables as long as you have a means to move up and down the ladder of abstraction "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": ". "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598810841.008500",
        "parent_user_id": "U017GNJM021"
    },
    {
        "client_msg_id": "136C8721-315A-4D43-8AC5-DC7706526114",
        "type": "message",
        "text": "<@UP3FH4CLU> I think you misunderstand my interest in natural language. I\u2019m interested in using it strictly as a primary programming interface. Few people would argue that we should have deep learning models interpreting all of our code (plaintext) to take action based on educated guesses about what we wanted to say (if you think that, that\u2019s a separate discussion). I\u2019m just exploring a syntax based on logic (i.e. explicitly broken into logical units with a well-defined semantics) but expressed in natural language (so that it is human-readable without having studied a course on logic).",
        "user": "UCGAK10LS",
        "ts": "1598838322.028400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NGw8Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": " I think you misunderstand my interest in natural language. I\u2019m interested in using it strictly as a primary programming interface. Few people would argue that we should have deep learning models interpreting all of our code (plaintext) to take action based on educated guesses about what we wanted to say (if you think that, that\u2019s a separate discussion). I\u2019m just exploring a syntax based on logic (i.e. explicitly broken into logical units with a well-defined semantics) but expressed in natural language (so that it is human-readable without having studied a course on logic)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598499469.142200",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f75cc92c-fc78-41ca-b3b5-d9da87260631",
        "type": "message",
        "text": "I mean making change of time more explicit: more directly observable, manipulatable, and constrainable.  This can take many forms.  Here's an example.\n\nStep 0: Setup\nImagine a fairly conventional imperative system.  We have a bunch of boxes (variables) in which we can put values.\n\nStep 1: Observable\nWe show which values go which boxes in what order.  Often systems let us check state only in the moment or keep dubious logs about what happened in the past.  Forget asking about the future.  Imagine lining up the boxes.  We might be able to scrub forward and backward through time, or add a timeline showing what values were in each box when.\n\nStep 2: Manipulatable\nGood old structured programming is kind of nice on this front.  Each assignment statement records how the contents of a box change.  Suppose we directly manipulate the boxes in some other way, then we can record a script of the assignments made.  Glue scripts together.  Good, clean fun.\n\nStep 3: Constrainable\nExcept we don't abstract cleanly from the step-to-step to composable recipes.  With functions/procedures, we keep track of arguments and return values, but we don't keep track of what boxes get examined or updated.  We can't easily tell if ordering of calls matters, and we cannot easily require that things always happen in a certain order.",
        "user": "UA14TGLTC",
        "ts": "1598847143.029100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0r+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mean making change of time more explicit: more directly observable, manipulatable, and constrainable.  This can take many forms.  Here's an example.\n\nStep 0: Setup\nImagine a fairly conventional imperative system.  We have a bunch of boxes (variables) in which we can put values.\n\nStep 1: Observable\nWe show which values go which boxes in what order.  Often systems let us check state only in the moment or keep dubious logs about what happened in the past.  Forget asking about the future.  Imagine lining up the boxes.  We might be able to scrub forward and backward through time, or add a timeline showing what values were in each box when.\n\nStep 2: Manipulatable\nGood old structured programming is kind of nice on this front.  Each assignment statement records how the contents of a box change.  Suppose we directly manipulate the boxes in some other way, then we can record a script of the assignments made.  Glue scripts together.  Good, clean fun.\n\nStep 3: Constrainable\nExcept we don't abstract cleanly from the step-to-step to composable recipes.  With functions/procedures, we keep track of arguments and return values, but we don't keep track of what boxes get examined or updated.  We can't easily tell if ordering of calls matters, and we cannot easily require that things always happen in a certain order."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "679dc7fe-773e-4c13-a71a-a4fc28394542",
        "type": "message",
        "text": "Starting from concrete values, you can approach abstraction by lifting from a single value to many at once.  Remember Bret's Ladder of Abstraction.  For extra fun, have interactions between the multiple values.  For instance, instead of a solution set of values that would work in a given context, have a probability distribution.  I was pretty into these propagation networks at once point <https://dspace.mit.edu/handle/1721.1/49525>.  Don't know if more progress has been made.",
        "user": "UA14TGLTC",
        "ts": "1598851279.029400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "16f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Starting from concrete values, you can approach abstraction by lifting from a single value to many at once.  Remember Bret's Ladder of Abstraction.  For extra fun, have interactions between the multiple values.  For instance, instead of a solution set of values that would work in a given context, have a probability distribution.  I was pretty into these propagation networks at once point "
                            },
                            {
                                "type": "link",
                                "url": "https://dspace.mit.edu/handle/1721.1/49525"
                            },
                            {
                                "type": "text",
                                "text": ".  Don't know if more progress has been made."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598810841.008500",
        "parent_user_id": "U017GNJM021"
    },
    {
        "client_msg_id": "f019ddaa-8004-470c-9038-5588083d5a27",
        "type": "message",
        "text": "<@UJFN50C00> The version of that concept with which I'm familiar is a sort of \"horizontal transfer\" of knowledge within orgs. Can you elaborate on how it would fit into your vision here?",
        "user": "U013ZLJARC7",
        "ts": "1598857072.029600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "n4W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJFN50C00"
                            },
                            {
                                "type": "text",
                                "text": " The version of that concept with which I'm familiar is a sort of \"horizontal transfer\" of knowledge within orgs. Can you elaborate on how it would fit into your vision here?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1595686084.036400",
        "parent_user_id": "U014WA16VNJ"
    },
    {
        "client_msg_id": "e9b2e797-71b1-4dfe-b82f-2f3442ce4fae",
        "type": "message",
        "text": "In Glamorous Toolkit, examples play a key role. We went so far as to replace classic tests with examples (a test that returns an object). This leads to a nicer way to compose examples, but most importantly, examples offer concrete objects you can program against. As in our environment every object can present itself through custom views and as these views can also be weaved into larger narratives, the examples also offer a nice infrastructure for documentation purposes. Here is a short article about them:\n<https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920>",
        "user": "UE1JQM9HQ",
        "ts": "1598857632.029800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Medium",
                "title": "An example of example-driven development",
                "title_link": "https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920",
                "text": "This is an example of example-driven development using Glamorous Toolkit. The concrete code snippets are written in Pharo.",
                "fallback": "Medium: An example of example-driven development",
                "image_url": "https://miro.medium.com/max/1090/1*sbjNSx4eorA9inCcMVgthg.png",
                "fields": [
                    {
                        "title": "Reading time",
                        "value": "6 min read",
                        "short": true
                    }
                ],
                "ts": 1550163638,
                "from_url": "https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920",
                "image_width": 216,
                "image_height": 250,
                "image_bytes": 156853,
                "service_icon": "https://cdn-images-1.medium.com/fit/c/152/152/1*8I-HPL0bfoIzGied-dzOvA.png",
                "id": 1,
                "original_url": "https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "au+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Glamorous Toolkit, examples play a key role. We went so far as to replace classic tests with examples (a test that returns an object). This leads to a nicer way to compose examples, but most importantly, examples offer concrete objects you can program against. As in our environment every object can present itself through custom views and as these views can also be weaved into larger narratives, the examples also offer a nice infrastructure for documentation purposes. Here is a short article about them:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://medium.com/feenk/an-example-of-example-driven-development-4dea0d995920"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598810841.008500",
        "parent_user_id": "U017GNJM021",
        "reactions": [
            {
                "name": "heart_eyes",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U01A1C2K8MP",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "18125efd-9674-4ffc-8302-5fca65b75f7c",
        "type": "message",
        "text": "<@U013ZLJARC7> Same for me. My biggest hope for a worthy successor to Emacs is <https://gtoolkit.com/>. It addresses what is for me the biggest limitation of Emacs: the lack of graphics.",
        "user": "UJBAJNFLK",
        "ts": "1598858460.030100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Glamorous Toolkit",
                "title_link": "https://gtoolkit.com/",
                "text": "Glamorous Toolkit is the moldable development environment",
                "fallback": "Glamorous Toolkit",
                "from_url": "https://gtoolkit.com/",
                "service_icon": "https://gtoolkit.com/favicon.ico",
                "service_name": "gtoolkit.com",
                "id": 1,
                "original_url": "https://gtoolkit.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/sD39",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " Same for me. My biggest hope for a worthy successor to Emacs is "
                            },
                            {
                                "type": "link",
                                "url": "https://gtoolkit.com/"
                            },
                            {
                                "type": "text",
                                "text": ". It addresses what is for me the biggest limitation of Emacs: the lack of graphics."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598649949.189300",
        "parent_user_id": "US370TRJA",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UDQBTJ211",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "4f03a2aa-de8b-4965-baf0-37aa60c196a2",
        "type": "message",
        "text": "<@UJBAJNFLK> I also really like Glamorous Toolkit. It's always good to see any system that embraces the old Smalltalk/D-Lisp philosophy of interaction and malleability! :slightly_smiling_face:",
        "user": "U013ZLJARC7",
        "ts": "1598875068.030500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pC9x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I also really like Glamorous Toolkit. It's always good to see any system that embraces the old Smalltalk/D-Lisp philosophy of interaction and malleability! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598649949.189300",
        "parent_user_id": "US370TRJA"
    },
    {
        "client_msg_id": "8853572d-025a-4759-8d7b-5132ce4a3089",
        "type": "message",
        "text": "(i.e., it's not a \"problem\" to be \"solved\", it's what most \"normals\" think of first)",
        "user": "UE6EFEPTQ",
        "ts": "1598878413.030700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DmH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(i.e., it's not a \"problem\" to be \"solved\", it's what most \"normals\" think of first)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "d61c2dfe-b508-4d72-939b-50f97ab58532",
        "type": "message",
        "text": "If you try to create a fully declarative, reactive semantics, I think you eventually run into the bind/commit distinction no matter what you do. Fundamentally, it\u2019s a question of how the lifetime of an assertion is controlled. Commit is saying the lifetime of this assertion is unconditional, whereas bind is conditioned on the other information this assertion is derived from. You\u2019ll want both, but it\u2019s awkward trying to make them play together.",
        "user": "UEBG0NPDK",
        "ts": "1598892105.031200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nPE=q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you try to create a fully declarative, reactive semantics, I think you eventually run into the bind/commit distinction no matter what you do. Fundamentally, it\u2019s a question of how the lifetime of an assertion is controlled. Commit is saying the lifetime of this assertion is unconditional, whereas bind is conditioned on the other information this assertion is derived from. You\u2019ll want both, but it\u2019s awkward trying to make them play together."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "02c5484f-613f-4317-a86f-e6c6236e1edd",
        "type": "message",
        "text": "Not being able to come up with something better is a big part of what convinced me that we needed to find something in the middle of the declarative/imperative spectrum, rather than constantly looking at the ends.",
        "user": "UEBG0NPDK",
        "ts": "1598892209.031400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NRsc3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not being able to come up with something better is a big part of what convinced me that we needed to find something in the middle of the declarative/imperative spectrum, rather than constantly looking at the ends."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "8a1f2bab-b069-4757-96c9-85cf20405bd5",
        "type": "message",
        "text": "programming with just rules or just procedures sucks, but being able to freely mix them both together is pretty magical :slightly_smiling_face:",
        "user": "UEBG0NPDK",
        "ts": "1598892378.031600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4IQsy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "programming with just rules or just procedures sucks, but being able to freely mix them both together is pretty magical "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "632d2246-f6b4-4195-a26c-07c1a3d1eaf1",
        "type": "message",
        "text": "our implementation of bind/commit led to a lot of complexity and we thought that we had hidden the implications of the different timelines from people, but as <@UA14TGLTC> said, it turned out there were cases where trying to get the right sequence of things to happen exposed you to that complexity and it was unequivocally worse than what you would normally do. Eve was much better than conventional languages on some axes, but on the axis of expressing process-like things it was significantly worse.",
        "user": "UEBG0NPDK",
        "ts": "1598892742.031800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=VFG4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "our implementation of bind/commit led to a lot of complexity and we thought that we had hidden the implications of the different timelines from people, but as "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " said, it turned out there were cases where trying to get the right sequence of things to happen exposed you to that complexity and it was unequivocally worse than what you would normally do. Eve was much better than conventional languages on some axes, but on the axis of expressing process-like things it was significantly worse."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "c83ca256-f794-4d0e-9ef2-062415c985be",
        "type": "message",
        "text": "Part of that comes from bind/commit naturally wanting to happen at different \u201ctimes,\u201d the other part came from blocks being islands that weren\u2019t obviously tied together in any meaningful way. Discovering the forest was pretty hard to do just by looking at the trees.",
        "user": "UEBG0NPDK",
        "ts": "1598892847.032000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3idCJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Part of that comes from bind/commit naturally wanting to happen at different \u201ctimes,\u201d the other part came from blocks being islands that weren\u2019t obviously tied together in any meaningful way. Discovering the forest was pretty hard to do just by looking at the trees."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "cd1ab628-a783-40ab-913b-f3e6fe445818",
        "type": "message",
        "text": "If you don\u2019t mind exposing users to the actual semantics/complexity of time, I would look at statelog as a better approach to the problem",
        "user": "UEBG0NPDK",
        "ts": "1598892968.032200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jgoe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you don\u2019t mind exposing users to the actual semantics/complexity of time, I would look at statelog as a better approach to the problem"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "6fc34fe0-7fed-4cd1-872a-32fbb8a3b839",
        "type": "message",
        "text": "It makes time fully explicit, though I don\u2019t know that it really makes it that much better when compared to something that can just express a procedure cleanly",
        "user": "UEBG0NPDK",
        "ts": "1598893081.032400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2hQ9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It makes time fully explicit, though I don\u2019t know that it really makes it that much better when compared to something that can just express a procedure cleanly"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL"
    },
    {
        "client_msg_id": "3f32d1db-401c-4312-ae2a-e5e8c90515cf",
        "type": "message",
        "text": "in any case, I\u2019d read the <https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.html|dedalus paper> and the <http://www2.informatik.uni-freiburg.de/~dbis/Publications/98/moc98.pdf|statelog paper> if you want to really dig into this stuff",
        "user": "UEBG0NPDK",
        "ts": "1598893429.032600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YxZ8e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "in any case, I\u2019d read the "
                            },
                            {
                                "type": "link",
                                "url": "https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.html",
                                "text": "dedalus paper"
                            },
                            {
                                "type": "text",
                                "text": " and the "
                            },
                            {
                                "type": "link",
                                "url": "http://www2.informatik.uni-freiburg.de/~dbis/Publications/98/moc98.pdf",
                                "text": "statelog paper"
                            },
                            {
                                "type": "text",
                                "text": " if you want to really dig into this stuff"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598684481.204900",
        "parent_user_id": "UBRKVHMCL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3fba6a01-0e48-4e92-b22a-931295d213e4",
        "type": "message",
        "text": "The problem arises when you think of consistency and how the programs change and read state.",
        "user": "U8A5MS6R1",
        "ts": "1598896531.043300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d8r=H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The problem arises when you think of consistency and how the programs change and read state."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "067773dd-5ad2-44e5-954c-838b7369966c",
        "type": "message",
        "text": "Can you give an example of the problem of consistency under read/write, in an end-user application?\nAs techies we are all aware of the issues with parallel access to replicated databases, but that's about optimisation for speed. What about an end-user-focused programming environment where all that is hidden?",
        "user": "UE6EFEPTQ",
        "ts": "1598901873.043600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "y/Vke",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Can you give an example of the problem of consistency under read/write, in an end-user application?\nAs techies we are all aware of the issues with parallel access to replicated databases, but that's about optimisation for speed. What about an end-user-focused programming environment where all that is hidden?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "48f7e900-fd2b-4630-8a06-5aa0302eff80",
        "type": "message",
        "text": "Anything involving collaborative editing of the same document, especially if some collaborators are sporadically online. Possibly a cheap answer, but I'd argue it really just emphasizes the need to build around state.",
        "user": "U016VUZGUUQ",
        "ts": "1598904577.043800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BHq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Anything involving collaborative editing of the same document, especially if some collaborators are sporadically online. Possibly a cheap answer, but I'd argue it really just emphasizes the need to build around state."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "8643a432-b0f4-4214-be2a-d2b2b3128799",
        "type": "message",
        "text": "<@U016VUZGUUQ> :smile: you landed on the exact example I was thinking of as one I hoped no-one would pick, which happens to be the one my own solution to end-user state management tends to punt on! :smile:",
        "user": "UE6EFEPTQ",
        "ts": "1598905932.044000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dEIHo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " you landed on the exact example I was thinking of as one I hoped no-one would pick, which happens to be the one my own solution to end-user state management tends to punt on! "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H",
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "U016VUZGUUQ",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "fc14ccfa-e2a3-4b3f-94e1-00f5f4d192cb",
        "type": "message",
        "text": "To what extent do our natural biases leek into the models (data structures, algorithms) we use. E.g is it possible that a tree data structure is more appealing to both users and developers because it mirrors a hierarchy (everything has a parent/cause) vs a graph which has a loop (which came first the chicken or the egg) which is considered less intuitive.\n\nIt seems a relevant design choice to consider not only the universal truthiness of something but also the cognitive load it takes to use it.",
        "user": "UJNJQD2AC",
        "ts": "1598907017.049900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJNJQD2AC",
            "ts": "1598907140.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mgRs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To what extent do our natural biases leek into the models (data structures, algorithms) we use. E.g is it possible that a tree data structure is more appealing to both users and developers because it mirrors a hierarchy (everything has a parent/cause) vs a graph which has a loop (which came first the chicken or the egg) which is considered less intuitive.\n\nIt seems a relevant design choice to consider not only the universal truthiness of something but also the cognitive load it takes to use it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598907017.049900",
        "reply_count": 35,
        "reply_users_count": 8,
        "latest_reply": "1599226864.105800",
        "reply_users": [
            "UUQ2EQW21",
            "UHWC9PXBL",
            "U01A0KANUUU",
            "U8A5MS6R1",
            "U013RRN6Y6N",
            "U013ZLJARC7",
            "UJNJQD2AC",
            "UA14TGLTC"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "7501d6c0-1339-4cc8-8f42-a9f23dbfe286",
        "type": "message",
        "text": ".. I guess my point is that, for most end-user applications, state doesn't cause issues even when building a distributed system of any sort, but I'm happy to be thrown counter-examples, alongside collaborative editing.",
        "user": "UE6EFEPTQ",
        "ts": "1598907337.050300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1598907469.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1F1uD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": ".. I guess my point is that, for most end-user applications, state doesn't cause issues even when building a distributed system of any sort, but I'm happy to be thrown counter-examples, alongside collaborative editing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598534303.161500",
        "parent_user_id": "U016LEA3J1H"
    },
    {
        "client_msg_id": "22CB0B45-0B73-4514-BF46-303AB43B379A",
        "type": "message",
        "text": "For me it usually comes down to cognitive load. If I can get away with a vector I\u2019ll use one, then a map, then a tree, then a graph.... I also believe in iterating towards a goal in an agile fashion and not over engineering a solution. But yeah, I don\u2019t lightly use a tree or a graph, because complexity == time",
        "user": "UUQ2EQW21",
        "ts": "1598907677.054400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vzl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For me it usually comes down to cognitive load. If I can get away with a vector I\u2019ll use one, then a map, then a tree, then a graph.... I also believe in iterating towards a goal in an agile fashion and not over engineering a solution. But yeah, I don\u2019t lightly use a tree or a graph, because complexity == time"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598907017.049900",
        "parent_user_id": "UJNJQD2AC"
    },
    {
        "client_msg_id": "9e26dc54-83a5-4e83-9d49-59bf0e4e8859",
        "type": "message",
        "text": "I suspect that material biases wrt existing libraries matter a lot more\u2014I\u2019d prefer a graph for most of my applications, but it\u2019s much easier to write hierarchies. Since relational databases depend on slow joins to emulate graph queries, we don\u2019t see a lot of many-linked relationships on apps and pages\u2014which I think limits peoples\u2019 imaginations (part of why Roam is taking off IMO)",
        "user": "UHWC9PXBL",
        "ts": "1598908801.054700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UIJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I suspect that material biases wrt existing libraries matter a lot more\u2014I\u2019d prefer a graph for most of my applications, but it\u2019s much easier to write hierarchies. Since relational databases depend on slow joins to emulate graph queries, we don\u2019t see a lot of many-linked relationships on apps and pages\u2014which I think limits peoples\u2019 imaginations (part of why Roam is taking off IMO)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1598907017.049900",
        "parent_user_id": "UJNJQD2AC"
    }
]