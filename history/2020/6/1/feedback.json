[
    {
        "client_msg_id": "ea73f901-e73d-430f-9ea1-dadc3507baa1",
        "type": "message",
        "text": "<@UP3FH4CLU> thanks for sharing these graphics! I know how much work it can be to put diagrams like that together. I have similar feelings as <@UEQ6M68H0>, in that I would worry the examples are too low level. The majority of \"business people\" (for example) who need to program are not doing complex math with reducers or functional programming. So, I would really conceptualize the kinds of problems you want your language users to be able to solve. At my company, we are building a textual language which operates at a far higher level like\n`once daily (at: 9am):`\n    `(@Postmates) (send) (item description: \"Any kind of flowers\") (to address: \ud83d\udccd324 Madison)`\nParens would not be necessary in our editor and our language is a bit richer allowing you to use things like <http://like%20this|links> to reference variables.",
        "user": "UFPPABQ7P",
        "ts": "1590963647.260500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFPPABQ7P",
            "ts": "1590963811.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H5s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": " thanks for sharing these graphics! I know how much work it can be to put diagrams like that together. I have similar feelings as "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": ", in that I would worry the examples are too low level. The majority of \"business people\" (for example) who need to program are not doing complex math with reducers or functional programming. So, I would really conceptualize the kinds of problems you want your language users to be able to solve. At my company, we are building a textual language which operates at a far higher level like\n"
                            },
                            {
                                "type": "text",
                                "text": "once daily (at: 9am):",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "    (@Postmates) (send) (item description: \"Any kind of flowers\") (to address: \ud83d\udccd324 Madison)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\nParens would not be necessary in our editor and our language is a bit richer allowing you to use things like "
                            },
                            {
                                "type": "link",
                                "url": "http://like%20this",
                                "text": "links"
                            },
                            {
                                "type": "text",
                                "text": " to reference variables."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU"
    },
    {
        "client_msg_id": "eab58144-de26-4600-8955-e7776a58d7ae",
        "type": "message",
        "text": "<@UP3FH4CLU> I cannot think of an example in any of the 20 sample programs i have written so far, where currying could be applied. Ambiguity is the enemy of comprehension, and in any language where you can't tell if something is a simple function call or instead a function that returns a function without checking the tail end of the parameter list, creates a difficulty in reading that is just not worth it. It means you have to know when reading the exact parameter list of every function call you see. Given that larger programs are mostly function calls, this imposes a significant memory burden on the reader. The idea of long sequences of positional parameters is an archaic notion dating back to FORTRAN, and is also not readable. I adopted the Smalltalk practice of using optional named parameters, which was also used in Objective-C. It is much more readable. Always a tradeoff between full named parameters and positional; i have adopted a mixed approach because they can get annoying.",
        "user": "UEQ6M68H0",
        "ts": "1590970123.261200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kvTQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": " I cannot think of an example in any of the 20 sample programs i have written so far, where currying could be applied. Ambiguity is the enemy of comprehension, and in any language where you can't tell if something is a simple function call or instead a function that returns a function without checking the tail end of the parameter list, creates a difficulty in reading that is just not worth it. It means you have to know when reading the exact parameter list of every function call you see. Given that larger programs are mostly function calls, this imposes a significant memory burden on the reader. The idea of long sequences of positional parameters is an archaic notion dating back to FORTRAN, and is also not readable. I adopted the Smalltalk practice of using optional named parameters, which was also used in Objective-C. It is much more readable. Always a tradeoff between full named parameters and positional; i have adopted a mixed approach because they can get annoying."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590817630.225600",
        "parent_user_id": "UP3FH4CLU",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "text": "I've been working on a deep learning project that feels relevant to this community, and would love to hear some of your thoughts. I'm training a neural network to translate abstract syntax trees into images (and then back into ASTs since the whole system is an autoencoder.) Right now this is limited to simple arithmetic statements like `c / (a+b)`, but the goal is to try it out on larger expressions with a greater vocabulary, so that you can turn larger ASTs into images. In addition to being really fun and interesting, it feels like it could offer ideas for visual programming?\nVisualized here is an interpolation between different expression trees. Still kind of rough around the edges.",
        "files": [
            {
                "id": "F014L83QPRT",
                "created": 1591038991,
                "timestamp": 1591038991,
                "name": "full_may29_6_animation.mp4",
                "title": "full_may29_6_animation.mp4",
                "mimetype": "video/mp4",
                "filetype": "mp4",
                "pretty_type": "MPEG 4 Video",
                "user": "UQPHR6Y3S",
                "editable": false,
                "size": 357158,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F014L83QPRT/full_may29_6_animation.mp4",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F014L83QPRT/download/full_may29_6_animation.mp4",
                "thumb_video": "https://files.slack.com/files-tmb/T5TCAFTA9-F014L83QPRT-6405a9ad6e/full_may29_6_animation_thumb_video.jpeg",
                "permalink": "https://futureofcoding.slack.com/files/UQPHR6Y3S/F014L83QPRT/full_may29_6_animation.mp4",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F014L83QPRT-22b4cfca7b",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KwB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been working on a deep learning project that feels relevant to this community, and would love to hear some of your thoughts. I'm training a neural network to translate abstract syntax trees into images (and then back into ASTs since the whole system is an autoencoder.) Right now this is limited to simple arithmetic statements like "
                            },
                            {
                                "type": "text",
                                "text": "c / (a+b)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but the goal is to try it out on larger expressions with a greater vocabulary, so that you can turn larger ASTs into images. In addition to being really fun and interesting, it feels like it could offer ideas for visual programming?\nVisualized here is an interpolation between different expression trees. Still kind of rough around the edges."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UQPHR6Y3S",
        "display_as_bot": false,
        "ts": "1591039501.266000",
        "edited": {
            "user": "UQPHR6Y3S",
            "ts": "1591039808.000000"
        },
        "thread_ts": "1591039501.266000",
        "reply_count": 13,
        "reply_users_count": 5,
        "latest_reply": "1591319196.291400",
        "reply_users": [
            "U0143PC0UTC",
            "UQPHR6Y3S",
            "UKDM3GLAJ",
            "UFPPABQ7P",
            "UJKKBAMLL"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    }
]