[
    {
        "client_msg_id": "1e3a3bf7-6f0b-469e-bae4-8a6a6b25ed5b",
        "type": "message",
        "text": "I\u2019m researching the influence of working memory in program comprehension. Question for the community:\n\nWhen you\u2019re reading or writing a program, are there specific tasks/examples/etc. where you found it hard to remember things? Maybe you were flipping back and forth between documents, or you kept looking back to the definition of something.",
        "user": "UFB8STN7K",
        "ts": "1591313174.458700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "i/27",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m researching the influence of working memory in program comprehension. Question for the community:\n\nWhen you\u2019re reading or writing a program, are there specific tasks/examples/etc. where you found it hard to remember things? Maybe you were flipping back and forth between documents, or you kept looking back to the definition of something."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "reply_count": 12,
        "reply_users_count": 6,
        "latest_reply": "1591414255.480800",
        "reply_users": [
            "USH01JEDQ",
            "U010SQSJGLS",
            "UC2A2ARPT",
            "UEQ6M68H0",
            "UFPPABQ7P",
            "UFB8STN7K"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "53fc754b-9134-4a61-b42b-2d2c0e2cdf5e",
        "type": "message",
        "text": "It's possible to remember things?",
        "user": "USH01JEDQ",
        "ts": "1591313558.458800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Tu8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's possible to remember things?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "478df8bf-1118-4950-a4cf-4e37f208eea4",
        "type": "message",
        "text": "Order of arguments is the worst.",
        "user": "U010SQSJGLS",
        "ts": "1591321285.459000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "P=r4E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Order of arguments is the worst."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UKP3B2J5D",
                    "UFB8STN7K",
                    "UA14TGLTC"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "604f43d4-69e9-460a-86db-61cf90250d29",
        "type": "message",
        "text": "<http://okmij.org/ftp/Prolog/Soutei.pdf|http://okmij.org/ftp/Prolog/Soutei.pdf>\nDelightful application of PLT principles to solve an actual problem. Debugging unix permissions problems is going to be more painful in the future because I'm always going to think back to this.",
        "user": "UT60XSVCN",
        "ts": "1591321615.461500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Af0K9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://okmij.org/ftp/Prolog/Soutei.pdf",
                                "text": "http://okmij.org/ftp/Prolog/Soutei.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\nDelightful application of PLT principles to solve an actual problem. Debugging unix permissions problems is going to be more painful in the future because I'm always going to think back to this."
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "client_msg_id": "3219f566-e438-453b-95ff-3f36bb9a500c",
        "type": "message",
        "text": "Ah, I believe I've had some contact with David Thue in the past. Thanks!",
        "user": "UC2A2ARPT",
        "ts": "1591331629.461800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R3DFO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah, I believe I've had some contact with David Thue in the past. Thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591294279.454500",
        "parent_user_id": "UV1CVSXGC"
    },
    {
        "client_msg_id": "091d263a-9e17-4870-8ec4-c6b0b2e78267",
        "type": "message",
        "text": "Does keeping track of the order of operations / events in a complex system (eg: which subsystems are invoked in which order in which circumstances) count? Because that's probably my biggest struggle.",
        "user": "UC2A2ARPT",
        "ts": "1591331822.462000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3VtIS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Does keeping track of the order of operations / events in a complex system (eg: which subsystems are invoked in which order in which circumstances) count? Because that's probably my biggest struggle."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFB8STN7K"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "BCC242E9-6C48-4E0D-95B2-5049ECB1E4E5",
        "type": "message",
        "text": "The biggest improvement that I cite in my beads language design is a 10 to 1 reduction in the number of APIs you had to learn in order to build a product. instead of having 100 drawing functions I have 10 with many parameters, all keyword type of parameters so that through repetition you eventually learn those 10 functions and then you can build your products without consulting any documentation or using auto complete. Autocomplete is a crutch that sometimes covers fir a complex design. It became very popular in the Java world because of the ridiculous number of function names that one ended up with. <@UC2A2ARPT> is Correct that the Biggest source of error in programming is trying to make sure things are done in the correct order. That is almost 50% of all programming is sequencing the operations. This is why I used deduction to automatically sequence as much as possible. It is the one thing that prolog had that was not copied by other languages after it. I traced the evolution of languages back to the 70s and there was a big funding battle between two groups one based on prologue in the other based on Lisp. Because the prolog group was based in France they of course lost the Funding battle, And after MIT failed to produce any tangible results from 10 years of high level of funding for automatic programming the term AI was poison for another 10 years after that. It has finally been long enough that people have forgotten the over blown claims of AI and now we are back with an AI fetish. This time however machine learning is delivering some good results and in vision language recognition Some of the areas they\u2019re doing great work and this time it won\u2019t blow up in their face. However as Conway has a proof that consciousness cannot be the result of computation there are Limits to the achievements we are going to get from gradient descent ML",
        "user": "UEQ6M68H0",
        "ts": "1591336851.465500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8g+J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The biggest improvement that I cite in my beads language design is a 10 to 1 reduction in the number of APIs you had to learn in order to build a product. instead of having 100 drawing functions I have 10 with many parameters, all keyword type of parameters so that through repetition you eventually learn those 10 functions and then you can build your products without consulting any documentation or using auto complete. "
                            },
                            {
                                "type": "text",
                                "text": "Autocomplete"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "is"
                            },
                            {
                                "type": "text",
                                "text": " a crutch that "
                            },
                            {
                                "type": "text",
                                "text": "sometimes covers fir a complex design. It became very popular in the Java world because of the ridiculous number of function names that one ended up with. "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " is Correct that the Biggest source of error in programming is trying to make sure things are done in the correct order. That is almost 50% of all programming is sequencing the operations. This is why I used deduction to automatically sequence as much as possible. It is the one thing that prolog had that was not copied by other languages after it. I traced the evolution of languages back to the 70s and there was a big funding battle between two groups one based on prologue in the other based on Lisp. Because the prolog group was based in France they of course lost the Funding battle, And after MIT failed to produce any tangible results from 10 years of high level of funding for automatic programming the term AI was poison for another 10 years after that. It has finally been long enough that people have forgotten the over blown claims of AI and now we are back with an AI fetish. This time however machine learning is delivering some good results and in vision language recognition Some of the areas they\u2019re doing great work and this time it won\u2019t blow up in their face. However as Conway has a proof that consciousness cannot be the result of computation there are Limits to the achievements we are going to get from gradient descent ML"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "F315FF93-C9CB-4232-8AA2-F6573B74B69D",
        "type": "message",
        "text": "Edward \u2014 can you also offer an example of somewhere in programming you've found it hard to remember things, specifically? I can't tell if the example of reducing 100 APIs to 10 with many params is about a struggle you've personally faced, or something you've done just to solve an issue others have faced (especially since the rest of your comment drifts way off topic, rather than, say, offering more relevant context). I'm interested in hearing about your personal struggle with remembering, if you have anything to share there.",
        "user": "UC2A2ARPT",
        "ts": "1591337636.467100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1591338117.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Op6V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Edward \u2014 can you also offer an example of somewhere in programming you've found it hard to remember things, specifically? I can't tell if the example of reducing 100 APIs to 10 with many params is about a struggle you've personally faced, or something you've done just to solve an issue others have faced (especially since the rest of your comment drifts way off topic, rather than, say, offering more relevant context). I'm interested in hearing about your personal struggle with remembering, if you have anything to share there."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "c0df869b-50da-4a04-8af2-35d053869bec",
        "type": "message",
        "text": "Here's a story of lock-in in Open Source: <https://blog.khinsen.net/posts/2020/02/26/the-rise-of-community-owned-monopolies/>\nOpen Source is a safeguard against lock-in only for those who can themselves assume  maintenance of all the Open Source tools they depend on. Which is roughly Google and Microsoft, plus perhaps Apple. The real question is not Open Source or proprietary, but how much a user's application profile matters for the producer of the infrastructure, and of course the long-term survival chances of the producer.",
        "user": "UJBAJNFLK",
        "ts": "1591349214.467700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "The rise of community-owned monopolies",
                "title_link": "https://blog.khinsen.net/posts/2020/02/26/the-rise-of-community-owned-monopolies/",
                "text": "One question I have been thinking about in the context of reproducible research is this: Why is all stable software technology old, and all recent technology fragile? Why is it easier to run 40-year-old Fortran code than ten-year-old Python code? A hypoth...",
                "fallback": "The rise of community-owned monopolies",
                "from_url": "https://blog.khinsen.net/posts/2020/02/26/the-rise-of-community-owned-monopolies/",
                "service_name": "blog.khinsen.net",
                "id": 1,
                "original_url": "https://blog.khinsen.net/posts/2020/02/26/the-rise-of-community-owned-monopolies/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=ujh6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Here's a story of lock-in in Open Source: "
                            },
                            {
                                "type": "link",
                                "url": "https://blog.khinsen.net/posts/2020/02/26/the-rise-of-community-owned-monopolies/"
                            },
                            {
                                "type": "text",
                                "text": "\nOpen Source is a safeguard against lock-in only for those who can themselves assume  maintenance of all the Open Source tools they depend on. Which is roughly Google and Microsoft, plus perhaps Apple. The real question is not Open Source or proprietary, but how much a user's application profile matters for the producer of the infrastructure, and of course the long-term survival chances of the producer."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U71PMQ1V0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "1bc6cbac-3461-4c84-b167-56e3843e0f03",
        "type": "message",
        "text": "While I agree people underestimate the maintenance burden of OS, there is a meaningful distinction in the degree of lock in. It's not about migrating, it's about tying your viability to another organisation.\n\nIf everything is open then it is possible to keep running an old version of something, potentially on old hardware, almost indefinitely. There are countless enterprises out there stuck on Java 6.\n\nObviously this slow death is not desirable, but IMO it is a completely different risk to say, Dark getting bought out and shuttered.",
        "user": "UDQBTJ211",
        "ts": "1591350900.468000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UDQBTJ211",
            "ts": "1591350969.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yDgsR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "While I agree people underestimate the maintenance burden of OS, there is a meaningful distinction in the degree of lock in. It's not about migrating, it's about tying your viability to another organisation.\n\nIf everything is open then it is possible to keep running an old version of something, potentially on old hardware, almost indefinitely. There are countless enterprises out there stuck on Java 6.\n\nObviously this slow death is not desirable, but IMO it is a completely different risk to say, Dark getting bought out and shuttered."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY",
        "reactions": [
            {
                "name": "slightly_smiling_face",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "569cdd4d-83d4-4070-999f-088161b43fdd",
        "type": "message",
        "text": "(Dark is perhaps a bad example because they actually are quite open about what would happen in such a scenario and how they would release everything)",
        "user": "UDQBTJ211",
        "ts": "1591351041.468300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M0TGj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Dark is perhaps a bad example because they actually are quite open about what would happen in such a scenario and how they would release everything)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "9d4a1f4e-5fe1-49ac-98a0-072e1a671832",
        "type": "message",
        "text": "At the moment, I'm having a hard time remembering which files I defined core logic in. I have many entry points due to the complexity of bundling and reusing my own library code. Then, a semi involved multi step build process with WASM in the middle. So, yeah, I'm currently hard at work to reduce that complexity",
        "user": "UFPPABQ7P",
        "ts": "1591352469.468500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Or/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "At the moment, I'm having a hard time remembering which files I defined core logic in. I have many entry points due to the complexity of bundling and reusing my own library code. Then, a semi involved multi step build process with WASM in the middle. So, yeah, I'm currently hard at work to reduce that complexity"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "e981d434-a1cc-4063-963e-eaa5753f5ebd",
        "type": "message",
        "text": "<@UDQBTJ211> I'd say that's more the difference between local vs. cloud, not open vs. proprietary. I know lots of people who still run Windows XP on old hardware, usually because they have drivers for exotic lab instruments for XP that were never ported to later versions.",
        "user": "UJBAJNFLK",
        "ts": "1591359451.468800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GnBU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": " I'd say that's more the difference between local vs. cloud, not open vs. proprietary. I know lots of people who still run Windows XP on old hardware, usually because they have drivers for exotic lab instruments for XP that were never ported to later versions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "DA97C88D-7285-4A07-B1E3-AD3C4105AA41",
        "type": "message",
        "text": "This is what I want to see from a programming language: <https://s.ai/nlws/|https://s.ai/nlws/>",
        "user": "UD69XQ9J8",
        "ts": "1591362068.469500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QQ5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is what I want to see from a programming language: "
                            },
                            {
                                "type": "link",
                                "url": "https://s.ai/nlws/",
                                "text": "https://s.ai/nlws/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591362068.469500",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1591422007.489300",
        "reply_users": [
            "UDKTZSD6H",
            "UJN1TAYEQ",
            "UAVCC2X70"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UUB7RA7PF",
                    "UE6EFEPTQ",
                    "UHWC9PXBL",
                    "UAVCC2X70"
                ],
                "count": 4
            },
            {
                "name": "+1",
                "users": [
                    "U0139HUPMQ9"
                ],
                "count": 1
            },
            {
                "name": "rolling_on_the_floor_laughing",
                "users": [
                    "UJKKBAMLL",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "392B4F91-2BC9-4F39-808E-E7D6FB4539C6",
        "type": "message",
        "text": "The better your memory the more obtuse you can be in your work And get away with yourself as the reader but will punish any other person who comes along later who tries to understand your code. You can see the bad effects of programmers who have good memories in many examples of code, where variable names are very short and non-descriptive, and where there are excessive numbers of modules with very complex inheritance systems. People with great memories gravitate towards languages which are known to be hard to read but because of their phenomenal memories it does not stress them. Languages where you have to remember exactly how many parameters are being consumed on the stack are highly bifurcated in terms of their user base, because people with poor memories find those languages rough going. Forth and Postscript both require you to know how many operands the function is going to absorb from the stack. That is a tremendous omnipresent memory load.  Languages and APIs which have long sequences of required positional parameters in functions also present a heavy burden. In fact almost any function that has more than one positional parameter starts to create a memory burden.. The Lego system proves that it is better to have a small number of primitives that are repeated many times then to have a huge set of complicated pieces to connect together.",
        "user": "UEQ6M68H0",
        "ts": "1591362990.471700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1591397633.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Wpr4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The better your memory the more obtuse you can be in your work And get away with yourself as the reader but will punish any other person who comes along later who tries to understand your code. You can see the bad effects of programmers who have good memories in many examples of code, where variable names are very short and non-descriptive, and where there are excessive numbers of modules with very complex inheritance systems. People with great memories gravitate towards languages which are known to be hard to read but because of their phenomenal memories it does not stress them. Languages where you have to remember exactly how many parameters are being consumed on the stack are highly bifurcated in terms of their user base, because people with poor memories find those languages rough going. Forth and Postscript both require you to know how many operands the function is going to absorb from the stack. That is a tremendous omnipresent memory load.  Languages and APIs which have long sequences of required positional parameters in functions also present a heavy burden. In fact almost any function that has more than one positional parameter starts to create a memory burden.. The Lego system proves that it is better to have a small number of primitives that are repeated many times then to have a huge set of complicated pieces to connect together."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "a7e9e56f-c755-4c81-b923-c71cac430eee",
        "type": "message",
        "text": "<@UC2A2ARPT> can you elaborate? What\u2019s the higher level task that requires you to understand the order of operations? (debugging, performance optimization, etc.)",
        "user": "UFB8STN7K",
        "ts": "1591377564.477500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lNCax",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " can you elaborate? What\u2019s the higher level task that requires you to understand the order of operations? (debugging, performance optimization, etc.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "9e293388-78ee-493f-b195-49df2dc5764b",
        "type": "message",
        "text": "Also, for APIs I think Matplotlib vs. Seaborn is a great example of what <@UEQ6M68H0> is talking about. MPL gives 100s of knobs each with its own API function. Seaborn gives maybe a dozen top-level functions with many parameters, along with many smart defaults.",
        "user": "UFB8STN7K",
        "ts": "1591377682.477700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oiUC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, for APIs I think Matplotlib vs. Seaborn is a great example of what "
                            },
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " is talking about. MPL gives 100s of knobs each with its own API function. Seaborn gives maybe a dozen top-level functions with many parameters, along with many smart defaults."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "brain",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "80897168-c0d5-4d0f-b3e2-45d7ec3bae41",
        "type": "message",
        "text": "My OoO difficulty usually occurs when acclimatizing myself to a new codebase, needing to learn what all the pieces are and how they fit together. Alternatively, returning to a familiar codebase after a time away from it, needing to recall or reacquaint myself with the workings.\n\nDebugging too, sure, but I think that has less to do with memory and more to do with visibility. The period of honing-in on the cause of a bug (subjectively) feels more like following a scent than making a map. Once the cause is found, it's usually a methodical process to determine the root cause.\n\nOptimization is almost the opposite of learning / reacquainting \u2014\u00a0by the time I'm ready to do optimization, I will have _loaded the entire program into my head_, so to speak (or at least the relevant bits), so it's all in working memory and is easy to recall.",
        "user": "UC2A2ARPT",
        "ts": "1591377978.478000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1591378159.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UNr1x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My OoO difficulty usually occurs when acclimatizing myself to a new codebase, needing to learn what all the pieces are and how they fit together. Alternatively, returning to a familiar codebase after a time away from it, needing to recall or reacquaint myself with the workings.\n\nDebugging too, sure, but I think that has less to do with memory and more to do with visibility. The period of honing-in on the cause of a bug (subjectively) feels more like following a scent than making a map. Once the cause is found, it's usually a methodical process to determine the root cause.\n\nOptimization is almost the opposite of learning / reacquainting \u2014\u00a0by the time I'm ready to do optimization, I will have "
                            },
                            {
                                "type": "text",
                                "text": "loaded the entire program into my head",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", so to speak (or at least the relevant bits), so it's all in working memory and is easy to recall."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5c5c4653-d113-4438-bdc8-a72f816895e5",
        "type": "message",
        "text": "In what cases do you need to understand OoO to understand a codebase? Perhaps put another way: for what kinds of pieces do you need OoO to reason about their composition?\n\nFor example, if I\u2019m understanding how Seaborn draws a graph, it might choose to draw the axis labels before the data points, but that\u2019s an arbitrary choice. Understanding the OoO doesn\u2019t give insight to the system design.",
        "user": "UFB8STN7K",
        "ts": "1591378225.478400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFB8STN7K",
            "ts": "1591378263.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LPX5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In what cases do you need to understand OoO to understand a codebase? Perhaps put another way: for what kinds of pieces do you need OoO to reason about their composition?\n\nFor example, if I\u2019m understanding how Seaborn draws a graph, it might choose to draw the axis labels before the data points, but that\u2019s an arbitrary choice. Understanding the OoO doesn\u2019t give insight to the system design."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591313174.458700",
        "parent_user_id": "UFB8STN7K"
    },
    {
        "client_msg_id": "f6d1f205-2a17-44bc-8314-71fe68bb5ca3",
        "type": "message",
        "text": "Or even just the difference between open, well understood data models and deliberate lockin. I used sublime text for a while, even though it was proprietary, because I would still be able to use it if the company folded and I would still be able to read my files if I stopped using it. Plus the extension api etc were well understood enough that someone would probably just clone it if it died. Similarly for using a proprietary service to host my email, because I can still backup my email with a standard protocol and easily migrate it somewhere else, or use third party software to read it if I don't like the interface. It's still a cloud service but I don't feel locked in.\n\nI guess I'm happy to use proprietary tools when they are to some extent fungible.",
        "user": "U71PMQ1V0",
        "ts": "1591378752.478700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U71PMQ1V0",
            "ts": "1591378790.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fRf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Or even just the difference between open, well understood data models and deliberate lockin. I used sublime text for a while, even though it was proprietary, because I would still be able to use it if the company folded and I would still be able to read my files if I stopped using it. Plus the extension api etc were well understood enough that someone would probably just clone it if it died. Similarly for using a proprietary service to host my email, because I can still backup my email with a standard protocol and easily migrate it somewhere else, or use third party software to read it if I don't like the interface. It's still a cloud service but I don't feel locked in.\n\nI guess I'm happy to use proprietary tools when they are to some extent fungible."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e74f78d4-68a1-4729-8568-aedfae736634",
        "type": "message",
        "text": "I wonder if the airtable api is sufficiently powerful to allow writing a third party interface.",
        "user": "U71PMQ1V0",
        "ts": "1591378816.479000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0+N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if the airtable api is sufficiently powerful to allow writing a third party interface."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "d8049ea6-196b-4b25-b967-850e7949c053",
        "type": "message",
        "text": "Yeah, the question of whether no-code tools _have_ a clearly describable data model that can be disentangled from their one implementation is pretty important. Like: software is the lines of code that define the software. Even Dark, you can imagine, because the text code is a 1:1 representation of the internal magic, that you could create another backend. Zapier-style tools, you can imagine a YAML/declarative definition of the workflow, like GitHub Workflows's YAML definitions. But then once things start getting visual\u2026\u00a0once you can move around nodes &amp; boxes, is that ineffable? Is it position metadata on top of a graph that could be exported? Somewhere in between?",
        "user": "U014BMRB170",
        "ts": "1591380182.479200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JpMc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, the question of whether no-code tools "
                            },
                            {
                                "type": "text",
                                "text": "have",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a clearly describable data model that can be disentangled from their one implementation is pretty important. Like: software is the lines of code that define the software. Even Dark, you can imagine, because the text code is a 1:1 representation of the internal magic, that you could create another backend. Zapier-style tools, you can imagine a YAML/declarative definition of the workflow, like GitHub Workflows's YAML definitions. But then once things start getting visual\u2026\u00a0once you can move around nodes & boxes, is that ineffable? Is it position metadata on top of a graph that could be exported? Somewhere in between?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "9485fcd8-9359-4024-955c-cf6932834f18",
        "type": "message",
        "text": "Everything is just bits in the end. I don't think there is some ineffable magic that can't be exported in the data model. The important distinction imo is whether they are willing to define and commit to a data model. One of the defining features of the rise of cloud services is the end of backwards compatibility. Most cloud services own all the user's data and hide the internal details, allowing them to arbitrarily migrate code and data whenever they feel like. It certainly makes development easier and the lockin it generates is just icing on the cake.\n\nCompare this to eg apps which store their data in sqlite which has a very stable serialization format and meta-model (sql schema), making it easy to access and understand that data in third party tools. Some cloud services do expose the same underlying api that all their front-end code goes through, which has a similar effect but still takes more work to interact with than a standard interface like sql. Perhaps the rise of graphql will lead to more of this kind of portability.",
        "user": "U71PMQ1V0",
        "ts": "1591381069.479400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U71PMQ1V0",
            "ts": "1591381113.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nBUz0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Everything is just bits in the end. I don't think there is some ineffable magic that can't be exported in the data model. The important distinction imo is whether they are willing to define and commit to a data model. One of the defining features of the rise of cloud services is the end of backwards compatibility. Most cloud services own all the user's data and hide the internal details, allowing them to arbitrarily migrate code and data whenever they feel like. It certainly makes development easier and the lockin it generates is just icing on the cake.\n\nCompare this to eg apps which store their data in sqlite which has a very stable serialization format and meta-model (sql schema), making it easy to access and understand that data in third party tools. Some cloud services do expose the same underlying api that all their front-end code goes through, which has a similar effect but still takes more work to interact with than a standard interface like sql. Perhaps the rise of graphql will lead to more of this kind of portability."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591214873.399000",
        "parent_user_id": "UR482RFPY",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3bea9d2e-45da-4ff0-aa18-30507d889f3d",
        "type": "message",
        "text": "First brush: Can't compute.",
        "user": "UDKTZSD6H",
        "ts": "1591385328.480000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PY+mQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "First brush: Can't compute."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591362068.469500",
        "parent_user_id": "UD69XQ9J8"
    }
]