[
    {
        "client_msg_id": "fee8af71-dadb-479a-9b24-1c4efc085fe3",
        "type": "message",
        "text": "None of what you said is really relevant to me. I'm _designing_ a language, not using BigInts as a library feature. Accordingly, situations where you can \"avoid overflow reliably\" are amenable to static analysis. It seems like it should be easy to identify sequences of operations where integer size won't change substantially, and you can perform a single size check before entering such a block of code, then branch to either a 64-bit version or a BigInt version as necessary. And memory management is also a language/runtime implementation issue which is going to have to be dealt with for general data structures either way.",
        "user": "UCGAK10LS",
        "ts": "1591839632.150000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1591839847.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "doL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "None of what you said is really relevant to me. I'm "
                            },
                            {
                                "type": "text",
                                "text": "designing",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a language, not using BigInts as a library feature. Accordingly, situations where you can \"avoid overflow reliably\" are amenable to static analysis. It seems like it should be easy to identify sequences of operations where integer size won't change substantially, and you can perform a single size check before entering such a block of code, then branch to either a 64-bit version or a BigInt version as necessary. And memory management is also a language/runtime implementation issue which is going to have to be dealt with for general data structures either way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590977348.305600",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f1e3db7f-63b5-4ac6-9791-48ed3ede5d38",
        "type": "message",
        "text": "I'd like to see <@UPU0YJ1CM> on the podcast",
        "user": "UBSMEUXAA",
        "ts": "1591857086.151100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fdR4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd like to see "
                            },
                            {
                                "type": "user",
                                "user_id": "UPU0YJ1CM"
                            },
                            {
                                "type": "text",
                                "text": " on the podcast"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591741456.139100",
        "parent_user_id": "UCXR52MU2",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT",
                    "UCXR52MU2"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "14c2a3bf-2523-4b53-9a42-36544559db17",
        "type": "message",
        "text": "Dwayne Reeves at Facebook has done a lot of programming language work but I don't think it falls in FOC",
        "user": "UBSMEUXAA",
        "ts": "1591857139.151300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9K8o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Dwayne Reeves at Facebook has done a lot of programming language work but I don't think it falls in FOC"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591741456.139100",
        "parent_user_id": "UCXR52MU2",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UCXR52MU2"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "51feeb47-5275-4e39-b850-ede259e3cfd3",
        "type": "message",
        "text": "I've tried not to volunteer myself during all of this, but in this case I'd definitely be a guest and talk about game engines, visual programming in VR and graphics/GPU programming",
        "user": "UBSMEUXAA",
        "ts": "1591857217.151500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lZzW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've tried not to volunteer myself during all of this, but in this case I'd definitely be a guest and talk about game engines, visual programming in VR and graphics/GPU programming"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591741456.139100",
        "parent_user_id": "UCXR52MU2",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UC2A2ARPT",
                    "UCXR52MU2"
                ],
                "count": 2
            },
            {
                "name": "tada",
                "users": [
                    "UCXR52MU2"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "fc788112-a347-4476-822d-c91951f30f28",
        "type": "message",
        "text": "<@UD6EXQVM0> Nothing I know of, though a tutorial for Lisp newbies would probably be the best way to gain an audience. Selling any alternative to s-expressions to people who are perfectly happy with s-expressions is a pretty dumb marketing strategy.",
        "user": "UJBAJNFLK",
        "ts": "1591864026.151700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vxq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UD6EXQVM0"
                            },
                            {
                                "type": "text",
                                "text": " Nothing I know of, though a tutorial for Lisp newbies would probably be the best way to gain an audience. Selling any alternative to s-expressions to people who are perfectly happy with s-expressions is a pretty dumb marketing strategy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590712683.260000",
        "parent_user_id": "UT60XSVCN"
    },
    {
        "client_msg_id": "f7f55e5c-1ae4-4c8b-a169-106fae9ac36a",
        "type": "message",
        "text": "<@U6KQ2S410> I agree with all that. Challenge problems are one way to formulate common goals. My point is that discussing challenge problems here on Slack will just lead to another interesting discussion that will die out after a few days. Slack is even worse than other stream media in being optimized for short attention spans.",
        "user": "UJBAJNFLK",
        "ts": "1591864254.152000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1tW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U6KQ2S410"
                            },
                            {
                                "type": "text",
                                "text": " I agree with all that. Challenge problems are one way to formulate common goals. My point is that discussing challenge problems here on Slack will just lead to another interesting discussion that will die out after a few days. Slack is even worse than other stream media in being optimized for short attention spans."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591463789.003800",
        "parent_user_id": "U71PMQ1V0"
    },
    {
        "client_msg_id": "469f70f2-5a64-43b5-92ad-8321cea63c62",
        "type": "message",
        "text": "Has anyone ever seen an implementation of arbitrary-precision floats (N.B: not rationals) where you don't actually have to set the precision BEFORE you perform an operation? I want to do a sequence of operations and then round the final result, not round constantly and incessantly. It seems like no human on earth has ever implemented this before, which baffles me. (Edit: division is allowed to be rounded)",
        "user": "UCGAK10LS",
        "ts": "1591869278.153800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1591928922.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fWmQ2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Has anyone ever seen an implementation of arbitrary-precision floats (N.B: not rationals) where you don't actually have to set the precision BEFORE you perform an operation? I want to do a sequence of operations and then round the final result, not round constantly and incessantly. It seems like no human on earth has ever implemented this before, which baffles me. (Edit: division is allowed to be rounded)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "reply_count": 38,
        "reply_users_count": 13,
        "latest_reply": "1592047355.248300",
        "reply_users": [
            "UA14TGLTC",
            "UCGAK10LS",
            "UAJ9DV971",
            "UBN9AFS0N",
            "UHWC9PXBL",
            "UC2A2ARPT",
            "UJBAJNFLK",
            "UDQBTJ211",
            "U015902ESJC",
            "UETFVV24Q",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "UAVCC2X70"
        ],
        "subscribed": true,
        "last_read": "1592049631.317000"
    },
    {
        "client_msg_id": "3cf00c9f-357e-4317-81cc-d9e24a9892d7",
        "type": "message",
        "text": "If you don't mean rationals, what do you mean?",
        "user": "UA14TGLTC",
        "ts": "1591869758.154200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EfF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you don't mean rationals, what do you mean?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ece5b837-22da-4793-bc46-eee45f9d2007",
        "type": "message",
        "text": "Just floats! But where the mantissa and exponent are BigInts, not fixed-size bit fields. I want to be able to add or multiply two floats and get an exact result, unless I explicitly ask for rounding.",
        "user": "UCGAK10LS",
        "ts": "1591869823.154400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e0G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Just floats! But where the mantissa and exponent are BigInts, not fixed-size bit fields. I want to be able to add or multiply two floats and get an exact result, unless I explicitly ask for rounding."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a68f566a-d54c-4c0d-ab68-2ebd682bcd99",
        "type": "message",
        "text": "Probably not what you\u2019re looking for but: <https://en.wikipedia.org/wiki/Unum_(number_format)>",
        "user": "UAJ9DV971",
        "ts": "1591870142.154600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAJ9DV971",
            "ts": "1591870146.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1wJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Probably not what you\u2019re looking for but: "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Unum_(number_format)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "846e9971-6cce-4d4d-80a9-1c47490e33cf",
        "type": "message",
        "text": "Unums don't provide exact results, despite the marketing type. Interval arithmetic (which floats or unums can be used for) provides a guarantee that the true result lies within an interval, but I'm not really interested in interval arithmetic.",
        "user": "UCGAK10LS",
        "ts": "1591870196.155000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1591870217.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iQnTE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unums don't provide exact results, despite the marketing type. Interval arithmetic (which floats or unums can be used for) provides a guarantee that the true result lies within an interval, but I'm not really interested in interval arithmetic."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "be53be0f-fa70-43ea-9ccd-84a4ca816324",
        "type": "message",
        "text": "probably you know about this and I'm not sure it solves your problem, but just in case: <https://gmplib.org/>",
        "user": "UBN9AFS0N",
        "ts": "1591870376.155300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/Bt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "probably you know about this and I'm not sure it solves your problem, but just in case: "
                            },
                            {
                                "type": "link",
                                "url": "https://gmplib.org/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "57c74fcd-08fe-4126-9674-c68e08f0d8ef",
        "type": "message",
        "text": "Unfortunately, you have to specify the precision of GMP floats before each operation.",
        "user": "UCGAK10LS",
        "ts": "1591870560.155500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rzpq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unfortunately, you have to specify the precision of GMP floats before each operation."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "4b766f87-385e-4f6e-97b7-732a8f7832c2",
        "type": "message",
        "text": "I could \"hack\" these existing libraries by setting the target precision insanely high (kilobytes), but it's a dodgy solution.",
        "user": "UCGAK10LS",
        "ts": "1591870598.155700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3XyS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I could \"hack\" these existing libraries by setting the target precision insanely high (kilobytes), but it's a dodgy solution."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b0f38861-37fa-48be-9550-d53a43a59b77",
        "type": "message",
        "text": "The kind of hack I've done is to have arithmetic operations build an expression tree, which you then reduce in some special way later.",
        "user": "UA14TGLTC",
        "ts": "1591876428.155900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jbND",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The kind of hack I've done is to have arithmetic operations build an expression tree, which you then reduce in some special way later."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5B155401-4571-4D2F-BAE0-2CA4401DB442",
        "type": "message",
        "text": "^^that\u2019s what i would do",
        "user": "UHWC9PXBL",
        "ts": "1591880506.156500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z9H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "^^that\u2019s what i would do"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5bd0eae7-bbf0-46c3-bb4d-6ebf639b5f11",
        "type": "message",
        "text": "How does that give me an associative SUM()?",
        "user": "UCGAK10LS",
        "ts": "1591885719.157000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dph",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How does that give me an associative SUM()?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "4ff229cc-4be9-48e4-9c8c-9b64d714e80d",
        "type": "message",
        "text": "This is a rabbit hole I went <https://twitter.com/spiralganglion/status/1141913756923912192|exploring> about a year ago. Some of the libraries had a maximum precision threshold you could set, which sounds like the thing you want to avoid. Other libraries dodged that by doing all calculations in a <http://algebrite.org|symbolic way> (<https://github.com/davidedc/Algebrite#references|see also>). There were a bunch of libraries I came across, but I didn't end up saving links to them because I never found one that fit my performance needs (ie: perfect precision with relatively constant execution time that handles the accumulation of millions of operations).",
        "user": "UC2A2ARPT",
        "ts": "1591888057.158100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1591888327.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "le8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a rabbit hole I went "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/spiralganglion/status/1141913756923912192",
                                "text": "exploring"
                            },
                            {
                                "type": "text",
                                "text": " about a year ago. Some of the libraries had a maximum precision threshold you could set, which sounds like the thing you want to avoid. Other libraries dodged that by doing all calculations in a "
                            },
                            {
                                "type": "link",
                                "url": "http://algebrite.org",
                                "text": "symbolic way"
                            },
                            {
                                "type": "text",
                                "text": " ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/davidedc/Algebrite#references",
                                "text": "see also"
                            },
                            {
                                "type": "text",
                                "text": "). There were a bunch of libraries I came across, but I didn't end up saving links to them because I never found one that fit my performance needs (ie: perfect precision with relatively constant execution time that handles the accumulation of millions of operations)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "1ea7c71f-0b8d-418c-8941-f564eca05c4f",
        "type": "message",
        "text": "I haven't been looking at FOC stuff for a while, so asking this if anyone can give some advice:\nWhat are the best implementations of interactive UI usage of OOP interfaces? for example I'd envision seeing an object as a box containing a list of methods (and other objects it contains, also as boxes), and being able to click on a method, and having it expand to give me places to drag and drop other objects in, and then turning into another box representing the object it returns.\n(Specifically I'm interested in making such an interactive UI for an advanced low-level OS interface I've created, mostly as a way to teach the interface)",
        "user": "UK500AGQ4",
        "ts": "1591889749.164700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CmO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven't been looking at FOC stuff for a while, so asking this if anyone can give some advice:\nWhat are the best implementations of interactive UI usage of OOP interfaces? for example I'd envision seeing an object as a box containing a list of methods (and other objects it contains, also as boxes), and being able to click on a method, and having it expand to give me places to drag and drop other objects in, and then turning into another box representing the object it returns.\n(Specifically I'm interested in making such an interactive UI for an advanced low-level OS interface I've created, mostly as a way to teach the interface)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591889749.164700",
        "reply_count": 4,
        "reply_users_count": 4,
        "latest_reply": "1592052924.251600",
        "reply_users": [
            "UC2A2ARPT",
            "UAVCC2X70",
            "UK500AGQ4",
            "UHWC9PXBL"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UC2A2ARPT",
                    "UHWC9PXBL"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "1f067276-69b2-4b7e-9498-0cb980aeb4cb",
        "type": "message",
        "text": "<@UCGAK10LS> If I understand correctly what you are looking for, it's impossible. The very principle of floating-point arithmetic is to make the precision part of the storage format for each number, in order to ensure a constant storage size, no matter which operations you do. If you are OK with indefinite storage size, as for big integers, then go for rational numbers.\n\nSomething that many people don't realize is that floats a _subset_ of rationals with fixed storage size. Perhaps it's because so many languages call them \"reals\" that so many people think floats are a _superset_ of rationals, whereas reality is the exact opposite.\n\nIf what you want is a superset of rationals, go for computable numbers (the subject of Alan Turing's famous paper that introduced the Turing machines). A number is then represented by a procedure that you call with the requested precision. But this is rarely what you really want, once you understand all the consequences, for example the impossibility to test for equality.",
        "user": "UJBAJNFLK",
        "ts": "1591891350.165000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "67WMb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " If I understand correctly what you are looking for, it's impossible. The very principle of floating-point arithmetic is to make the precision part of the storage format for each number, in order to ensure a constant storage size, no matter which operations you do. If you are OK with indefinite storage size, as for big integers, then go for rational numbers.\n\nSomething that many people don't realize is that floats a "
                            },
                            {
                                "type": "text",
                                "text": "subset",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of rationals with fixed storage size. Perhaps it's because so many languages call them \"reals\" that so many people think floats are a "
                            },
                            {
                                "type": "text",
                                "text": "superset",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of rationals, whereas reality is the exact opposite.\n\nIf what you want is a superset of rationals, go for computable numbers (the subject of Alan Turing's famous paper that introduced the Turing machines). A number is then represented by a procedure that you call with the requested precision. But this is rarely what you really want, once you understand all the consequences, for example the impossibility to test for equality."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "6a779420-bda8-4fff-bbb9-dd8cd3675f74",
        "type": "message",
        "text": "I wonder if there's some solution that carries several representations, and is aware of their accuracy, so it can fall back to an expensive symbolic calculation if it knows the test is outside float accuracy.",
        "user": "UDQBTJ211",
        "ts": "1591891977.165200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kXn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if there's some solution that carries several representations, and is aware of their accuracy, so it can fall back to an expensive symbolic calculation if it knows the test is outside float accuracy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "090bc2f5-a4db-48a3-8a91-8c44093e2564",
        "type": "message",
        "text": "<@UCGAK10LS> the reason it doesn't exist is that not all numbers are representable in base 2 float, even with infinite precision. For example: 0.1 is 0.00011001100110011...2 (with the 0011 part repeating forever). So, you literally can't represent all numbers of even a finite base 10 decimal space without infinite precision. See this for a more detailed",
        "user": "U015902ESJC",
        "ts": "1591893143.165400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8H69d",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " the reason it doesn't exist is that not all numbers are representable in base 2 float, even with infinite precision. For example: 0.1 is 0.00011001100110011...2 (with the 0011 part repeating forever). So, you literally can't represent all numbers of even a finite base 10 decimal space without infinite precision. See this for a more detailed"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "28ba53f7-c318-40eb-8e01-1da8c0b038b6",
        "type": "message",
        "text": "Forgot the link: <https://softwareengineering.stackexchange.com/questions/237014/are-there-numbers-that-are-not-representable-in-base-10-but-can-be-represented-i>",
        "user": "U015902ESJC",
        "ts": "1591893164.165600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Software Engineering Stack Exchange",
                "title": "Are there numbers that are not representable in base 10 but can be represented in base 2?",
                "title_link": "https://softwareengineering.stackexchange.com/questions/237014/are-there-numbers-that-are-not-representable-in-base-10-but-can-be-represented-i",
                "text": "C# has the decimal type which is used for numbers that needs exact representation in base 10. For instance, 0.1 cannot be represented in base 2 (e.g. float and double) and will always be an approxi...",
                "fallback": "Software Engineering Stack Exchange: Are there numbers that are not representable in base 10 but can be represented in base 2?",
                "thumb_url": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
                "from_url": "https://softwareengineering.stackexchange.com/questions/237014/are-there-numbers-that-are-not-representable-in-base-10-but-can-be-represented-i",
                "thumb_width": 316,
                "thumb_height": 316,
                "service_icon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon.png?v=5e581fc45e58",
                "id": 1,
                "original_url": "https://softwareengineering.stackexchange.com/questions/237014/are-there-numbers-that-are-not-representable-in-base-10-but-can-be-represented-i"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XcUL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Forgot the link: "
                            },
                            {
                                "type": "link",
                                "url": "https://softwareengineering.stackexchange.com/questions/237014/are-there-numbers-that-are-not-representable-in-base-10-but-can-be-represented-i"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d86255a9-f6f7-41d6-b3a1-6800f553e262",
        "type": "message",
        "text": "Let's say you have the following code:\n```def do_it(x, y)\n  if x &gt; y\n   x = x + y\n  else\n   x = x - y\n  end\nend\n\nnumber_x = read_from_stdin\nnumber_y = read_from_stdin\ndo_it(number_x, number_y)```\nThis is completely arbitrary, of course, but at which location can you reliably know you can avoid overflow? Any code that takes input could be handed values which cause an overflow at some point right? If you are duplicating logic (i.e. you have a 32-bit version, 64-bit version and perhaps more) how do you know which one to use? The only way you can know if it will overflow is essentially by doing the mathematical operation, so checking which path to take is at least as complicated as just doing it, which means you just need to do it and check for overflows and extend/retry with the next size. I'm having a hard time seeing how static analysis helps here except in arbitrarily small cases where you can compute the entire possible result space and prove it and all intermediate values are less than x-bits. I'm not sure if static analysis of this kind can really be reduced below the complexity of the halting problem, which is an NP-hard problem.",
        "user": "U015902ESJC",
        "ts": "1591894992.166000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0Ra0u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let's say you have the following code:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "def do_it(x, y)\n  if x > y\n   x = x + y\n  else\n   x = x - y\n  end\nend\n\nnumber_x = read_from_stdin\nnumber_y = read_from_stdin\ndo_it(number_x, number_y)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis is completely arbitrary, of course, but at which location can you reliably know you can avoid overflow? Any code that takes input could be handed values which cause an overflow at some point right? If you are duplicating logic (i.e. you have a 32-bit version, 64-bit version and perhaps more) how do you know which one to use? The only way you can know if it will overflow is essentially by doing the mathematical operation, so checking which path to take is at least as complicated as just doing it, which means you just need to do it and check for overflows and extend/retry with the next size. I'm having a hard time seeing how static analysis helps here except in arbitrarily small cases where you can compute the entire possible result space and prove it and all intermediate values are less than x-bits. I'm not sure if static analysis of this kind can really be reduced below the complexity of the halting problem, which is an NP-hard problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1590977348.305600",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "648599f3-a255-42cd-9fd9-bf4f357893b4",
        "type": "message",
        "text": "there\u2019s systems like Common Lisp that support arbitrary-sized rational numbers, any rational can be stored as a fraction of (bigint) / (bigint)",
        "user": "UETFVV24Q",
        "ts": "1591899671.166800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pLD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "there\u2019s systems like Common Lisp that support arbitrary-sized rational numbers, any rational can be stored as a fraction of (bigint) / (bigint)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "4ff6cfd5-d877-48b0-91f8-bf852850c4c6",
        "type": "message",
        "text": "I'll be streaming some WhiteBox (live code previsualizer/debugger) dev in a few mins, which you're very welcome to join.\nI'll be doing some bug fixes and working on some UI for status feedback.\u00a0<https://www.twitch.tv/azmreece>\nFeel free to join the streamed voice chat:\u00a0<https://discord.gg/xHgepxM>",
        "user": "UEDDR6L5Q",
        "ts": "1591901178.168200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEDDR6L5Q",
            "ts": "1591901185.000000"
        },
        "attachments": [
            {
                "service_name": "Twitch",
                "title": "azmreece - Twitch",
                "title_link": "https://www.twitch.tv/azmreece",
                "text": "azmreece streams live on Twitch! Check out their videos, sign up to chat, and join their community.",
                "fallback": "Twitch: azmreece - Twitch",
                "thumb_url": "https://static-cdn.jtvnw.net/jtv_user_pictures/4acc8bcb-8641-4937-9945-8cc7ede3542b-profile_image-300x300.png",
                "from_url": "https://www.twitch.tv/azmreece",
                "thumb_width": 300,
                "thumb_height": 300,
                "service_icon": "https://static.twitchcdn.net/assets/favicon-32-d6025c14e900565d6177.png",
                "id": 1,
                "original_url": "https://www.twitch.tv/azmreece"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "crWbn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'll be streaming some WhiteBox (live code previsualizer/debugger) dev in a few mins, which you're very welcome to join.\nI'll be doing some bug fixes and working on some UI for status feedback.\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://www.twitch.tv/azmreece"
                            },
                            {
                                "type": "text",
                                "text": "\nFeel free to join the streamed voice chat:\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://discord.gg/xHgepxM"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UFLN9JFRT",
                    "UGLSY9X3J"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "b15564a8-22cb-4158-9e34-0079b45eef53",
        "type": "message",
        "text": "there is an excellent youtube video and code sample by Crockford on the DEC64 floating point representation, which is far superior to stupid IEEE double precision format. It was a tragedy that the committee sought to save a few transistors and used  binary exponents.  Countless programs wrestle with this, and i believe it is one of the reasons COBOL still runs in many industries because COBOL for all its verbosity and ugliness contains BCD arithmetic in its syntax and computation model.",
        "user": "UEQ6M68H0",
        "ts": "1591905760.168500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1591905774.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qQ0CW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "there is an excellent youtube video and code sample by Crockford on the DEC64 floating point representation, which is far superior to stupid IEEE double precision format. It was a tragedy that the committee sought to save a few transistors and used  binary exponents.  Countless programs wrestle with this, and i believe it is one of the reasons COBOL still runs in many industries because COBOL for all its verbosity and ugliness contains BCD arithmetic in its syntax and computation model."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "911c4a95-48e8-4006-98b4-b95fc6ba33b9",
        "type": "message",
        "text": "And let's not forget mathematica, which as a symbolic language, will deliver whatever precision you wish to ask for. It is one of its \"superpowers\".",
        "user": "UEQ6M68H0",
        "ts": "1591905873.168800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1591905893.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J=J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And let's not forget mathematica, which as a symbolic language, will deliver whatever precision you wish to ask for. It is one of its \"superpowers\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "08afcd4b-9cf6-4d87-8628-d31c4891f0c1",
        "type": "message",
        "text": "<@UFB8STN7K> I finally finished the Morgan Ames paper you posted. Really fascinating. I have had a tangential awareness of Logo as this very evidence-based and well-tested pedagogical tool, and having that examined and criticized was very eye-opening. I\u2019ll definitely be seeking out more of ~his~ her research. It\u2019s really got me thinking about how much I have internalized the MIT ethos (had no idea it developed there), and view certain ways of using a computer as legitimate. Thanks for posting it :pray:",
        "user": "UKDM3GLAJ",
        "ts": "1591908052.169100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UKDM3GLAJ",
            "ts": "1591908398.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wUC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " I finally finished the Morgan Ames paper you posted. Really fascinating. I have had a tangential awareness of Logo as this very evidence-based and well-tested pedagogical tool, and having that examined and criticized was very eye-opening. I\u2019ll definitely be seeking out more of "
                            },
                            {
                                "type": "text",
                                "text": "his",
                                "style": {
                                    "strike": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " her research. It\u2019s really got me thinking about how much I have internalized the MIT ethos (had no idea it developed there), and view certain ways of using a computer as legitimate. Thanks for posting it "
                            },
                            {
                                "type": "emoji",
                                "name": "pray"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591498636.036100",
        "parent_user_id": "UFB8STN7K",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFB8STN7K",
                    "UA14TGLTC",
                    "UFLN9JFRT"
                ],
                "count": 3
            },
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "C96BCA30-A4B7-4F4C-8979-B35B29E9C35A",
        "type": "message",
        "text": "Pharo and Glamorous Toolkit are pretty good. I'm also fond of the approach you see in game engines like Unity.",
        "user": "UC2A2ARPT",
        "ts": "1591908329.170400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Gog",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Pharo and Glamorous Toolkit are pretty good. I'm also fond of the approach you see in game engines like Unity."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591889749.164700",
        "parent_user_id": "UK500AGQ4",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UDKTZSD6H",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "207A10A2-465E-4633-87BD-99CBD5B46566",
        "type": "message",
        "text": "Yeah, DEC64 is nice. Wish we had that in JS.",
        "user": "UC2A2ARPT",
        "ts": "1591908476.171600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1591908501.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PUE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, DEC64 is nice. Wish we had that in JS."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591869278.153800",
        "parent_user_id": "UCGAK10LS"
    }
]