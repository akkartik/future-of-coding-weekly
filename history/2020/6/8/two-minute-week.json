[
    {
        "client_msg_id": "669a65a6-1758-48d9-8f2a-c827d69c632e",
        "type": "message",
        "text": "Progress on supporting a subset of Markdown in my text-mode paginator, and how programming languages can use modules without explicitly importing them.\n\n<https://archive.org/details/akkartik-2min-2020-06-07>",
        "user": "UCUSW7WVD",
        "ts": "1591570004.468100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Internet Archive",
                "title": "2020-06-07: Stop specifying modules : Kartik Agaram : Free Download, Borrow, and Streaming : Internet Archive",
                "title_link": "https://archive.org/details/akkartik-2min-2020-06-07",
                "text": "2-minute video of the Mu project for the Future of Coding forum (<https://futureofcoding.org>)",
                "fallback": "Internet Archive: 2020-06-07: Stop specifying modules : Kartik Agaram : Free Download, Borrow, and Streaming : Internet Archive",
                "thumb_url": "https://archive.org/download/akkartik-2min-2020-06-07/akkartik-2min-2020-06-07.thumbs/akkartik-2min-2020-06-07_000005.jpg",
                "video_html_width": 818,
                "video_html_height": 480,
                "video_url": "https://archive.org/download/akkartik-2min-2020-06-07/akkartik-2min-2020-06-07.mp4",
                "from_url": "https://archive.org/details/akkartik-2min-2020-06-07",
                "thumb_width": 720,
                "thumb_height": 422,
                "service_icon": "https://archive.org/favicon.ico",
                "id": 1,
                "original_url": "https://archive.org/details/akkartik-2min-2020-06-07"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0sO3c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Progress on supporting a subset of Markdown in my text-mode paginator, and how programming languages can use modules without explicitly importing them.\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://archive.org/details/akkartik-2min-2020-06-07"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591570004.468100",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1591631974.472100",
        "reply_users": [
            "U5STGTB3J",
            "UCUSW7WVD"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "bulb",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2608FEFD-450A-4212-AA32-3A316370C51D",
        "type": "message",
        "text": "The algorithm you use to determine the types is interesting. Did you come up with that yourself? Or do you have any pointers to what inspired you?\n\nI\u2018m also curious how you settled on Markdown parsing for the demo? I\u2018m strangely attracted to Markdown for a prototype as well.",
        "user": "U5STGTB3J",
        "ts": "1591622169.471500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VJC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The algorithm you use to determine the types is interesting. Did you come up with that yourself? Or do you have any pointers to what inspired you?\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "I\u2018m also curious how you settled on Markdown parsing for the demo? I\u2018m strangely attracted to Markdown for a prototype as well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591570004.468100",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "8f6d42b0-7468-498f-a73a-08d7fd211230",
        "type": "message",
        "text": "I'm basically noodling on what a simpler world wide web looks like, where we only use browsers for reading and hyperlinking, not for web apps. The only reason there was a demand for sandboxed web apps historically was that native apps on PCs had so thoroughly polluted the well for users. But in a world where apps are always distributed with source and there's a culture of calling folks out for dark patterns, you don't need the web to run apps anymore.\n\nMy ideas here are a lot less well-formed than for the foundations of Mu, so I'm extremely open to suggestions. Markdown's just the first syntax I tried to avoid designing a 15th standard. Though I'm already seeing crap I'm never going to support, like this:\n\n```This is *emphasized\n# text.* Or is it?```\nThings are simpler if I require headings to always start a new paragraph.\n\n---\n\nI came up with the algorithm myself, but it felt like a fairly straightforward multi-pass compiler design. The only minor issue was the chicken-and-egg problem of needing sizes to compute field offsets, and needing field offsets to compute sizes. I'm not well-versed with the theory of Algorithms so I can't cite good keywords here. But I think a lot of people would be able to come up with it after completing a grad course in compilers. Once the problem was framed.",
        "user": "UCUSW7WVD",
        "ts": "1591627376.471700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1591627514.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CUa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm basically noodling on what a simpler world wide web looks like, where we only use browsers for reading and hyperlinking, not for web apps. The only reason there was a demand for sandboxed web apps historically was that native apps on PCs had so thoroughly polluted the well for users. But in a world where apps are always distributed with source and there's a culture of calling folks out for dark patterns, you don't need the web to run apps anymore.\n\nMy ideas here are a lot less well-formed than for the foundations of Mu, so I'm extremely open to suggestions. Markdown's just the first syntax I tried to avoid designing a 15th standard. Though I'm already seeing crap I'm never going to support, like this:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is *emphasized\n# text.* Or is it?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Things are simpler if I require headings to always start a new paragraph.\n\n---\n\nI came up with the algorithm myself, but it felt like a fairly straightforward multi-pass compiler design. The only minor issue was the chicken-and-egg problem of needing sizes to compute field offsets, and needing field offsets to compute sizes. I'm not well-versed with the theory of Algorithms so I can't cite good keywords here. But I think a lot of people would be able to come up with it after completing a grad course in compilers. Once the problem was framed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591570004.468100",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "72f08d58-66ec-48d9-8ce1-f0d9aee6a2ec",
        "type": "message",
        "text": "Yeah, there are some weird edge cases in Markdown. I'm all for a simpler standard and would be happy to break backwards compatibility, getting rid of some of those weird edge cases. Complexity of implementation is particularly important for standards where we hope to see many implementations, but hardly ever considered.\n\nWe learn so much from implementing a thing, but we tend to only practice additive design, cramming more things into it over time. Maybe that is the nature of things. At some point more people feel that the old thing is now bloated and that opens the door for another, better designed, simpler thing to take over. Somewhat the story of Mu, I guess\u2026 ;)",
        "user": "U5STGTB3J",
        "ts": "1591631974.472100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rHkzN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, there are some weird edge cases in Markdown. I'm all for a simpler standard and would be happy to break backwards compatibility, getting rid of some of those weird edge cases. Complexity of implementation is particularly important for standards where we hope to see many implementations, but hardly ever considered.\n\nWe learn so much from implementing a thing, but we tend to only practice additive design, cramming more things into it over time. Maybe that is the nature of things. At some point more people feel that the old thing is now bloated and that opens the door for another, better designed, simpler thing to take over. Somewhat the story of Mu, I guess\u2026 ;)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1591570004.468100",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    }
]