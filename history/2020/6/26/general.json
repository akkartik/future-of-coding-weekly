[
    {
        "client_msg_id": "4a87e09f-84df-4b8c-a983-5d28cd55b575",
        "type": "message",
        "text": "Heh, I was just looking at PEP 622. First I was excited, then thought it's very messy and confusing. There's a new 'pattern grammar' which doesn't quite look or work like usual Python. Maybe it will make sense to me at some point.",
        "user": "U8A5MS6R1",
        "ts": "1593123372.474700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/Ny",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Heh, I was just looking at PEP 622. First I was excited, then thought it's very messy and confusing. There's a new 'pattern grammar' which doesn't quite look or work like usual Python. Maybe it will make sense to me at some point."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "3322d4c9-e098-4908-962d-d7eade8dd4ef",
        "type": "message",
        "text": "It's not exactly like PEG. It's a language feature that lets you match objects against a pattern and *also* extract some matched parts into variables.",
        "user": "U8A5MS6R1",
        "ts": "1593123446.474900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3zRs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's not exactly like PEG. It's a language feature that lets you match objects against a pattern and "
                            },
                            {
                                "type": "text",
                                "text": "also",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " extract some matched parts into variables."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "4c28f66c-6c45-4eca-b013-e09caab4b5f3",
        "type": "message",
        "text": "So PEGs (and regexes) are matchers for _text_. This is a built in language syntax to make a matcher for _object trees_, if that makes any sense.",
        "user": "U8A5MS6R1",
        "ts": "1593123683.475100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nvxG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So PEGs (and regexes) are matchers for "
                            },
                            {
                                "type": "text",
                                "text": "text",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". This is a built in language syntax to make a matcher for "
                            },
                            {
                                "type": "text",
                                "text": "object trees",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", if that makes any sense."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "type": "message",
        "text": "My goal is to hybridize a few tried-and-true styles of visual programming. I'm starting simple with something in the ballpark of patch based or block based programming, although I'm not being very disciplined about fitting myself into an existing category.\n\nAttached is a mock up I've been using as reference material for the last few weeks.\n\nMy plan is to draw the entire layout, then progressively replace variable references with arrows. I don't want the arrows to ever cross. The idea is to use a jump if two lines would ever have to cross, like you see with 'constant z' and 'ref z' (although its not a realistic example because you could easily draw a line to replace the ref).",
        "files": [
            {
                "id": "F01634YQ1K5",
                "created": 1593124292,
                "timestamp": 1593124292,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U01448TH3PG",
                "editable": false,
                "size": 1217234,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F01634YQ1K5/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F01634YQ1K5/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 237,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 315,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 473,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 526,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 631,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F01634YQ1K5-cf6268c39c/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 673,
                "original_w": 2828,
                "original_h": 1858,
                "thumb_tiny": "AwAfADDSamkgHGace1MYfN0FJgOz9aM/Wm55xmgnnqKVwFLAHHNOB60DpQO9NAB7UhUE5I5pTSbhQwEPAzjmmgkkZUCncetHHqaBWHDpQO9IDjvSr60IZ//Z",
                "permalink": "https://futureofcoding.slack.com/files/U01448TH3PG/F01634YQ1K5/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F01634YQ1K5-1420a5e898",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RZWa5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My goal is to hybridize a few tried-and-true styles of visual programming. I'm starting simple with something in the ballpark of patch based or block based programming, although I'm not being very disciplined about fitting myself into an existing category.\n\nAttached is a mock up I've been using as reference material for the last few weeks.\n\nMy plan is to draw the entire layout, then progressively replace variable references with arrows. I don't want the arrows to ever cross. The idea is to use a jump if two lines would ever have to cross, like you see with 'constant z' and 'ref z' (although its not a realistic example because you could easily draw a line to replace the ref)."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "U01448TH3PG",
        "display_as_bot": false,
        "ts": "1593125067.475300",
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UP28ETUSE"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ec2bf877-f19a-4911-8f41-f1a2a9e82f6c",
        "type": "message",
        "text": "I think drawing any single arrow is easy (it should just be pathfinding), but drawing the arrows in aggregate can become hard or impossible as they begin to cut each other off. Potentially being able to re-order blocks to prevent wires from overlapping also introduces a feedback loop between drawing wires and laying out blocks that smells tricky.\n\nBy allows 'ref's I always give myself an out, but I'd rather show as many arrows as possible, for clarity's sake.",
        "user": "U01448TH3PG",
        "ts": "1593125353.475700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "m/D6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think drawing any single arrow is easy (it should just be pathfinding), but drawing the arrows in aggregate can become hard or impossible as they begin to cut each other off. Potentially being able to re-order blocks to prevent wires from overlapping also introduces a feedback loop between drawing wires and laying out blocks that smells tricky.\n\nBy allows 'ref's I always give myself an out, but I'd rather show as many arrows as possible, for clarity's sake."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG"
    },
    {
        "client_msg_id": "186aad51-02e7-4ee9-8570-bd814d12126b",
        "type": "message",
        "text": "Yeah, this sounds amenable to a progressive refinement / iterative approximation approach. You could even make it somewhat interactive, where the programmer can put edges _roughly_ where they want them, and then the system can sort of _tidy up_ the layout.\n\nOf course, with these sorts of approaches, you usually have to give up determinism, and naive implementations can be quite slow. You can probably do better than NP, though, since you can take advantage of spatial locality, just like collision detection systems in games.",
        "user": "UC2A2ARPT",
        "ts": "1593125484.475900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1593125828.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aPbnS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, this sounds amenable to a progressive refinement / iterative approximation approach. You could even make it somewhat interactive, where the programmer can put edges "
                            },
                            {
                                "type": "text",
                                "text": "roughly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " where they want them, and then the system can sort of "
                            },
                            {
                                "type": "text",
                                "text": "tidy up",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the layout.\n\nOf course, with these sorts of approaches, you usually have to give up determinism, and naive implementations can be quite slow. You can probably do better than NP, though, since you can take advantage of spatial locality, just like collision detection systems in games."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG"
    },
    {
        "client_msg_id": "dac6b2cf-eab0-45b0-839e-7966ffb45018",
        "type": "message",
        "text": "(I'm personally of the total opposite opinion \u2014 that the programmer should have total manual control over the layout of their graph \u2014\u00a0so I don't have a good collection of references for ways that people have handled auto-layout. Others here might.)",
        "user": "UC2A2ARPT",
        "ts": "1593125801.476300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1uk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(I'm personally of the total opposite opinion \u2014 that the programmer should have total manual control over the layout of their graph \u2014\u00a0so I don't have a good collection of references for ways that people have handled auto-layout. Others here might.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG"
    },
    {
        "client_msg_id": "64d83d9b-4d4e-4499-b635-b44fa7dec5e5",
        "type": "message",
        "text": "I've been thinking of formatting like linting in a text based langauge, so what you're saying makes total sense to me. In addition to locality, I'm _hoping_ good code hygiene will encourage fairly clean wires.",
        "user": "U01448TH3PG",
        "ts": "1593125981.476600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AUg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been thinking of formatting like linting in a text based langauge, so what you're saying makes total sense to me. In addition to locality, I'm "
                            },
                            {
                                "type": "text",
                                "text": "hoping",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " good code hygiene will encourage fairly clean wires."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9a0d561c-55b6-43b0-a460-9872098bb743",
        "type": "message",
        "text": "My dream is to support pluggable editors so users can view each block in their program in a different way. So, you could have most of your code automatically laid out, but the inside of your loop manually laid out or in a text editor. The dream is that each library would provide an editor that made sense for its contents. So, if you make a spreadsheet library, you would provide an editor that lets you manipulate the content of the spreadsheet, and if you write a GUI library, you provide a wysiwig widget editor.\n\nI though this editor was a fun place to start, though.",
        "user": "U01448TH3PG",
        "ts": "1593126563.476900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EEE9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My dream is to support pluggable editors so users can view each block in their program in a different way. So, you could have most of your code automatically laid out, but the inside of your loop manually laid out or in a text editor. The dream is that each library would provide an editor that made sense for its contents. So, if you make a spreadsheet library, you would provide an editor that lets you manipulate the content of the spreadsheet, and if you write a GUI library, you provide a wysiwig widget editor.\n\nI though this editor was a fun place to start, though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5252949a-e3c5-44e0-bed0-58d1b9a65206",
        "type": "message",
        "text": "Oh! I forgot to ask, what is it that you like about manually laying out patch based code? Do you have a particular example of an environment where that's a satisfying experience?",
        "user": "U01448TH3PG",
        "ts": "1593128014.477200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y7J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh! I forgot to ask, what is it that you like about manually laying out patch based code? Do you have a particular example of an environment where that's a satisfying experience?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG"
    },
    {
        "client_msg_id": "69b8af5b-96d6-49e3-94ff-38dcbd7dc54c",
        "type": "message",
        "text": "<@U8A5MS6R1> I'm curious, what makes you say \"doesn't quite look or work like usual Python\"?",
        "user": "UP28ETUSE",
        "ts": "1593152028.477700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP28ETUSE",
            "ts": "1593152034.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JULC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " I'm curious, what makes you say \"doesn't quite look or work like usual Python\"?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "90f46168-eaae-4496-a6c3-203feee7d086",
        "type": "message",
        "text": "Hehe do we really want to get into PEP 622 here? Mainly it's because the meaning of whatever follows `case` is surprising if you know Python. It's not regular Python, it looks regular but is designed to work as a structure matching (and name binding language). Consider:\n`case 123:` - matches the value 123. so far so good\n\n`abc = 123`\n`case abc:` - matches 123? No, it matches _any_ value because `abc` is a name pattern (will capture any value). What if you really wanted to match the value in the variable `abc`? Well now there's a brand new syntax (which only works inside case): `case .abc`.\n\nThen there's the class patterns, which look like calls but actually *capture* values from an existing structure:\n`case Point(x, y)` - creates/sets x and y, if the object is a Point.\n\nAnyway the PEP is still being worked on so lets see what it looks like eventually.",
        "user": "U8A5MS6R1",
        "ts": "1593154751.478000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Woauq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hehe do we really want to get into PEP 622 here? Mainly it's because the meaning of whatever follows "
                            },
                            {
                                "type": "text",
                                "text": "case",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is surprising if you know Python. It's not regular Python, it looks regular but is designed to work as a structure matching (and name binding language). Consider:\n"
                            },
                            {
                                "type": "text",
                                "text": "case 123:",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - matches the value 123. so far so good\n\n"
                            },
                            {
                                "type": "text",
                                "text": "abc = 123",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "case abc:",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - matches 123? No, it matches "
                            },
                            {
                                "type": "text",
                                "text": "any",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " value because "
                            },
                            {
                                "type": "text",
                                "text": "abc",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a name pattern (will capture any value). What if you really wanted to match the value in the variable "
                            },
                            {
                                "type": "text",
                                "text": "abc",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? Well now there's a brand new syntax (which only works inside case): "
                            },
                            {
                                "type": "text",
                                "text": "case .abc",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nThen there's the class patterns, which look like calls but actually "
                            },
                            {
                                "type": "text",
                                "text": "capture",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " values from an existing structure:\n"
                            },
                            {
                                "type": "text",
                                "text": "case Point(x, y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - creates/sets x and y, if the object is a Point.\n\nAnyway the PEP is still being worked on so lets see what it looks like eventually."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "81f14104-eaa1-462b-a913-b6886ec0a081",
        "type": "message",
        "text": "Thanks for going into the details. I don't want to hijack this Slack/thread with programming language minutia, but I'm a PL nerd so I'm always curious to see what new features there are in various languages.\n\nI'm writing Scala for my day job and I've also used Haskell, Standard ML and Erlang for personal projects. They all have pattern matching constructs and pretty much all of them expose the same set of features you're talking about, with slight variations of course. From this point of view, at least, this PEP follows \"industry standards\".",
        "user": "UP28ETUSE",
        "ts": "1593156847.478300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP28ETUSE",
            "ts": "1593156858.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CMQNa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for going into the details. I don't want to hijack this Slack/thread with programming language minutia, but I'm a PL nerd so I'm always curious to see what new features there are in various languages.\n\nI'm writing Scala for my day job and I've also used Haskell, Standard ML and Erlang for personal projects. They all have pattern matching constructs and pretty much all of them expose the same set of features you're talking about, with slight variations of course. From this point of view, at least, this PEP follows \"industry standards\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UKP3B2J5D"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dc2951fa-9296-4989-b27d-85f352197ec6",
        "type": "message",
        "text": "This type of complex domain specific language with all of its tricks and traps is probably a mistake. For those rare instances when it would be used, you have now added 50 pages in the reference manual to explain all the subtleties. This type of feature is exactly the kind of thing Guido was constantly refusing to add. Now that he has left his position as BDFL, the complexification committee will take care of ruining Python. That's okay, i designed my Beads language as the evolution of Python by simplification, it can only help me.",
        "user": "UEQ6M68H0",
        "ts": "1593157374.478600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1593157474.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bxM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This type of complex domain specific language with all of its tricks and traps is probably a mistake. For those rare instances when it would be used, you have now added 50 pages in the reference manual to explain all the subtleties. This type of feature is exactly the kind of thing Guido was constantly refusing to add. Now that he has left his position as BDFL, the complexification committee will take care of ruining Python. That's okay, i designed my Beads language as the evolution of Python by simplification, it can only help me."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "4e8ceafa-241c-4919-8627-db0421b26c44",
        "type": "message",
        "text": "If anything, this feature is in general abused, rather than seldomly used. I quite like it to be honest, but I find it more useful in a language with static typing.",
        "user": "UP28ETUSE",
        "ts": "1593158757.478900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bEn4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If anything, this feature is in general abused, rather than seldomly used. I quite like it to be honest, but I find it more useful in a language with static typing."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "ff9a1ea4-cfdf-4800-8065-73515a02c2f0",
        "type": "message",
        "text": "Strangely, Guido is one of the PEP authors :smile: Also there is resistance to the PEP from some core Python folk, so lets see where this goes.\n\nI like the idea of pattern matching too. Having it from the start in a language means other features were designed with it in mind. In Python it is being added later so it's going to be more complex to make it seem to fit. Consider the `except E as e` syntax - it's already kind of a pattern match using just isinstance. Would we not want matching to work identically in that syntax as well? IIRC you can have destructuring assignment in Erlang and put constants on the left, roughly `\"red\", a = f()` - this only matches and binds iff f() returns \"red\" as the first item in a pair. There's no such thing in Python, but you can have only free variables on the left that always get bound. Should that also work now, given the unpacking pattern can use `case [\"red\", a]` ?",
        "user": "U8A5MS6R1",
        "ts": "1593159488.479100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IcJxm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Strangely, Guido is one of the PEP authors "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " Also there is resistance to the PEP from some core Python folk, so lets see where this goes.\n\nI like the idea of pattern matching too. Having it from the start in a language means other features were designed with it in mind. In Python it is being added later so it's going to be more complex to make it seem to fit. Consider the "
                            },
                            {
                                "type": "text",
                                "text": "except E as e",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " syntax - it's already kind of a pattern match using just isinstance. Would we not want matching to work identically in that syntax as well? IIRC you can have destructuring assignment in Erlang and put constants on the left, roughly "
                            },
                            {
                                "type": "text",
                                "text": "\"red\", a = f()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - this only matches and binds iff f() returns \"red\" as the first item in a pair. There's no such thing in Python, but you can have only free variables on the left that always get bound. Should that also work now, given the unpacking pattern can use "
                            },
                            {
                                "type": "text",
                                "text": "case [\"red\", a]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UKP3B2J5D"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7f19199e-0f66-48ce-8cad-c15ea868f383",
        "type": "message",
        "text": "My first impression is much like <@U8A5MS6R1>'s: this is going to add a lot of complexity to Python, and is likely to become a nightmare for Python teachers. To add a criticism to <@U8A5MS6R1>'s list: `Point(x, y)` not only looks like a constructor but isn't, it also interprets arguments in a different way from a constructor. Sure, one would expect Python programmers to ensure that a class' `__init__` and `__match__` are semantically compatible, but I bet we will see many classes whose `__init__` allows more variations than `__match__` . And I also bet that people will try to use `class(**args)` as a pattern and expect `class` to be bound to the class object.",
        "user": "UJBAJNFLK",
        "ts": "1593174608.479600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M7i",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My first impression is much like "
                            },
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": "'s: this is going to add a lot of complexity to Python, and is likely to become a nightmare for Python teachers. To add a criticism to "
                            },
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": "'s list: "
                            },
                            {
                                "type": "text",
                                "text": "Point(x, y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " not only looks like a constructor but isn't, it also interprets arguments in a different way from a constructor. Sure, one would expect Python programmers to ensure that a class' "
                            },
                            {
                                "type": "text",
                                "text": "_",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "init",
                                "style": {
                                    "italic": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "_",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "__match__",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " are semantically compatible, but I bet we will see many classes whose "
                            },
                            {
                                "type": "text",
                                "text": "_",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "init",
                                "style": {
                                    "italic": true,
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "_",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " allows more variations than "
                            },
                            {
                                "type": "text",
                                "text": "__match__",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " . And I also bet that people will try to use "
                            },
                            {
                                "type": "text",
                                "text": "class(**args)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as a pattern and expect "
                            },
                            {
                                "type": "text",
                                "text": "class",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to be bound to the class object."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "32a7e6fc-4fcb-4f26-a8c8-f978b9a8fed4",
        "type": "message",
        "text": "Luna is now called Enso and they are starting from scratch: <https://medium.com/@enso_org/enso-dev-blog-19th-june-2020-335e528d50b>",
        "user": "UBN9AFS0N",
        "ts": "1593176908.480100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1593176952.000000"
        },
        "attachments": [
            {
                "service_name": "Medium",
                "title": "Enso Dev Blog\u200a\u2014\u200a19th June 2020",
                "title_link": "https://medium.com/@enso_org/enso-dev-blog-19th-june-2020-335e528d50b",
                "text": "Welcome to the inaugural Enso devblog. In this series, we will share the latest updates from the development of Enso (formerly Luna), a\u2026",
                "fallback": "Medium: Enso Dev Blog\u200a\u2014\u200a19th June 2020",
                "image_url": "https://miro.medium.com/freeze/max/1000/1*35kALPUkwLyNIEtAwwbRYA.gif",
                "fields": [
                    {
                        "title": "Reading time",
                        "value": "7 min read",
                        "short": true
                    }
                ],
                "ts": 1593176324,
                "from_url": "https://medium.com/@enso_org/enso-dev-blog-19th-june-2020-335e528d50b",
                "image_width": 500,
                "image_height": 250,
                "image_bytes": 20416,
                "service_icon": "https://cdn-images-1.medium.com/fit/c/152/152/1*8I-HPL0bfoIzGied-dzOvA.png",
                "id": 1,
                "original_url": "https://medium.com/@enso_org/enso-dev-blog-19th-june-2020-335e528d50b"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H920",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Luna is now called Enso and they are starting from scratch: "
                            },
                            {
                                "type": "link",
                                "url": "https://medium.com/@enso_org/enso-dev-blog-19th-june-2020-335e528d50b"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "reply_count": 8,
        "reply_users_count": 4,
        "latest_reply": "1593221097.494800",
        "reply_users": [
            "UP28ETUSE",
            "UC2A2ARPT",
            "UBN9AFS0N",
            "UEQ6M68H0"
        ],
        "subscribed": true,
        "last_read": "1593221097.494800"
    },
    {
        "client_msg_id": "53f1749a-d047-4cf4-8544-ec4e8c3aa425",
        "type": "message",
        "text": "Not to be confused with another Enso, which seems dead now: <http://enso-lang.org/> They seem to share the etymology, though.",
        "user": "UP28ETUSE",
        "ts": "1593177089.480400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP28ETUSE",
            "ts": "1593177104.000000"
        },
        "attachments": [
            {
                "title": "Enso",
                "title_link": "http://enso-lang.org/",
                "text": "Your description goes here",
                "fallback": "Enso",
                "from_url": "http://enso-lang.org/",
                "service_name": "enso-lang.org",
                "id": 1,
                "original_url": "http://enso-lang.org/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yz/gf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not to be confused with another Enso, which seems dead now: "
                            },
                            {
                                "type": "link",
                                "url": "http://enso-lang.org/"
                            },
                            {
                                "type": "text",
                                "text": " They seem to share the etymology, though."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "436c06ef-5883-400d-bd01-833553227a56",
        "type": "message",
        "text": "<@UC2A2ARPT> ^^ ripe for innovation. I do :100: agree that current voice interfaces are disappointing. This is perfect, just where I personally want them.",
        "user": "UJKKBAMLL",
        "ts": "1593179045.480800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJKKBAMLL",
            "ts": "1593179133.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q48Wa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " ^^ ripe for innovation. I do "
                            },
                            {
                                "type": "emoji",
                                "name": "100"
                            },
                            {
                                "type": "text",
                                "text": " agree that current voice interfaces are disappointing. This is perfect, just where I personally want them."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593073685.439700",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "341F4D25-1181-404C-BFE6-565795B993E3",
        "type": "message",
        "text": "&gt; For example, the GUI was slow, based on SVGs, and integrated with the Atom editor. It would be difficult, if not impossible, to get the performance we wanted building on that foundation.\n&gt; \nThis feels like a dodge. You can do wickedly complex stuff with SVG and maintain buttery 60. So I'm thinking this has more to do with their architecture (building on Atom instead of just Electron?) than the underlying tech.",
        "user": "UC2A2ARPT",
        "ts": "1593181592.483800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4hNCB",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example, the GUI was slow, based on SVGs, and integrated with the Atom editor. It would be difficult, if not impossible, to get the performance we wanted building on that foundation.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThis feels like a dodge. You can do wickedly complex stuff with SVG and maintain buttery 60. So I'm thinking this has more to do with their architecture (building on Atom instead of just Electron?) than the underlying tech."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "e730d33b-6b4b-4016-a78b-d52b02fb048b",
        "type": "message",
        "text": "<https://twitter.com/pcwalton/status/1266049915848777730>",
        "user": "UBN9AFS0N",
        "ts": "1593183742.485500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/pcwalton|@pcwalton>: Work-in-progress GL4/compute shader branch of Pathfinder brings the paris-30k.svg stress test (50,000 paths) from ~15 FPS to ~20 FPS on my MacBook Pro\u2019s Radeon Pro 560, while CPU time falls from 60 ms to 8 ms. More performance work to come :)",
                "ts": 1590684796,
                "author_name": "Patrick Walton",
                "author_link": "https://twitter.com/pcwalton/status/1266049915848777730",
                "author_icon": "https://pbs.twimg.com/profile_images/619088718/twitter-icon_normal.jpeg",
                "author_subname": "@pcwalton",
                "text": "Work-in-progress GL4/compute shader branch of Pathfinder brings the paris-30k.svg stress test (50,000 paths) from ~15 FPS to ~20 FPS on my MacBook Pro\u2019s Radeon Pro 560, while CPU time falls from 60 ms to 8 ms. More performance work to come :)",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/pcwalton/status/1266049915848777730",
                "id": 1,
                "original_url": "https://twitter.com/pcwalton/status/1266049915848777730",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "L3Aw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://twitter.com/pcwalton/status/1266049915848777730"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d81f5ee2-8849-4694-9b2f-e6e24913da44",
        "type": "message",
        "text": "<https://twitter.com/pcwalton/status/1250557429189763073>",
        "user": "UBN9AFS0N",
        "ts": "1593183802.485800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/pcwalton|@pcwalton>: Pathfinder (branch I'll push later today) rendering the MPVG paris-30k demo.\n\n(That CPU performance is improvable, I'm sure, though it's already fairly fast for 50K paths at max AA quality and likely a good bit of it is just the price I pay for GL3/WebGL compatibility.) <https://pbs.twimg.com/media/EVre4VTU0AEC7tY.jpg>",
                "ts": 1586991100,
                "author_name": "Patrick Walton",
                "author_link": "https://twitter.com/pcwalton/status/1250557429189763073",
                "author_icon": "https://pbs.twimg.com/profile_images/619088718/twitter-icon_normal.jpeg",
                "author_subname": "@pcwalton",
                "text": "Pathfinder (branch I'll push later today) rendering the MPVG paris-30k demo.\n\n(That CPU performance is improvable, I'm sure, though it's already fairly fast for 50K paths at max AA quality and likely a good bit of it is just the price I pay for GL3/WebGL compatibility.) <https://pbs.twimg.com/media/EVre4VTU0AEC7tY.jpg>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/pcwalton/status/1250557429189763073",
                "image_url": "https://pbs.twimg.com/media/EVre4VTU0AEC7tY.jpg",
                "image_width": 1182,
                "image_height": 1200,
                "image_bytes": 446341,
                "id": 1,
                "original_url": "https://twitter.com/pcwalton/status/1250557429189763073",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c5UtF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://twitter.com/pcwalton/status/1250557429189763073"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "7115bef9-6347-4beb-a4f1-a4728628c6ac",
        "type": "message",
        "text": "it will eventually ship on firefox",
        "user": "UBN9AFS0N",
        "ts": "1593183906.486100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fp2f7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "it will eventually ship on firefox"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "F2420519-8436-40E1-80A5-622815088330",
        "type": "message",
        "text": "Right, but that's a GPU SVG implementation. If you're making something that looks like Luna/Enso, you can go super fast just by being slightly clever about how you touch the DOM. No need for GPU, vdom, etc.\n\nAnyways, this is OT.\n\nFor Enso, I like the look of their UI for ports around the nodes. Hard to tell from the GIFs on my phone, but it looks like you can't see variable declarations in the graph, just in the text view. That feels like a weakness, but I'm sure they have a plan in mind. Glad to hear they'll be posting regular updates!",
        "user": "UC2A2ARPT",
        "ts": "1593188563.490900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WNX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Right, but that's a GPU SVG implementation. If you're making something that looks like Luna/Enso, you can go super fast just by being slightly clever about how you touch the DOM. No need for GPU, vdom, etc.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Anyways, this is OT.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "For Enso, I like the look of their UI for ports around the nodes. Hard to tell from the GIFs on my phone, but it looks like you can't see variable declarations in the graph, just in the text view. That feels like a weakness, but I'm sure they have a plan in mind. Glad to hear they'll be posting regular updates!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "e21184bf-b2dd-40da-854f-6784949b8510",
        "type": "message",
        "text": "I think a fundamental limitation is also you can only match over a key/value like structure. E.g. you can't match `case Regex('a.*b')` - the inner pattern is not sent to the class, but the class is supposed to return a 'static data field like' structure. So this also will cause problems if you have a few expensive computed properties - are you know supposed to generate and return all of them? What if the caller is only matching one?",
        "user": "U8A5MS6R1",
        "ts": "1593192337.491400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PX5xJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think a fundamental limitation is also you can only match over a key/value like structure. E.g. you can't match "
                            },
                            {
                                "type": "text",
                                "text": "case Regex('a.*b')",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - the inner pattern is not sent to the class, but the class is supposed to return a 'static data field like' structure. So this also will cause problems if you have a few expensive computed properties - are you know supposed to generate and return all of them? What if the caller is only matching one?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "236975FE-BCB2-4C4D-8188-7BE8769C0A4B",
        "type": "message",
        "text": "<https://twitter.com/enso_org/status/1276550780347179010|https://twitter.com/enso_org/status/1276550780347179010>",
        "user": "UC2A2ARPT",
        "ts": "1593193166.491800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1593208033.000000"
        },
        "attachments": [
            {
                "fallback": "<https://twitter.com/enso_org|@enso_org>: What do you want to hear about in the next devblog? <https://twitter.com/enso_org/status/1276492210293354497>",
                "ts": 1593188397,
                "author_name": "Enso (formerly Luna)",
                "author_link": "https://twitter.com/enso_org/status/1276550780347179010",
                "author_icon": "https://pbs.twimg.com/profile_images/1276175817400291335/zvrNeVit_normal.jpg",
                "author_subname": "@enso_org",
                "text": "What do you want to hear about in the next devblog? <https://twitter.com/enso_org/status/1276492210293354497>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/enso_org/status/1276550780347179010",
                "id": 1,
                "original_url": "https://twitter.com/enso_org/status/1276550780347179010",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MNF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://twitter.com/enso_org/status/1276550780347179010",
                                "text": "https://twitter.com/enso_org/status/1276550780347179010"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593176908.480100",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "f3202d55-edc3-4f95-9a55-89bc30a5e9ff",
        "type": "message",
        "text": "BTW, this discussion made me think of <https://dl.acm.org/doi/10.1145/1639949.1640133|this paper> which basically says that destructuring or pattern-matching objects makes no sense at all. TL;DR: Objects expose only their behavior (via methods), but not their internal data structures.",
        "user": "UJBAJNFLK",
        "ts": "1593195952.492100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qt=k",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "BTW, this discussion made me think of "
                            },
                            {
                                "type": "link",
                                "url": "https://dl.acm.org/doi/10.1145/1639949.1640133",
                                "text": "this paper"
                            },
                            {
                                "type": "text",
                                "text": " which basically says that destructuring or pattern-matching objects makes no sense at all. TL;DR: Objects expose only their behavior (via methods), but not their internal data structures."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "7ee69a4a-4522-45e5-a8cf-c7f431235f67",
        "type": "message",
        "text": "<@U8A5MS6R1> for your regex example, it might be possible to do something like:\n\n```pattern = Regex('a.*b')\nmatch 'aaaab':\n    case pattern(matched, capturingGroup1, etc): pass```\nRegarding your other point, about expensive computations, the PEP says this:\n\n&gt; There is no requirement that the attributes on the proxy object be the same type or value as the attributes of the original object; one envisioned use case is for expensive-to-compute properties to be computed lazily on the proxy object via property getters.\nAlso, your concerns about pattern matching for exceptions and assignments are well founded, but it seems to me that they can add these capabilities later.",
        "user": "UP28ETUSE",
        "ts": "1593201054.492300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP28ETUSE",
            "ts": "1593201557.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qmeP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " for your regex example, it might be possible to do something like:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "pattern = Regex('a.*b')\nmatch 'aaaab':\n    case pattern(matched, capturingGroup1, etc): pass"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Regarding your other point, about expensive computations, the PEP says this:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is no requirement that the attributes on the proxy object be the same type or value as the attributes of the original object; one envisioned use case is for expensive-to-compute properties to be computed lazily on the proxy object via property getters."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, your concerns about pattern matching for exceptions and assignments are well founded, but it seems to me that they can add these capabilities later."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "2521858a-0d33-4312-8c7d-dd7a92a34a8c",
        "type": "message",
        "text": "<@UJBAJNFLK> that's a good paper, but pattern matching does not preclude data abstraction, just as using lists and dictionaries does not preclude it. At some point we have to inspect data and patttern matching helps there. Without this, we'd have to ban `return` or `yield` and write our programs in a completely continuation-passing style, which would be quite hard to understand.\n\nI feel that once you'll be able to play with it, you'll like it more, unless you've already used pattern matching in some other language and decided it was a bad idea there.",
        "user": "UP28ETUSE",
        "ts": "1593201391.492500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP28ETUSE",
            "ts": "1593201524.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Khe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " that's a good paper, but pattern matching does not preclude data abstraction, just as using lists and dictionaries does not preclude it. At some point we have to inspect data and patttern matching helps there. Without this, we'd have to ban "
                            },
                            {
                                "type": "text",
                                "text": "return",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "yield",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and write our programs in a completely continuation-passing style, which would be quite hard to understand.\n\nI feel that once you'll be able to play with it, you'll like it more, unless you've already used pattern matching in some other language and decided it was a bad idea there."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "da9b7002-1017-4bce-acbd-98537da5a2de",
        "type": "message",
        "text": "<@UP28ETUSE> that seems quite a roundabout way to do regexes, consider if you had multiple cases, you wouldn't be able to write literal regexes inline and have to alias them via new variable names. The PEP also says `__match__`  should be a class or static method, so we'll be creating one class per regex.",
        "user": "U8A5MS6R1",
        "ts": "1593205285.493000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1593205317.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "E106",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP28ETUSE"
                            },
                            {
                                "type": "text",
                                "text": " that seems quite a roundabout way to do regexes, consider if you had multiple cases, you wouldn't be able to write literal regexes inline and have to alias them via new variable names. The PEP also says "
                            },
                            {
                                "type": "text",
                                "text": "__match__",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  should be a class or static method, so we'll be creating one class per regex."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "4005b3fd-1014-4bac-a75c-5dd2fb03eef0",
        "type": "message",
        "text": "May main issue though is the seeming arbitrary mixing of 'capture variables' (lvalues) and variables as references. E.g. `a = f()` is clear and `a.b = f()` kinda follows. But `case a` is totally different from `case a.b` - in the latter case it's a reference, the the former case `a` is a name to be bound.",
        "user": "U8A5MS6R1",
        "ts": "1593205414.493300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ITmh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "May main issue though is the seeming arbitrary mixing of 'capture variables' (lvalues) and variables as references. E.g. "
                            },
                            {
                                "type": "text",
                                "text": "a = f()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is clear and "
                            },
                            {
                                "type": "text",
                                "text": "a.b = f()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " kinda follows. But "
                            },
                            {
                                "type": "text",
                                "text": "case a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is totally different from "
                            },
                            {
                                "type": "text",
                                "text": "case a.b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - in the latter case it's a reference, the the former case "
                            },
                            {
                                "type": "text",
                                "text": "a",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is a name to be bound."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "364a36f4-aaa4-4c23-8710-dca13717ad4a",
        "type": "message",
        "text": "Honestly if all lvalues were tagged or separated, this would be much more acceptable to me. e.g. `case Point as x,y` or `case Point(?x, ?y)`",
        "user": "U8A5MS6R1",
        "ts": "1593205749.493500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jh+c",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Honestly if all lvalues were tagged or separated, this would be much more acceptable to me. e.g. "
                            },
                            {
                                "type": "text",
                                "text": "case Point as x,y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "case Point(?x, ?y)",
                                "style": {
                                    "code": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "79e93b7e-8a26-4673-b660-4e5d50197105",
        "type": "message",
        "text": "I guess you can tag the other case, although it's not enforced: `case .a.b` would work instead of `case a.b`. And I get your point, but on the other hand, the main purpose of pattern matching is to introduce new bindings, so the main use case should introduce as little syntax as possible, I think.",
        "user": "UP28ETUSE",
        "ts": "1593205893.493700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cVYQp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess you can tag the other case, although it's not enforced: "
                            },
                            {
                                "type": "text",
                                "text": "case .a.b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " would work instead of "
                            },
                            {
                                "type": "text",
                                "text": "case a.b",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". And I get your point, but on the other hand, the main purpose of pattern matching is to introduce new bindings, so the main use case should introduce as little syntax as possible, I think."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "87e5d19d-0e3c-4cd5-86ec-fb3f30d6c100",
        "type": "message",
        "text": "Also, regarding regexes. I haven't seen any language that supports both passing arguments and binding values in a pattern. That would be interesting.",
        "user": "UP28ETUSE",
        "ts": "1593205978.493900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "J7y8x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, regarding regexes. I haven't seen any language that supports both passing arguments and binding values in a pattern. That would be interesting."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    },
    {
        "client_msg_id": "ae791c61-9fc3-4c87-8303-273b49f1ae16",
        "type": "message",
        "text": "I'm used to graphics programs (2d and 3d), video editors, DAWs, and other environments where the arrangement of elements has an effect on the outcome. When it comes to code, I also prefer laying out my own code, rather than using a linter. I dislike the auto-layout feature of Max/MSP (though I think they could do a _ton_ to improve their GUI regardless).",
        "user": "UC2A2ARPT",
        "ts": "1593208251.494300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NU2f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm used to graphics programs (2d and 3d), video editors, DAWs, and other environments where the arrangement of elements has an effect on the outcome. When it comes to code, I also prefer laying out my own code, rather than using a linter. I dislike the auto-layout feature of Max/MSP (though I think they could do a "
                            },
                            {
                                "type": "text",
                                "text": "ton",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to improve their GUI regardless)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593105659.452700",
        "parent_user_id": "U01448TH3PG"
    },
    {
        "client_msg_id": "555fc964-1b2c-4413-816e-48fa92423523",
        "type": "message",
        "text": "I guess you could tag the other case.\n\nI also think these are warts: in places where both `x` and `x()` are valid, the `x` part means the same exact thing. But here one is a new name and one is a reference. What if I wanted to match a specific point at a known x,y? `case Point(x, y)` wont work, but I feel it should work, given I can do `case \"hello\"` and have the value match. Literals and predefined constants get special features here.",
        "user": "U8A5MS6R1",
        "ts": "1593208721.494500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ccg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess you could tag the other case.\n\nI also think these are warts: in places where both "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "x()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " are valid, the "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " part means the same exact thing. But here one is a new name and one is a reference. What if I wanted to match a specific point at a known x,y? "
                            },
                            {
                                "type": "text",
                                "text": "case Point(x, y)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " wont work, but I feel it should work, given I can do "
                            },
                            {
                                "type": "text",
                                "text": "case \"hello\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and have the value match. Literals and predefined constants get special features here."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1593119706.472200",
        "parent_user_id": "UES04SML7"
    }
]