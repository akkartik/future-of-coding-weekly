[
    {
        "client_msg_id": "25ff600e-8d7b-4d1b-a226-9d885f1afd11",
        "type": "message",
        "text": "I used to collect names of serialization formats (only reluctantly including RPC protocols, because I was young and didn't yet know true suffering*). So I have this urge to add all these links to my list, but also can't really get excited about them. After a while they all look the same.\n\nI think the rpc protocol that makes a difference will have to be one that makes it easy, or at least feasible, to bridge all these other formats, including the mucky legacy wire protocols. A couple other people here have expressed similar ideas.\n\nI do like the idea that the OSs job is to allow composing heterogeneous components. I think that fits in with the interop idea above.\n\n* Probably still true, honestly.",
        "user": "U016VUZGUUQ",
        "ts": "1606522068.161000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NVf5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I used to collect names of serialization formats (only reluctantly including RPC protocols, because I was young and didn't yet know true suffering*). So I have this urge to add all these links to my list, but also can't really get excited about them. After a while they all look the same.\n\nI think the rpc protocol that makes a difference will have to be one that makes it easy, or at least feasible, to bridge all these other formats, including the mucky legacy wire protocols. A couple other people here have expressed similar ideas.\n\nI do like the idea that the OSs job is to allow composing heterogeneous components. I think that fits in with the interop idea above.\n\n* Probably still true, honestly."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "grin",
                "users": [
                    "UN9SCH5RD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7054da02-8650-44d3-9796-9b2728a026ea",
        "type": "message",
        "text": "just came here from that podcast episode and wanted to check in if this were ever organized? :slightly_smiling_face:",
        "user": "U01EMHQHGC9",
        "ts": "1606549488.161600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MGV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "just came here from that podcast episode and wanted to check in if this were ever organized? "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1589072792.292000",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "781ba3d1-b251-47c1-bf3d-5b84160dc4a8",
        "type": "message",
        "text": "Are there languages where files are functions and imports are parameters?\n\nI am annoyed with file path issues when building typescript. When I try to build the same exact files with tsc, webpack, jest, or yarn, I get 4 different results.\n\nAre there any languages out there where a file is a function that takes parameters which are the paths to its imports? Where you don't include a file, but call it? Built-in dependency injection at the build level?\n\nie:\n\n\n`// main.foo`\n`printLib = printLib ?? \"a_default_value_for_print.foo_import\"`\n\n`printLib.print \"hello world\"`\n\n`// project.build`\n`main.foo(printLib = \"print.foo\")`",
        "user": "UMVFWPZ36",
        "ts": "1606580326.162400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UMVFWPZ36",
            "ts": "1606580985.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CPsx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there languages where files are functions and imports are parameters?\n\nI am annoyed with file path issues when building typescript. When I try to build the same exact files with tsc, webpack, jest, or yarn, I get 4 different results.\n\nAre there any languages out there where a file is a function that takes parameters which are the paths to its imports? Where you don't include a file, but call it? Built-in dependency injection at the build level?\n\nie:\n\n\n"
                            },
                            {
                                "type": "text",
                                "text": "// main.foo",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "printLib = printLib ?? \"a_default_value_for_print.foo_import\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "printLib.print \"hello world\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "// project.build",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "main.foo(printLib = \"print.foo\")",
                                "style": {
                                    "code": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1606591586.166000",
        "reply_users": [
            "U8A5MS6R1",
            "UMVFWPZ36"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "6e6de199-5575-47a9-b512-a5dc9cb4af0a",
        "type": "message",
        "text": "Newspeak\n\nThere is no import statement or hard linked external dependencies. Modules are just top level classes you instantiate and pass in the deps. See <https://bracha.org/newspeak-modules.pdf|https://bracha.org/newspeak-modules.pdf>\nand <https://gbracha.blogspot.com/2010/02/serialization-killer.html|https://gbracha.blogspot.com/2010/02/serialization-killer.html>",
        "user": "U8A5MS6R1",
        "ts": "1606582534.162700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Serialization Killer",
                "title_link": "https://gbracha.blogspot.com/2010/02/serialization-killer.html",
                "text": "Way back in October 2009 , I threatened to write a post about how serialization can serve as a binary format. The moment of reckoning has ar...",
                "fallback": "Serialization Killer",
                "from_url": "https://gbracha.blogspot.com/2010/02/serialization-killer.html",
                "service_icon": "https://gbracha.blogspot.com/favicon.ico",
                "service_name": "gbracha.blogspot.com",
                "id": 1,
                "original_url": "https://gbracha.blogspot.com/2010/02/serialization-killer.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/W9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Newspeak\n\nThere is no import statement or hard linked external dependencies. Modules are just top level classes you instantiate and pass in the deps. See "
                            },
                            {
                                "type": "link",
                                "url": "https://bracha.org/newspeak-modules.pdf",
                                "text": "https://bracha.org/newspeak-modules.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\nand "
                            },
                            {
                                "type": "link",
                                "url": "https://gbracha.blogspot.com/2010/02/serialization-killer.html",
                                "text": "https://gbracha.blogspot.com/2010/02/serialization-killer.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "U019CPED6T1"
                ],
                "count": 2
            },
            {
                "name": "clap",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "E6546697-C262-42BF-80E5-D5C55CA5D10C",
        "type": "message",
        "text": "infra includes a few interesting properties: a \u201cpatch\u201d datatype, which represents references to other infra data as well as immutable changes, using the same format as the rest of the data, and an editor that lets you make changes to data with mouse and keyboard and then outputs the changed data with a record in the form of patches",
        "user": "UHWC9PXBL",
        "ts": "1606586289.165500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Ofx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "infra includes a few interesting properties: a \u201cpatch\u201d datatype, which represents references to other infra data as well as immutable changes, using the same format as the rest of the data, and an editor that lets you make changes to data with mouse and keyboard and then outputs the changed data with a record in the form of patches"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3ab6b13c-f2e6-4127-a2be-2a86c1c6a09a",
        "type": "message",
        "text": "The relevant bits: \"Imports Code within a module must often make use of code defined by other modules. For example, ShapeLibrary requires utility classes such as List, defined by the standard collections library. In the absence of a global namespace, there is no way to refer to a class such as List directly. Instead, we have defined a slot named List inside ShapeLibrary. The slot declarations used in figure 2 differ slightly from our earlier examples. Here, slot initialization uses = rather than ::=. The use of = signifies that these are immutable slots, that will not be changed after they are initialized. No setter methods are generated for immutable slots, thus enforcing immutability. When ShapeLibrary is instantiated, it expects an object representing the underlying platform as an argument to its factory method usingPlatform:. This object will be the value of the factory method\u2019s formal parameter platform. During the initialization of the module, the slot List will be initialized via the expression platform collections List. This sends the message collections to platform, presumably returning an object representing an instance of the platform\u2019s collection library. This object then responds to the message List, returning the desired class. The class is stored in the slot, and is available to code within the module definition via the slot\u2019s getter method. The slot definition of List fills the role of an import statement, as do those of Error and Point. Note that the parameters to the factory method are only in scope within the instance initializer. The programmer must take explicit action to make (parts of) them available to the rest of the module. The preferred idiom is to extract individual classes and store them in slots, as shown here. It is then possible to determine the module\u2019s external dependencies at a glance, by looking at the instance initializer. Encouraging this idiom is the prime motivation for restricting the scope of the factory arguments to the initializer\"",
        "user": "UMVFWPZ36",
        "ts": "1606591555.165800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bpn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The relevant bits: \"Imports Code within a module must often make use of code defined by other modules. For example, ShapeLibrary requires utility classes such as List, defined by the standard collections library. In the absence of a global namespace, there is no way to refer to a class such as List directly. Instead, we have defined a slot named List inside ShapeLibrary. The slot declarations used in figure 2 differ slightly from our earlier examples. Here, slot initialization uses = rather than ::=. The use of = signifies that these are immutable slots, that will not be changed after they are initialized. No setter methods are generated for immutable slots, thus enforcing immutability. When ShapeLibrary is instantiated, it expects an object representing the underlying platform as an argument to its factory method usingPlatform:. This object will be the value of the factory method\u2019s formal parameter platform. During the initialization of the module, the slot List will be initialized via the expression platform collections List. This sends the message collections to platform, presumably returning an object representing an instance of the platform\u2019s collection library. This object then responds to the message List, returning the desired class. The class is stored in the slot, and is available to code within the module definition via the slot\u2019s getter method. The slot definition of List fills the role of an import statement, as do those of Error and Point. Note that the parameters to the factory method are only in scope within the instance initializer. The programmer must take explicit action to make (parts of) them available to the rest of the module. The preferred idiom is to extract individual classes and store them in slots, as shown here. It is then possible to determine the module\u2019s external dependencies at a glance, by looking at the instance initializer. Encouraging this idiom is the prime motivation for restricting the scope of the factory arguments to the initializer\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "687f04c6-63de-4383-af91-4472ad6a0959",
        "type": "message",
        "text": "(better of course to look at the PDF to see the source example, but just wanted to paste that for easier ctrl+f)",
        "user": "UMVFWPZ36",
        "ts": "1606591586.166000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I5u62",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(better of course to look at the PDF to see the source example, but just wanted to paste that for easier ctrl+f)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606580326.162400",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "c09fbad6-8319-428f-827d-b7a02415daf6",
        "type": "message",
        "text": "In this comment I present a counterpoint to what I think <@UCUSW7WVD> is saying here:\n&gt;  Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n&gt; _&lt;snipped a long list of mechanism details pertaining to function invocation&gt;_\nhere:\n&gt;  Shannon's law of entropy you have to trade off flexibility for concision\nand here:\n&gt; _\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"_\nFunnily I kind of agree with Kartik but only while we stick to the current models of abstraction.\n\nI'm going to use the following analogy to describe how I think about this. Imagine we are all \"electronics people\" making circuit boards with LEDs, batteries, wires, switches etc. We send signals around encoded as voltage-on-wire or even FM. Note that voltage-on-wire serves a higher purpose (e.g. a specific voltage on a line may represent the \"turn this light on\" signal). We create  wired-ports/FM transmitters/recievers to hook up multiple such gizmos together. Unfortunately we all use different conventions for _how_ the voltage levels or FM bands correspond to the the signals we share. So most of our integration work is spent building adapters - the simple ones might just step up/down the voltage. The complex ones may receive a signal encoded as FM and re-encode the same signal as voltage-on-wire, or even re-transmit it on another FM band. There's nothing wrong with this because _this is reality_.\n\nOTOH, we can also think of making things better, or even doing something  _different_. Here, and this is key, I think there are two broad paths:\n\n1. Standardize. If everyone uses 5V and the same FM band and the same \"encoding\" of the shared signals, we can more easily plug things with each other. _We're still electronics people, doing mostly the same thing,_ but better and easier.\n2. A new level of abstraction. Say we completely stop thinking about voltages and think in a new level of abstraction called \"bytes\". This is the idea of software. I'd say we're now doing a fundamentally different thing - _we now are \"software people\" and no longer electronics people_ - because we are absolved of concerns about voltages and such things. The voltage didn't disappear, but don't matter directly to us. In fact many different physical contraptions may use very different physical mechanisms to represent the same bytes, but from our abstraction level, we still think of those disparate systems through a unified model of \"bytes\".\nNow the next chapter.. bytes are themselves problematic in ways that resemble voltage and FM band mismatches. The thing is bytes are used to represent \"higher purpose\" signals and messages that we send around - so encoding matters, again. The first approach is \"standardize the encodings\". This is very popular (cue this history of byte formats). But is there a second approach which would _make bytes irrelevant_ _to us_? What are the new concepts we would think and design in? We may end up with many different byte level encodings for the same messages we send around but we will have a new unified model of design across all of them. We will no longer be \"bytes people\", so what will we be? (BTW, eventually we could forego bytes completely in some cases and map directly to voltage or other physical representations.)",
        "user": "U8A5MS6R1",
        "ts": "1606594264.166300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606594412.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SBKR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In this comment I present a counterpoint to what I think "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " is saying here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n"
                            },
                            {
                                "type": "text",
                                "text": "<snipped a long list of mechanism details pertaining to function invocation>",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " Shannon's law of entropy you have to trade off flexibility for concision"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "and here:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"",
                                "style": {
                                    "italic": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nFunnily I kind of agree with Kartik but only while we stick to the current models of abstraction.\n\nI'm going to use the following analogy to describe how I think about this. Imagine we are all \"electronics people\" making circuit boards with LEDs, batteries, wires, switches etc. We send signals around encoded as voltage-on-wire or even FM. Note that voltage-on-wire serves a higher purpose (e.g. a specific voltage on a line may represent the \"turn this light on\" signal). We create  wired-ports/FM transmitters/recievers to hook up multiple such gizmos together. Unfortunately we all use different conventions for "
                            },
                            {
                                "type": "text",
                                "text": "how",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the voltage levels or FM bands correspond to the the signals we share. So most of our integration work is spent building adapters - the simple ones might just step up/down the voltage. The complex ones may receive a signal encoded as FM and re-encode the same signal as voltage-on-wire, or even re-transmit it on another FM band. There's nothing wrong with this because "
                            },
                            {
                                "type": "text",
                                "text": "this is reality",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n\nOTOH, we can also think of making things better, or even doing something  "
                            },
                            {
                                "type": "text",
                                "text": "different",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Here, and this is key, I think there are two broad paths:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Standardize. If everyone uses 5V and the same FM band and the same \"encoding\" of the shared signals, we can more easily plug things with each other. "
                                    },
                                    {
                                        "type": "text",
                                        "text": "We're still electronics people, doing mostly the same thing, ",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "but better and easier."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A new level of abstraction. Say we completely stop thinking about voltages and think in a new level of abstraction called \"bytes\". This is the idea of software. I'd say we're now doing a fundamentally different thing - "
                                    },
                                    {
                                        "type": "text",
                                        "text": "we now are \"software people\" and no longer electronics people",
                                        "style": {
                                            "italic": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " - because we are absolved of concerns about voltages and such things. The voltage didn't disappear, but don't matter directly to us. In fact many different physical contraptions may use very different physical mechanisms to represent the same bytes, but from our abstraction level, we still think of those disparate systems through a unified model of \"bytes\"."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNow the next chapter.. bytes are themselves problematic in ways that resemble voltage and FM band mismatches. The thing is bytes are used to represent \"higher purpose\" signals and messages that we send around - so encoding matters, again. The first approach is \"standardize the encodings\". This is very popular (cue this history of byte formats). But is there a second approach which would "
                            },
                            {
                                "type": "text",
                                "text": "make bytes irrelevant",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "to us",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? What are the new concepts we would think and design in? We may end up with many different byte level encodings for the same messages we send around but we will have a new unified model of design across all of them. We will no longer be \"bytes people\", so what will we be? (BTW, eventually we could forego bytes completely in some cases and map directly to voltage or other physical representations.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    }
]