[
    {
        "client_msg_id": "bb6d5ae1-d677-4c7f-9c84-27f8c901b504",
        "type": "message",
        "text": "The growing prevalence of pattern matching in modern languages seems to bear this out.",
        "user": "UCUSW7WVD",
        "ts": "1605136087.385800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QLwOz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The growing prevalence of pattern matching in modern languages seems to bear this out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    },
    {
        "client_msg_id": "80d687a3-5d31-4155-8bbf-8edc9efb95b2",
        "type": "message",
        "text": "<@UPX3PH28N> the refactor concern is a good one.  I've long asked myself how to better manage refactoring from a dynamic perspective \u2014 as opposed to adding static features to a dynamic language.  Since a refactor wants to be behaviorally invariant (to some degree), why not keep track of the behavior?\n\nConsider the case of changing a parameter type.  If the normal brain dynamic way is to make the change and see what tests break, then the galaxy brain dynamic way would be to show all the places where code needs to change from having remembered (traced) all the times the function is called in practice.  Using traces in this way feels a lot like static analysis and loops around when you switch from concrete traces to more symbolic/partial kind of evaluation.  You find yourself back in familiar static typing territory when the symbolic evaluation is more limited.",
        "user": "UA14TGLTC",
        "ts": "1605152712.386100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9Rh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UPX3PH28N"
                            },
                            {
                                "type": "text",
                                "text": " the refactor concern is a good one.  I've long asked myself how to better manage refactoring from a dynamic perspective \u2014 as opposed to adding static features to a dynamic language.  Since a refactor wants to be behaviorally invariant (to some degree), why not keep track of the behavior?\n\nConsider the case of changing a parameter type.  If the normal brain dynamic way is to make the change and see what tests break, then the galaxy brain dynamic way would be to show all the places where code needs to change from having remembered (traced) all the times the function is called in practice.  Using traces in this way feels a lot like static analysis and loops around when you switch from concrete traces to more symbolic/partial kind of evaluation.  You find yourself back in familiar static typing territory when the symbolic evaluation is more limited."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    },
    {
        "client_msg_id": "ae1db0ba-59ef-4b68-96f8-c4f2cb5b181d",
        "type": "message",
        "text": "<@UCUSW7WVD> What do you mean by \"The growing prevalence of pattern matching in modern languages seems to bear this out.\"? I'm trying to reach for examples of pattern matching in modern languages and am drawing a blank.",
        "user": "U015902ESJC",
        "ts": "1605161690.386300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2f+MC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " What do you mean by \"The growing prevalence of pattern matching in modern languages seems to bear this out.\"? I'm trying to reach for examples of pattern matching in modern languages and am drawing a blank."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    },
    {
        "client_msg_id": "839551c6-eb20-4886-9cdd-1fe2feea180d",
        "type": "message",
        "text": "Approximately in chronological order:\n\nSML: <https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html|https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html>\n\nHaskell: <http://learnyouahaskell.com/syntax-in-functions|http://learnyouahaskell.com/syntax-in-functions>\n\nScheme: <https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html|https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html>\n\nScala: <https://docs.scala-lang.org/tour/pattern-matching.html|https://docs.scala-lang.org/tour/pattern-matching.html>\n\nRust: <https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html|https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html>\n\nSwift: <https://docs.swift.org/swift-book/ReferenceManual/Patterns.html|https://docs.swift.org/swift-book/ReferenceManual/Patterns.html>\n\nEtc.",
        "user": "UCUSW7WVD",
        "ts": "1605167685.386500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=2Ng",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Approximately in chronological order:\n\nSML: "
                            },
                            {
                                "type": "link",
                                "url": "https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html",
                                "text": "https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nHaskell: "
                            },
                            {
                                "type": "link",
                                "url": "http://learnyouahaskell.com/syntax-in-functions",
                                "text": "http://learnyouahaskell.com/syntax-in-functions"
                            },
                            {
                                "type": "text",
                                "text": "\n\nScheme: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html",
                                "text": "https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nScala: "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.scala-lang.org/tour/pattern-matching.html",
                                "text": "https://docs.scala-lang.org/tour/pattern-matching.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nRust: "
                            },
                            {
                                "type": "link",
                                "url": "https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html",
                                "text": "https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nSwift: "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.swift.org/swift-book/ReferenceManual/Patterns.html",
                                "text": "https://docs.swift.org/swift-book/ReferenceManual/Patterns.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nEtc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "U015902ESJC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e08c4fd9-e9ee-42ca-987a-cace973cd046",
        "type": "message",
        "text": "Erlang/Elixir, too.",
        "user": "U016VUZGUUQ",
        "ts": "1605172819.398700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AmZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Erlang/Elixir, too."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    },
    {
        "client_msg_id": "5aca824e-180c-4cd4-aec3-e902e45eb47d",
        "type": "message",
        "text": "Are there any languages/compilers in existence which perform optimization steps while staying in the high level language, and makes these steps visible to the user?\n\nFor example, instead of compiling from a tail-recursive C function, directly to a loop in assembly, it first optimises to a loop in C, then the translation to ASM is a dumb single-pass compilation.\n\nFor example, this (contrived) tail call elimination is quite hard to follow if you are expecting function calls to appear in the assembly <https://godbolt.org/z/jhecj5>\n\nYou could have a compiler that first said, \"You code is equivalent to this code\" <https://godbolt.org/z/3v6ezj> - which is easier to see why it compiles to those same instructions.",
        "user": "UDQBTJ211",
        "ts": "1605186819.404500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Compiler Explorer - C++ (x86-64 gcc 8.2)",
                "title_link": "https://godbolt.org/z/jhecj5",
                "text": "static int sum_int(int num, int acc) { if (num == 0) return acc; return sum_int(num - 1, acc + num); } int sum(int num) { return sum_int(num, 0); }",
                "fallback": "Compiler Explorer - C++ (x86-64 gcc 8.2)",
                "from_url": "https://godbolt.org/z/jhecj5",
                "service_icon": "https://godbolt.org/favicon.ico?v=1",
                "service_name": "godbolt.org",
                "id": 1,
                "original_url": "https://godbolt.org/z/jhecj5"
            },
            {
                "title": "Compiler Explorer - C++ (x86-64 gcc 8.2)",
                "title_link": "https://godbolt.org/z/3v6ezj",
                "text": "int sum(int num) { int r = 0; while(num != 0){ r += num; num--; } return r; }",
                "fallback": "Compiler Explorer - C++ (x86-64 gcc 8.2)",
                "from_url": "https://godbolt.org/z/3v6ezj",
                "service_icon": "https://godbolt.org/favicon.ico?v=1",
                "service_name": "godbolt.org",
                "id": 2,
                "original_url": "https://godbolt.org/z/3v6ezj"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "B7UJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there any languages/compilers in existence which perform optimization steps while staying in the high level language, and makes these steps visible to the user?\n\nFor example, instead of compiling from a tail-recursive C function, directly to a loop in assembly, it first optimises to a loop in C, then the translation to ASM is a dumb single-pass compilation.\n\nFor example, this (contrived) tail call elimination is quite hard to follow if you are expecting function calls to appear in the assembly "
                            },
                            {
                                "type": "link",
                                "url": "https://godbolt.org/z/jhecj5"
                            },
                            {
                                "type": "text",
                                "text": "\n\nYou could have a compiler that first said, \"You code is equivalent to this code\" "
                            },
                            {
                                "type": "link",
                                "url": "https://godbolt.org/z/3v6ezj"
                            },
                            {
                                "type": "text",
                                "text": " - which is easier to see why it compiles to those same instructions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "reply_count": 6,
        "reply_users_count": 3,
        "latest_reply": "1605383420.460600",
        "reply_users": [
            "UBN9AFS0N",
            "UPX3PH28N",
            "U01661S9F34"
        ],
        "subscribed": true,
        "last_read": "1605383420.460600"
    },
    {
        "client_msg_id": "b0be16df-4f37-4cba-9a9e-451f70f7cac3",
        "type": "message",
        "text": "<http://nanopass.org/>",
        "user": "UBN9AFS0N",
        "ts": "1605187174.404700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e9/O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://nanopass.org/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U013ZLJARC7",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "66a7f1d7-2323-445f-a53d-a9010c6f488b",
        "type": "message",
        "text": "<https://www.youtube.com/watch?v=Os7FE3J-U5Q>",
        "user": "UBN9AFS0N",
        "ts": "1605187224.404900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1M+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=Os7FE3J-U5Q"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UDQBTJ211"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UDQBTJ211"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8B879729-A9B0-405A-8E65-B608B686E239",
        "type": "message",
        "text": "This is very close to what I am imagining: a gradual typechecker that can deal with holes. Sort of a combination between the Typescript compiler and Hazel. Except in addition to being \"gradually typed\", the language would be \"gradually programmed\": the user would initially provide only names with some (loose) type annotations and (later) maybe some implementation details attached to them (which is why I realize my use of the term \"pseudocode\" was probably more misleading than anything). ",
        "user": "UG0EL18H3",
        "ts": "1605191179.413500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Tnqw0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is very close to what I am imagining: a gradual typechecker that can deal with holes. Sort of a combination between the Typescript compiler and Hazel. Except in addition to being \"gradually typed\", the language would be \"gradually programmed\": the user would initially provide only names with some (loose) type annotations and (later) maybe some implementation details attached to them (which is why I realize my use of the term \"pseudocode\" was probably more misleading than anything). "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "75e14712-c963-494e-bea4-5ade32657208",
        "type": "message",
        "text": "GHC has a couple of intermediate forms that the code goes through. <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html|https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html>",
        "user": "UPX3PH28N",
        "ts": "1605194047.413700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SUedN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "GHC has a couple of intermediate forms that the code goes through. "
                            },
                            {
                                "type": "link",
                                "url": "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html",
                                "text": "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/debugging.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "fb81eda7-749e-443a-b5b0-77832c8846b0",
        "type": "message",
        "text": "Another interesting thing in GHC are rewrite rules: the programmer can specify how to transform expressions in high-level language into equivalent but faster expressions. <https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/rewrite-rules.html|https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/rewrite-rules.html> <https://wiki.haskell.org/GHC/Using_rules|https://wiki.haskell.org/GHC/Using_rules>",
        "user": "UPX3PH28N",
        "ts": "1605194219.413900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0wEO=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Another interesting thing in GHC are rewrite rules: the programmer can specify how to transform expressions in high-level language into equivalent but faster expressions. "
                            },
                            {
                                "type": "link",
                                "url": "https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/rewrite-rules.html",
                                "text": "https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/rewrite-rules.html"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https://wiki.haskell.org/GHC/Using_rules",
                                "text": "https://wiki.haskell.org/GHC/Using_rules"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "ca8b7b54-1b66-4975-a83f-d1022fdec558",
        "type": "message",
        "text": "to add more, almost all optimization passes on Erlang/Elixir are done one a representation called \"core erlang\" which is a low level yet human readabble functional language",
        "user": "UBN9AFS0N",
        "ts": "1605211967.414200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "id51",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "to add more, almost all optimization passes on Erlang/Elixir are done one a representation called \"core erlang\" which is a low level yet human readabble functional language"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UPX3PH28N"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c0f40849-a823-4f78-a83e-9f9f8e8008a3",
        "type": "message",
        "text": "<@UG0EL18H3> You may like something like this\n<https://github.com/fulcrologic/guardrails>",
        "user": "U01DUNFS2N4",
        "ts": "1605217151.414500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "fulcrologic/guardrails",
                "title_link": "https://github.com/fulcrologic/guardrails",
                "text": "A middle ground between unguarded functions and enforced spec instrumentation. - fulcrologic/guardrails",
                "fallback": "GitHub: fulcrologic/guardrails",
                "thumb_url": "https://avatars3.githubusercontent.com/u/30102823?s=400&v=4",
                "from_url": "https://github.com/fulcrologic/guardrails",
                "thumb_width": 211,
                "thumb_height": 211,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/fulcrologic/guardrails"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zN1H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UG0EL18H3"
                            },
                            {
                                "type": "text",
                                "text": " You may like something like this\n"
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/fulcrologic/guardrails"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    },
    {
        "client_msg_id": "e5191cd8-fa42-4693-8ede-9b436966b5f9",
        "type": "message",
        "text": "It allows the use of any level of specification that you want. not-nil? int? positive-int? etc. I'm using it in my current work projects to instrument common functions so I don't get calling semantics wrong.",
        "user": "U01DUNFS2N4",
        "ts": "1605220210.414900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZHW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It allows the use of any level of specification that you want. not-nil? int? positive-int? etc. I'm using it in my current work projects to instrument common functions so I don't get calling semantics wrong."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605124537.384800",
        "parent_user_id": "U01DUNFS2N4"
    }
]