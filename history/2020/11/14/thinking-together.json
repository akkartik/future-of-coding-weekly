[
    {
        "client_msg_id": "5ba204c3-918b-4acc-bfe1-3a11190b8c3c",
        "type": "message",
        "text": "Love the analogy with food service! It\u2019s also apt to say that just because someone can cook or wants to cook for themselves or their family doesn\u2019t mean that they have or necessarily want to have the skills to cater a wedding!",
        "user": "UG0EL18H3",
        "ts": "1605316516.446200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fvPSw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Love the analogy with food service! It\u2019s also apt to say that just because someone can cook or wants to cook for themselves or their family doesn\u2019t mean that they have or necessarily want to have the skills to cater a wedding!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605274939.423400",
        "parent_user_id": "UAJKEBGP8",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UAJKEBGP8"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2A1DB9F2-798D-4BE1-A0BC-A119F3717106",
        "type": "message",
        "text": "I wish there was node-based programming that wanted to be a mind-map more than a working gizmo. \n\nIt seems deeply inspired by mind-maps, but also seems happy to leave the \"thought space\" behind pretty quickly in favor of the work-space. \nYes we want to see our ideas \"work\", but sometimes the thrill is in the ideas themselves, adjacent possibilities, the model, the schema. \nThe code, the wires, the implementation, those are often much less exciting \u2014 we know we can make those work, they're rote.\n\nMind-map software itself has very little ambition, little automation, shockingly little creativity, which is beyond ironic.\nOn the other end, I don't really need something that compiles and runs. My mind can \"compile and run\" lots of things \u2014 even given fragmented and incomplete material. It loves that, in fact.\n\nI guess what I want is fewer Turing machines and more mind bicycles.",
        "user": "USH01JEDQ",
        "ts": "1605332413.446900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t5Hh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wish there was node-based programming that wanted to be a mind-map more than a working gizmo. \n\nIt seems deeply inspired by mind-maps, but also seems happy to leave the \"thought space\" behind pretty quickly in favor of the work-space. \nYes we want to see our ideas \"work\", but sometimes the thrill is in the ideas themselves, adjacent possibilities, the model, the schema. \nThe code, the wires, the implementation, those are often much less exciting \u2014 we know we can make those work, they're rote.\n\nMind-map software itself has very little ambition, little automation, shockingly little creativity, which is beyond ironic.\nOn the other end, I don't really need something that compiles and runs. My mind can \"compile and run\" lots of things \u2014 even given fragmented and incomplete material. It loves that, in fact.\n\nI guess what I want is fewer Turing machines and more mind bicycles."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "reply_count": 9,
        "reply_users_count": 5,
        "latest_reply": "1605498869.470200",
        "reply_users": [
            "UC2A2ARPT",
            "USH01JEDQ",
            "UAHHWT22U",
            "U017GNJM021",
            "UDKTZSD6H"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "94fe25ae-504e-4c4a-88b8-e69fc38d695e",
        "type": "message",
        "text": "A node-based visual programming system that was also a full-featured drawing tool would probably get you there, yeah?",
        "user": "UC2A2ARPT",
        "ts": "1605369612.447700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1605369642.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IAMxC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A node-based visual programming system that was also a full-featured drawing tool would probably get you there, yeah?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "parent_user_id": "USH01JEDQ"
    },
    {
        "client_msg_id": "CC2F8E63-9233-4608-BA95-49EBB5A6A42F",
        "type": "message",
        "text": "I'd still like it to be a machine of some sort - beyond a mind-map application - with some programming, but that does something to the nodes themselves, grows them, prunes them - surfaces related, possibly connected things, sometimes random things - ultimately expands the thinking surface, evolves it\n\nThe interaction would be about the node graph itself - rather than me doing everything to the node graph to produce an effect I already understand\n\nThat's really the thought exercise - not using a node-graph to program, but a node-graph to explore, and in the nature of node-graph qua mind-map - maybe something like a node-quine?",
        "user": "USH01JEDQ",
        "ts": "1605375292.452600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ozYt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd still like it to be a machine of some sort - beyond a mind-map application - with some programming, but that does something to the nodes themselves, grows them, prunes them - surfaces related, possibly connected things, sometimes random things - ultimately expands the thinking surface, evolves it\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "The interaction would be about the node graph itself - rather than me doing everything to the node graph to produce an effect I already understand\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "That's really the thought exercise - not using a node-graph to program, but a node-graph to explore, and in the nature of node-graph qua mind-map - maybe something like a node-quine?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "parent_user_id": "USH01JEDQ"
    },
    {
        "client_msg_id": "76646B8D-C3D6-4FB1-BEA5-48C8D6FCCE66",
        "type": "message",
        "text": "Some more thinking aloud:\n\u2022 Consider what the \"assembly language\" of building and navigating a graph would be - now presume that those are the very same behaviors that you give to the running machine - for instance, a script where touching a node runs the NAVIGATE and then BRANCH steps - you play with those until you start producing useful new iterations of the mind-map - the most basic action might be JUMP/GOTO to a known node, because it's a part of the mind-map you always want to look at - advanced actions might use neural-network-lite scoring to try to discover a useful node to bring into the view\n\u2022 There is probably a Hypercard-like toggle between \"use\" and \"edit\" modes\nIt feels like I've used a node-based environment like this, but not one where it considered itself as a mind-map, trying to work in a conceptual space",
        "user": "USH01JEDQ",
        "ts": "1605377082.460100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HYT2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some more thinking aloud:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Consider what the \"assembly language\" of building and navigating a graph would be - now presume that those are the very same behaviors that you give to the running machine - for instance, a script where touching a node runs the NAVIGATE and then BRANCH steps - you play with those until you start producing useful new iterations of the mind-map - the most basic action might be JUMP/GOTO to a known node, because it's a part of the mind-map you always want to look at - advanced actions might use neural-network-lite scoring to try to discover a useful node to bring into the view"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "There is probably a Hypercard-like toggle between \"use\" and \"edit\" modes"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt feels like I've used a node-based environment like this, but not one where it considered itself as a mind-map, trying to work in a conceptual space"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "parent_user_id": "USH01JEDQ",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "26c7a193-e7b8-44a4-a97b-f22550fb8f01",
        "type": "message",
        "text": "<@UAHHWT22U> \u2014\u00a0Remind you of anything? :)",
        "user": "UC2A2ARPT",
        "ts": "1605377657.460400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tuh4v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UAHHWT22U"
                            },
                            {
                                "type": "text",
                                "text": " \u2014\u00a0Remind you of anything? :)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "parent_user_id": "USH01JEDQ"
    },
    {
        "client_msg_id": "ba5e0cbb-9592-4c36-b7ae-2a169599dbff",
        "type": "message",
        "text": "Meta-programming in general have been used for this kind of thing for a long time. I often see macros as a way to \"add your own user defined compiler stage.\" There are many examples of lisp macros that try to optimize code. <https://youtu.be/8FoAxasNssA|Here is an example> of C++ templates being used to generate optimized shader code depending on the compile target.\n\nTo be a shill for my favorite hobby lang for a bit: Nim is interesting on this topic. Nim has lisp style macros, and liberally uses high level rewrite passes to generate optimized code. For example, Nim has the concept of an <https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-first-class-iterators|inline iterator>, which gives you convenient python style iterator syntax, but rewrites the code into a more optimal for loop. <https://nim-lang.org/docs/asyncdispatch.html|Async / Await> in Nim is entirely built as a macro library. But, as interesting as those examples are, any language with a macro system can accomplish something similar in theory.\n\nWhat is interesting about Nim is that it is purely a \"compiler front end\" to use compiler terminology. Nim does not produce assembly language. It produces C code that can then be fed into any C compiler. This means the output is fairly high level, and while it's not \"pretty\" or  \"elegant\", it's inspectable! You can read it and understand what is going on.",
        "user": "U01661S9F34",
        "ts": "1605383420.460600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1605383427.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "r9E",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Meta-programming in general have been used for this kind of thing for a long time. I often see macros as a way to \"add your own user defined compiler stage.\" There are many examples of lisp macros that try to optimize code. "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/8FoAxasNssA",
                                "text": "Here is an example"
                            },
                            {
                                "type": "text",
                                "text": " of C++ templates being used to generate optimized shader code depending on the compile target.\n\nTo be a shill for my favorite hobby lang for a bit: Nim is interesting on this topic. Nim has lisp style macros, and liberally uses high level rewrite passes to generate optimized code. For example, Nim has the concept of an "
                            },
                            {
                                "type": "link",
                                "url": "https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-first-class-iterators",
                                "text": "inline iterator"
                            },
                            {
                                "type": "text",
                                "text": ", which gives you convenient python style iterator syntax, but rewrites the code into a more optimal for loop. "
                            },
                            {
                                "type": "link",
                                "url": "https://nim-lang.org/docs/asyncdispatch.html",
                                "text": "Async / Await"
                            },
                            {
                                "type": "text",
                                "text": " in Nim is entirely built as a macro library. But, as interesting as those examples are, any language with a macro system can accomplish something similar in theory.\n\nWhat is interesting about Nim is that it is purely a \"compiler front end\" to use compiler terminology. Nim does not produce assembly language. It produces C code that can then be fed into any C compiler. This means the output is fairly high level, and while it's not \"pretty\" or  \"elegant\", it's inspectable! You can read it and understand what is going on."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605186819.404500",
        "parent_user_id": "UDQBTJ211"
    },
    {
        "client_msg_id": "375a6c58-b2b8-40fc-a5f6-387af94997e4",
        "type": "message",
        "text": "<@UC2A2ARPT> Uncanny :smile:\n\n<@USH01JEDQ> you should check out <@UC2A2ARPT>'s <https://ivanish.ca/hest-time-travel/|Hest> :wink:",
        "user": "UAHHWT22U",
        "ts": "1605384723.461000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAHHWT22U",
            "ts": "1605384731.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SaktJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": " Uncanny "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "USH01JEDQ"
                            },
                            {
                                "type": "text",
                                "text": " you should check out "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "'s "
                            },
                            {
                                "type": "link",
                                "url": "https://ivanish.ca/hest-time-travel/",
                                "text": "Hest"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605332413.446900",
        "parent_user_id": "USH01JEDQ"
    },
    {
        "client_msg_id": "c4e81934-ccdf-478a-b043-d24f4739b3bd",
        "type": "message",
        "text": "Love the analogy too (because I love food :stuck_out_tongue:).\n\nSome other directions for the analogy, taking into account some innovations in food technology/media:\n\n\u2022 More powerful home equipment packaged in consumer friendly ways eg, slow cooker, sous vide machine, ninja food blenders. On a socio-technical level, I can see the parallel elistism of using such tools by \u201cproper\u201d chefs, similar to C++ programmers looking at Unity, or professional programmers looking at no-code tools.\n\u2022 Recipe boxes eg, gousto, mindful chef. Meet halfway with the user so they still need to cook, but provide the ingredients and recipes to them to guide them. Maybe no-code with tutorials/sharing community is going in this direction\n\u2022 Masterchef/British Bake off/Youtube videos - it\u2019s quite easy to be inspired by others making food, and it\u2019s just pure entertaining! I\u2019m not sure watching a code editor/terminal on twitch will be very entertaining to someone who does not program. There\u2019s this thing with game design, where some games are fun to watch, as well as play (sometimes more so). Making software can be quite solitary a lot of times. I guess dynamic land tackles this by having a \u201clocal-multiplayer\u201d feel to it. Also, may live programming eg, <https://sonic-pi.net/|sonic-pi>",
        "user": "UP00ZLX6G",
        "ts": "1605393762.461400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP00ZLX6G",
            "ts": "1605393945.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IHV7z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Love the analogy too (because I love food "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            },
                            {
                                "type": "text",
                                "text": ").\n\nSome other directions for the analogy, taking into account some innovations in food technology/media:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "More powerful home equipment packaged in consumer friendly ways eg, slow cooker, sous vide machine, ninja food blenders. On a socio-technical level, I can see the parallel elistism of using such tools by \u201cproper\u201d chefs, similar to C++ programmers looking at Unity, or professional programmers looking at no-code tools."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Recipe boxes eg, gousto, mindful chef. Meet halfway with the user so they still need to cook, but provide the ingredients and recipes to them to guide them. Maybe no-code with tutorials/sharing community is going in this direction"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Masterchef/British Bake off/Youtube videos - it\u2019s quite easy to be inspired by others making food, and it\u2019s just pure entertaining! I\u2019m not sure watching a code editor/terminal on twitch will be very entertaining to someone who does not program. There\u2019s this thing with game design, where some games are fun to watch, as well as play (sometimes more so). Making software can be quite solitary a lot of times. I guess dynamic land tackles this by having a \u201clocal-multiplayer\u201d feel to it. Also, may live programming eg, "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://sonic-pi.net/",
                                        "text": "sonic-pi"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1605274939.423400",
        "parent_user_id": "UAJKEBGP8"
    }
]