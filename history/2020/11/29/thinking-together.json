[
    {
        "client_msg_id": "873dab04-3373-4e47-8c65-f50e09c747cf",
        "type": "message",
        "text": "what you are describing sounds  an awful lot like networking. In networking you go from radio, copper. fiber optic mediums to ... bytes, and then more layers of bytes by packing in \"layers\". The way systems like TCP/IP has been successful is .. by standardizing. I may be wrong but it sounds like you are thinking there may be something undiscovered that is superior to \"arranging bits\", but encoding and decoding data just seems like the nature of the problem.",
        "user": "UN9SCH5RD",
        "ts": "1606607135.166800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bi/WR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "what you are describing sounds  an awful lot like networking. In networking you go from radio, copper. fiber optic mediums to ... bytes, and then more layers of bytes by packing in \"layers\". The way systems like TCP/IP has been successful is .. by standardizing. I may be wrong but it sounds like you are thinking there may be something undiscovered that is superior to \"arranging bits\", but encoding and decoding data just seems like the nature of the problem."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "bb475ffc-279a-4c91-bd80-ff0b63e834e8",
        "type": "message",
        "text": "I'm not proposing a solution but rather suggesting a perspective on the problem. It's not about superior, but the about virtual concepts we work with. Yes it is about what concepts have been standardized. E.g. TCP/IP will work across copper wire, _or_ radio frequency _or_ microwave frequency _or_ any other medium the someone cares to map it to.\n\nI could just as correctly say \"designing circuits or radio frequencies is just the nature of the problem\". Yet in decades of building systems that _transmit information_ I have never once had to design the mapping of information to radio frequencies. Yet I have often designed (or reckoned with) the mapping of information to _bits._ You could standardize on a concept higher level than bits of course, (one example is something based on \"symbols\"). In fact we always work with higher levels within PLs or frameworks. Yet the OS and networks stop at giving us support for bits.",
        "user": "U8A5MS6R1",
        "ts": "1606611089.167000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lVA8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not proposing a solution but rather suggesting a perspective on the problem. It's not about superior, but the about virtual concepts we work with. Yes it is about what concepts have been standardized. E.g. TCP/IP will work across copper wire, "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " radio frequency "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " microwave frequency "
                            },
                            {
                                "type": "text",
                                "text": "or",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " any other medium the someone cares to map it to.\n\nI could just as correctly say \"designing circuits or radio frequencies is just the nature of the problem\". Yet in decades of building systems that "
                            },
                            {
                                "type": "text",
                                "text": "transmit information",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " I have never once had to design the mapping of information to radio frequencies. Yet I have often designed (or reckoned with) the mapping of information to "
                            },
                            {
                                "type": "text",
                                "text": "bits. ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "You could standardize on a concept higher level than bits of course, (one example is something based on \"symbols\"). In fact we always work with higher levels within PLs or frameworks. Yet the OS and networks stop at giving us support for bits."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "69e0c189-f475-47b3-aedd-b42b0811bfc2",
        "type": "message",
        "text": "Since software is executable, it gives us much more powerful ways of re-configuring than we can have with hardware. With hardware the encodings tend to be fixed. With software we can look at standardizing the bare minimum and leveraging its reconfigurability. For instance instead of standardizing \"encodings\" we could standardize \"encoding grammar\" which are pre-shared, but any real encodings can just be defined using this grammar and sent on the wire. Any receiver can then generate encoder/decoder on the fly. This doesn't do away with bits but encapsulates them in a way.",
        "user": "U8A5MS6R1",
        "ts": "1606612182.167300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606612219.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o0mrS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Since software is executable, it gives us much more powerful ways of re-configuring than we can have with hardware. With hardware the encodings tend to be fixed. With software we can look at standardizing the bare minimum and leveraging its reconfigurability. For instance instead of standardizing \"encodings\" we could standardize \"encoding grammar\" which are pre-shared, but any real encodings can just be defined using this grammar and sent on the wire. Any receiver can then generate encoder/decoder on the fly. This doesn't do away with bits but encapsulates them in a way."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3875c2d5-5a0a-46fa-991a-d9d4be19bd7a",
        "type": "message",
        "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language. Maybe a total language depending on your definition. I mean, the idea is pretty close to what I want to do/see, but even these \"grammars\" have to be encoded to be shared, and standardizing that encoding won't be any easier than the others.\n\nI think of this as \"encoding\" vs \"intent\". Intent is the human purpose for whatever the system is supposed to do. We would really like to specify everything in terms of intent, both messages and programs, but intent is inherently non-physical (unless you want to talk about neurology). You can't standardize intent, or transmit it. I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\n\nMy design goals, as far as I've nailed them down, revolve in large part around precisely capturing intent, in particular, _avoiding_ encoding things that are not intended but merely side effects of the encoding a user is using to convey their intent to a computer. One of my catchphrases is \"as specific as desired\", something I've thought about since I first felt straitjacketed by a mind-mapping app. Implicit ordering and implicit dependencies are quite pernicious, e.g. a supposedly unordered map that is nevertheless processed in order and allows/requires you to make assumptions based on that order. (Notably, bit strings are always ordered, which in a way is the fundamental obstacle.)\n\nI've gotten as far as \"make all dependencies explicit and optional (including ordering)\" and \"define things by the effects (in the sense of I/O!) they produce\". What form of communication your intent produces, or whether it results in native code, is a matter of encoding, to be specified independently; as I (and Emmanuel I guess) said, the OS's job. Details are WIP. :-/",
        "user": "U016VUZGUUQ",
        "ts": "1606620852.167600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UMZn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language. Maybe a total language depending on your definition. I mean, the idea is pretty close to what I want to do/see, but even these \"grammars\" have to be encoded to be shared, and standardizing that encoding won't be any easier than the others.\n\nI think of this as \"encoding\" vs \"intent\". Intent is the human purpose for whatever the system is supposed to do. We would really like to specify everything in terms of intent, both messages and programs, but intent is inherently non-physical (unless you want to talk about neurology). You can't standardize intent, or transmit it. I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\n\nMy design goals, as far as I've nailed them down, revolve in large part around precisely capturing intent, in particular, "
                            },
                            {
                                "type": "text",
                                "text": "avoiding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " encoding things that are not intended but merely side effects of the encoding a user is using to convey their intent to a computer. One of my catchphrases is \"as specific as desired\", something I've thought about since I first felt straitjacketed by a mind-mapping app. Implicit ordering and implicit dependencies are quite pernicious, e.g. a supposedly unordered map that is nevertheless processed in order and allows/requires you to make assumptions based on that order. (Notably, bit strings are always ordered, which in a way is the fundamental obstacle.)\n\nI've gotten as far as \"make all dependencies explicit and optional (including ordering)\" and \"define things by the effects (in the sense of I/O!) they produce\". What form of communication your intent produces, or whether it results in native code, is a matter of encoding, to be specified independently; as I (and Emmanuel I guess) said, the OS's job. Details are WIP. :-/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "b45f2140-396a-4bbe-b143-1b52eb0ac0f4",
        "type": "message",
        "text": "<@U016VUZGUUQ> wrote\n&gt; In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language.\nI agree.\n&gt; I think of this as \"encoding\" vs \"intent\".\nYou've put this really well. I think of this as \"meaning\", which only exists in our minds, and \"representations\" and \"mechanisms\" which exist outside the mind.\n&gt; I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality.\nIf you're saying that irrespective of the encoding, the machines can only hold _signifiers_ and all mechanisms in the end amount to just transmitting arbitrary symbols (bits are just a sequence of symbols \"1\", \"0\") I must agree. But consider that we spend a lot of effort designing and manually implementing the mapping between _multiple_ vocabularies of such symbols - all of which are entirely in the machine. So there is the possibility of removing this extra work. (BTW, <@UJBAJNFLK> and I have a <https://shalabh.com/programmable-systems/files-and-file-formats.html#comment-7|discussion> on this topic on my blog post).\n\n&gt; _avoiding_ encoding things that are \n&gt; not intended but merely side effects of the encoding a user is using to \n&gt; convey their intent to a computer\nNicely put. In some sense these are _encoding artifacts_. Looking forward to see where you take these ideas.",
        "user": "U8A5MS6R1",
        "ts": "1606631008.167900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606631112.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kTYU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " wrote\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the general case, I suspect your \"encoding grammar\" is equivalent in complexity to a general purpose programming language."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think of this as \"encoding\" vs \"intent\"."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You've put this really well. I think of this as \"meaning\", which only exists in our minds, and \"representations\" and \"mechanisms\" which exist outside the mind.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe you can really get higher-level than \"arranging bits\" without confronting this non-physicality."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you're saying that irrespective of the encoding, the machines can only hold "
                            },
                            {
                                "type": "text",
                                "text": "signifiers",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and all mechanisms in the end amount to just transmitting arbitrary symbols (bits are just a sequence of symbols \"1\", \"0\") I must agree. But consider that we spend a lot of effort designing and manually implementing the mapping between "
                            },
                            {
                                "type": "text",
                                "text": "multiple",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " vocabularies of such symbols - all of which are entirely in the machine. So there is the possibility of removing this extra work. (BTW, "
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " and I have a "
                            },
                            {
                                "type": "link",
                                "url": "https://shalabh.com/programmable-systems/files-and-file-formats.html#comment-7",
                                "text": "discussion"
                            },
                            {
                                "type": "text",
                                "text": " on this topic on my blog post).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "avoiding",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " encoding things that are \nnot intended but merely side effects of the encoding a user is using to \nconvey their intent to a computer"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Nicely put. In some sense these are "
                            },
                            {
                                "type": "text",
                                "text": "encoding artifacts",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Looking forward to see where you take these ideas."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "8f890de7-7a01-4ca7-bfc7-51a9ce4f13ce",
        "type": "message",
        "text": "<@U8A5MS6R1> It seems like we're mostly on the same track. :) Thanks for the interesting link, too.\n\n&gt; So there is the possibility of removing this extra work.\n&gt; \nPerhaps the closest thing to a disagreement is this: it would be more precise to say that we're only doing the work once, rather than not doing it at all (and we want to let a compiler handle the details of hooking up encodings to business logic). Probably this is already what you were thinking, but I like to be explicit that the essential complexity is still there.\n\nI think we should keep in mind that any \"solution\" to this problem of lots of encodings needs to be imagined in a world that still seethes with conflicting formats and protocols. Even besides the mess of existing formats that have zero chance of going away, different encodings have different useful properties, notably performance under various queries (also space efficiency, error resilience, etc). You wouldn't try to back a relational database with the same encoding you send over a network. I'm looking for a tool to navigate chaos more than tame it (at least in a global standard sense).",
        "user": "U016VUZGUUQ",
        "ts": "1606683105.168600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iWflV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " It seems like we're mostly on the same track. :) Thanks for the interesting link, too.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So there is the possibility of removing this extra work.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPerhaps the closest thing to a disagreement is this: it would be more precise to say that we're only doing the work once, rather than not doing it at all (and we want to let a compiler handle the details of hooking up encodings to business logic). Probably this is already what you were thinking, but I like to be explicit that the essential complexity is still there.\n\nI think we should keep in mind that any \"solution\" to this problem of lots of encodings needs to be imagined in a world that still seethes with conflicting formats and protocols. Even besides the mess of existing formats that have zero chance of going away, different encodings have different useful properties, notably performance under various queries (also space efficiency, error resilience, etc). You wouldn't try to back a relational database with the same encoding you send over a network. I'm looking for a tool to navigate chaos more than tame it (at least in a global standard sense)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    }
]