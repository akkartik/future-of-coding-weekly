[
    {
        "client_msg_id": "850a3d32-9be5-4441-b417-3b549dd3cebf",
        "type": "message",
        "text": "proto is close  but a lot more strict, I like open formats like JSON or RDF because you can add things and pass them trough so is more composable",
        "user": "UN9SCH5RD",
        "ts": "1606435197.151700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SgS5a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "proto is close  but a lot more strict, I like open formats like JSON or RDF because you can add things and pass them trough so is more composable"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "02e76a1b-8dbc-4b76-883c-7e3755351138",
        "type": "message",
        "text": "for all nice things people say about the wisdom of unix there's little talk about the ugly parts. Plain text as an interface between programs is awful, because every program can output whatever, usually the glue is parsing line by line using regular expressions. Even something as simple as numbers can come in a number of formats. Not to speak of so called \"comma separated values\", which may use comma, semicolons tabs of fixed width, etc... often times without a spec or documentation",
        "user": "UN9SCH5RD",
        "ts": "1606435347.151900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KBZ=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "for all nice things people say about the wisdom of unix there's little talk about the ugly parts. Plain text as an interface between programs is awful, because every program can output whatever, usually the glue is parsing line by line using regular expressions. Even something as simple as numbers can come in a number of formats. Not to speak of so called \"comma separated values\", which may use comma, semicolons tabs of fixed width, etc... often times without a spec or documentation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "c238c05b-37ad-4c3c-bc1f-0a706165089c",
        "type": "message",
        "text": "if unix has \u201csmall programs, each doing one thing well\u201d, why are the man pages 20 pages long? Can you imagine having *one function* which takes 200 parameters? No type checking, mind you, you just need to provide the right parameters *in the correct order* (`find`, i'm looking at you)",
        "user": "UN9SCH5RD",
        "ts": "1606435431.152100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BSMd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "if unix has \u201csmall programs, each doing one thing well\u201d, why are the man pages 20 pages long? Can you imagine having "
                            },
                            {
                                "type": "text",
                                "text": "one function",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " which takes 200 parameters? No type checking, mind you, you just need to provide the right parameters "
                            },
                            {
                                "type": "text",
                                "text": "in the correct order",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ("
                            },
                            {
                                "type": "text",
                                "text": "find",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", i'm looking at you)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "959fc5a7-cde0-494f-b78f-56edf7be3415",
        "type": "message",
        "text": "`powershell` went in the right direction but after trying really hard to like it, I still don't feel like it has very good ergonomics",
        "user": "UN9SCH5RD",
        "ts": "1606435504.152300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fNZ2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "powershell",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " went in the right direction but after trying really hard to like it, I still don't feel like it has very good ergonomics"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "be715146-acf8-4eda-a135-13c189166fc4",
        "type": "message",
        "text": "There's a fable about a historian who distilled a comprehensive history down to three sentences: _\"People were born. They lived. They died.\"_ If I had to do a similar distillation for programming, it might be: _\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"_\n\nHere's Maurice Wilkes:\n\n&gt; I can remember the exact instant when I realized that a large part of my life from then on was going to be spent [doing this].\nI've been grinding my wheels for the past week because I've been reading about how to print floating-point numbers in decimal. Absurdly, ridiculously difficult as it is, the time has gone less in figuring out how to do it and more in coming to terms with the irreducible difficulty of it. No, this shortcut doesn't work. No, we can't avoid bignum support. And on and on. No, reading this one more research paper isn't going to make the problem magically simpler.\n\nOP seems similar. Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n* Where to look for the function. (Is it a source file? A dynamic library somewhere in the path? A database? A registry somewhere online?)\n* How to look for the function in that source. (An address in RAM? A mangled name? A URL? A file handle?)\n* Where to look for each input, and how to look for it. (An address in RAM? A file handle to load lines asynchronously from? How to unmarshall?)\n* Where the computation must run. (Same process? A new child sharing nothing? A threadpool? A coroutine? Some computer on the internet?)\n* Where to send each output. (To a register? Memory location? In-memory FIFO? File system? Database table? API endpoint on some server on the internet?)\n\nGiven the infinite detail of reality (<http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail>), each of these questions can be answered with arbitrary, Turing-complete code. Still, totally doable. You just have to be willing to be verbose. At every single call site.\n\nNo? Well, if you aren't willing to be verbose, by Shannon's law of entropy you have to trade off flexibility for concision. Live within the life-boat of a shell script, and it will impose the standard policy called, \"`execve()` all the things\". Live within the life-boat of a single language, and it will impose the standard policy called, \"push args on the stack and call.\" Or something like that.\n\nIt's certainly possible to explore other points on this spectrum. For example it might be quite ergonomic to unbundle an OS to the point that any synchronous function call `foo()` forks a process in an isolated address space and receives its inputs asynchronously over a channel simply by calling it as `foo!()` (or `spawn`, or `go`, in a maze of subtle differences in semantics). But it seems clear you have to accept a limited menu of choices. Languages that share this menu can interoperate. Languages that make distinct choices will have to \"be told again.\" Regardless of what you choose, I submit that having to specify the algorithm again is not that big a deal next to these problems of namespace management, mutable stores and marshalling/unmarshalling. Computation is always the easiest part of any non-trivial program.\n\nInteresting question. It's clearly one Louis Pouzin grappled with, and I see a day later that I've dealt with it multiple times in myriad guises. It's a question my brain is designed to keep butting heads against every so often.",
        "user": "UCUSW7WVD",
        "ts": "1606444940.153300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1606453526.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4w3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's a fable about a historian who distilled a comprehensive history down to three sentences: "
                            },
                            {
                                "type": "text",
                                "text": "\"People were born. They lived. They died.\"",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " If I had to do a similar distillation for programming, it might be: "
                            },
                            {
                                "type": "text",
                                "text": "\"People tried to solve problems. The problems turned out to be more difficult than expected. People came slowly to terms with how difficult they were.\"",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nHere's Maurice Wilkes:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I can remember the exact instant when I realized that a large part of my life from then on was going to be spent [doing this]."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been grinding my wheels for the past week because I've been reading about how to print floating-point numbers in decimal. Absurdly, ridiculously difficult as it is, the time has gone less in figuring out how to do it and more in coming to terms with the irreducible difficulty of it. No, this shortcut doesn't work. No, we can't avoid bignum support. And on and on. No, reading this one more research paper isn't going to make the problem magically simpler.\n\nOP seems similar. Yes, it's actually not that hard to reuse code between shell scripts and standard libraries. All you have to do is specify for every function call:\n* Where to look for the function. (Is it a source file? A dynamic library somewhere in the path? A database? A registry somewhere online?)\n* How to look for the function in that source. (An address in RAM? A mangled name? A URL? A file handle?)\n* Where to look for each input, and how to look for it. (An address in RAM? A file handle to load lines asynchronously from? How to unmarshall?)\n* Where the computation must run. (Same process? A new child sharing nothing? A threadpool? A coroutine? Some computer on the internet?)\n* Where to send each output. (To a register? Memory location? In-memory FIFO? File system? Database table? API endpoint on some server on the internet?)\n\nGiven the infinite detail of reality ("
                            },
                            {
                                "type": "link",
                                "url": "http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail"
                            },
                            {
                                "type": "text",
                                "text": "), each of these questions can be answered with arbitrary, Turing-complete code. Still, totally doable. You just have to be willing to be verbose. At every single call site.\n\nNo? Well, if you aren't willing to be verbose, by Shannon's law of entropy you have to trade off flexibility for concision. Live within the life-boat of a shell script, and it will impose the standard policy called, \""
                            },
                            {
                                "type": "text",
                                "text": "execve()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " all the things\". Live within the life-boat of a single language, and it will impose the standard policy called, \"push args on the stack and call.\" Or something like that.\n\nIt's certainly possible to explore other points on this spectrum. For example it might be quite ergonomic to unbundle an OS to the point that any synchronous function call "
                            },
                            {
                                "type": "text",
                                "text": "foo()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " forks a process in an isolated address space and receives its inputs asynchronously over a channel simply by calling it as "
                            },
                            {
                                "type": "text",
                                "text": "foo!()",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (or "
                            },
                            {
                                "type": "text",
                                "text": "spawn",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", or "
                            },
                            {
                                "type": "text",
                                "text": "go",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", in a maze of subtle differences in semantics). But it seems clear you have to accept a limited menu of choices. Languages that share this menu can interoperate. Languages that make distinct choices will have to \"be told again.\" Regardless of what you choose, I submit that having to specify the algorithm again is not that big a deal next to these problems of namespace management, mutable stores and marshalling/unmarshalling. Computation is always the easiest part of any non-trivial program.\n\nInteresting question. It's clearly one Louis Pouzin grappled with, and I see a day later that I've dealt with it multiple times in myriad guises. It's a question my brain is designed to keep butting heads against every so often."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0640e1d1-ccc1-4890-9c6d-ce219cb4b05e",
        "type": "message",
        "text": "Not \"difficult\" so much as \"fiddly\" where often you need to handle the fiddly bit (names, dates, addresses, Pythagorean commas) rather iron it out \u2014 presuming you can iron it out at all.",
        "user": "UA14TGLTC",
        "ts": "1606446003.153500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xjaL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not \"difficult\" so much as \"fiddly\" where often you need to handle the fiddly bit (names, dates, addresses, Pythagorean commas) rather iron it out \u2014 presuming you can iron it out at all."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "205aa754-eb19-45a8-bfbf-a98a7104ee73",
        "type": "message",
        "text": "Part of what we have to come to terms with is what we think of as \"honorably difficult\" vs \"unfair fiddly bits\".\n\n\"What, do you really expect me to think about that? What am I, a farmer?\"\n\"No, Mr. Baldwin, I expect you to die.\"",
        "user": "UCUSW7WVD",
        "ts": "1606446481.153700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ied",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Part of what we have to come to terms with is what we think of as \"honorably difficult\" vs \"unfair fiddly bits\".\n\n\"What, do you really expect me to think about that? What am I, a farmer?\"\n\"No, Mr. Baldwin, I expect you to die.\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "cfdb53c1-1ddc-4716-a90e-73d6928bc6fa",
        "type": "message",
        "text": "that's a great observation Kartik, it is true that \"plumbing programs together\" has some irreducible complexity, but I think the premise of a lot of projects in here (FoC) is that we can do better. I feel like many times though we fantasize sci-fi like solutions involving A.I., advanced GUIs and what not when we could be taking smaller incremental steps to a more ergonomic computing system",
        "user": "UN9SCH5RD",
        "ts": "1606446538.153900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e4U",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that's a great observation Kartik, it is true that \"plumbing programs together\" has some irreducible complexity, but I think the premise of a lot of projects in here (FoC) is that we can do better. I feel like many times though we fantasize sci-fi like solutions involving A.I., advanced GUIs and what not when we could be taking smaller incremental steps to a more ergonomic computing system"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "ba908f79-0215-4d4e-8192-90674163d22b",
        "type": "message",
        "text": "I'm not as visionary as others ... I feel like shells could work closer to IDEs, with inline documentation, autocompletion and solid language oriented tools, it doesn't feel like scifi, it feels doable. I feel like current shells are a bit hacky in this regard. Say, Bash completions are like the crappy version of real grammar and type analysis to produce completions that you would get in a normal IDE. We could start sending JSON at least, the least common denominator, to our standard outputs, instead of plain text (then we can start thinking how to add encodings for things like dates and bignums...). The small overhead is probably worth all the benefits.",
        "user": "UN9SCH5RD",
        "ts": "1606446806.154100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Mj2Fa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not as visionary as others ... I feel like shells could work closer to IDEs, with inline documentation, autocompletion and solid language oriented tools, it doesn't feel like scifi, it feels doable. I feel like current shells are a bit hacky in this regard. Say, Bash completions are like the crappy version of real grammar and type analysis to produce completions that you would get in a normal IDE. We could start sending JSON at least, the least common denominator, to our standard outputs, instead of plain text (then we can start thinking how to add encodings for things like dates and bignums...). The small overhead is probably worth all the benefits."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "069c6844-9ffd-4420-9583-8225330ef3bb",
        "type": "message",
        "text": "Current shells seem all kinds of hacking.  I've been typing at this shell for twenty years, and I still don't know it's basic syntax.  For all the programming languages I know, never seemed much point in learning the rhyme and reason to the shell as there seems to be little to none.",
        "user": "UA14TGLTC",
        "ts": "1606446875.154300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UA14TGLTC",
            "ts": "1606446972.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "un2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Current shells seem all kinds of hacking.  I've been typing at this shell for twenty years, and I still don't know it's basic syntax.  For all the programming languages I know, never seemed much point in learning the rhyme and reason to the shell as there seems to be little to none."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "b54e0c19-2226-41b8-a1de-a5105823c0d6",
        "type": "message",
        "text": "For sure. I think my comment was a long-winded way of saying, \"don't expect to support a large plethora of languages and runtimes.\" If you want it to cleanly interoperate and not be hacky, you have to be modernist about it and control diversity.",
        "user": "UCUSW7WVD",
        "ts": "1606447004.154600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1606452948.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sxg/K",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For sure. I think my comment was a long-winded way of saying, \"don't expect to support a large plethora of languages and runtimes.\" If you want it to cleanly interoperate and not be hacky, you have to be modernist about it and control diversity."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "34e0511a-9ce6-4632-9c59-25a8ab70716f",
        "type": "message",
        "text": "<@UN9SCH5RD> \"for all nice things people say about the wisdom of unix there's little talk about the ugly parts\"\nIt's not like we haven't been talking about this for decades: <http://doc.cat-v.org/bell_labs/structural_regexps/se.pdf>\n\nJust yesterday: <https://twitter.com/jackrusher/status/1331901111620481025>",
        "user": "U013ZLJARC7",
        "ts": "1606464254.155100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1606464325.000000"
        },
        "attachments": [
            {
                "fallback": "<https://twitter.com/jackrusher|@jackrusher>: <https://twitter.com/plexus|@plexus> I'm sad so many better things that came before the web were ignored during the development of those standards. The tragedy of Unix is the inverse: it was just good enough to block the better things that came after (e.g. Plan9).:man-shrugging::skin-tone-2:",
                "ts": 1606384945,
                "author_name": "\u2e18Jack Rusher\u203d",
                "author_link": "https://twitter.com/jackrusher/status/1331901111620481025",
                "author_icon": "https://pbs.twimg.com/profile_images/931507447088500736/j50JPYN5_normal.jpg",
                "author_subname": "@jackrusher",
                "text": "<https://twitter.com/plexus|@plexus> I'm sad so many better things that came before the web were ignored during the development of those standards. The tragedy of Unix is the inverse: it was just good enough to block the better things that came after (e.g. Plan9).:man-shrugging::skin-tone-2:",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/jackrusher/status/1331901111620481025",
                "id": 1,
                "original_url": "https://twitter.com/jackrusher/status/1331901111620481025",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PAjy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UN9SCH5RD"
                            },
                            {
                                "type": "text",
                                "text": " \"for all nice things people say about the wisdom of unix there's little talk about the ugly parts\"\nIt's not like we haven't been talking about this for decades: "
                            },
                            {
                                "type": "link",
                                "url": "http://doc.cat-v.org/bell_labs/structural_regexps/se.pdf"
                            },
                            {
                                "type": "text",
                                "text": "\n\nJust yesterday: "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/jackrusher/status/1331901111620481025"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UN9SCH5RD",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "3543cf28-0f49-4571-aa8a-5ce411961ee5",
        "type": "message",
        "text": "Its almost as if history moves forward as a kind of dialectic and unix was a thesis and smalltalk (maybe) was an anti-thesis and now we wait for synthesis which create something with best of both worlds. Its just taking so long",
        "user": "UJFN50C00",
        "ts": "1606467048.155500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/xXC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Its almost as if history moves forward as a kind of dialectic and unix was a thesis and smalltalk (maybe) was an anti-thesis and now we wait for synthesis which create something with best of both worlds. Its just taking so long"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3be27a48-dda7-4b54-8ced-55e178fb8196",
        "type": "message",
        "text": "&gt; I feel like shells could work closer to IDEs, with inline documentation, autocompletion and solid language oriented tools, it doesn't feel like scifi, it feels doable.\n<@UN9SCH5RD> - have you looked into the Genera Lisp Machines? It comes very close to what you are describing. Each \"function\" is available at the \"shell\" (they call it something else, I think \"listener\"?). When you invoke a function from the listener, it does have autocomplete. E.g. if it accepts a file, all the filenames on the screen will \"light up\" and become clickable. This works because fundamentally it is not dumping streams of text on a tty, but _attaching presentation objects on the screen_ - so each visible presentation is linked to the backing object and its type is available to the system. There are some details in this short demo: <https://www.youtube.com/watch?v=o4-YnLpLgtk>.\n\nYou can also introspect and jump to source from the listener. I linked to a twitter thread about some more features: <https://twitter.com/chatur_shalabh/status/1213740969201262593>. Also check out <http://lispm.de/genera-concepts> (section \"Data Level Integration\")",
        "user": "U8A5MS6R1",
        "ts": "1606474471.156100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1606474490.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zqh7",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I feel like shells could work closer to IDEs, with inline documentation, autocompletion and solid language oriented tools, it doesn't feel like scifi, it feels doable."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UN9SCH5RD"
                            },
                            {
                                "type": "text",
                                "text": " - have you looked into the Genera Lisp Machines? It comes very close to what you are describing. Each \"function\" is available at the \"shell\" (they call it something else, I think \"listener\"?). When you invoke a function from the listener, it does have autocomplete. E.g. if it accepts a file, all the filenames on the screen will \"light up\" and become clickable. This works because fundamentally it is not dumping streams of text on a tty, but "
                            },
                            {
                                "type": "text",
                                "text": "attaching presentation objects on the screen",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " - so each visible presentation is linked to the backing object and its type is available to the system. There are some details in this short demo: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=o4-YnLpLgtk"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nYou can also introspect and jump to source from the listener. I linked to a twitter thread about some more features: "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/chatur_shalabh/status/1213740969201262593"
                            },
                            {
                                "type": "text",
                                "text": ". Also check out "
                            },
                            {
                                "type": "link",
                                "url": "http://lispm.de/genera-concepts"
                            },
                            {
                                "type": "text",
                                "text": " (section \"Data Level Integration\")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UN9SCH5RD",
                    "UMVFWPZ36"
                ],
                "count": 2
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d7becfd5-0c83-4563-9df5-c8a20ab21421",
        "type": "message",
        "text": "&gt;  for all nice things people say about the wisdom of unix\nSome say fewer nice things than others :wink:.\n\nI'm starting to think the primary purpose of an OS is providing _composition models_ which subsumes the abstract objects they provide. E.g. the Unix models are the C ABI, bytestream pipes, command shells and the rest are built on top of these. The concepts of processes and files sort of live within these models.",
        "user": "U8A5MS6R1",
        "ts": "1606475174.156800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k8uH",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " for all nice things people say about the wisdom of unix"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some say fewer nice things than others "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nI'm starting to think the primary purpose of an OS is providing "
                            },
                            {
                                "type": "text",
                                "text": "composition models",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " which subsumes the abstract objects they provide. E.g. the Unix models are the C ABI, bytestream pipes, command shells and the rest are built on top of these. The concepts of processes and files sort of live within these models."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFEQUBNNT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b37f9392-8245-4bf4-bddc-3ca1622e64ee",
        "type": "message",
        "text": "haven't seen the lisp machines demo before, really cool",
        "user": "UN9SCH5RD",
        "ts": "1606475727.157200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YNOWa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "haven't seen the lisp machines demo before, really cool"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "d670c3f7-ae74-465d-a8e2-ec56724e7fa9",
        "type": "message",
        "text": "<@U8A5MS6R1> An example of a less nice thing :joy_cat:\n&gt; _\u201cI liken starting one\u2019s computing career with Unix, say as an under- graduate, to being born in East Africa. It is intolerably hot, your body is covered with lice and flies, you are malnourished and you suffer from numerous curable diseases. But, as far as young East Africans can tell, this is simply the natural condition and they live within it. By the time they find out differently, it is too late. They already think that the writing of shell scripts is a natural act.\u201d_\n&gt; \u2014 Ken Pier, Xerox PARC\n(taken, of course, from *The UNIX- HATERS Handbook* <https://en.wikipedia.org/wiki/The_UNIX-HATERS_Handbook|wiki>, <http://web.mit.edu/~simsong/www/ugh.pdf|pdf>)",
        "user": "U013ZLJARC7",
        "ts": "1606485554.157500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nAU5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " An example of a less nice thing "
                            },
                            {
                                "type": "emoji",
                                "name": "joy_cat"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\u201cI liken starting one\u2019s computing career with Unix, say as an under- graduate, to being born in East Africa. It is intolerably hot, your body is covered with lice and flies, you are malnourished and you suffer from numerous curable diseases. But, as far as young East Africans can tell, this is simply the natural condition and they live within it. By the time they find out differently, it is too late. They already think that the writing of shell scripts is a natural act.\u201d",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\u2014 Ken Pier, Xerox PARC"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(taken, of course, from "
                            },
                            {
                                "type": "text",
                                "text": "The UNIX- HATERS Handbook",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/The_UNIX-HATERS_Handbook",
                                "text": "wiki"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "http://web.mit.edu/~simsong/www/ugh.pdf",
                                "text": "pdf"
                            },
                            {
                                "type": "text",
                                "text": ")"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "grin",
                "users": [
                    "UN9SCH5RD",
                    "UMVFWPZ36"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "70039BA6-4B3E-47CB-8B6F-13D2101D0939",
        "type": "message",
        "text": "infra is another stab at this problem <http://www.infra-structure.org/specification.html|http://www.infra-structure.org/specification.html>",
        "user": "UHWC9PXBL",
        "ts": "1606492223.157900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zuNe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "infra is another stab at this problem "
                            },
                            {
                                "type": "link",
                                "url": "http://www.infra-structure.org/specification.html",
                                "text": "http://www.infra-structure.org/specification.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "4389BAC6-8854-461B-AA7C-77EBD31A351A",
        "type": "message",
        "text": "Interesting, also incomplete and already abandoned? (Is the Working Group active?)",
        "user": "USH01JEDQ",
        "ts": "1606495030.158700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "USH01JEDQ",
            "ts": "1606495084.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wLzT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting, also incomplete and already abandoned? (Is the Working Group active?)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "01cda609-896f-4c4b-9040-6677ef109a7c",
        "type": "message",
        "text": "\"There is a long and sordid history of numerous attempts to bridge composition barriers: CORBA, COM, D-Bus, XML-RPC, SOAP, Protocol Buffers, JSON, the list goes on.\" We only need 1 more: Tree/2-D Notation  :)",
        "user": "UMVFWPZ36",
        "ts": "1606514948.159500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zSg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"There is a long and sordid history of numerous attempts to bridge composition barriers: CORBA, COM, D-Bus, XML-RPC, SOAP, Protocol Buffers, JSON, the list goes on.\" We only need 1 more: Tree/2-D Notation  :)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "scream",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "73f40f3f-4f1b-44a3-a996-928838e48e39",
        "type": "message",
        "text": "another one: <https://concise-encoding.org/>",
        "user": "UN9SCH5RD",
        "ts": "1606516076.159800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Concise Encoding",
                "title_link": "https://concise-encoding.org/",
                "text": "The friendly data format for human and machine. Think JSON, but with 1:1 compatible twin binary and text formats, and rich type support.",
                "fallback": "Concise Encoding",
                "from_url": "https://concise-encoding.org/",
                "service_name": "concise-encoding.org",
                "id": 1,
                "original_url": "https://concise-encoding.org/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "u3kRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "another one: "
                            },
                            {
                                "type": "link",
                                "url": "https://concise-encoding.org/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            },
            {
                "name": "clap",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ce4bd633-b698-4a4f-93f4-e563b0c01115",
        "type": "message",
        "text": "I think this is a bit of an spinoff this thread (serialization/IDL languages), but there was an interesting <https://news.ycombinator.com/item?id=24994304|thread going on on HN recently>.\n\nTwo type definition languages presented something that I did not think about before when dealing with IDL:\n\u2022 the concept of *equality* (preserves: \"two Values are equal if neither is less than the other according to the total order.\")\n\u2022 a design that ensures that `serialized . deserialize = id`, which may seem obvious but in fact is not trivial.\nI guess there's a reason unix people went with plaintext, they were basically kicking the problem to someone else to deal with (\"do the simplest thing that works\" and such).",
        "user": "UN9SCH5RD",
        "ts": "1606516816.160100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T=j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think this is a bit of an spinoff this thread (serialization/IDL languages), but there was an interesting "
                            },
                            {
                                "type": "link",
                                "url": "https://news.ycombinator.com/item?id=24994304",
                                "text": "thread going on on HN recently"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nTwo type definition languages presented something that I did not think about before when dealing with IDL:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "the concept of "
                                    },
                                    {
                                        "type": "text",
                                        "text": "equality ",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "(preserves: \"two Values are equal if neither is less than the other according to the total order.\")"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "a design that ensures that "
                                    },
                                    {
                                        "type": "text",
                                        "text": "serialized . deserialize = id",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": ", which may seem obvious but in fact is not trivial."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI guess there's a reason unix people went with plaintext, they were basically kicking the problem to someone else to deal with (\"do the simplest thing that works\" and such)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1606359276.136400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    }
]