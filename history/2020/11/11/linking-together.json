[
    {
        "client_msg_id": "8d3ea6fa-eefb-4593-8b6c-73c0584f0e06",
        "type": "message",
        "text": "Just wondering: why is everyone focusing so much on termination? In my personal debugging experience, endless loops are a rare issue and usually found and fixed quickly. As long as the OS allows interrupting a process... what's the problem?",
        "user": "UJBAJNFLK",
        "ts": "1605075904.220300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sfus",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Just wondering: why is everyone focusing so much on termination? In my personal debugging experience, endless loops are a rare issue and usually found and fixed quickly. As long as the OS allows interrupting a process... what's the problem?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1604952430.207700",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "80e3a038-c0c4-4783-9605-2df43ea96e71",
        "type": "message",
        "text": "What I hope to find in the space of Turing-incomplete languages is some form of robustness: ensure that small changes in the input (code + data) of a computation can only lead to small changes in the output. Robustness matters a lot in other forms of engineering - software should have access to it as well.",
        "user": "UJBAJNFLK",
        "ts": "1605076079.220500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9faU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I hope to find in the space of Turing-incomplete languages is some form of robustness: ensure that small changes in the input (code + data) of a computation can only lead to small changes in the output. Robustness matters a lot in other forms of engineering - software should have access to it as well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1604952430.207700",
        "parent_user_id": "UPVBV34EL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5ba9596c-eaf9-4be2-9329-317e4ce13266",
        "type": "message",
        "text": "When you phrase it that way, robustness seems to be the opposite of expressiveness",
        "user": "UT60XSVCN",
        "ts": "1605096979.220800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WTVn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When you phrase it that way, robustness seems to be the opposite of expressiveness"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1604952430.207700",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "381e4946-b8e4-4ca7-8c8f-562258375a78",
        "type": "message",
        "text": "Yes and no. It's the opposite of expressiveness if you think about general-purpose programming. But I am thinking of DSLs. If your robustness criteria are those of the domain you design for, they don't imply a loss of expressiveness.",
        "user": "UJBAJNFLK",
        "ts": "1605113049.221000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "K/N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes and no. It's the opposite of expressiveness if you think about general-purpose programming. But I am thinking of DSLs. If your robustness criteria are those of the domain you design for, they don't imply a loss of expressiveness."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1604952430.207700",
        "parent_user_id": "UPVBV34EL"
    }
]