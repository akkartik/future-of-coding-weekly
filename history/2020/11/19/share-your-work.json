[
    {
        "client_msg_id": "8b8fd8e4-2519-4142-81c4-5087d10cc343",
        "type": "message",
        "text": "Interesting stuff. I am partial to the entity-attribube-value triples so I think this is a good start.\n\n&gt; Being honest to myself, I have to give up some of my language ideas and implement a simpler language.\n+1. I don't think the substrate language should have advanced concepts. It should be something really simple and other features could be added in higher layers",
        "user": "U8A5MS6R1",
        "ts": "1605764593.248600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LiX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Interesting stuff. I am partial to the entity-attribube-value triples so I think this is a good start.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Being honest to myself, I have to give up some of my language ideas and implement a simpler language."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "+1. I don't think the substrate language should have advanced concepts. It should be something really simple and other features could be added in higher layers"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605731807.247500",
        "parent_user_id": "UPX3PH28N"
    },
    {
        "client_msg_id": "7c9b411e-5a5c-46fd-9401-755f7a8e13f8",
        "type": "message",
        "text": "Hey man, I like your thought here and definitely like how you guys have thought of it as a DSL with a compiler creating the output. One thing I have found out as these sort of websites grow in complexity is that it becomes really hard to reason about how components are wired together. Like if you have n number of pages referring m different components, you have n * m different components getting referred and with each layer of recursion on inclusion and cross referencing this really becomes an unwieldly graph. Have you thought about any way to control this kind of complexity? Curious because it is a problem I\u2019m trying to reason about and solve as it reappears in many software engineering contexts.\n\nAnother way I might frame is that, have you thought of any visual ways to represent the dependency graph of the components that the compiler weaves.",
        "user": "UDKTZSD6H",
        "ts": "1605777069.249100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UDKTZSD6H",
            "ts": "1605777167.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gM2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hey man, I like your thought here and definitely like how you guys have thought of it as a DSL with a compiler creating the output. One thing I have found out as these sort of websites grow in complexity is that it becomes really hard to reason about how components are wired together. Like if you have n number of pages referring m different components, you have n * m different components getting referred and with each layer of recursion on inclusion and cross referencing this really becomes an unwieldly graph. Have you thought about any way to control this kind of complexity? Curious because it is a problem I\u2019m trying to reason about and solve as it reappears in many software engineering contexts.\n\nAnother way I might frame is that, have you thought of any visual ways to represent the dependency graph of the components that the compiler weaves."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605630429.212300",
        "parent_user_id": "UUB7RA7PF"
    },
    {
        "client_msg_id": "d352e858-d697-4494-a82b-cf2d532dd675",
        "type": "message",
        "text": "Browser based at the moment.",
        "user": "UEBG0NPDK",
        "ts": "1605805498.249900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "K8rP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Browser based at the moment."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK"
    },
    {
        "client_msg_id": "1eb05987-bcf2-4705-9737-4d34b086b0ec",
        "type": "message",
        "text": "Yeah the original mad-lib version of Eve was fun :slightly_smiling_face: A big problem with it though is that while it read like english, it didn\u2019t have the mental model that people actually have. As you pointed out, this definitely isn\u2019t datalog, it\u2019s basically just an imperative language (though with some interesting twists that we\u2019ll see later). That change makes actually using these two things wildly different. As an example, we sat down to write a few larger programs, one of which was an implementation of the board game terraforming mars. The result was something that reads shockingly close to what you see in the game manual. The Eve version would\u2019ve looked nothing like it.",
        "user": "UEBG0NPDK",
        "ts": "1605805741.250100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ijPgf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah the original mad-lib version of Eve was fun "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " A big problem with it though is that while it read like english, it didn\u2019t have the mental model that people actually have. As you pointed out, this definitely isn\u2019t datalog, it\u2019s basically just an imperative language (though with some interesting twists that we\u2019ll see later). That change makes actually using these two things wildly different. As an example, we sat down to write a few larger programs, one of which was an implementation of the board game terraforming mars. The result was something that reads shockingly close to what you see in the game manual. The Eve version would\u2019ve looked nothing like it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c4fbd3fa-5ade-4d16-b43b-33266cffe249",
        "type": "message",
        "text": "the other side of the equation is that the tooling itself is very different here. The schematic constantly adapts to what you\u2019re focused on at the moment. This helps address the problem I bring up a few minutes after where you linked in that video. Datalog scatters logic all over the place and we never could really figure out good way to help you answer the question \u201cwhat is this doing?\u201d But we can with imperative English. For one, it\u2019s largely self-summarizing, but even more importantly you are constructing intentional lines of execution rather than accidental ones. With some clever analysis and tooling on top, we can take advantage of that to tell you at any point in the system what\u2019s important. What are the effects of what I\u2019m looking at right now? If I change this what else will change? While it\u2019s technically possible to know that in a datalog program, it\u2019s hard to explain it to the user programmatically because there\u2019s nothing that ties it together. Processes fix that for us and so our tools can do some really awesome things.",
        "user": "UEBG0NPDK",
        "ts": "1605806186.250300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Q5h",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the other side of the equation is that the tooling itself is very different here. The schematic constantly adapts to what you\u2019re focused on at the moment. This helps address the problem I bring up a few minutes after where you linked in that video. Datalog scatters logic all over the place and we never could really figure out good way to help you answer the question \u201cwhat is this doing?\u201d But we can with imperative English. For one, it\u2019s largely self-summarizing, but even more importantly you are constructing intentional lines of execution rather than accidental ones. With some clever analysis and tooling on top, we can take advantage of that to tell you at any point in the system what\u2019s important. What are the effects of what I\u2019m looking at right now? If I change this what else will change? While it\u2019s technically possible to know that in a datalog program, it\u2019s hard to explain it to the user programmatically because there\u2019s nothing that ties it together. Processes fix that for us and so our tools can do some really awesome things."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK",
        "reactions": [
            {
                "name": "open_mouth",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "55979366-5a3c-4c13-b75e-6659f6147145",
        "type": "message",
        "text": "The other part of my argument against executable specifications (that they require knowing everything above where you\u2019re currently reading) is helped by the schematic stuff I said above, but is also more fundamentally addressed by the semantics of gadgets and parts. Concepts are modeled as parts and you slot those into gadgets, which naturally turns monolithic specifications into small composable ones. To give an example, we could create a part for \u201cwet\u201d that has some specific behavior attached to it and then give that to any arbitrary thing in the system. This makes it truly behave like natural language where we don\u2019t need to understand everything about \u201cwet.\u201d We can just take a dog and add the wet part to it.",
        "user": "UEBG0NPDK",
        "ts": "1605806755.250500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZX=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The other part of my argument against executable specifications (that they require knowing everything above where you\u2019re currently reading) is helped by the schematic stuff I said above, but is also more fundamentally addressed by the semantics of gadgets and parts. Concepts are modeled as parts and you slot those into gadgets, which naturally turns monolithic specifications into small composable ones. To give an example, we could create a part for \u201cwet\u201d that has some specific behavior attached to it and then give that to any arbitrary thing in the system. This makes it truly behave like natural language where we don\u2019t need to understand everything about \u201cwet.\u201d We can just take a dog and add the wet part to it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK"
    },
    {
        "client_msg_id": "74dea1c6-bddb-4f9c-a693-eda3c4e5e509",
        "type": "message",
        "text": "<@UK3LH8CF5> ^",
        "user": "UEBG0NPDK",
        "ts": "1605807969.250700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oIw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UK3LH8CF5"
                            },
                            {
                                "type": "text",
                                "text": " ^"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK"
    },
    {
        "client_msg_id": "659700a5-1a45-4b87-be01-c2f4922bf2f6",
        "type": "message",
        "text": "Thanks, that's really instructive for understanding the difference. I am going to be really interested to see this play out. It seems like there is an interesting full circle going on here with the ECS system in light table (with some various obvious differences). But also interesting how you went from functional (aurora), to logical (eve), and now to imperative.\n\nDefinitely going to be interested to see how those twists and how the type system comes into play. I love the usage of a board game as an example. Seems like the right level of complexity, with clarity because it becomes really a translation problem. Can't wait to see more.",
        "user": "UK3LH8CF5",
        "ts": "1605811660.250900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vgb4Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks, that's really instructive for understanding the difference. I am going to be really interested to see this play out. It seems like there is an interesting full circle going on here with the ECS system in light table (with some various obvious differences). But also interesting how you went from functional (aurora), to logical (eve), and now to imperative.\n\nDefinitely going to be interested to see how those twists and how the type system comes into play. I love the usage of a board game as an example. Seems like the right level of complexity, with clarity because it becomes really a translation problem. Can't wait to see more."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1605645239.224300",
        "parent_user_id": "UEBG0NPDK"
    }
]