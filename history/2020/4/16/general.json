[
    {
        "type": "message",
        "text": "was thinking about \"comment-driven development\" a while back and came up with this sketch: typically when i'm writing a complex series of transformations, i'll write out all the steps in individual comments and then \"fill in the blanks\" with code once i have an outline for the whole transformation. would be interesting to have the comments exist as \"blocks\" that could be expanded and contracted (and nested?) so you'd be able to zoom out and see the entire system at a glance without looking at the code",
        "files": [
            {
                "id": "F011GPZUNDV",
                "created": 1586994540,
                "timestamp": 1586994540,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UG0EL18H3",
                "editable": false,
                "size": 382922,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F011GPZUNDV/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F011GPZUNDV/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 248,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 330,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 496,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 551,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 661,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-F011GPZUNDV-ce42664746/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 705,
                "original_w": 2252,
                "original_h": 1550,
                "thumb_tiny": "AwAhADDRNGaDjPNHHoaAAHmg9aQflQRz14oAXNAJzSY+v5UAc0AKev40dqXHWkxQADrSn+tJjBpfWgBKB1oxRjFAAetJSnrSUAKOtDdaB1obrQAlKOtJSjrQB//Z",
                "permalink": "https://futureofcoding.slack.com/files/UG0EL18H3/F011GPZUNDV/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F011GPZUNDV-8f60e5c0f6",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "15d=8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "was thinking about \"comment-driven development\" a while back and came up with this sketch: typically when i'm writing a complex series of transformations, i'll write out all the steps in individual comments and then \"fill in the blanks\" with code once i have an outline for the whole transformation. would be interesting to have the comments exist as \"blocks\" that could be expanded and contracted (and nested?) so you'd be able to zoom out and see the entire system at a glance without looking at the code"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UG0EL18H3",
        "display_as_bot": false,
        "ts": "1586994546.454900",
        "client_msg_id": "95f5bc68-48fb-4dc0-a936-b46fcca1be81",
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "262e9f27-c0bb-4f4d-8b40-e2e299a739f2",
        "type": "message",
        "text": "<@UML4ZEKDK>: \"anti-post\" - You mean like BV's \"Future of programming\"?\n\n<https://youtu.be/8pTEmbeENF4|https://youtu.be/8pTEmbeENF4>",
        "user": "UAVCC2X70",
        "ts": "1587010204.455700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Bret Victor   The Future of Programming",
                "title_link": "https://youtu.be/8pTEmbeENF4",
                "author_name": "Joey Reid",
                "author_link": "https://www.youtube.com/channel/UCrsAgqP6k_aVMD2cPr1194g",
                "thumb_url": "https://i.ytimg.com/vi/8pTEmbeENF4/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Bret Victor   The Future of Programming",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/8pTEmbeENF4?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://youtu.be/8pTEmbeENF4",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://youtu.be/8pTEmbeENF4"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Hbk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UML4ZEKDK"
                            },
                            {
                                "type": "text",
                                "text": ": \"anti-post\" - You mean like BV's \"Future of programming\"?\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/8pTEmbeENF4",
                                "text": "https://youtu.be/8pTEmbeENF4"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586818028.382000",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "63D8BF46-AB8A-4210-BBCB-7289F537BD4E",
        "type": "message",
        "text": "<https://twitter.com/jonathoda/status/1250477469032996872|https://twitter.com/jonathoda/status/1250477469032996872>",
        "user": "USH01JEDQ",
        "ts": "1587014414.456100",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/jonathoda|@jonathoda>: The <https://twitter.com/airtable|@airtable>  scripting environment. Interesting tradeoffs. JS. Terminal-like interaction. Nice auto-completion on APIs and user data model. Nice tethered docs with runnable examples customized to user data model. via <https://twitter.com/geoffreylitt|@geoffreylitt> \n<https://airtable.news/creating-a-scripting-environment-for-airtable-that-anyone-can-use-21a43e5de841>",
                "ts": 1586972036,
                "author_name": "Jonathan Edwards",
                "author_link": "https://twitter.com/jonathoda/status/1250477469032996872",
                "author_icon": "https://pbs.twimg.com/profile_images/587356046223486976/Si4vWb1__normal.jpg",
                "author_subname": "@jonathoda",
                "text": "The <https://twitter.com/airtable|@airtable>  scripting environment. Interesting tradeoffs. JS. Terminal-like interaction. Nice auto-completion on APIs and user data model. Nice tethered docs with runnable examples customized to user data model. via <https://twitter.com/geoffreylitt|@geoffreylitt> \n<https://airtable.news/creating-a-scripting-environment-for-airtable-that-anyone-can-use-21a43e5de841>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/jonathoda/status/1250477469032996872",
                "id": 1,
                "original_url": "https://twitter.com/jonathoda/status/1250477469032996872",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "S7I0=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://twitter.com/jonathoda/status/1250477469032996872",
                                "text": "https://twitter.com/jonathoda/status/1250477469032996872"
                            }
                        ]
                    }
                ]
            }
        ],
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UE0ETTCG7",
                    "UJ6LDMMN0"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "21e06058-e1cc-4c34-bddd-cd1a9da98ac3",
        "type": "message",
        "text": "Similar to this is gradual typing where you start \"sloppy\" and gradually add guarantees to your code. It's an area of active research (typescript being the most well known)",
        "user": "UN57U8V53",
        "ts": "1587015827.456500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4Gz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Similar to this is gradual typing where you start \"sloppy\" and gradually add guarantees to your code. It's an area of active research (typescript being the most well known)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "0bbdd0b8-2f8b-4183-ac86-8e7d8d07c966",
        "type": "message",
        "text": "It all depends on your definition of working. We could easily make a language where every library/function had a default (noop) and only good states could be entered (like scratch). But does it really help you sketch out your idea?",
        "user": "UN57U8V53",
        "ts": "1587016117.456700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SRsMJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It all depends on your definition of working. We could easily make a language where every library/function had a default (noop) and only good states could be entered (like scratch). But does it really help you sketch out your idea?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "E1BEAD03-77B3-4CB1-BFB0-A591DB18F248",
        "type": "message",
        "text": "<@UBSMEUXAA> Thanks for sharing that talk. I hadn\u2019t seen it. I obviously love how he approached the design of his fantasy consoles. So many thoughtful design decisions! For instance moving from a character limit to a token limit to rectify a bias towards minification and encourage shareable code. Love this stuff.",
        "user": "U5STGTB3J",
        "ts": "1587033153.466800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4AB3C",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBSMEUXAA"
                            },
                            {
                                "type": "text",
                                "text": " Thanks for sharing that talk. I hadn\u2019t seen it. I obviously love how he approached the design of his fantasy consoles. So many thoughtful design decisions! For instance moving from a character limit to a token limit to rectify a bias towards minification and encourage shareable code. Love this stuff."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586906564.409300",
        "parent_user_id": "U5STGTB3J"
    },
    {
        "client_msg_id": "4b9546d5-ad3a-4f4c-9785-fe2f370f2f97",
        "type": "message",
        "text": "(<@UG0EL18H3> I'm working on something like that! I imagine there is a gradient from detailed/machine code implementation - to abstract/natural language description; Imagine if you're able to start out each \"block\" at any level, and then iteratively add details as needed. Combine that with an auto-complete that works more like google search than word completion, but context sensitive, and somewhat semi-structured such that some computer-processable \"meaning\" may be derived (declarative probably preferred); Then, the \"comments\"/most abstract/top-most (as in top-down) \"notes\" would \"always\" be \"in sync\" with the implementation, and you'd have something \"useful\" at each level of detail)",
        "user": "UNCP67JSK",
        "ts": "1587049093.467200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "frF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "("
                            },
                            {
                                "type": "user",
                                "user_id": "UG0EL18H3"
                            },
                            {
                                "type": "text",
                                "text": " I'm working on something like that! I imagine there is a gradient from detailed/machine code implementation - to abstract/natural language description; Imagine if you're able to start out each \"block\" at any level, and then iteratively add details as needed. Combine that with an auto-complete that works more like google search than word completion, but context sensitive, and somewhat semi-structured such that some computer-processable \"meaning\" may be derived (declarative probably preferred); Then, the \"comments\"/most abstract/top-most (as in top-down) \"notes\" would \"always\" be \"in sync\" with the implementation, and you'd have something \"useful\" at each level of detail)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "6bc8a574-7ea8-4800-9b13-f3f94c8c934b",
        "type": "message",
        "text": "i've been using \"outliner\" apps for the last few months (OmniOutliner, specifically) to jot down thoughts and keep notes in a more structured way. what i've found is that the outline medium contributes greatly to the breadth of what i'm trying to express and allows me to both dive deeper to add detail or collapse elements to see the bigger picture. (which is tangential, but related to what <@UN57U8V53> said about starting \"sloppy\" and adding guarantees). as far as what you're building <@UNCP67JSK>, it seems like the real utility there is in the comment blocks that you get \"for free\" as a result of building them first. a point of contention though: how do you make sure that when you change the code at a lower level, that it will \"line up\" with the comment you wrote before? what happens when your mental model for how it _*should*_ behave or be built differs substantially from how you actually end up implementing it? the nice part about using types as your guide, as Don alluded to, is that they are an intrinsic part of the code: if the types don't line up with the values you're passing in, your program won't compile. how can we make the same guarantees for natural language?",
        "user": "UG0EL18H3",
        "ts": "1587051374.467500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "byN+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "i've been using \"outliner\" apps for the last few months (OmniOutliner, specifically) to jot down thoughts and keep notes in a more structured way. what i've found is that the outline medium contributes greatly to the breadth of what i'm trying to express and allows me to both dive deeper to add detail or collapse elements to see the bigger picture. (which is tangential, but related to what "
                            },
                            {
                                "type": "user",
                                "user_id": "UN57U8V53"
                            },
                            {
                                "type": "text",
                                "text": " said about starting \"sloppy\" and adding guarantees). as far as what you're building "
                            },
                            {
                                "type": "user",
                                "user_id": "UNCP67JSK"
                            },
                            {
                                "type": "text",
                                "text": ", it seems like the real utility there is in the comment blocks that you get \"for free\" as a result of building them first. a point of contention though: how do you make sure that when you change the code at a lower level, that it will \"line up\" with the comment you wrote before? what happens when your mental model for how it "
                            },
                            {
                                "type": "text",
                                "text": "should",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "behave or be built differs substantially from how you actually end up implementing it? the nice part about using types as your guide, as Don alluded to, is that they are an intrinsic part of the code: if the types don't line up with the values you're passing in, your program won't compile. how can we make the same guarantees for natural language?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    },
    {
        "client_msg_id": "e6578cd2-c8e5-4ef4-8cd9-b0584619f9f9",
        "type": "message",
        "text": "Yeah, sadly they are usually \"adjunctions\" rather than \"isomorphisms\" (sorry for the vocab)",
        "user": "UN57U8V53",
        "ts": "1587051494.467700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ec=C",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, sadly they are usually \"adjunctions\" rather than \"isomorphisms\" (sorry for the vocab)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1586957244.445200",
        "parent_user_id": "USUMN6XLH"
    }
]