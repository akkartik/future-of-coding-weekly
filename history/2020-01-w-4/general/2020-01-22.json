[
    {
        "client_msg_id": "680af047-d057-4f3b-be82-31b65fa51cba",
        "type": "message",
        "text": "A wonderful lecture from a grizzled veteran. He may not have the answers, but he is very clear on the problems. He wanted to see physical units of measurement, and a syntax for a finite state machine, both of which are in the Beads syntax. I am pondering his proposal to have both a unit of time and a time interval type. Most people think of a time interval as a non-dimensional quantity (if you assume seconds).  Will have to think about that.  If you clutter up the language with too many primitive types it can get cumbersome.",
        "user": "UEQ6M68H0",
        "ts": "1579666086.242300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1579666254.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mQY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A wonderful lecture from a grizzled veteran. He may not have the answers, but he is very clear on the problems. He wanted to see physical units of measurement, and a syntax for a finite state machine, both of which are in the Beads syntax. I am pondering his proposal to have both a unit of time and a time interval type. Most people think of a time interval as a non-dimensional quantity (if you assume seconds).  Will have to think about that.  If you clutter up the language with too many primitive types it can get cumbersome."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "aec7324f-1ad0-4ca0-be72-150a38f2d625",
        "type": "message",
        "text": "Part of the challenge is that the programming world is a lot bigger with a lot more noise these days.  There may be a strong signal, but unless you're tuned to it.",
        "user": "UA14TGLTC",
        "ts": "1579676532.242800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "aNF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Part of the challenge is that the programming world is a lot bigger with a lot more noise these days.  There may be a strong signal, but unless you're tuned to it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "a55419bd-26f5-4d86-bbea-73cd4d360839",
        "type": "message",
        "text": "I suspect the problem with applying this idea to software design is step 3 - we have no idea how to define an equivalent of wiggle room. Related reading: \"Building robust systems\" by G Sussman. <http://sites.google.com/site/adaptiveunm/seminar/paper_suggestions/robust-systems.pdf>",
        "user": "UJBAJNFLK",
        "ts": "1579680957.243000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JrZW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I suspect the problem with applying this idea to software design is step 3 - we have no idea how to define an equivalent of wiggle room. Related reading: \"Building robust systems\" by G Sussman. "
                            },
                            {
                                "type": "link",
                                "url": "http://sites.google.com/site/adaptiveunm/seminar/paper_suggestions/robust-systems.pdf"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579640836.237100",
        "parent_user_id": "UQ706GB9U",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U8A5MS6R1",
                    "USJK2D2H3"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "d8bb9754-d30f-426b-a094-59834cb51f8c",
        "type": "message",
        "text": "<@UFB8STN7K> I agree with you, but the problem for practitioners is that the results of PL theory are out of reach for them. Academics implement their ideas in languages that are easy for them to work on, do a few test applications, and then move on to other subjects. Programmers need programming languages with strong ecosystems of tools and libraries. There is little overlap between the two worlds. Plus, as <@UA14TGLTC> points out, there is so much noise interfering with communication.",
        "user": "UJBAJNFLK",
        "ts": "1579681297.243200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "WwR+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFB8STN7K"
                            },
                            {
                                "type": "text",
                                "text": " I agree with you, but the problem for practitioners is that the results of PL theory are out of reach for them. Academics implement their ideas in languages that are easy for them to work on, do a few test applications, and then move on to other subjects. Programmers need programming languages with strong ecosystems of tools and libraries. There is little overlap between the two worlds. Plus, as "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " points out, there is so much noise interfering with communication."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bb46feaa-ee84-48c2-8fba-d889c34e7933",
        "type": "message",
        "text": "<@UJBAJNFLK> For sure, I think this guy\u2019s concerns are super reasonable. This presentation would have been great if he just explained about how existing PLs failed based on his long experience building interesting systems. I\u2019m just taking umbrage at the historical revisionism that makes him call math the root of his problems.",
        "user": "UFB8STN7K",
        "ts": "1579681546.243700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bqcj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " For sure, I think this guy\u2019s concerns are super reasonable. This presentation would have been great if he just explained about how existing PLs failed based on his long experience building interesting systems. I\u2019m just taking umbrage at the historical revisionism that makes him call math the root of his problems."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "7297413c-2293-4321-9694-39e5cc034f0e",
        "type": "message",
        "text": "And I do genuinely believe that the theories being developed in the PL world will ultimately be what he wants in his DSLs. For example, embedding a dimensional analysis system in a language like Rust is due to innovations in type systems that have spilled into real world languages.",
        "user": "UFB8STN7K",
        "ts": "1579681659.243900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eIy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And I do genuinely believe that the theories being developed in the PL world will ultimately be what he wants in his DSLs. For example, embedding a dimensional analysis system in a language like Rust is due to innovations in type systems that have spilled into real world languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "163acb4f-c357-433e-957e-6a66bc885872",
        "type": "message",
        "text": "<@U8A5MS6R1> I am aware of one type system implementation that fits roughtly what you describe: the one in Shen (<http://shenlanguage.org/>). The type checker is an optional tool, you can switch it off. Which implies that types have no influence on the run-time behavior of the code, and run-time type checking is still there. Any property that can be tested can be turned into a type, but you then have to supply deduction rules to extend the type checker. I am not sure if types and deduction rules can be added per module rather than globally, that could be interesting. And of course you are completely free to write alternative or additional type checkers in Shen, though I doubt anyone has done this.",
        "user": "UJBAJNFLK",
        "ts": "1579681764.244100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d=s+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " I am aware of one type system implementation that fits roughtly what you describe: the one in Shen ("
                            },
                            {
                                "type": "link",
                                "url": "http://shenlanguage.org/"
                            },
                            {
                                "type": "text",
                                "text": "). The type checker is an optional tool, you can switch it off. Which implies that types have no influence on the run-time behavior of the code, and run-time type checking is still there. Any property that can be tested can be turned into a type, but you then have to supply deduction rules to extend the type checker. I am not sure if types and deduction rules can be added per module rather than globally, that could be interesting. And of course you are completely free to write alternative or additional type checkers in Shen, though I doubt anyone has done this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579556106.218100",
        "parent_user_id": "U5STGTB3J",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a69ea43e-109b-4a61-b477-c7a730917f9a",
        "type": "message",
        "text": "Good point. F# is another example. But dimensional analysis is also a good example to illustrate the communication issues between academia and software development. For years I have seen static typing fanboys citing it as an example for why static typing is great, and for a while I took pleasure in commenting that no mainstream type system can actually be used to implement dimensional analysis. One reason is that it requires dependent types (not necessarily full-blown, but more than standard type systems can handle). The other reason is that is applies only to a subset of variables in a program, so any type system that insists on every variable having exactly one type is unsuitable for dimensional analysis.",
        "user": "UJBAJNFLK",
        "ts": "1579682090.244300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ejrD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Good point. F# is another example. But dimensional analysis is also a good example to illustrate the communication issues between academia and software development. For years I have seen static typing fanboys citing it as an example for why static typing is great, and for a while I took pleasure in commenting that no mainstream type system can actually be used to implement dimensional analysis. One reason is that it requires dependent types (not necessarily full-blown, but more than standard type systems can handle). The other reason is that is applies only to a subset of variables in a program, so any type system that insists on every variable having exactly one type is unsuitable for dimensional analysis."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "a2872604-f0db-481d-ac6b-79d21fac54ac",
        "type": "message",
        "text": "would the set of available methods constitute as the wiggle room?",
        "user": "URV7B2542",
        "ts": "1579713306.244900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qKk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "would the set of available methods constitute as the wiggle room?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579640836.237100",
        "parent_user_id": "UQ706GB9U"
    },
    {
        "client_msg_id": "bad67580-9f9e-4bfb-9166-ea109f8abea0",
        "type": "message",
        "text": "otherwise you create a new method",
        "user": "URV7B2542",
        "ts": "1579713312.245100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uVIU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "otherwise you create a new method"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579640836.237100",
        "parent_user_id": "UQ706GB9U"
    },
    {
        "type": "message",
        "text": "I didn't think the position was anti-math as much as saying that math is only one slice but building systems involves all these other non mathy things. Here's the list of things:",
        "files": [
            {
                "id": "FSN1DU1FV",
                "created": 1579715753,
                "timestamp": 1579715753,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "U8A5MS6R1",
                "editable": false,
                "size": 257067,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-FSN1DU1FV/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-FSN1DU1FV/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 203,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 270,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_160.png",
                "thumb_720": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_720.png",
                "thumb_720_w": 720,
                "thumb_720_h": 405,
                "thumb_800": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_800.png",
                "thumb_800_w": 800,
                "thumb_800_h": 450,
                "thumb_960": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_960.png",
                "thumb_960_w": 960,
                "thumb_960_h": 540,
                "thumb_1024": "https://files.slack.com/files-tmb/T5TCAFTA9-FSN1DU1FV-c170112878/image_1024.png",
                "thumb_1024_w": 1024,
                "thumb_1024_h": 576,
                "image_exif_rotation": 1,
                "original_w": 1280,
                "original_h": 720,
                "thumb_tiny": "AwAbADCrZKHukU9Dn+VaX2ePd90/nWdYf8fkf4/yrXIy1A02iL7Mn93/AMe/+tSG1jJ5U/8AfVTnOOcU3zk9T+VKyDmfcj+xw+jfnWbefu7l0UnaMdfpWt5yep/Ksm+IN25Ht/KmHM2Fh/x+R/j/ACrW2nP3j+dY0BKyqV4P/wBarPny/wB80CNHae+fzo2DuP1rP8+X++aPPl/vmgdjQ2L6VkX/ABeP+H8qn8+X++arXB3SMx5PHNAj/9k=",
                "permalink": "https://futureofcoding.slack.com/files/U8A5MS6R1/FSN1DU1FV/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-FSN1DU1FV-e3ad0a0b17",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": true,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p+rR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I didn't think the position was anti-math as much as saying that math is only one slice but building systems involves all these other non mathy things. Here's the list of things:"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "U8A5MS6R1",
        "display_as_bot": false,
        "ts": "1579715758.245300",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1579715772.000000"
        },
        "client_msg_id": "86cb1fb4-856c-4c9b-90ca-e741f723dc52",
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7eeca390-7916-4738-8615-2e2d3944b068",
        "type": "message",
        "text": "Things like usability and evolvability aren't typically considered in the domain of maths. Same thing with DSLs. Being able to build a DSL and having an unambiguous syntax is one thing. But what about the study of what makes a DSL good? How do we evaluate in terms of how it fits the context? Yes we may use some math notation in this kind of study but the study itself is not considered math or even PL, afaik. My sense is that the HCI, design, usability and system integration are not really considered part of PL theory anymore.",
        "user": "U8A5MS6R1",
        "ts": "1579716095.245800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1579716119.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LLvA8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Things like usability and evolvability aren't typically considered in the domain of maths. Same thing with DSLs. Being able to build a DSL and having an unambiguous syntax is one thing. But what about the study of what makes a DSL good? How do we evaluate in terms of how it fits the context? Yes we may use some math notation in this kind of study but the study itself is not considered math or even PL, afaik. My sense is that the HCI, design, usability and system integration are not really considered part of PL theory anymore."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UKASUGYL8",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "0b091657-3327-4c88-ad47-e53203beeabf",
        "type": "message",
        "text": "There\u2019s a _huge difference_ between \u201cmaths\u201d as the set of topics regularly covered in a math major (discrete/real analysis, topology, proofs, etc.) vs. maths as the general study of formal languages x logical systems. The latter, I would, say covers _every single bullet point_ under \u201cnon-functional properties\u201d except for usability. Just look at POPL/PLDI proceedings and you will find papers about all of these topics.\n\nYes, HCI/usability are left out since they aren\u2019t amenable to theory, for all the reasons that people are difficult to model. And I\u2019m the first person to advocate for more HCI in PL, it\u2019s literally my PhD thesis. I\u2019m all for balanced discussions of what problems programmers face in practice, and what methods can help design better tools for them. But thinking mathematically about programming has been, and will continue to be, an invaluable methodology in designing programming systems. Broadly casting aspersions about being too math-focused will not help move the needle.",
        "user": "UFB8STN7K",
        "ts": "1579721027.246100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XRtw8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There\u2019s a "
                            },
                            {
                                "type": "text",
                                "text": "huge difference",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " between \u201cmaths\u201d as the set of topics regularly covered in a math major (discrete/real analysis, topology, proofs, etc.) vs. maths as the general study of formal languages x logical systems. The latter, I would, say covers "
                            },
                            {
                                "type": "text",
                                "text": "every single bullet point",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " under \u201cnon-functional properties\u201d except for usability. Just look at POPL/PLDI proceedings and you will find papers about all of these topics.\n\nYes, HCI/usability are left out since they aren\u2019t amenable to theory, for all the reasons that people are difficult to model. And I\u2019m the first person to advocate for more HCI in PL, it\u2019s literally my PhD thesis. I\u2019m all for balanced discussions of what problems programmers face in practice, and what methods can help design better tools for them. But thinking mathematically about programming has been, and will continue to be, an invaluable methodology in designing programming systems. Broadly casting aspersions about being too math-focused will not help move the needle."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1579645005.241100",
        "parent_user_id": "U8A5MS6R1"
    }
]