[
    {
        "client_msg_id": "C14475E3-A16F-47BD-9DA9-C6E7567EC19F",
        "type": "message",
        "text": "<https://youtu.be/yuk7n43xU4g> can we get this guy in the slack if he\u2019s not already in here?",
        "user": "UHWC9PXBL",
        "ts": "1572392098.347200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Building WebApps Like It's 1972 \ud83e\uddd9\u2642\ufe0fby Leandro Ostera |\u00a0JSConf EU 2019",
                "title_link": "https://youtu.be/yuk7n43xU4g",
                "author_name": "JSConf",
                "author_link": "https://www.youtube.com/user/jsconfeu",
                "thumb_url": "https://i.ytimg.com/vi/yuk7n43xU4g/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Building WebApps Like It's 1972 \ud83e\uddd9\u200d\u2642\ufe0fby Leandro Ostera |\u00a0JSConf EU 2019",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/yuk7n43xU4g?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://youtu.be/yuk7n43xU4g",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://youtu.be/yuk7n43xU4g"
            }
        ]
    },
    {
        "client_msg_id": "f04281b3-b07c-4989-b8a6-6075c334f5bd",
        "type": "message",
        "text": "I used to think talking to users had to be about your product or latest iteration. But sometimes the next iteration would take weeks or months, so there would be no point in talking to users until that was done. I changed my thinking now to consider the 2 completely orthogonal. I schedule meetings to talk/listen to potential users, and more often than not don't talk about my stuff at all, unless I have a new version. What I've found is that it's just often really non-linearly productive to talk to users, who might point you to a product or book or paper that can make a big difference.",
        "user": "UMVFWPZ36",
        "ts": "1572393294.347800",
        "team": "T5TCAFTA9",
        "thread_ts": "1572282098.317700",
        "parent_user_id": "UPV1HUCBH",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UML4ZEKDK",
                    "UEQ7QL15F"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UN6AXQX5W"
                ],
                "count": 1
            },
            {
                "name": "thinking_face",
                "users": [
                    "UPV1HUCBH"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bfb714ce-8cee-49cb-91b8-b65c60314a8e",
        "type": "message",
        "text": "Plus, when you do have a new iteration to share later on, you have a bigger group of people to ping because you've been talking to more and more people over time",
        "user": "UMVFWPZ36",
        "ts": "1572393356.348000",
        "team": "T5TCAFTA9",
        "thread_ts": "1572282098.317700",
        "parent_user_id": "UPV1HUCBH",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UEQ7QL15F"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "770c6d57-6f85-4356-ad67-43aa1a1f699e",
        "type": "message",
        "text": "It is amusing to me that his laptop has an Erlang sticker, when Joe Armstrong, the inventor had such a dim view of the Actor model. There is a lively reunion on YouTube of three famous senior UK computer scientists who each selected a different technology to pursue. One was Hewitt, the actor model, and Armstrong, and Hoare who had some other paradigm i forget which. Anyway they had a debate about what were the results, and Armstrong ripped them to shreds because he pointed out that is system worked and theirs didn't actually work. Pharo has the best IDE i have ever seen, but the underlying language smalltalk was DOA (dead on arrival). The original editions of the smalltalk book by Goldberg are worth a lot, because sensible people like me who bought that book tossed it out because the language is so clunky and hard to read, and frankly absurd. You send the message PLUS to the number 3 along with another operator 2, and then the 3 updates itself to 5. That isn't too far out, but when you get to bitmap manipulation, the model really gets ugly.\n\n The actor model creates not only huge numbers of little islands of state, but then compounds that mistake by creating a message passing system that is hell to debug. In any toolchain that becomes hypercomplex to understand, there are always exceptional people who claim it is no problem, but if you take a big actor model program, and pass it to another programmer, they will have zero chance of understanding it. It becomes a nightmare of dependencies and cross-connections, just like the human body.\n\nI only make these possibly inflammatory remarks to warn people to look up Armstrong's talk, and think twice about wasting your time on a model that has such a legacy of failure.    If someone would like to debate this with me, we can have Steve Krouse act as referee, and hold a fire extinguisher nearby so when you burst into flames you won't be permanently harmed ;-&gt;",
        "user": "UEQ6M68H0",
        "ts": "1572414362.359200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1572503120.000000"
        },
        "thread_ts": "1572414362.359200",
        "reply_count": 30,
        "reply_users_count": 6,
        "latest_reply": "1572553145.430800",
        "reply_users": [
            "ULM3U6275",
            "UBN9AFS0N",
            "UJBAJNFLK",
            "UJN1TAYEQ",
            "U8A5MS6R1",
            "UEQ6M68H0"
        ],
        "subscribed": true,
        "last_read": "1572553145.430800"
    },
    {
        "client_msg_id": "F2EB8313-B7D9-428B-8E11-C751D8E79C34",
        "type": "message",
        "text": "I don\u2019t think Smalltalk numbers are, as you suggest, mutable. Also, Erlang, as I understand it, uses a mutable state actor model.",
        "user": "ULM3U6275",
        "ts": "1572415496.360500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1572415578.000000"
        },
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "72c6a082-8b99-4636-893f-9050d67ab5ec",
        "type": "message",
        "text": "I'm not sure this is relevant but my background in memory constrained apps with lots of data means that macros have to happen at build time not runtime. An example macro might get the size of N files, take tha max size of those sizes, and check that that size is under some specified max size, then use the size of the largest file to statically allocate a specifically sized piece of memory. There is no memory free to include any of this logic at runtime nor could it be done at runtime since if maxsize(files) &gt; maxSizeAvailale the program will crash. That's something we need to catch at build time and fix the files (take out some data, simplifiy something, etc..). And, even if it could be done at runtime it would be a bad user experience waiting for the system to get the max size of N files adding to the wait time for the app to start.\n\nSo at one level I agree it's code transformation all the way down but each transformation stage has a purpose.",
        "user": "UC6997THT",
        "ts": "1572425309.361000",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "8e5ef5bd-f8ee-439b-8c2b-c035f4c5021a",
        "type": "message",
        "text": "Erlang is close to the actor model but not exactly, the creators didn't know about its existence until they already implemented the first erlang prototypes.",
        "user": "UBN9AFS0N",
        "ts": "1572425567.361200",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "1124bc83-cf41-422b-b79a-d53c8a9e10e5",
        "type": "message",
        "text": "Erlang is immutable, the way erlang processes keep state is simply by recursing passing the next state to themselves",
        "user": "UBN9AFS0N",
        "ts": "1572425602.361400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "08b2c240-be6e-40f1-ab21-fd5c17eed496",
        "type": "message",
        "text": "<@UEQ6M68H0> If you believe that Smalltalk was a failure because it applied its OO approach even to arithmetic, you will have to explain why Python, which does exactly the same (up to syntactic sugar) has worked so well for so many people.\n<@ULM3U6275> Smalltalk numbers are indeed immutable, as are characters and booleans but perhaps not much else. The value of immutability was discovered after Smalltalk, and that's perhaps one of its main defects. Pharo is introducing immutability, though in an unusual way (you can set an object to be immutable but also back to mutable).",
        "user": "UJBAJNFLK",
        "ts": "1572425723.361600",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "6c7bcd81-11c6-4c26-b6d0-a52fa5a5efd2",
        "type": "message",
        "text": "I would assume you have few large customers? The average customer value of my customers is so small I'm literally loosing money talking to them - unless it is for learning purposes.",
        "user": "UPV1HUCBH",
        "ts": "1572434287.361900",
        "team": "T5TCAFTA9",
        "thread_ts": "1572282098.317700",
        "parent_user_id": "UPV1HUCBH"
    },
    {
        "client_msg_id": "d5687c59-2e33-4730-94b7-75719c48a603",
        "type": "message",
        "text": "I think the main advantage to talking with customers for a startup or other growth companies is precisely about learning. It helps at directing the product development to right directions and to get insights that you wouldn\u2019t otherwise get (or even know about) and also the opposite, to validate which areas are working or good-enough.",
        "user": "UEQ7QL15F",
        "ts": "1572435916.362100",
        "team": "T5TCAFTA9",
        "thread_ts": "1572282098.317700",
        "parent_user_id": "UPV1HUCBH",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "fa7d48f7-cd03-4c86-98cd-ce5a8d594f08",
        "type": "message",
        "text": "If your goal is truly to motivate people to watch Armstrong's talk, then post a link to it. Trolling the forum with ill informed, inflammatory bullshit is not a good way to spread whatever message you derived from Armstrong's talk. Instead, you are just pissing everybody off.",
        "user": "UJN1TAYEQ",
        "ts": "1572440360.362400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "UBKNXPBAB"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5aebd10f-8441-4ec6-9ce1-2a5e64383d83",
        "type": "message",
        "text": "SQL, datalog both provide ways to Manage lots of data. \n\nSpecter in clojure, and lenses in haskell are both programming solutions I'm aware of for these types of issues as well.",
        "user": "UJNJQD2AC",
        "ts": "1572443360.363400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572270935.312600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "67f82368-fc7a-4f6f-a621-be954d5be08c",
        "type": "message",
        "text": "I didn't see the word graphicially...",
        "user": "UJNJQD2AC",
        "ts": "1572443465.363600",
        "team": "T5TCAFTA9",
        "thread_ts": "1572270935.312600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "84A03F15-B4B9-4053-BC31-4F3707676492",
        "type": "message",
        "text": "<@UBN9AFS0N> Erlang processes see one another as mutable actors, don\u2019t they?",
        "user": "ULM3U6275",
        "ts": "1572449278.365200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1572449296.000000"
        },
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "ce298c33-442d-460f-ab4d-8e7a80cb4ef9",
        "type": "message",
        "text": "in the sense that internal state may be mutated by sending messages? yes",
        "user": "UBN9AFS0N",
        "ts": "1572449311.365500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "d7daab87-80d7-45df-a410-54fee4c207d9",
        "type": "message",
        "text": "but state is only accesible from the actor itself and \"mutated in time\", that is, returning a new immutable state after handling a message",
        "user": "UBN9AFS0N",
        "ts": "1572449342.365700",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "type": "message",
        "subtype": "thread_broadcast",
        "text": "But there is no referential transparency between actors(processes), correct? The reference that one actor has to another does not change in order to reference the new state, so wrt state between actors we have exactly the situation as we do with mutable objects messaging one another in smalltalk. The two differences (which are both interesting) is the enhanced isolation of actors internal state from one another and that actors have message queues and their own threads of execution - both of which make actors more pure in the OO sense as state and processing are more encapsulated.",
        "user": "ULM3U6275",
        "ts": "1572454660.373100",
        "thread_ts": "1572414362.359200",
        "root": {
            "client_msg_id": "770c6d57-6f85-4356-ad67-43aa1a1f699e",
            "type": "message",
            "text": "It is amusing to me that his laptop has an Erlang sticker, when Joe Armstrong, the inventor had such a dim view of the Actor model. There is a lively reunion on YouTube of three famous senior UK computer scientists who each selected a different technology to pursue. One was Hewitt, the actor model, and Armstrong, and Hoare who had some other paradigm i forget which. Anyway they had a debate about what were the results, and Armstrong ripped them to shreds because he pointed out that is system worked and theirs didn't actually work. Pharo has the best IDE i have ever seen, but the underlying language smalltalk was DOA (dead on arrival). The original editions of the smalltalk book by Goldberg are worth a lot, because sensible people like me who bought that book tossed it out because the language is so clunky and hard to read, and frankly absurd. You send the message PLUS to the number 3 along with another operator 2, and then the 3 updates itself to 5. That isn't too far out, but when you get to bitmap manipulation, the model really gets ugly.\n\n The actor model creates not only huge numbers of little islands of state, but then compounds that mistake by creating a message passing system that is hell to debug. In any toolchain that becomes hypercomplex to understand, there are always exceptional people who claim it is no problem, but if you take a big actor model program, and pass it to another programmer, they will have zero chance of understanding it. It becomes a nightmare of dependencies and cross-connections, just like the human body.\n\nI only make these possibly inflammatory remarks to warn people to look up Armstrong's talk, and think twice about wasting your time on a model that has such a legacy of failure.    If someone would like to debate this with me, we can have Steve Krouse act as referee, and hold a fire extinguisher nearby so when you burst into flames you won't be permanently harmed ;-&gt;",
            "user": "UEQ6M68H0",
            "ts": "1572414362.359200",
            "team": "T5TCAFTA9",
            "edited": {
                "user": "UEQ6M68H0",
                "ts": "1572503120.000000"
            },
            "thread_ts": "1572414362.359200",
            "reply_count": 30,
            "reply_users_count": 6,
            "latest_reply": "1572553145.430800",
            "reply_users": [
                "ULM3U6275",
                "UBN9AFS0N",
                "UJBAJNFLK",
                "UJN1TAYEQ",
                "U8A5MS6R1",
                "UEQ6M68H0"
            ],
            "subscribed": true,
            "last_read": "1572553145.430800"
        },
        "client_msg_id": "F1AFB109-00B7-4D48-AEE5-D0D4A8C8D54E",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4981af49-c0fe-4428-a077-ac9999f7b812",
        "type": "message",
        "text": "<@ULM3U6275>\u2019s comment is spot on. Externally, when you send a message to an Erlang process you don't know what 'version' it's at. So it looks like this mutable bundle of state you're interacting with. This is very similar to any other actor model. The only thing is a process has more control of when it accepts new messages and can do so when it has reached a consistent state.\n\nHere's an interesting comment from Joe Armstrong:\n&gt; Then, my thesis supervisor said \"But you're wrong, Erlang is extremely object oriented\". He said object oriented languages aren't object oriented. I might think, though I'm not quite sure if I believe this or not, but Erlang might be the only object oriented language because the 3 tenets of object oriented programming are that it's based on message passing, that you have isolation between objects and have polymorphism.\n\nSource: <https://www.infoq.com/interviews/johnson-armstrong-oop/>",
        "user": "U8A5MS6R1",
        "ts": "1572455175.373500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "InfoQ",
                "title": "Ralph Johnson, Joe Armstrong on the State of OOP",
                "title_link": "https://www.infoq.com/interviews/johnson-armstrong-oop/",
                "text": "Ralph Johnson and Joe Armstrong discuss the state of OOP, what Smalltalk got right/wrong and the image concept. Also: Joe decides he likes OOP as long as its done the Erlang way: focused on messaging.",
                "fallback": "InfoQ: Ralph Johnson, Joe Armstrong on the State of OOP",
                "from_url": "https://www.infoq.com/interviews/johnson-armstrong-oop/",
                "service_icon": "https://cdn.infoq.com/statics_s1_20191025-0248/apple-touch-icon.png",
                "id": 1,
                "original_url": "https://www.infoq.com/interviews/johnson-armstrong-oop/"
            }
        ],
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "2b48da86-583a-40ce-a2a2-a82afc434944",
        "type": "message",
        "text": "<@ULM3U6275> yes",
        "user": "UBN9AFS0N",
        "ts": "1572456072.373800",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "c3bff051-9b10-4263-9016-cc7e2c2ff3be",
        "type": "message",
        "text": "I was just highlighting that state is not mutable in erlang (nothing is mutable on the erlang vm), but yes, you can keep a reference to the same process and it will \"mutate\", it's the only thing that can change state while you hold the same reference if I remember correctly",
        "user": "UBN9AFS0N",
        "ts": "1572456203.374000",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "2819252B-373A-4648-86CE-96E3B855DD6B",
        "type": "message",
        "text": "\u201cState is not mutable in Erlang\u201d If the way people wrote Erlang only involved a single process/actor, I would agree.",
        "user": "ULM3U6275",
        "ts": "1572456498.376500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "ef8d6508-5dee-4056-b92b-f956a20deb17",
        "type": "message",
        "text": "Oh I think another important aspect of Erlang processes is that each is 'single threaded' in the sense there can only be one control flow happening inside at one time - any other messages sent it it will wait.  This is a nice property because you can think locally and ensure it always reaches some consistent state.\n\nRe state - if you write into a db from a process (dets/mnesia?) - you're still dealing with mutable state again.",
        "user": "U8A5MS6R1",
        "ts": "1572456587.376700",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "c5d1caee-bab9-4bad-953a-290e1a65ec36",
        "type": "message",
        "text": "BTW I always thought of Erlang as very close to the actor model, intentionally or unintentionally. So I'm a bit confused about the assertion that Armstrong held a dim view of the actor model. I think I found the panel discussion referred to (haven't finished watching yet): <https://www.youtube.com/watch?v=37wFVVVZlVU>",
        "user": "U8A5MS6R1",
        "ts": "1572456703.376900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Let's #TalkConcurrency Panel Discussion with Sir Tony Hoare, Joe Armstrong, and Carl Hewitt",
                "title_link": "https://www.youtube.com/watch?v=37wFVVVZlVU",
                "author_name": "Erlang Solutions",
                "author_link": "https://www.youtube.com/user/ErlangSolutions",
                "thumb_url": "https://i.ytimg.com/vi/37wFVVVZlVU/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Let's #TalkConcurrency Panel Discussion with Sir Tony Hoare, Joe Armstrong, and Carl Hewitt",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/37wFVVVZlVU?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=37wFVVVZlVU",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=37wFVVVZlVU"
            }
        ],
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "5ddba2a6-3b4b-4a85-91e0-5576df823911",
        "type": "message",
        "text": "usually people make the distinction between \"sequential erlang\", the language and its semantics that you write as modules and functions and \"Erlang/OTP\" the concurrency primitives and patterns used to organize processes into systems, the immutability is in the sequential part (the language) the \"mutability\" is in the platform",
        "user": "UBN9AFS0N",
        "ts": "1572456904.377200",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "7EC60C99-56E4-4F86-94D4-17E637686D72",
        "type": "message",
        "text": "Yes, or have any interaction (i/o) with the actual world at all, but who needs users, keyboards, mice, touch screens, user interfaces, files, databases, sensors, or network communications? ;)",
        "user": "ULM3U6275",
        "ts": "1572457704.379200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1572461181.000000"
        },
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "f4f6ce92-9991-4061-b492-6f983c308f8e",
        "type": "message",
        "text": "The immutable model, single assignment, etc does affect how you write code in the small, based on my very limited experience with Erlang. The main thing I liked was things aren't going to just change underneath you - within your process of course. Its kind of like working in a single threaded isolated heap. But you know when you're looking outside the process that you'll may get anything. Also you don't usually synchronously look outside your process. You just send a message and are done. Then later, you may get a message related to one you sent.",
        "user": "U8A5MS6R1",
        "ts": "1572458462.379500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "6f8dca13-d13e-46f8-a52c-f1e618a3e35a",
        "type": "message",
        "text": "In the talk above the Hoare and Hewitt are somewhat smug, and Armstrong upbraids them because he points out his system actually built shipping products that worked well. Their approaches did not work.  It is easy to lump Erlang/Elixir into a category with other languages, but it is a unique beast; with a very clever runtime that creates a stack and heap for each micro-process. This allows you to reboot a process, and not have some godawful pile of a million tiny chunks of memory that have to be marked and swept. When it comes to massive multithreading, there is only two ways to do it: a super meticulously hand-crafted runtime, or use the runtime that Erlang/Elixir have, because it solves an immensely difficult problem.\n\nIf you take the straight actor model, and combine non-reversibility with  concurrency, your system will be incredibly fragile. That is Armstrong's point. He wasn't a theoretician like Hewitt and Hoare, but someone building real high volume things, not toys.",
        "user": "UEQ6M68H0",
        "ts": "1572469244.379900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1572469263.000000"
        },
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "255cfcae-08d9-4272-99e8-1dd57ecfcd73",
        "type": "message",
        "text": "Armstrong has a lot of good videos up. They are entertaining and informative. One thing to remember though is that Erlang was banned inside Ericsson, where it was created, and that banning is probably related to the poor transferability score that Erlang possesses. If you notice that Elixir is having much greater acceptance, because some would describe the Erlang syntax as opaque. A program in commercial use lasts decades, and the ability to transfer code from one person to the next is a major factor in language selection. This means sticking with popular languages, but also avoiding ones like LISP, FORTH, and APL which have super low transferability.  It would be great to hear from people who used to work at Ericsson as to why exactly it was banned. There was no question that his system worked well, and was robust; but maybe it was too hard to maintain and thus fragile in the end? There is a lot of information in failure, and i wish people would be more honest about the failures of the past; this is how you get wisdom.",
        "user": "UEQ6M68H0",
        "ts": "1572471412.380200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1572471487.000000"
        },
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "e3bc1f65-4009-41b2-b400-c328c152aaf3",
        "type": "message",
        "text": "<https://twitter.com/JaneWalerud/status/1189461281184636928>",
        "user": "UBN9AFS0N",
        "ts": "1572474176.380500",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/JaneWalerud|@JaneWalerud>: <https://twitter.com/FrancescoC|@FrancescoC> <https://twitter.com/mjcoffeeholick|@mjcoffeeholick> <https://twitter.com/ElixirConfLA|@ElixirConfLA> In 1998, E/// had 19 products dependent on Erlang and no success on selling E/// outside the organisation for five years. 1/n",
                "ts": 1572424643,
                "author_name": "Jane Walerud",
                "author_link": "https://twitter.com/JaneWalerud/status/1189461281184636928",
                "author_icon": "https://pbs.twimg.com/profile_images/712613127242780674/Hox3ZiuD_normal.jpg",
                "author_subname": "@JaneWalerud",
                "text": "<https://twitter.com/FrancescoC|@FrancescoC> <https://twitter.com/mjcoffeeholick|@mjcoffeeholick> <https://twitter.com/ElixirConfLA|@ElixirConfLA> In 1998, E/// had 19 products dependent on Erlang and no success on selling E/// outside the organisation for five years. 1/n",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/JaneWalerud/status/1189461281184636928",
                "id": 1,
                "original_url": "https://twitter.com/JaneWalerud/status/1189461281184636928",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "efe0f762-b0f3-4199-9c54-9073ea6f799c",
        "type": "message",
        "text": "that thread explains why",
        "user": "UBN9AFS0N",
        "ts": "1572474183.380800",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "df1e452b-6d40-4dc1-8993-4ce1f99a19f4",
        "type": "message",
        "text": "Erlang is used a lot again inside Ericsson since it was open sourced and the ban was lifted",
        "user": "UBN9AFS0N",
        "ts": "1572474209.381000",
        "team": "T5TCAFTA9",
        "thread_ts": "1572414362.359200",
        "parent_user_id": "UEQ6M68H0"
    }
]