[
    {
        "client_msg_id": "4fb57252-6edb-49f9-838f-bf57096e1a55",
        "type": "message",
        "text": "Anybody have a half hour to read a draft blog post? <http://akkartik.name/post/mu-2019>. It deals with low-level programming details, but I don't want readers to have knowledge of low-level programming. So I'm particularly appreciative of someone pointing out large gaps where I forget to explain something basic.",
        "user": "UCUSW7WVD",
        "ts": "1570949673.034500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "reply_count": 72,
        "reply_users_count": 7,
        "latest_reply": "1572028542.136600",
        "reply_users": [
            "UCKRZS3DZ",
            "UCUSW7WVD",
            "UEQ6M68H0",
            "UHWC9PXBL",
            "UMVFWPZ36",
            "U5STGTB3J",
            "UPV1HUCBH"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "5871dd14-541a-4520-9dd8-f83f34149ecb",
        "type": "message",
        "text": "Hey!\n\nWould it be correct to say that Mu is a fancy assembler for existing architecture? Or Mu is a different CPU architecture that for now runs on top x86? Article says Mu is a \"computing stack\", but I am not sure I understand exactly what it is.",
        "user": "UCKRZS3DZ",
        "ts": "1570950516.034600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1570950569.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ac64bd84-ab0b-4820-a0da-15a4d71efe07",
        "type": "message",
        "text": "Thanks, <@UCKRZS3DZ>! It's a purely software stack. I have zero plans to build a new processor or anything like that. It's a new computer the way the BBC Sinclair or original Mac was a new computer, building on hardware supplied by others.\n\nI may end up supporting other processors (maybe RISC-V?), but that'll happen in a fork. I don't plan to support multiple processors in a single repo/codebase.\n\nDoes this make sense? Let me think about how to make this clearer. Thanks again!",
        "user": "UCUSW7WVD",
        "ts": "1570950665.034900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570950783.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCKRZS3DZ"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cc7688d2-615a-40fc-81d6-2ac992522327",
        "type": "message",
        "text": "One of the key properties of assembly code is that it is machine dependent. By your description I get that Mu don't have to be machine dependent, may translate to different architectures.\n\nWould it be correct to call Mu an IR (Intermediate representation), similar to LLVM IR?",
        "user": "UCKRZS3DZ",
        "ts": "1570950916.035300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCKRZS3DZ",
            "ts": "1570950938.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d6b0406c-a9d2-473d-bc23-aae7228c4ac9",
        "type": "message",
        "text": "Mu is in fact machine dependent, just like Assembly. I need to think about how to get that across more clearly.\n\nIt's not really an IR because IRs are designed to be compiler targets rather than for people to program manually. Mu on the other hand wants to design all levels of the stack to be fun to program manually.\n\nIRs also tend to be designed keeping in mind multiple frontends and/or backends. Mu has only one backend, and so far there are no plans for a second frontend.",
        "user": "UCUSW7WVD",
        "ts": "1570951289.035700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570951988.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "760105e8-296d-4847-805f-07a81e49faa2",
        "type": "message",
        "text": "Okay\n\n&gt; Top priority is keeping the compiler implementation tiny and hackable over time.\n\nWhy ability to hack into compiler is important? You listed it as a top priority, what are the benefits? What could be done with this feature that hard or impossible to do with current tools?\n\n&gt; You won't be able to use math notation like `a + b*c`\n\nIs this a typo? Maybe it should be \"would be able\"?",
        "user": "UCKRZS3DZ",
        "ts": "1570951417.035900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c8328537-68fd-4564-9481-f0edee5e3d56",
        "type": "message",
        "text": "Nope :smile: :cry:\n\nI know it's a strange philosophy. Could you check out <http://futureofautomation.wikidot.com/mu> if you haven't already? It's my elevator pitch for this group. I wasn't sure how much to side-track this particular post with considerations of goals and philosophy. Hopefully I'll have some ideas as we continue chatting.",
        "user": "UCUSW7WVD",
        "ts": "1570951589.036100",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "ee58eec2-8b8c-49e2-9355-794c18bee7a1",
        "type": "message",
        "text": ":smiley:",
        "user": "UCKRZS3DZ",
        "ts": "1570951617.036300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "3d666f7a-c1a4-4888-8ecc-9d24b2fb5353",
        "type": "message",
        "text": "<@UCUSW7WVD> I read your doc, but have no clue as to the types of programs you are trying to facilitate. A language is a tool, and like a hammer which is great for nails but lousy at being a screwdriver, every language has its natural problem space where it excels. You are clearly very concerned with compactness and performance, as your language maps directly to the Intel instruction set (which has 99% market share in desktop computers, but ARM has 99% share in mobile devices). Wouldn't you be better off first picking some test programs you want to build, little utility things that represent the kinds of things you want to build, and then by working from both ends meet in the middle, like the golden spike of the transcontinental railroad of the USA. Working from both ends at once is the only way design can work; after all you always have at least 3 layers in a compiler system, the source syntax, the intermediate representation, and the target machine + runtime. With no runtime mentioned, i cannot figure out what this project is for. You clearly have spent a great deal of time thinking about and building stuff, but honestly i can't figure out the \"why\".",
        "user": "UEQ6M68H0",
        "ts": "1570956351.036600",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7b5b9ecd-cf33-43ef-a474-4691610b5a07",
        "type": "message",
        "text": "Thanks Edward, I'll reflect on what you said.\n\nI don't care about compactness or performance. My top priority is simple translation to machine code, using as little (machine) code as possible. I tried to say this in the second section (\"constraints\"), one screen down from the top. Any suggestions on how to reword?\n\nWhat do you mean by 'runtime' beyond the processor? I'm not assuming anything else.\n\nThere's more about the 'why' at <http://futureofautomation.wikidot.com/mu>. Right now I just want to get my point across to you. Once we're on the same page I will have a better idea about how to rewrite things.",
        "user": "UCUSW7WVD",
        "ts": "1570978880.036800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570979210.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "1f4758bb-7aa5-42b8-8141-cc33f40e8390",
        "type": "message",
        "text": "<@UMVFWPZ36> Looking forward to the next iteration. Your last paragraph is a lot clearer than the current blog post.\nBTW, a more general source of confusion is that you don't explain the relation between the cell universe and the tree universe. My initial impression of tree notation is that it's all about trees, as the name implies. Trees can of course be used to encode pretty much anything (which I think is the main contribution of Lisp), including any type of cell universe. If that's what you are doing, please say so. Otherwise I wonder what role cells do play in tree notation, given that the main Web site does not use the term.",
        "user": "UJBAJNFLK",
        "ts": "1570982696.037200",
        "team": "T5TCAFTA9",
        "thread_ts": "1570582830.061900",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "4F87563C-2564-48B8-B598-ACF7B59268F4",
        "type": "message",
        "text": "going to spit out some feedback as a self-appointed assembler village idiot here: \n\nfirst one: \u201cIt would be nice to be able to see at a glance which operands of an instruction are read, written or both.\u201d it wasn\u2019t clear to me from the 'op o1 o2' example that operates were a thing that could be written to. i read it as a normal function call in a call-by-value language (? always mixing the call-by language up)",
        "user": "UHWC9PXBL",
        "ts": "1570992520.041300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "42F68C59-00C7-4073-9648-11599E587316",
        "type": "message",
        "text": "never mind, i\u2019m lost from that point onwards. would be helpful if you explained registers in this article",
        "user": "UHWC9PXBL",
        "ts": "1570992658.042200",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "128CFF25-4DC0-4EFE-AF14-A633C430A930",
        "type": "message",
        "text": "also i know you link to a \u201cwhy\u201d post, but that\u2019s probably your most important tagline and you should compress it and repeat it as often as possible. because most people don\u2019t click links, do jump around and skim, and also need to constantly be reminded of how to contextualize explanations in a bigger picture",
        "user": "UHWC9PXBL",
        "ts": "1570992791.045300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "27a1811a-ee8f-4932-95e8-7f1bb61e0159",
        "type": "message",
        "text": "Thanks <@UJBAJNFLK> ! That is a good point, that cells are not talked about much yet throughout the rest of the Tree stuff. I haven't yet shown how you can build new types of hardware for directly executing Tree Language code, and that's where the cells will come in in a big way. Cells I think now only come up in Tree Language code (cells are placeholder for words and provide types, you'll see a \"cells\" keyword in the Tree Language called Grammar)...but the 2D register bit and \"tree machines\" is where this paper is headed, long term...",
        "user": "UMVFWPZ36",
        "ts": "1570996168.045800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570582830.061900",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "310f0759-74e2-4c25-852a-856ea3230362",
        "type": "message",
        "text": "Would it be correct to say mu is a language that compiles to x86 Assembly, with the goal of being easier to use than direct x86, but not to be far removed from x86 so that the programmer in mu is at all times aware of what the x86 machine is doing?",
        "user": "UMVFWPZ36",
        "ts": "1570996959.046500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "30404423-5cbf-40c6-b088-701a015ae18c",
        "type": "message",
        "text": "If that's the case, and it's tightly bound to x86, then I think a worthwhile project (and you may already have this), is to take this (<https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf>) and make a machine readable version (there may already be one)",
        "user": "UMVFWPZ36",
        "ts": "1570997031.046700",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7d94468b-0411-4293-b643-76672e391f01",
        "type": "message",
        "text": "my guess is only 1 out of 100 programmers knows x86, so you should either have the words x86 all over the place, and really target those users, or if your goal is to target a broader audience, it may help to explain more x86...perhaps some animated gifs would help, showing high level mu and the generated x86 and then what's happening on the processor (of course I'm glossing over microcode)..",
        "user": "UMVFWPZ36",
        "ts": "1570997253.046900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7239523c-67c2-489d-8f3d-019c0ccd18c4",
        "type": "message",
        "text": "my big picture feedback is that if you want it to be easy to understand and remain so over time, you are going to have to design new hardware",
        "user": "UMVFWPZ36",
        "ts": "1570997379.047100",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9c385d87-5579-4b91-af90-af84bf7b85db",
        "type": "message",
        "text": "or focus on RISC-V or something",
        "user": "UMVFWPZ36",
        "ts": "1570997390.047300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "26be6707-8230-4c8c-8cf8-c109b4663e97",
        "type": "message",
        "text": "because if your users only understand things from the x86 level on up, they don't really understand things, imo",
        "user": "UMVFWPZ36",
        "ts": "1570997448.047500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c8fc8de3-e67a-4bfa-a7f2-db38b13292f6",
        "type": "message",
        "text": "are there no risc-v boards yet that people are making with open chip schemas?",
        "user": "UMVFWPZ36",
        "ts": "1570997511.047700",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c52b535d-d382-468b-8082-ee6f311af6dc",
        "type": "message",
        "text": "it might be worthwhile to consider saying \"screw x86\" and ride the future open risc-v wave (or some other competing open architecture). perhaps it will take a few more years for that wave to get going, but then mu would be in a good spot",
        "user": "UMVFWPZ36",
        "ts": "1570997627.047900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "cfdc0828-98c3-4f5b-9688-baa73090c1d2",
        "type": "message",
        "text": "&gt; because if your users only understand things from the x86 level on up, they don't really understand things, imo\n\nHmm, not sure why you think this. You have to accept _some_ substrate.\n\nI'm not a fan of x86, but it is easily accessible for anyone who wants to try Mu out on a whim.\n\n&gt; Would it be correct to say Mu is a language that compiles to x86 Assembly, with the goal of being easier to use than direct x86, but not to be far removed from x86 so that the programmer is at all times aware of what the x86 machine is doing?\n\nYep! The Mu programmer can always bump down to machine code at a moment's notice, no matter how many levels of abstraction it gains over time. And all the tooling takes this capability for granted, so it can be less hermetically sealed and need less code at all levels of the stack.\n\nIf conventional stacks try to be like the _Starship Enterprise_, all gleaming chrome, Mu is designed like _Serenity_, with the ductwork hanging out.\n\n&gt; it may help to explain more x86...\n\nYeah, this is the fundamental underlying struggle. Currently the Mu Readme tries to provide a crash course on x86 in ~500 words: <https://github.com/akkartik/mu/blob/master/Readme.md#lengthy-interlude-how-x86-instructions-compute-operands>. But I need to improve on that.\n\nThanks a lot for all the feedback, Breck!",
        "user": "UCUSW7WVD",
        "ts": "1570998309.048100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570998485.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "4fac747f-01ea-42ba-aaab-c339cdd5ea1a",
        "type": "message",
        "text": "&gt; Yep! The Mu programmer can always bump down to machine code at a moment's notice, no matter how many levels of abstraction it gains over time. And all the tooling takes this capability for granted, so it can be less hermetically sealed and need less code at all levels of the stack.\n\nAhhh! I get it now. I really like that idea. Again, I think it might be worth looking at RISC-V long term (or other competing open ISAs). Perhaps people would even go out and buy RISC-V boards just to use something like Mu. I know I would. I think otherwise your users will constantly run into the question, \"well why is there this instruction?\" and the answer will be \"because intel says so!\" and they will never be able to say \"how does this instruction *actually* get executed on the processer\" and they won't be able to say \"I'd like a new instruction, how can I go about it\"",
        "user": "UMVFWPZ36",
        "ts": "1570999758.048400",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "adc4de67-18a8-4ddf-b701-cf9f62abaa8c",
        "type": "message",
        "text": "I think perhaps the reason we've lost understandability over time has to do not with the language problem, but because of the closed source hardware/isa problem",
        "user": "UMVFWPZ36",
        "ts": "1570999804.048600",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "04d38f64-9a23-46e1-aa77-ec5716173f1f",
        "type": "message",
        "text": "and perhaps there is a risc-v emulator, so in the interim you could have something that works?",
        "user": "UMVFWPZ36",
        "ts": "1570999866.048800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "0fbf8b00-19f3-4b2a-b7b8-e1f507cca38a",
        "type": "message",
        "text": "i could be wrong, maybe the current ubiquity argument is a good reason to do the x86 route, but i think the puck is going to open ISAs",
        "user": "UMVFWPZ36",
        "ts": "1570999907.049000",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "385e2065-a282-4742-8712-0acb8ea48d60",
        "type": "message",
        "text": "and personally if Mu helped me learn the future (Risc-V or something), I'd be more excited about it than putting more time into x86 ISA, for the same reason I put zero time into learning the Windows API and all my time on Nix like things",
        "user": "UMVFWPZ36",
        "ts": "1570999971.049200",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "2aae0779-85c3-468d-a365-2827c512cfda",
        "type": "message",
        "text": "but I finally get what you are doing with Mu now, and i love it. Seems like it would be fun to be in a productive language but at the same time being able to seamlessly inspect a register or execute a particular instruction",
        "user": "UMVFWPZ36",
        "ts": "1571000050.049400",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "85eea3b5-3b7b-4d5b-9d8a-d8ae9c933b9e",
        "type": "message",
        "text": "Glad I was able to convey it to _someone_! :smile:\n\nI'm definitely keeping RISC-V on my radar. I don't want Mu to stay restricted to x86 forever: <https://mastodon.social/@akkartik/100412831846978802>. But I think it'll lead to less bloat in the long term to keep each processor on a separate fork.\n\n&gt; I think perhaps the reason we've lost understandability over time has to do not with the language problem, but because of the closed source hardware/isa problem\n\nI'm skeptical. Programmers love creating abstractions so much that we have a bazillion of them above the processor. Portability is considered so important that our software supports multiple processors. It's not clear the ISA influences anything at the app tier. Except maybe for making everyone scramble for security fixes every so often.",
        "user": "UCUSW7WVD",
        "ts": "1571001277.049700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1571001310.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9c2757c5-c603-4dc8-a6ca-9429591d58cc",
        "type": "message",
        "text": "Nothing wrong with picking intel. They make good chips and it is a simple enough chip to work with. But nowadays every shipping chip includes the AMD x64 extensions, which AMD licensed back to Intel. It adds enough registers so that you aren't constantly shuffling data in and out of the measly 2 registers EAX and EBX. Remember that multiply uses the ECX EDX registers, so intel x86 really is a 2 general purpose register machine, and a huge percentage of instructions are loading and storing data from those registers. Another thing to consider is that most of the work Intel has been doing in the last 5 years with their instruction set is adding crazy instructions that have zero actual practical value, but are solely designed to confound and raise costs for the cloners in China, who have caught up with the basic instruction set, and sell cut-rate intel clone chips. The only useful instruction intel has added in the last 10 years is a true random number generator, which uses electron noise conditioned to produce the first actual random numbers for computers. Part of the AES extensions. But i would ignore the batshit crazy instructions like the GF2P8AFFINEINVQB \u2014 Galois Field Affine Transformation Inverse, which not one person in a million will ever use, much less understand.",
        "user": "UEQ6M68H0",
        "ts": "1571001679.050100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1571001902.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f943b180-219b-4697-bde8-28ad471a533a",
        "type": "message",
        "text": "IMUL actually uses EDX:EAX (<https://c9x.me/x86/html/file_module_x86_id_138.html>). If we all stopped using EAX (the accumulator register) because of that, then x86 would not have taken over the world.\n\nIn the 40kLoC of x86 machine code I've written so far I've been using 6 registers: EAX ECX EDX EBX ESI EDI.",
        "user": "UCUSW7WVD",
        "ts": "1571001893.050400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1571002029.000000"
        },
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "187dbf6e-888a-4781-a497-744fb5a01a1d",
        "type": "message",
        "text": "okay i corrected my comment. I wrote 1% of my Discus labeler in intel assembler because i needed to do various bitmap masking operations that are not part of Win32, but  present in Quicktime; but that was 15 years ago. The MS Assembler is a fantastic tool, with macros for IF, WHILE, etc.,; and with macros you are really quite productive, and readable. Just don't forget to restore a register or else you will be hounded by phantom bugs! That's the reason people abandoned assembler. Otherwise it was quite productive, and incredibly efficient.",
        "user": "UEQ6M68H0",
        "ts": "1571002127.051000",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "cbce2e9a-a52d-48e9-99d8-3870eeec5d88",
        "type": "message",
        "text": "<@UMVFWPZ36>\n\n&gt; otherwise your users will constantly run into the question, \"well why is there this instruction?\" and the answer will be \"because intel says so!\"\n\nTotally valid point. I mitigate it somewhat by only supporting a fairly small, regular subset of x86. Try cloning the repo and running `subx help opcodes`. But I still end up with random-looking opcodes from all the picking and choosing.",
        "user": "UCUSW7WVD",
        "ts": "1571003936.051300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570949673.034500",
        "parent_user_id": "UCUSW7WVD"
    }
]