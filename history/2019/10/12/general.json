[
    {
        "client_msg_id": "782F8200-56AF-4D24-BE94-0901147F2728",
        "type": "message",
        "text": "i mean, there aren\u2019t even classes in self so i think your comment is actually illustrating the degree to which you have to learn a whole new way of thinking about what code is in order to grok self at all (which might be less of a burden for end users?). but i stand by the idea that being able to for example drag and drop methods from one object to another embodies a way of thinking about code that we\u2019re nowhere near realizing yet",
        "user": "UHWC9PXBL",
        "ts": "1570832591.236600",
        "team": "T5TCAFTA9",
        "thread_ts": "1570649221.097300",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "3dbe1d29-0b2b-4016-93f4-faada0128662",
        "type": "message",
        "text": "Whether you use Java classes, or prototypical inheritance to describe the meta-information location where methods are stored that apply to a larger set of objects, these concepts are highly abstract, and a barrier to a beginner understanding the program.  That a drag and drop  gesture does some magical thing does not make it easy to understand the semantics of what is happening.",
        "user": "UEQ6M68H0",
        "ts": "1570841261.236900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570649221.097300",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "ca593479-1d56-4eb1-8214-398ed7c428c7",
        "type": "message",
        "text": "<https://hcii.cmu.edu/news/event/2019/10/hcii-25th-anniversary-celebration> this seems interesting, anyone planning to attend?",
        "user": "U85HCL7JP",
        "ts": "1570850274.237400",
        "team": "T5TCAFTA9"
    },
    {
        "client_msg_id": "b702f1d4-3fc9-447f-94f3-c5b828b74175",
        "type": "message",
        "text": "20 million is a lot of money. If i recall correctly Eve raised 2.3 million from Andreesen Horowitz, and the Luna team just raised 2 million for their second round, and the Red team via an ICO raised an unknown amount, probably in the tens of millions.  So 2 million gets you about a team of 6 people for 2-3 years, depends on the country of course. Red is pursuing a multi-platform initial release, so they have higher costs and a larger team. the best way to do this type of funding is to put at least 3 parallel competing teams on the same general project area, and whichever one looks the most promising after N months gets increased funding and the other teams are disbanded. This was the general methodology used so successfully under Thomas J. Watson Jr. who presided over the most successful and excellent tech company the world has ever seen. I know that most of you folks don't know how great IBM was, but they were amazing, and for a near monopoly, while Watson was in charge, the company was of the highest integrity and innovative like no other. After he retired it was ruined as a company, they became gutless and lazy. They are only a shadow of their former selves. But anyway back to this idea, by having competing teams you get peoples' juices going. A race is far more exciting than a country club atmosphere with no deadlines and a steady paycheck you won't get much. Look at how little gets accomplished in France. They are so smart, but so far behind in programming. I think it is just too comfortable. I had a friend David who tried working in Paris and couldn't stand the lack of motivation and quit his cushy job. If you are not going to have a VC breathing down your neck, at least put some danger into the process by having some competition. Some of the greatest creations in history were done very quickly. Like building the Pentagon (under 1 year), or the most impressive musical composition feat in a short time period in history, Donizetti's Don Pasquale which was done in just in a handful of weeks, which if you ever go to a big public library and see the score, you would be hard pressed to copy by hand that score in the time he took to write it. Nobody has ever done an opera of that quality in what amounted to just a few days.  <@U5TCAFTD3> , i suggest you study the biography of Thomas J. Watson, as he directed some of the most productive R&amp;D, and was quite a forceful personality without being a chair thrower, etc. Hewlett &amp; Packard were also superb tech managers and developers; actually very few great leaders in computer history. If you just throw money into a project without a strong plan, you get poor results. Take a gander at the doomed california high speed rail project for an example of how not to run a project. They spent billions, and accomplished nothing useful. Or the hot fusion projects of the last 30 years, which have promised fusion in 10 years for the last 30 years straight. Many R&amp;D projects fail, so I thing Watson had the most practical approach to solving an important problem.",
        "user": "UEQ6M68H0",
        "ts": "1570872743.237500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1570906346.000000"
        },
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3d475433-acc2-47db-9bae-d10ef274e0ec",
        "type": "message",
        "text": "I don\u2019t think I\u2019d want to maintain a Self project (nor a Smalltalk one), but the level of introspectability of these tools is pretty amazing, and something I\u2019d like in other languages. I think we can learn from the good stuff, and praise them without needing to have these rants about how terrible inheritance and OOP is all the time. That\u2019s an unrelated issue.",
        "user": "UJUQESQ1Z",
        "ts": "1570875520.237800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570649221.097300",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "21166437-6daf-4ba5-9445-2ed6289d6d1d",
        "type": "message",
        "text": "Perhaps <https://scalameta.org/docs/semanticdb/specification.html> is an angle on a similar idea?\nIts a \"data model for semantic information such as symbols and types about programs.\"",
        "user": "UN06QADNV",
        "ts": "1570881041.238200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "SemanticDB Specification \u00b7 Scalameta",
                "title_link": "https://scalameta.org/docs/semanticdb/specification.html",
                "text": "SemanticDB is a data model for semantic information such as symbols and types about",
                "fallback": "SemanticDB Specification \u00b7 Scalameta",
                "from_url": "https://scalameta.org/docs/semanticdb/specification.html",
                "service_name": "scalameta.org",
                "id": 1,
                "original_url": "https://scalameta.org/docs/semanticdb/specification.html"
            }
        ],
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "d2e7df17-f280-4d08-8176-0444342f7673",
        "type": "message",
        "text": "<@UEBG0NPDK> Could you please expand on \u201cstubbed out demo\u201d? How do you decide which parts to stub out? What is most minimal demo do you start with?\n\n&gt; When we build something we try creating an end to end stubbed out demo and then fill it in over time.",
        "user": "UP6RJV9KP",
        "ts": "1570881843.238500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3"
    },
    {
        "client_msg_id": "ddaac693-06bb-4182-8b92-cfee4124650e",
        "type": "message",
        "text": "An idea from a discussion I had yesterday with different people on a different topic: One way to usefully spend money on researchy topics with little overhead is organizing meetings/workshops/... and pay for all the participants' travel costs. It's a small-perturbation thing for everyone (nobody moves to a different job, for example), and therefore creates no long-term seconday effect (\"what will I do when my grant runs out?\"). But it's a big boon for those of us who somehow manage to work on our FoC projects but couldn't afford spending much money on it.",
        "user": "UJBAJNFLK",
        "ts": "1570886861.238900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "85b41e50-4d86-435f-bdde-c5988f6345ee",
        "type": "message",
        "text": "PG announced his second Lisp variant: Bel. <http://paulgraham.com/bel.html> He\u2019s taking an axiomatic approach to Lisp, as described here: <https://sep.yimg.com/ty/cdn/paulgraham/bellanguage.txt?t=1570888282&amp;>",
        "user": "UNLS33M61",
        "ts": "1570892929.240300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "reply_count": 37,
        "reply_users_count": 10,
        "latest_reply": "1571335071.468300",
        "reply_users": [
            "UAVCC2X70",
            "UCKRZS3DZ",
            "UEQ6M68H0",
            "UJN1TAYEQ",
            "ULM3U6275",
            "UMVFWPZ36",
            "UCUSW7WVD",
            "UJBAJNFLK",
            "U71PMQ1V0",
            "UKJGU23KP"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UAVCC2X70",
                    "ULM3U6275",
                    "UA14TGLTC"
                ],
                "count": 3
            },
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "ULM3U6275"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "cdf9591c-af16-4245-9a15-f28b39c6bbef",
        "type": "message",
        "text": "Hence, I\u2019m guessing this made queries in Eve data independent and had more flexibility in the paths it can find to arrive at an answer?",
        "user": "UNLS33M61",
        "ts": "1570893762.240400",
        "team": "T5TCAFTA9",
        "thread_ts": "1569782281.071300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "c862a78c-d96b-418a-850a-de3e7698224c",
        "type": "message",
        "text": "Very nice!",
        "user": "UAVCC2X70",
        "ts": "1570894342.240700",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "87968002-5ad6-4ab1-ad1f-471b144c97c3",
        "type": "message",
        "text": "I have many ideas/goals for [Interact](<https://github.com/d-cook/Interact>), but one is that instead of representing \"source code\" as static text, it is instead an entire interactive model/representation. And everything that makes that model work (how it is visualized and interacted with, how it builds, etc.) is built in to the self-same model.\n\nThe relevance here is that everything about language (e.g. compilers, interpreters, syntax, semantics), data representation, visualization, editors/tools, ... everything about programs and programming, really ... It's really no different from (e.g. can be accomplished via) ordinary programming techniques using functions + data-structures + abstraction, etc. And since code can be represented as data-structures, the whole world of programming can fit into things like lists and key-value stores. You really don't need anything more than that for anything!\n\nAs for the DB, you can code up whatever model works best instead, or you have something that translates your \"ideal model\" into code that creates and populates a DB and the code interface to it. (I can explain more if needed)",
        "user": "UAVCC2X70",
        "ts": "1570896466.240900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570897088.000000"
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "45ad7137-5554-4abc-809a-3f1e8f5c5f0d",
        "type": "message",
        "text": "<@UAVCC2X70> can you talk about how your different projects are connected?",
        "user": "UCUSW7WVD",
        "ts": "1570897577.241800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "c002ea42-3a7d-482c-a7bc-9183e3ae21d8",
        "type": "message",
        "text": "I'll start with \"Objects\":\n<https://github.com/d-cook/Objects>\n\nMy first attempt/iteration at making a system entirely out of \"objects\" (e.g. JSON/LISP-like data-structures). Expressions are LISP-like (list of operation + arguments), but the interpreter/evaluator simply looks up ALL operations in a \"context\" object (which represents lexical scope and may reference a \"parent\" context -- think Scheme).\n\nFunctions can be native, or consist of objects that contain the code to evaluate, the arguments it takes, and the context (scope) in which to do so (typically same as lexical scope of the function).\n\nThe entire system (evaluator, a compiler, base operations like get, set, +, -, etc.) are all defined in a \"root\" context, which is not different from any other manipulatable entity. The evaluator was originally written natively (JavaScript for now), but then rewritten in \"objects\".\n\nThe goal was to rewrite everything that way, and have code that regenerates the native code for the whole system which, when run, recreates everything as it was at the time. This mostly just means spitting out the static data-structure for the whole thing, inserting a native evaluator (by feeding it into the compiler) which is then invoked immediately on some code to bootstrap the UI.\n\nFrom that point, you can reshape the whole thing just by interacting with the running program -- and that will allow me to evolve it further without ever looking at the \"source code\" again!\n\nThe only remaining \"native\" code (other than the base operations) was the logic in the compile function to convert code to JavaScript. But hey, I could (using the tool itself) make a compiler for something else (e.g. assembly, .NET, JVM) and supply the level base operations for it, and then boot up the entire system (in the same state) on something else!\n\nI took it too far with how minimal I wanted the native set to be (e.g. defining \"lookup\" in terms of objects, when that's a key function that the compiler injects everywhere), and forcing a CPS model under the hood sooner than I should have. It just became very difficult to manage, and stuff started to blow up when I got 90% of the way through rewriting it in itself ... I might go back some day and replay some of my development with different decisions.\n\nI'd been developing and interact with this entirely though the browser debugger, leaving the UI as an afterthought for after the base system was working properly. I knew I'd need some primitive graphical operations that could translate to any system -- just whatever is minimally sufficient to bootstrap a minimal foot-in-the-door UI, because then I could just use the UI to improve the UI code. ... But as stated, I never got to the UI.\n\nMy \"Interact\" project starts from the UI first and will work backwards to eventually bootstrap itself into that UI. It's essentially becoming a do-over of \"Objects\", though I might come back to that model eventually and reconcile them. ... I'll describe \"Interact\" next",
        "user": "UAVCC2X70",
        "ts": "1570901439.242200",
        "team": "T5TCAFTA9",
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "a258948a-1c00-48ba-b93a-2fe5eb71c2b1",
        "type": "message",
        "text": "\"Interact\":\n<https://github.com/d-cook/Interact>\n\n(continuing from previous) ... So the minimal UI would just expose the raw structure of everything, and provide a way to execute / evaluate code. (That's not the end goal, but I'll get back to that later)\n\nEntities (strings, numbers, lists, functions, etc.) sit freely on a canvas, where they can be moved around, inspected, expanded/collapsed, etc.\n\nDragging values onto a function causes the function to be evaluated with those \"arguments\", and the result appears as a new entity on the canvas. Since there is a function for every basic operation, this is sufficient for making every kind of manipulation *possible* (but not necessarily ideal - I'll get back to that!)\n\n(Certain basic things like getting or setting a value could be as simple as drag-and-drop; but I'll get a working tool first, and then use the tool itself to see what works best for what -- let's call that \"phase 2\")\n\nEither way (e.g. whether the UI \"helps\" or not), any sequence of operations that can be done -- whether through user interaction or by evaluating \"code\" -- directly corresponds to sequence of (nested or otherwise) function calls. Therefore, by recording and replaying actions taken, all code can be created and viewed as direct interactions, rather than as the textual or structural representation one normally thinks of as \"code\". *(From here I might use \"code\" and \"actions\" interchangeably)\n\nSo essentially you can do a bunch of manipulations, and then say \"See what I did? Call that a function, and THIS value here is the result\". And then edit the *actions and/or the object that represents the new function to replace certain values with arguments, etc.\n\nNow whereas \"normal\" code references values by identifiers (e.g. looking up variables by name), the user is able to just \"grab\" values that are just sitting there. So under the hood, code is stored as a list of actions, which contain either simple values or the index of some other action (referring to the result of that action) ... In other words, it's a DAG.\n\nWhen viewing / editing a function, actual values are substituted from the arguments, and you are shown the \"aftermath\" of the actions (i.e. values on a canvas), as if you had performed all the actions yourself. Changing any actions or values causes the whole thing to recompute (think FRP)\n\nThis means that any operation you do becomes part of the current \"function\" you are editing. I'll provide a way to \"cut\" dependencies though, so you can use the canvas as an interactive REPL, and then either throw out the results, or \"forget\" how it was computed and just use the generated value directly. I could also have a \"cleanup\" that will throw out all intermediate operations that did not contribute to the ultimate result of the function.\n\nAll editing is done in a function, so even the \"top level\" (global scope) is a \"function\" with its own record of actions taken. This also means that all the work of \"programming\" you do is recorded as some step somewhere, giving you multiple layers of undo/redo.  Anything you do can be abstracted into a function and edited for generic reuse. E.g. \"Here's how I do x to the code\"\n\n... Anyway, I'm getting lost in low-level specifics. I'll tie this up in another reply",
        "user": "UAVCC2X70",
        "ts": "1570901752.242400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570928072.000000"
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "4b0e211e-0a68-478e-aa7a-825d2f33652f",
        "type": "message",
        "text": "I skimmed through it, still didn't understand is there any novelty",
        "user": "UCKRZS3DZ",
        "ts": "1570903753.242800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "62f2a745-f832-43f1-995a-1de75ea312dd",
        "type": "message",
        "text": "From my reading it is a back to basics Lisp.  A very clever language from a great mathematician, but its over-reliance on recursion as the main power tool makes Lisp unsuitable for the future.",
        "user": "UEQ6M68H0",
        "ts": "1570906198.243200",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "44f8ac5a-6794-4e9f-a701-ea3c3e57354c",
        "type": "message",
        "text": "The power of Lisp has everything to do with the kind of underlying model it can be (and on that sense, it's inescapable).\n\nBut it's not necessarily a good top-level model (aka \"language\" or \"interface\") for most things. But that's also true of programming language + code in general",
        "user": "UAVCC2X70",
        "ts": "1570906768.243800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "99e4c4db-a475-4365-9a25-8e62d53d11be",
        "type": "message",
        "text": "I really like the idea of building up a full featured programming language from a small core. It's elegant. In theory, it means that creating a new from-scratch implementation of the language can be done quickly, with a small amount of code, since you only need to reimplement the core. I mostly associate this idea with Lisp and Forth: having a small, simple syntax makes it easier to have a small core.",
        "user": "UJN1TAYEQ",
        "ts": "1570910690.245000",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "6a298996-9c35-4151-812a-1dfcf43ff5e7",
        "type": "message",
        "text": "<@UEQ6M68H0> I like the IBM \"build 3 and pick the best\" approach. I think perhaps you could have \"problem teams\", and \"solution teams\". The problem teams would go out and define what the problems are, and build datasets that all the solution teams could use (like <@U5TCAFTD3>\u2019s recent dataset on next gen IDEs). That work is a lot more straightforward (but less sexy and underfunded). Then you have the competition on the solution teams. Perhaps, i dunno.",
        "user": "UMVFWPZ36",
        "ts": "1570913248.248300",
        "team": "T5TCAFTA9",
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "655d9088-4b68-4188-a436-62814ab5959a",
        "type": "message",
        "text": "(Continuing about \"Interact\" from before)\n\nAnyway, the point is not to have that specific tool per se, but to have *something* sufficient to edit code in a more freeform way, and to let whatever that looks like be very easy to evolve and change to whatever is more ideal for whatever context.\n\nThe plan is to eventually bootstrap all the code for the tool into itself, so it can be changed and explored over time (per use, and to evolve this tool generally). The benefit is that whatever \"nice way\" is found to represent or edit something, can be immediately applied to itself to make it easier to make things easier, etc.\n\nOne thing I'll provide to that end, is the idea of a custom \"view\". What I've described for viewing and editing functions is just one such \"view\", which is different than viewing a \"function\" as raw JSON. But perhaps something is better viewed as a table, or a graph, or some other interactive visualization.\n\nA custom view will contain whatever code is necessary to render something, and respond to interaction. This will probably \"just be code\", but (for example) there's no reason there couldn't be a custom view for specifying views using some custom DSL.\n\nAnd that brings me to another major goal of this tool:\n\nThings like DSLs, macros, syntax, even \"programming language\" (compiling, interpreting, translating), ... these can all be fluid things defined by ordinary code. The only difference is when and where it happens. But in a system like this, everything is the result of some \"actions\" taken to create it. So there's always some \"code\" that specifies how your code got created. And there's no reason to treat *that* code any differently!\n\nExpanding this further, with all the possible ways to view and edit \"code\" (or anything else), there's no reason to distinguish between \"code\" and a UI widget with its own custom behavior. No fundamental difference between a macro or a compiler, and anything else that let's you specify or view code/data one way, and then generate it another way.",
        "user": "UAVCC2X70",
        "ts": "1570913324.249400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1570928135.000000"
        },
        "thread_ts": "1570641258.055700",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "15FD4994-9372-4F7E-93D3-DE640CE089B2",
        "type": "message",
        "text": "I love seeing ambitious projects like this where the author is making the tool they\u2019d like to use.",
        "user": "ULM3U6275",
        "ts": "1570913339.249600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1570913359.000000"
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UAVCC2X70"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b0e2dbed-cfbd-4636-8eb1-d332bd930302",
        "type": "message",
        "text": "Very cool! Also cool to see the shoutout to  <@UCUSW7WVD> !  Any thoughts you could share about Bel? \"The code I wrote to generate and test the Bel source is written in Arc,\" So he was not writing Bel directly?",
        "user": "UMVFWPZ36",
        "ts": "1570913423.249900",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "69e64d6c-9a2b-4542-b589-77dbc259ac2b",
        "type": "message",
        "text": "I actually asked the same question but didn't get an answer. I haven't seen Bel running either, just given feedback on early drafts of what you see.",
        "user": "UCUSW7WVD",
        "ts": "1570913863.250500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "312b308b-2ce9-48fc-b97d-a5f3eed19685",
        "type": "message",
        "text": "I'd like to implement something like Bel in my machine code. With its emphasis on using little of the underlying platform it feels like a good fit for Mu. But I'm not sure when I'll get to that. I'm currently designing the C-ish level of the Mu stack.",
        "user": "UCUSW7WVD",
        "ts": "1570913994.250800",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "UC2A2ARPT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e05e358c-35c3-4723-885b-316a53de2e5d",
        "type": "message",
        "text": "The minimalistic approach I use is like a Lisp/Scheme evaluator, but all operations are stored as functions (native if necessary), and the evaluator simply looks them up from a dictionary and invokes them. No operations are \"built in\" to the language",
        "user": "UAVCC2X70",
        "ts": "1570914101.251000",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "ae110f04-3844-4121-956d-8eff41fc9265",
        "type": "message",
        "text": "While the Bel interpreter shown here is built in itself, it only needs a subset of Bel. One suggestion I had was to show two interpreters, one for Bel0 and one for the full Bel. Implement both in Bel0. That would improve the exposition, I think.",
        "user": "UCUSW7WVD",
        "ts": "1570914107.251200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1570914135.000000"
        },
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "70f2dbc6-92e3-4bea-b5e0-5ccd00809172",
        "type": "message",
        "text": "<@UAVCC2X70> Does your language have primitives that are not functions? Other languages have keywords. Lisp has special forms. Smalltalk has blocks. I suspect you can't avoid something like that.",
        "user": "UCUSW7WVD",
        "ts": "1570914235.251500",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "fb9d13d7-df0d-4550-9fd7-0206996ebe50",
        "type": "message",
        "text": "At the end of the day you are looking for some combination of 1) ease of learning and use during development, 2) ability to transfer projects from original author to maintainer gracefully, 3) aesthetic quality of the products produced, 4) target platform range, and 5) suitability for large data inputs. I don't think the future of computing is going to target niche markets like ML or exascale computing; those are best left to specialized toolchains custom made for that sort of thing. You could start by giving a product to clone, saying make me facebook in 3000 man hours, or pick some popular game, etc. Jonathan Blow's very clever Jai programming language is custom built around making his next game. The language does exactly what he needs for that game. And since it is a complex game, the language is pretty complex, and fairly low level as he is shooting for low power consoles like the Nintendo switch.",
        "user": "UEQ6M68H0",
        "ts": "1570914783.251700",
        "team": "T5TCAFTA9",
        "thread_ts": "1570632039.005300",
        "parent_user_id": "U5TCAFTD3",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "172c67e5-5366-44cd-a4d3-c7cf847aff8b",
        "type": "message",
        "text": "Smalltalk is a bit different: the entire Smalltalk system is written in Smalltalk, all the way down. It's similar in this sense to C and Unix, where the C compiler and the operating system are written in C. I gather that the Smalltalk bootstrapping process involves a small, statically typed subset of Smalltalk with semantics similar to C, but I'm not familiar with the details. C was originally bootstrapped using a C compiler written in assembly language, but I bet nobody has bootstrapped C in that way since the 1970's.",
        "user": "UJN1TAYEQ",
        "ts": "1570915304.252000",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "7303435c-fb86-4f4b-a737-e0cf28ae2e0a",
        "type": "message",
        "text": "It's not clear to me that Smalltalk is different. Since the substrate (machine code) isn't Smalltalk or C, it is by definition impossible that the entire system is written in Smalltalk all the way down. Even if nobody works on the bootstrap any more it's still worth spreading the knowledge about how the bootstrap works, precisely what subset of the language it uses, and how the semantics differ from the full language. Until we understand this we can't actually say how parsimonious Smalltalk's bootstrap is compared to other languages.\n\n(This may seem pedantic, but I think it's hugely important for the health of society: <https://app.slack.com/client/T5TCAFTA9/C5T9GPWFL>)",
        "user": "UCUSW7WVD",
        "ts": "1570916231.252400",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    },
    {
        "client_msg_id": "1d84401f-bcf8-46c8-aaa6-3d5a182c0fca",
        "type": "message",
        "text": "In a system like Bel, I gather that most Bel functions are written in Bel, but some Bel functions are 'primitive': they do not have source code written in Bel. In Smalltalk, nothing is primitive. The entire interpreter and virtual machine are written in Smalltalk. You can inspect the source code, you can debug it, you can change the way it works, using live coding within a running Smalltalk image. That's what's different, and that's what I meant by \"written in Smalltalk all the way down\".",
        "user": "UJN1TAYEQ",
        "ts": "1570916932.252600",
        "team": "T5TCAFTA9",
        "thread_ts": "1570892929.240300",
        "parent_user_id": "UNLS33M61"
    }
]