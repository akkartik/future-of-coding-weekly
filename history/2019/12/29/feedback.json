[
    {
        "client_msg_id": "cbe39f6c-bc85-47a9-ba61-0fff66ca72b7",
        "type": "message",
        "text": "Unfortunately the node and wire models that are so successful in music don't map well to general computing. In the example of an analog synthesizer, you might start with a simple pure tone sine wave, and then add an effect that modulates its frequency, creating a warble, then you might add distortion that fades in and out, and by virtue of mixing all these effect stages eventually create something very interesting. But the output of all music productions is either two channel stereo or in the case of film music surround sound. But you only have to please the two ears of the listener. Text or graphics for example doesn't add together well; you superimpose two pieces of text, you can't read either of them any more. It is the simple fact that audio channels can just be added together and it never gets ruined; the texture just gets thicker and better. Wagner was the first multi-track artist, and in the history of music, you can see the Beach Boy's Pet Sounds album produced by Brian Wilson was a high water mark for US music production technique at the time, but soon surpassed by George Martin's production of Sgt. Pepper's. I believe that Wilson went into a major depression when he heard Sgt. Peppers because it was so good. Anyway it is quite common now to see 24 or more audio tracks combined. The peak of that phase wa Quincy Jone's Thriller, arguably the best made record in history. But the producers can just sit at the mixing board and fiddle until it sounds just right. We programmers don't have a raw material that can be added. If you put a nice big graph on the screen, you just pushed off the screen something else you wanted. We software people live in a world of tiny screens where we have to trade off what gets the most space. Shaders, image filter stacking, and audio are examples of subsets of the computational space that are fundamentally additive.",
        "user": "UEQ6M68H0",
        "ts": "1577575029.331800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oxV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unfortunately the node and wire models that are so successful in music don't map well to general computing. In the example of an analog synthesizer, you might start with a simple pure tone sine wave, and then add an effect that modulates its frequency, creating a warble, then you might add distortion that fades in and out, and by virtue of mixing all these effect stages eventually create something very interesting. But the output of all music productions is either two channel stereo or in the case of film music surround sound. But you only have to please the two ears of the listener. Text or graphics for example doesn't add together well; you superimpose two pieces of text, you can't read either of them any more. It is the simple fact that audio channels can just be added together and it never gets ruined; the texture just gets thicker and better. Wagner was the first multi-track artist, and in the history of music, you can see the Beach Boy's Pet Sounds album produced by Brian Wilson was a high water mark for US music production technique at the time, but soon surpassed by George Martin's production of Sgt. Pepper's. I believe that Wilson went into a major depression when he heard Sgt. Peppers because it was so good. Anyway it is quite common now to see 24 or more audio tracks combined. The peak of that phase wa Quincy Jone's Thriller, arguably the best made record in history. But the producers can just sit at the mixing board and fiddle until it sounds just right. We programmers don't have a raw material that can be added. If you put a nice big graph on the screen, you just pushed off the screen something else you wanted. We software people live in a world of tiny screens where we have to trade off what gets the most space. Shaders, image filter stacking, and audio are examples of subsets of the computational space that are fundamentally additive."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "3425b627-4fc6-45a7-90f5-ae632fa5cc58",
        "type": "message",
        "text": "<@ULM3U6275> if you would like to see a great painting program for kids and have access to a windows program, you can get a free copy of my now ancient Flying Colors program. It was a big hit in its day (1995), and still runs even in Windows 10. It used a time travel feature for training, where it could narrate how to use the product while moving the mouse like a ghost. It was designed to be a sequel to KidPix  and had art from the incomparable pixel artist Mark Ferrari who did Loom, Monkey Island, and most recently Thimbleweek Park.   <https://www.magicmouse.com/downloads/Flying%20Colors%20211D.zip>\n\nBut to reinforce my point, the reason pixel-pushing programs work so well via direct manipulation interfaces, is that pixels in a bitmap add together easily. If you aren't blending, new pixels simply replace the old ones. You can't break the image by adding new pixels. At all times it functions as an image, while in general software, you add some new code and can easily break the whole product.",
        "user": "UEQ6M68H0",
        "ts": "1577575566.332000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZlnX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " if you would like to see a great painting program for kids and have access to a windows program, you can get a free copy of my now ancient Flying Colors program. It was a big hit in its day (1995), and still runs even in Windows 10. It used a time travel feature for training, where it could narrate how to use the product while moving the mouse like a ghost. It was designed to be a sequel to KidPix  and had art from the incomparable pixel artist Mark Ferrari who did Loom, Monkey Island, and most recently Thimbleweek Park.   "
                            },
                            {
                                "type": "link",
                                "url": "https://www.magicmouse.com/downloads/Flying%20Colors%20211D.zip"
                            },
                            {
                                "type": "text",
                                "text": "\n\nBut to reinforce my point, the reason pixel-pushing programs work so well via direct manipulation interfaces, is that pixels in a bitmap add together easily. If you aren't blending, new pixels simply replace the old ones. You can't break the image by adding new pixels. At all times it functions as an image, while in general software, you add some new code and can easily break the whole product."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "aa896188-7d7b-44d4-897f-b710681a5dd3",
        "type": "message",
        "text": "&gt; Unfortunately the node and wire models that are so successful in music don't map well to general computing.\nI am not sure there is such a thing as \"general computing\", at least in the sense of looking for A General Language that can be used for everything. As an exemple, the project I am working on currently for my company, is to use a scientific algorithms to produce snow and ice maps over Europe from satellite images. For this \"simple\" project, I use code for multiple things in different programming languages. Code for infrastructure in a Yaml based language specific to the cloud plateform I use (OpenStack), underlying scientific alglorithms in C++ with Python glue, Python for microservices, HTML/CSS/JavaScript/Vue for dashboard, SQL for DB, Dockerfile for containers, another Yaml based language for container orchestration and batch job management (HashiCorp Nomad). I can't see how a general language can handle all this programming use cases in an expressive way. But I can see the limitations of some of these text languages and I can imagine more expressive representation than text for some of them (for example the Yaml based language for infrastructure).",
        "user": "UJ6LDMMN0",
        "ts": "1577617809.332200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3Eqw",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unfortunately the node and wire models that are so successful in music don't map well to general computing."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am not sure there is such a thing as \"general computing\", at least in the sense of looking for A General Language that can be used for everything. As an exemple, the project I am working on currently for my company, is to use a scientific algorithms to produce snow and ice maps over Europe from satellite images. For this \"simple\" project, I use code for multiple things in different programming languages. Code for infrastructure in a Yaml based language specific to the cloud plateform I use (OpenStack), underlying scientific alglorithms in C++ with Python glue, Python for microservices, HTML/CSS/JavaScript/Vue for dashboard, SQL for DB, Dockerfile for containers, another Yaml based language for container orchestration and batch job management (HashiCorp Nomad). I can't see how a general language can handle all this programming use cases in an expressive way. But I can see the limitations of some of these text languages and I can imagine more expressive representation than text for some of them (for example the Yaml based language for infrastructure)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "URKL31C2J",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    }
]