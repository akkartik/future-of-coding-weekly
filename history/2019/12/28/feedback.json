[
    {
        "client_msg_id": "a8b2a531-aa0e-4906-8195-db4a232525db",
        "type": "message",
        "text": "IMO designing a \"composition model\" is the primary job in programming language design. Minimizing the amount of glue code you need to write when plugging components together is a major goal. Designing a type system is a big part of semantic composition. I take the same view for designing syntax: I want good syntactic composability for syntactic phrases, and I want to minimize the amount of \"glue syntax\" that you need to write.",
        "user": "UJN1TAYEQ",
        "ts": "1577492634.282600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z0Bu9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "IMO designing a \"composition model\" is the primary job in programming language design. Minimizing the amount of glue code you need to write when plugging components together is a major goal. Designing a type system is a big part of semantic composition. I take the same view for designing syntax: I want good syntactic composability for syntactic phrases, and I want to minimize the amount of \"glue syntax\" that you need to write."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "75ed158b-864c-42fe-97ea-f591ccddda99",
        "type": "message",
        "text": "The Unix shell has good syntactic composability. But the \"everything is text\" model requires too much parsing (glue code). As many people have observed, a more differentiated type system would eliminate a lot of the parsing glue, and provide better semantic composability.",
        "user": "UJN1TAYEQ",
        "ts": "1577493336.282800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AcY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The Unix shell has good syntactic composability. But the \"everything is text\" model requires too much parsing (glue code). As many people have observed, a more differentiated type system would eliminate a lot of the parsing glue, and provide better semantic composability."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "77eab782-ec02-4f9a-ab57-33bd4529f121",
        "type": "message",
        "text": "I was taught a style of object oriented programming wherein you define a large number of classes, each with a bespoke interface. Composability was considered a code smell. According to the \"Law of Demeter\" (as interpreted by my instructor), objects should only talk to their immediate friends, using a private language only that object and its friends understand. The goal of this was supposed to be \"information hiding\" and \"loose coupling\", and writing tons of glue code and boilerplate was how you achieved these important goals. Maybe other people can offer a different perspective on OOP, but I don't like this style of programming, and I prefer functional style programming, which focuses more on composability.",
        "user": "UJN1TAYEQ",
        "ts": "1577494865.283000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rlzE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was taught a style of object oriented programming wherein you define a large number of classes, each with a bespoke interface. Composability was considered a code smell. According to the \"Law of Demeter\" (as interpreted by my instructor), objects should only talk to their immediate friends, using a private language only that object and its friends understand. The goal of this was supposed to be \"information hiding\" and \"loose coupling\", and writing tons of glue code and boilerplate was how you achieved these important goals. Maybe other people can offer a different perspective on OOP, but I don't like this style of programming, and I prefer functional style programming, which focuses more on composability."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "e3d1c50b-128d-43e6-8ce8-42296d986caf",
        "type": "message",
        "text": "Please.",
        "user": "UL3FQ4PHB",
        "ts": "1577499076.283300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kMm3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Please."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577307438.157000",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_check_mark",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "92172cca-bb63-4048-9605-0af2873dc3a6",
        "type": "message",
        "text": "Actually photoshop is a huge collection of graphical manipulation subroutines that have a more user friendly front-end that lets you control via sliders and text entry fields the parameters to these magical functions which do some devious operation on the underlying channels of the image. I count over 500 different custom dialog boxes in Photoshop. Although one selects things and certainly one uses the mouse to track position when drawing, the vast bulk of Photoshop skill by users is not direct manipulation based, but learning how to use all those dialog boxes with their super tricky underlying function in the right order. I would venture to guess that Photoshop has the most PhD thesis content of any software product on earth, and is one of the most clever and difficult to copy software products. I could easily surpass Twitter's client, which is fairly stupid but Photoshop is probably 1000 man years to duplicate in its full glory.  Subsets of Photoshop's functionality exist of course, but if you dive down to the bottom of the vast menu and palette tree they offer, it is a monstrously complex product at this point. I would say they are reaching the omega point of complexity where each thing they add makes the product worse in usability.",
        "user": "UEQ6M68H0",
        "ts": "1577499391.283500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=1co",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Actually photoshop is a huge collection of graphical manipulation subroutines that have a more user friendly front-end that lets you control via sliders and text entry fields the parameters to these magical functions which do some devious operation on the underlying channels of the image. I count over 500 different custom dialog boxes in Photoshop. Although one selects things and certainly one uses the mouse to track position when drawing, the vast bulk of Photoshop skill by users is not direct manipulation based, but learning how to use all those dialog boxes with their super tricky underlying function in the right order. I would venture to guess that Photoshop has the most PhD thesis content of any software product on earth, and is one of the most clever and difficult to copy software products. I could easily surpass Twitter's client, which is fairly stupid but Photoshop is probably 1000 man years to duplicate in its full glory.  Subsets of Photoshop's functionality exist of course, but if you dive down to the bottom of the vast menu and palette tree they offer, it is a monstrously complex product at this point. I would say they are reaching the omega point of complexity where each thing they add makes the product worse in usability."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UBSMEUXAA"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "bed0bfcd-b385-41fb-8e26-abe62e8e31dd",
        "type": "message",
        "text": "&gt; teams focusing on the graphical interface before they defined their backend algebra.\nI feel attacked haha :joy:  /jk but to take an example from the computer graphics industry, we've come to build really solid node-based interfaces for all sorts of applications (shader creation, AI, game scripting, etc...) and this explosion of solutions is in most cases thanks to technical artists; a small subset of people in the industry that often come from an art background but end up diving into code because their problems never get solved/understood by programmers.\n\nThis however often results in softwares/plugins that are extremely easy and pleasing to read for the artist, but quite limited due to the lack of technical skills of most technical artists that try to solve these issues.\n\nThe CEO of the company I work for (Quixel, who just got acquired by Epic Games) started as a texture artist, got frustrated by all the manual work and the lack of efforts from engineers to solve common problems that artists have been facing for nearly a decade, and started coding in Photoshop with Actions (a macro system that helps you wrap a chain of commands into one clickable button), then Actionscript, etc... and a few years later the company grew to over 150+ people all around the world.\n\nThis has perplexed me for a long time, and often makes me wonder how different programming could be if there were more artists/designers involved in the creation process, instead of it being \"just\" programmers.",
        "user": "URKL31C2J",
        "ts": "1577509240.283800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DENj",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "teams focusing on the graphical interface before they defined their backend algebra."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI feel attacked haha "
                            },
                            {
                                "type": "emoji",
                                "name": "joy"
                            },
                            {
                                "type": "text",
                                "text": "  /jk but to take an example from the computer graphics industry, we've come to build really solid node-based interfaces for all sorts of applications (shader creation, AI, game scripting, etc...) and this explosion of solutions is in most cases thanks to technical artists; a small subset of people in the industry that often come from an art background but end up diving into code because their problems never get solved/understood by programmers.\n\nThis however often results in softwares/plugins that are extremely easy and pleasing to read for the artist, but quite limited due to the lack of technical skills of most technical artists that try to solve these issues.\n\nThe CEO of the company I work for (Quixel, who just got acquired by Epic Games) started as a texture artist, got frustrated by all the manual work and the lack of efforts from engineers to solve common problems that artists have been facing for nearly a decade, and started coding in Photoshop with Actions (a macro system that helps you wrap a chain of commands into one clickable button), then Actionscript, etc... and a few years later the company grew to over 150+ people all around the world.\n\nThis has perplexed me for a long time, and often makes me wonder how different programming could be if there were more artists/designers involved in the creation process, instead of it being \"just\" programmers."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UBSMEUXAA"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1",
                    "UJ6LDMMN0",
                    "UHWC9PXBL"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "38d184cf-a3eb-4e9f-892b-5993758487f2",
        "type": "message",
        "text": "Thanks for great insights guys, I loved this thread!! :slightly_smiling_face:",
        "user": "UFLN9JFRT",
        "ts": "1577510958.284700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UHZ5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for great insights guys, I loved this thread!! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "f1295558-7c28-48f6-b406-b29ca07e2e80",
        "type": "message",
        "text": "Hi everyone, one thing I should have emphasized up front: this paper is kinda tailored to the specific conference I'm submitting to. So please read the call for papers linked above if you haven't already. Many thanks.",
        "user": "UCUSW7WVD",
        "ts": "1577513503.285000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "opyli",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi everyone, one thing I should have emphasized up front: this paper is kinda tailored to the specific conference I'm submitting to. So please read the call for papers linked above if you haven't already. Many thanks."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577307438.157000",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "298020B1-9D71-4393-B2C3-EB7933384272",
        "type": "message",
        "text": "<@UFLN9JFRT> Oh, are we done yet? ;-)",
        "user": "U5STGTB3J",
        "ts": "1577534491.285900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+8E7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFLN9JFRT"
                            },
                            {
                                "type": "text",
                                "text": " Oh, are we done yet? ;-)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "D2A56D04-4394-4F4B-8D5E-A139ADAA1BC8",
        "type": "message",
        "text": "<@UJN1TAYEQ> Yes! Lots of truth in your comments. The post-Kay re-interpretation of OOP certainly was somewhat misguided, even though with good intentions \u2014 it is very natural to try to mirror an objective reality in a system and employing the same structure we thought we\u2019d naturally use in our heads.\n\nDesigning a composition model might be one of the most important aspects of designing a programming language, however, I think it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context.",
        "user": "U5STGTB3J",
        "ts": "1577534856.293300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "jBDwM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Yes! Lots of truth in your comments. The post-Kay re-interpretation of OOP certainly was somewhat misguided, even though with good intentions \u2014 it is very natural to try to mirror an objective reality in a system and employing the same structure we thought we\u2019d naturally use in our heads."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Designing a composition model might be one of the most important aspects of designing a programming language, however, I think it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "033F2347-BDE1-4505-A722-4CF9E93B03F8",
        "type": "message",
        "text": "Any other takes on what makes things composable? What\u2019s the essence of composability?",
        "user": "U5STGTB3J",
        "ts": "1577535235.295400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hugA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Any other takes on what makes things composable? What\u2019s the essence of composability?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "38E9EA6F-775C-472B-B95D-478BD5087EE1",
        "type": "message",
        "text": "<@UJN1TAYEQ> Can you elaborate on the difference between syntactic and semantic composability?",
        "user": "U5STGTB3J",
        "ts": "1577535238.295600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/mt/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " Can you elaborate on the difference between syntactic and semantic composability?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "D9BE6C46-FBF0-4D39-A886-D33A07F18E2F",
        "type": "message",
        "text": "<@U5STGTB3J> haha yep definitely not done yet, I want this thread to keep going. This is basically a learning stream for me, as a bystander lol :)",
        "user": "UFLN9JFRT",
        "ts": "1577537887.297500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DhX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " haha yep definitely not done yet, I want this thread to keep going. This is basically a learning stream for me, as a bystander lol :)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "93552AC9-C5A0-4824-AE14-AA621232E673",
        "type": "message",
        "text": "<@U5STGTB3J> although some of this thread still goes above my head. I still haven\u2019t figured out what a monad or monoid is, so I need some dumbing down  with the explanations ",
        "user": "UFLN9JFRT",
        "ts": "1577538098.299700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yEnM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " although some of this thread still goes above my head. I still haven\u2019t figured out what a monad or monoid is, so I need some dumbing down  with the explanations "
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "70CE40AA-0E32-4963-AB66-0E82655738F6",
        "type": "message",
        "text": "Also are we trying to solve a problem with composing things that maybe taking it too far. I always get reminded of this <https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/|https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/>",
        "user": "UFLN9JFRT",
        "ts": "1577538662.301800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "Joel on Software",
                "title": "Architecture astronauts take over",
                "title_link": "https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/",
                "text": "It was seven years ago today when everybody was getting excited about Microsoft\u2019s bombastic announcement of Hailstorm, promising that \u201cHailstorm makes the technology in your life work t\u2026",
                "fallback": "Joel on Software: Architecture astronauts take over",
                "thumb_url": "https://i0.wp.com/www.joelonsoftware.com/wp-content/uploads/2016/12/11969842.jpg?fit=400%2C400&ssl=1",
                "ts": 1209600714,
                "from_url": "https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://i0.wp.com/www.joelonsoftware.com/wp-content/uploads/2016/12/11969842.jpg?fit=180%2C180&#038;ssl=1",
                "id": 1,
                "original_url": "https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+aN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also are we trying to solve a problem with composing things that maybe taking it too far. I always get reminded of this "
                            },
                            {
                                "type": "link",
                                "url": "https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/",
                                "text": "https://www.joelonsoftware.com/2008/05/01/architecture-astronauts-take-over/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "72d66429-81ab-4eb5-a422-3afa77c08a9d",
        "type": "message",
        "text": "<@UFLN9JFRT> Welcome to Future of Coding, the club for Architecture Astronauts. I'm serious: we have ambitious goals for the future of coding, and to reach these goals, we need to be able to see the big picture, which can only be seen from orbit. Some of us use mathematical tools, abstract algebra and category theory (monoids and monads) to help us see the big picture. Of course, we don't want to stay in orbit permanently: at some point you must leave the design phase, touch ground and write useful code. And many people in our community are doing that.",
        "user": "UJN1TAYEQ",
        "ts": "1577548795.302100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dlkE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UFLN9JFRT"
                            },
                            {
                                "type": "text",
                                "text": " Welcome to Future of Coding, the club for Architecture Astronauts. I'm serious: we have ambitious goals for the future of coding, and to reach these goals, we need to be able to see the big picture, which can only be seen from orbit. Some of us use mathematical tools, abstract algebra and category theory (monoids and monads) to help us see the big picture. Of course, we don't want to stay in orbit permanently: at some point you must leave the design phase, touch ground and write useful code. And many people in our community are doing that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ab7f3804-bb15-4bd2-953b-5021d5450534",
        "type": "message",
        "text": "&gt; <@U5STGTB3J> Designing a composition model might be one of the most important aspects of designing a programming language, however, I think it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context.\nThis assumes a very narrow definition of \"programming language\", and my plans for the future of coding involve expanding the definition of \"programming language\" to encompass the entire system. Many past systems were like this, so I can point to earlier systems in order to show that this is feasible.\n\nFor example, the original Unix system (before Macintosh-style GUIs were added) was a programming language. The user interface was the shell, which is a programming language. Every shell command is a program written in the shell language. Abstract mechanisms like variables, functions, conditionals and loops are right at hand. The Unix file system is the global namespace for this programming language. Want to do some word processing? Troff is a programming language, and a word processing document is a program written in that language. With Unix, you booted right into an IDE, and you stayed in that IDE the whole time you were using the computer. Of course 1970's Unix was difficult to use by modern standards, but that's not the point. The point is that Unix mimiced the user interfaces of early systems, and extended those interfaces into programming languages without making them harder to use. The Unix shell looked a lot like earlier and more primitive command line interfaces that weren't fully programmable. Troff was just runoff extended to be fully programmable.",
        "user": "UJN1TAYEQ",
        "ts": "1577551174.308300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T8bCn",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " Designing a composition model might be one of the most important aspects of designing a programming language, however, I think it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This assumes a very narrow definition of \"programming language\", and my plans for the future of coding involve expanding the definition of \"programming language\" to encompass the entire system. Many past systems were like this, so I can point to earlier systems in order to show that this is feasible.\n\nFor example, the original Unix system (before Macintosh-style GUIs were added) was a programming language. The user interface was the shell, which is a programming language. Every shell command is a program written in the shell language. Abstract mechanisms like variables, functions, conditionals and loops are right at hand. The Unix file system is the global namespace for this programming language. Want to do some word processing? Troff is a programming language, and a word processing document is a program written in that language. With Unix, you booted right into an IDE, and you stayed in that IDE the whole time you were using the computer. Of course 1970's Unix was difficult to use by modern standards, but that's not the point. The point is that Unix mimiced the user interfaces of early systems, and extended those interfaces into programming languages without making them harder to use. The Unix shell looked a lot like earlier and more primitive command line interfaces that weren't fully programmable. Troff was just runoff extended to be fully programmable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "c6a7bc4a-f13a-4618-a1d7-d59c6aa44a4f",
        "type": "message",
        "text": "Yes, programming languages do design the composition methods inside of them. I came to respond to that but <@U5STGTB3J> already said it much better so I'll just quote it\n&gt; it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context.\nYes, yes! One connotation of the 'language context' is that we write programs in full, and then run them, but the composition of two running programs is not usually considered a 'program'.\n&gt; my plans for the future of coding involve expanding the definition of \"programming language\" to encompass the entire system\nSounds very interesting. At this point is it worth calling it a programming language? We don't usually call Excel a programming language. And when we talk of Smalltalk as a programming language that fits on a postcard, I think it misses a key aspect of programming Smalltalk in that you're not writing then running programs in batch mode, but rather crafting the system very differently by tweaking parts of it live. It's kind of like the Unix shell in some sense?",
        "user": "U8A5MS6R1",
        "ts": "1577553048.327700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1577553083.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Rk2UN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, programming languages do design the composition methods inside of them. I came to respond to that but "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " already said it much better so I'll just quote it\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "it\u2019s worth to note that at that point, once you decided to design a programming language, you have already made a lot of assumptions and entered a context that makes the bigger picture harder to see and you might overlook other ways to compose systems, outside the language context."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, yes! One connotation of the 'language context' is that we write programs in full, and then run them, but the composition of two running programs is not usually considered a 'program'.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "my plans for the future of coding involve expanding the definition of \"programming language\" to encompass the entire system"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sounds very interesting. At this point is it worth calling it a programming language? We don't usually call Excel a programming language. And when we talk of Smalltalk as a programming language that fits on a postcard, I think it misses a key aspect of programming Smalltalk in that you're not writing then running programs in batch mode, but rather crafting the system very differently by tweaking parts of it live. It's kind of like the Unix shell in some sense?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "7389af95-8dda-4893-8a4f-753ad55a2350",
        "type": "message",
        "text": "&gt;  how different programming could be if there were more artists/designers involved in the creation process\nProbably much nicer to use.",
        "user": "U8A5MS6R1",
        "ts": "1577553394.328000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "omaJx",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " how different programming could be if there were more artists/designers involved in the creation process"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Probably much nicer to use."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "cea91518-5a24-494d-ac20-3a0b67472b98",
        "type": "message",
        "text": "I mean HCI has branched off from PLs but really should it be a totally separate field? A programming language is a human interface.",
        "user": "U8A5MS6R1",
        "ts": "1577553453.328200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "68sv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mean HCI has branched off from PLs but really should it be a totally separate field? A programming language is a human interface."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "6A7CD2D8-44E9-44EC-B35D-8DBD569F1AC2",
        "type": "message",
        "text": "<@UJN1TAYEQ> thanks, that was a useful response. I would actually like to know what those goals are , something concrete, instead of just saying we want to make computation easier. What are the use cases that will be solved?",
        "user": "UFLN9JFRT",
        "ts": "1577555748.330700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wctf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " thanks, that was a useful response. I would actually like to know what those goals are , something concrete, instead of just saying we want to make computation easier. What are the use cases that will be solved?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "309104d3-f682-4814-9b1d-03d3128357e6",
        "type": "message",
        "text": "<@UEQ6M68H0> \u201cActually photoshop is a huge collection of graphical manipulation subroutines\u2026\u201d\n\nI\u2019ve never used it and was (apparently) incorrectly using it as a prototypical drawing application as drawing apps seem to be good examples of the power of direct manipulation. Please replace my mentions of it with \u201cdrawing application\u201d when considering my remarks.",
        "user": "ULM3U6275",
        "ts": "1577556331.330900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1577558327.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bV4e",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " \u201cActually photoshop is a huge collection of graphical manipulation subroutines\u2026\u201d\n\nI\u2019ve never used it and was (apparently) incorrectly using it as a prototypical drawing application as drawing apps seem to be good examples of the power of direct manipulation. Please replace my mentions of it with \u201cdrawing application\u201d when considering my remarks."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "306c8f66-c99b-4ee6-8000-4af81c5a20e1",
        "type": "message",
        "text": "Considering nodes and arrows languages, take MaxMSP for audio processing and compare to equivalent text/algebra code. The former is more expressive even if you can always map it to the later.",
        "user": "UJ6LDMMN0",
        "ts": "1577572134.331600",
        "team": "T5TCAFTA9",
        "thread_ts": "1577254484.117800",
        "parent_user_id": "UEQ6M68H0"
    }
]