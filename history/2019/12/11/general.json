[
    {
        "client_msg_id": "07884c1b-2249-47b3-83f6-11aa59e2449e",
        "type": "message",
        "text": "ty",
        "user": "UL3CJ7YKC",
        "ts": "1576021604.312900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qm1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "ty"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575999932.302500",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "5526b1df-1b1e-436a-a3ce-70b342e65c29",
        "type": "message",
        "text": "<@UBN9AFS0N> Ahh that is really useful! Especially the fact orleans is something similar! Thanks a lot!\n\nCould you please expand on these? :)\n\u2022 \u201cActors build on top are *cooperative*\u201d\n\u2022 \u201cmessages are copied when sent\u201d - how is that not possible on jvm/akka? It is, right? Or with some downside opposed to the erlang version?\n\u2022 \u201cmost of BEAM features have some JVM equivalents, but the BEAM is built from the ground up to solve those problems\u201d - Is it possible that on the long run virtually all features will be implemented on JVM and with the perf + ecosystem difference BEAM will slowly fade away? If you would not bet on that, why?\n\u2022 \u201cI like orleans more\u201d - that is interesting! Why is that?",
        "user": "UL3CJ7YKC",
        "ts": "1576022117.317800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1576022205.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fz2J",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBN9AFS0N"
                            },
                            {
                                "type": "text",
                                "text": " Ahh that is really useful! Especially the fact orleans is something similar! Thanks a lot!\n\nCould you please expand on these? :)\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201cActors build on top are "
                                    },
                                    {
                                        "type": "text",
                                        "text": "cooperative",
                                        "style": {
                                            "bold": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": "\u201d"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201cmessages are copied when sent\u201d - how is that not possible on jvm/akka? It is, right? Or with some downside opposed to the erlang version?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201cmost of BEAM features have some JVM equivalents, but the BEAM is built from the ground up to solve those problems\u201d - Is it possible that on the long run virtually all features will be implemented on JVM and with the perf + ecosystem difference BEAM will slowly fade away? If you would not bet on that, why?"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "\u201cI like orleans more\u201d - that is interesting! Why is that?"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "4ae30851-3116-40d4-a65b-11a3f6323790",
        "type": "message",
        "text": "Low-code/no code/red-lang/spreadsheets etc - I have been thinking about no-code apps etc, the problem of how to make programming more accessible. When it comes to making programming more accessible, one challenge that I see is combining the UI, data store and calculations. It is a challenge to combine these in a way that is accessible to the masses. An example of the challenge is no-code applications. There are many no-code applications that make it easy to edit the UI and data store. They offer an easy to use solution with very little learning. But don't make calculations available. A similar problem with most low-code applications, the calculations part of low code applications is typically not accessible in the way that a spreadsheet is, for example. ... Or there is red-lang, it does a good job of linking UI and calculations, but the data store is, as far as I can tell, a regular external database.  ... Or take a spreadsheet, it is good at data storage and calculations, these are both accessible with very little learning, but the UI is a problem, you can't create a regular UI with a spreadsheet, you need to use the grid. Or look at scratch (drag and drop coding) it makes calculations and game style UI available, you can create complex games with it, I was surprised how complex, and it is easy to learn, but does not do data storage or data i/o style UI. .... The hard thing looks to be making UI, data store and calculations work as one. So the calculations can do validation and control writes to the data store. So the calculations are able to produce a responsive UI that guides the user. So the data from the data store is visible and editable in the UI.  ... it looks to be a hard problem to make the UI, data store and calculations work together. It can be a challenge to do this in a good programming language, and very hard to create something that is easy for people to learn.",
        "user": "UP6G25H35",
        "ts": "1576025152.342800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UP6G25H35",
            "ts": "1576026191.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eUp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Low-code/no code/red-lang/spreadsheets etc - I have been thinking about no-code apps etc, the problem of how to make programming more accessible. When it comes to making programming more accessible, one challenge that I see is combining the UI, data store and calculations. It is a challenge to combine these in a way that is accessible to the masses. An example of the challenge is no-code applications. There are many no-code applications that make it easy to edit the UI and data store. They offer an easy to use solution with very little learning. But don't make calculations available. A similar problem with most low-code applications, the calculations part of low code applications is typically not accessible in the way that a spreadsheet is, for example. ... Or there is red-lang, it does a good job of linking UI and calculations, but the data store is, as far as I can tell, a regular external database.  ... Or take a spreadsheet, it is good at data storage and calculations, these are both accessible with very little learning, but the UI is a problem, you can't create a regular UI with a spreadsheet, you need to use the grid. Or look at scratch (drag and drop coding) it makes calculations and game style UI available, you can create complex games with it, I was surprised how complex, and it is easy to learn, but does not do data storage or data i/o style UI. .... The hard thing looks to be making UI, data store and calculations work as one. So the calculations can do validation and control writes to the data store. So the calculations are able to produce a responsive UI that guides the user. So the data from the data store is visible and editable in the UI.  ... it looks to be a hard problem to make the UI, data store and calculations work together. It can be a challenge to do this in a good programming language, and very hard to create something that is easy for people to learn."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "reply_count": 11,
        "reply_users_count": 5,
        "latest_reply": "1576197372.390200",
        "reply_users": [
            "UEBG0NPDK",
            "ULM3U6275",
            "UP6G25H35",
            "UEQ6M68H0",
            "UE6EFEPTQ"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            },
            {
                "name": "bulb",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UA14TGLTC",
                    "URDRJEWS0",
                    "UPDJV04FR"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "ea82d211-497d-46ea-9550-1bd082acb99c",
        "type": "message",
        "text": "In Erlang/BEAM the runtime partitions the memory into isolated heaps. Cross heap references are not possible. All code evaluation is done by the runtime so all objects created only refer to the local heap. If you send something over to another heap, it is copied. This is similar to how Unix processes have isolated heaps.\n\nThe JVM is one big heap and any object cam refer to any other object anywhere. The runtime itself doesn't prevent any references. Now if you implement a framework on top that creates partitioned heaps and allows copying - you can only get so far. There will always be holes and once you use any shared library outside your framework, all bets are off. This kind of isolation is very hard to retrofit. Python has the same limitation (as Java).\n\nA similar thing happens with lightweight threads. The Erlang runtime decides which heap/process (each heap is associated with a process) gets to run for how many steps. Then it can run another process for some steps. The multiplexing is preemptive so no tight loop can starve other processes. With user threads in Java, the code is supposed to call `yield` or something like that every so often and only then control goes back to the main loop which will schedule another thread. You can have starvation and latency spikes. Again this is hard to retrofit. The only preemptive scheduling available in JVM uses the (heavy) system threads.\n\nFWIW, I think the Erlang isolated heap lightweight process model is great. Go copied the lightweight process (with preemptive scheduling) but it still uses a single heap.",
        "user": "U8A5MS6R1",
        "ts": "1576026127.343000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "P0hPJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Erlang/BEAM the runtime partitions the memory into isolated heaps. Cross heap references are not possible. All code evaluation is done by the runtime so all objects created only refer to the local heap. If you send something over to another heap, it is copied. This is similar to how Unix processes have isolated heaps.\n\nThe JVM is one big heap and any object cam refer to any other object anywhere. The runtime itself doesn't prevent any references. Now if you implement a framework on top that creates partitioned heaps and allows copying - you can only get so far. There will always be holes and once you use any shared library outside your framework, all bets are off. This kind of isolation is very hard to retrofit. Python has the same limitation (as Java).\n\nA similar thing happens with lightweight threads. The Erlang runtime decides which heap/process (each heap is associated with a process) gets to run for how many steps. Then it can run another process for some steps. The multiplexing is preemptive so no tight loop can starve other processes. With user threads in Java, the code is supposed to call "
                            },
                            {
                                "type": "text",
                                "text": "yield",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or something like that every so often and only then control goes back to the main loop which will schedule another thread. You can have starvation and latency spikes. Again this is hard to retrofit. The only preemptive scheduling available in JVM uses the (heavy) system threads.\n\nFWIW, I think the Erlang isolated heap lightweight process model is great. Go copied the lightweight process (with preemptive scheduling) but it still uses a single heap."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UL3CJ7YKC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5d7b87af-122a-4ee1-b1bd-0962151b3684",
        "type": "message",
        "text": "Take a look at Eve: <http://witheve.com/>",
        "user": "UEBG0NPDK",
        "ts": "1576026755.343300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Eve",
                "title_link": "http://witheve.com/",
                "text": "Eve: Programming designed for humans.",
                "fallback": "Eve",
                "from_url": "http://witheve.com/",
                "service_name": "witheve.com",
                "id": 1,
                "original_url": "http://witheve.com/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JEV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Take a look at Eve: "
                            },
                            {
                                "type": "link",
                                "url": "http://witheve.com/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "d6653525-6127-4ef4-b2ce-bf7e79cd0cd1",
        "type": "message",
        "text": "<@UR482RFPY> just came across this <http://tomasp.net/academic/papers/inforich/inforich-msr.pdf> . Seems to be a decent amount of work in this area in F#",
        "user": "UMVFWPZ36",
        "ts": "1576030892.343600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BTy2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UR482RFPY"
                            },
                            {
                                "type": "text",
                                "text": " just came across this "
                            },
                            {
                                "type": "link",
                                "url": "http://tomasp.net/academic/papers/inforich/inforich-msr.pdf"
                            },
                            {
                                "type": "text",
                                "text": " . Seems to be a decent amount of work in this area in F#"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575413468.408200",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "103a6aba-f49e-46ef-bd54-d6b842109fb9",
        "type": "message",
        "text": "Thanks <@UMVFWPZ36>, I'll check it out",
        "user": "UR482RFPY",
        "ts": "1576031213.343800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0UB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UMVFWPZ36"
                            },
                            {
                                "type": "text",
                                "text": ", I'll check it out"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575413468.408200",
        "parent_user_id": "UR482RFPY"
    },
    {
        "client_msg_id": "27F5A06C-ABE8-4172-8F17-25FF72414347",
        "type": "message",
        "text": "You\u2019ve hit the nail on the head. Every FoC project I\u2019m aware of misses the mark on some combination of UI, storage, or \u201ccalculation\u201d.",
        "user": "ULM3U6275",
        "ts": "1576032315.346600",
        "team": "T5TCAFTA9",
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "188B88DD-2017-4760-9753-E8A7E082FAE2",
        "type": "message",
        "text": "I would add that (I suspect) the reason for this is that none are focused on reusability, which is why they don\u2019t consider having to reimplement the missing aspects as a problem.",
        "user": "ULM3U6275",
        "ts": "1576032569.350400",
        "team": "T5TCAFTA9",
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT",
                    "UKP3B2J5D",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "3978BC99-E2C4-4539-B9CC-D7CD7407CFBA",
        "type": "message",
        "text": "Anarchists unite!",
        "user": "U6KQ2S410",
        "ts": "1576034225.351000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UyNT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Anarchists unite!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575912122.225300",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "bomb",
                "users": [
                    "UE6EFEPTQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5cea17e7-40eb-4b9b-91c0-4facfd459bdf",
        "type": "message",
        "text": "<@ULM3U6275> I assume you mean code reuse. Code reuse is an interesting problem. Thinking about it, it is almost as if code reuse makes the problem hard. e.g. a database is code, a button is code, string search is code. They all tend to exist separately from each other. I suspect some of this is standards for the data. They all have data that goes in/out, they need the right data to work correctly. .... interesting topic, I will think about it.",
        "user": "UP6G25H35",
        "ts": "1576037009.351200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "90WY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " I assume you mean code reuse. Code reuse is an interesting problem. Thinking about it, it is almost as if code reuse makes the problem hard. e.g. a database is code, a button is code, string search is code. They all tend to exist separately from each other. I suspect some of this is standards for the data. They all have data that goes in/out, they need the right data to work correctly. .... interesting topic, I will think about it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "ed408837-02cf-4c49-9c43-58293258a740",
        "type": "message",
        "text": "My Beads language does this type of subscription system, with dependency analysis. Dependency analysis was really put forth in PROLOG, and we haven't seen much of it for a very long time. You are entirely correct that this approach solves some, but not all, issues of concurrent programming. It works wonders for multiplayer games, but does not solve the issue of contradictory transactions, which in business is not really done outside of bitcoin-like stuff, because once you transfer money to a bank account, there is nothing stopping the party from further transferring it; so one in general business does not presume unwindability. Traditionally you issue a credit or debit to cancel out the prior transaction, but you don't erase anything ever.",
        "user": "UEQ6M68H0",
        "ts": "1576042756.351400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XJ8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My Beads language does this type of subscription system, with dependency analysis. Dependency analysis was really put forth in PROLOG, and we haven't seen much of it for a very long time. You are entirely correct that this approach solves some, but not all, issues of concurrent programming. It works wonders for multiplayer games, but does not solve the issue of contradictory transactions, which in business is not really done outside of bitcoin-like stuff, because once you transfer money to a bank account, there is nothing stopping the party from further transferring it; so one in general business does not presume unwindability. Traditionally you issue a credit or debit to cancel out the prior transaction, but you don't erase anything ever."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575999812.302200",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UL3CJ7YKC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b030d2db-0fe7-4c4c-b491-3a951e827a58",
        "type": "message",
        "text": "<@UP6G25H35> I believe you are correct that the core problem holding back reuseability of code is the lack of a general purpose, extendable, data structure standard that allows differing modules to share and add information without disturbing other modules' functions. VB6 surprisingly got very close to this system by having little tables, and you could add fields to existing things. Java allowed you to add properties, and achieves some semblance of  extensibility, but its clumsiness made the perusal of data structures (i believe they call it reflection in the Java universe) painful. It is indeed a very interesting topic.",
        "user": "UEQ6M68H0",
        "ts": "1576043072.351700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iD/Ns",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP6G25H35"
                            },
                            {
                                "type": "text",
                                "text": " I believe you are correct that the core problem holding back reuseability of code is the lack of a general purpose, extendable, data structure standard that allows differing modules to share and add information without disturbing other modules' functions. VB6 surprisingly got very close to this system by having little tables, and you could add fields to existing things. Java allowed you to add properties, and achieves some semblance of  extensibility, but its clumsiness made the perusal of data structures (i believe they call it reflection in the Java universe) painful. It is indeed a very interesting topic."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UP6G25H35"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "193351e4-4682-4eec-b0de-86e5478cd929",
        "type": "message",
        "text": "Myself i am building my system for the new hardware in the pipeline which requires a new model of computation, as RAM will become non-volatile.",
        "user": "UEQ6M68H0",
        "ts": "1576043137.351900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TSG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Myself i am building my system for the new hardware in the pipeline which requires a new model of computation, as RAM will become non-volatile."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "5b9bf19d-06a1-4781-8096-fedf61c78685",
        "type": "message",
        "text": "<@UJN1TAYEQ> <@UKB1S7ZMY> There are a number of visual languages based on Haskell that represent recursive functions and pattern matching: Visual Haskell (chapter four of <https://ptolemy.berkeley.edu/~johnr/papers/pdf/thesis.pdf>), Viskell (<https://github.com/viskell/viskell/blob/master/viskell-nlfpday.pdf>), and Glance (<https://github.com/rgleichman/glance>). Glance can have recursive unnamed functions (lambdas), I'm not sure if that's possible in the other visual languages.",
        "user": "UP3FH4CLU",
        "ts": "1576052463.352200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lQA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UKB1S7ZMY"
                            },
                            {
                                "type": "text",
                                "text": " There are a number of visual languages based on Haskell that represent recursive functions and pattern matching: Visual Haskell (chapter four of "
                            },
                            {
                                "type": "link",
                                "url": "https://ptolemy.berkeley.edu/~johnr/papers/pdf/thesis.pdf"
                            },
                            {
                                "type": "text",
                                "text": "), Viskell ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/viskell/viskell/blob/master/viskell-nlfpday.pdf"
                            },
                            {
                                "type": "text",
                                "text": "), and Glance ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/rgleichman/glance"
                            },
                            {
                                "type": "text",
                                "text": "). Glance can have recursive unnamed functions (lambdas), I'm not sure if that's possible in the other visual languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575957899.255600",
        "parent_user_id": "UPDJV04FR"
    },
    {
        "client_msg_id": "a4d32f89-e7ec-4972-9938-ac7e9e9a88f1",
        "type": "message",
        "text": "<@UL3CJ7YKC> Shalab explained preemptive/cooperative above :slightly_smiling_face:",
        "user": "UBN9AFS0N",
        "ts": "1576053831.352400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nKC3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UL3CJ7YKC"
                            },
                            {
                                "type": "text",
                                "text": " Shalab explained preemptive/cooperative above "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "a762e56e-f8a3-43eb-b7fe-6d5f748221aa",
        "type": "message",
        "text": "<@UP6G25H35> You've missed one major block: networking!\nIn Onex, I have four major blocks:\n\u2022 ONF - data store, graph, update notification\n\u2022 ONP - P2P networking\n\u2022 ONR - rules language ('calculations' as you say)\n\u2022 ONT - i/o, UI, domain types\n",
        "user": "UE6EFEPTQ",
        "ts": "1576055863.352700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PSe+F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UP6G25H35"
                            },
                            {
                                "type": "text",
                                "text": " You've missed one major block: networking!\nIn Onex, I have four major blocks:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "ONF - data store, graph, update notification"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "ONP - P2P networking"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "ONR - rules language ('calculations' as you say)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "ONT - i/o, UI, domain types"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": []
                    }
                ]
            }
        ],
        "thread_ts": "1576025152.342800",
        "parent_user_id": "UP6G25H35"
    },
    {
        "client_msg_id": "01596314-87d3-44d6-8f50-a7eba44a7ba5",
        "type": "message",
        "text": "Thanks for the suggestions <@UP3FH4CLU>!",
        "user": "UKB1S7ZMY",
        "ts": "1576059352.352900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AEvO5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for the suggestions "
                            },
                            {
                                "type": "user",
                                "user_id": "UP3FH4CLU"
                            },
                            {
                                "type": "text",
                                "text": "!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1575957899.255600",
        "parent_user_id": "UPDJV04FR"
    },
    {
        "client_msg_id": "2E9B1982-11A1-43DF-84B0-269679008069",
        "type": "message",
        "text": "<@U8A5MS6R1> Awesome! Thanks! \n\n<@UBN9AFS0N> What about your orleans, why do you like it the most? :)",
        "user": "UL3CJ7YKC",
        "ts": "1576061560.354100",
        "team": "T5TCAFTA9",
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "b4f0a66e-a592-4852-b8c8-5742cddd02de",
        "type": "message",
        "text": "the concept of virtual actors, actors that \"always\" exist and the lifetime is handled transparently by the runtime, this means you can send a message to an actor and don't care if it doesn't exist yet, just crashed, was suspended or is being migrated to another node, the runtime will take care of finding it and delivering the message. The same with runtime support for actor state persistence.",
        "user": "UBN9AFS0N",
        "ts": "1576062233.354400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wpUp0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the concept of virtual actors, actors that \"always\" exist and the lifetime is handled transparently by the runtime, this means you can send a message to an actor and don't care if it doesn't exist yet, just crashed, was suspended or is being migrated to another node, the runtime will take care of finding it and delivering the message. The same with runtime support for actor state persistence."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UL3CJ7YKC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ebb7e80a-e07e-4c55-9725-e795e0fbef51",
        "type": "message",
        "text": "Now that I think about it, it sounds like distributed smalltalk :stuck_out_tongue:",
        "user": "UBN9AFS0N",
        "ts": "1576062271.354600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nsr0x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Now that I think about it, it sounds like distributed smalltalk "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1576009389.307100",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "smile",
                "users": [
                    "UL3CJ7YKC"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "C4672B93-D53E-4074-821F-99E6B823F15A",
        "type": "message",
        "text": "<@UEQ6M68H0>  jesus! I was not aware of this but seems really close to my thoughts! (I've just checked a reddit thread by CodingFiend - its you right? :) ).\n\nIt is really interesting you mentioned Prolog, because I just wanted to add a question to this thread: if you (FoC) are aware of a language which uses declarative constraints + a solver as a robust glue between core pieces of code.   With loose declarative constraints instead tight/rigid imperative code seems inevitable to me if we want better programming environment. \n\n<@UEQ6M68H0>  is this something you have already considered, right? Where can I find more about your thinking process which lead you to beads?",
        "user": "UL3CJ7YKC",
        "ts": "1576065642.364100",
        "team": "T5TCAFTA9",
        "thread_ts": "1575999812.302200",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "CD780256-94DA-49A4-A11F-13B9CCE53426",
        "type": "message",
        "text": "<@UEQ6M68H0>  I asked the question because the links were down for the old site but now I found \" <http://beadslang.org/blog> \" and I see the same expressions what I have \"fed up with current complex programming\" :) Do you have more on the design process? Can  try the lang / read a docs?",
        "user": "UL3CJ7YKC",
        "ts": "1576066473.368300",
        "team": "T5TCAFTA9",
        "thread_ts": "1575999812.302200",
        "parent_user_id": "UL3CJ7YKC"
    }
]