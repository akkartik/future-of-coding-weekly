[
    {
        "client_msg_id": "a353837a-0486-4940-8825-2471321ae519",
        "type": "message",
        "text": "<@ULM3U6275> which recording tool do you favor for screen captures? The mac comes with Quictime screen recording, but those files do get rather large. Be nice to find something that compresses as it goes.",
        "user": "UEQ6M68H0",
        "ts": "1577144820.058600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bnf8Q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "ULM3U6275"
                            },
                            {
                                "type": "text",
                                "text": " which recording tool do you favor for screen captures? The mac comes with Quictime screen recording, but those files do get rather large. Be nice to find something that compresses as it goes."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577070542.049700",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "8162ee13-754b-48a9-91a4-ef6927259cc5",
        "type": "message",
        "text": "I've been writing this thing for a while - on and off. Finally 'finished' it enough. Hope you like it. <https://shalabh.com/programmable-systems/on-composition.html>",
        "user": "U8A5MS6R1",
        "ts": "1577178650.059300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1577178734.000000"
        },
        "attachments": [
            {
                "title": " On Composition  ",
                "title_link": "https://shalabh.com/programmable-systems/on-composition.html",
                "text": "Our composition models are poor and don't scale well.",
                "fallback": " On Composition  ",
                "from_url": "https://shalabh.com/programmable-systems/on-composition.html",
                "service_name": "shalabh.com",
                "id": 1,
                "original_url": "https://shalabh.com/programmable-systems/on-composition.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lvw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been writing this thing for a while - on and off. Finally 'finished' it enough. Hope you like it. "
                            },
                            {
                                "type": "link",
                                "url": "https://shalabh.com/programmable-systems/on-composition.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "reply_count": 41,
        "reply_users_count": 7,
        "latest_reply": "1586631989.111100",
        "reply_users": [
            "U5STGTB3J",
            "UCUSW7WVD",
            "UJN1TAYEQ",
            "U8A5MS6R1",
            "UHZUS56SV",
            "UFLN9JFRT",
            "UJBAJNFLK"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "U7C7B75R6",
                    "UFLN9JFRT",
                    "UJBAJNFLK"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "79CF8C2B-71D9-432A-AD7C-8AA11F6C49E0",
        "type": "message",
        "text": "I like it very much! Yes, this is a great lens on one of the big issues that\u2019s causing a lot of complexity in our field.\n\nSome random thoughts:\n\n1. I\u2019ve always wondered why the Unix command line and in particular its pipe feature is considered a good solution and what makes it so special. I don\u2019t have a final conclusion, but I suspect the \u201cfuzziness\u201d of the not very clearly defined text stream interface has to do with it. Every other data format you list tries very hard to be precise in describing data structure and even types. The text stream a sort command operates on, just needs agreement on the used delimiter. When specifying function interfaces within a programming language we\u2019re by default already in a much more precise type system (even in dynamically types languages), which prevent that level of ambiguity (and break-ability).\n2. Human language also has this fuzziness: we can describe concepts without being sure that the person we talk to has the same definitions. Surprisingly, it works more often than it doesn\u2019t, even though the receiver has a slightly different understanding than the sender. Programming languages break as soon as there is the slightest mismatch in syntax, grammar, or data types. We design data formats like programming languages. There\u2019s is no room for ambiguity. By design. Maybe there should be.\n3. The pipe-able Unix text stream \u201ctype\u201d is a very loose specification of a type, and it\u2019s kind of monoidal in nature \u2014 everything going through a filter command line program ends up as another text stream. The required structure to make piping work is minimal and doesn\u2019t even touch on what the data in that text stream actually is. That makes it extremely generic and composable. The parameters and return values in function calls are very specific and usually mix strict expectations on both structure and data type/format. By that we\u2019re creating countless different API calls that are all not easily composable.\n4. #3 is also a not yet well expressed reason why functional/declarative is superior to imperative. Imperative code composes function calls over time (when to call what), and creates these huge, complex hierarchies and if you add concurrency to the mix it blows up even more. Other types of composition in imperative languages require additional structure in form of higher-level constructs like interfaces or design patterns. Pure functional composition and algebraic data structures allow a monoidal composition where you stay in the same category \u2014 you compose lots of things but yet they all stay the same type, just like piping on the Unix command line. There is some objective superiority in the functional or declarative approach (not sure yet which one exactly, although it could be both for different reasons) over imperative \u2014 by that I mean it can be objectively described and explained and it isn\u2019t just a \u201cdepends on the context\u201d issue. Unfortunately, I don\u2019t know how to explain that yet. But the way composition works in these approaches is key. Imperative still has its value, but likely as an implementation detail between a functional/declarative high-level language and its low-level implementation on a machine. I know that\u2019s controversial. Please @ me! :-)\n\nI have lots more to say about this, but that\u2019s already a lot to read so I leave it at that for now.\n\nI\u2019ve been thinking about this for a while, but more focused on data formats and structuring data and trying to stay away from the typical programming issues like interoperability for now. I came to believe that a lot of the issues we\u2019re trying to solve are self-made and we need to break out of our own context to find better solutions.",
        "user": "U5STGTB3J",
        "ts": "1577183094.103200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1577183161.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tj2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like it very much! Yes, this is a great lens on one of the big issues that\u2019s causing a lot of complexity in our field."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Some random thoughts:"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "I\u2019ve always wondered why the Unix command line and in particular its pipe feature is considered a good solution and what makes it so special. I don\u2019t have a final conclusion, but I suspect the \u201cfuzziness\u201d of the not very clearly defined text stream interface has to do with it. Every other data format you list tries very hard to be precise in describing data structure and even types. The text stream a sort command operates on, just needs agreement on the used delimiter. When specifying function interfaces within a programming language we\u2019re by default already in a much more precise type system (even in dynamically types languages), which prevent that level of ambiguity (and break-ability)."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Human language also has this fuzziness: we can describe concepts without being sure that the person we talk to has the same definitions. Surprisingly, it works more often than it doesn\u2019t, even though the receiver has a slightly different understanding than the sender. Programming languages break as soon as there is the slightest mismatch in syntax, grammar, or data types. We design data formats like programming languages. There\u2019s is no room for ambiguity. By design. Maybe there should be."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "The pipe-able Unix text stream \u201ctype\u201d is a very loose specification of a type, and it\u2019s kind of monoidal in nature \u2014 everything going through a filter command line program ends up as another text stream. The required structure to make piping work is minimal and doesn\u2019t even touch on what the data in that text stream actually is. That makes it extremely generic and composable. The parameters and return values in function calls are very specific and usually mix strict expectations on both structure and data type/format. By that we\u2019re creating countless different API calls that are all not easily composable."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "#3 is also a not yet well expressed reason why functional/declarative is superior to imperative. Imperative code composes function calls over time (when to call what), and creates these huge, complex hierarchies and if you add concurrency to the mix it blows up even more. Other types of composition in imperative languages require additional structure in form of higher-level constructs like interfaces or design patterns. Pure functional composition and algebraic data structures allow a monoidal composition where you stay in the same category \u2014 you compose lots of things but yet they all stay the same type, just like piping on the Unix command line. There is some objective superiority in the functional or declarative approach (not sure yet which one exactly, although it could be both for different reasons) over imperative \u2014 by that I mean it can be objectively described and explained and it isn\u2019t just a \u201cdepends on the context\u201d issue. Unfortunately, I don\u2019t know how to explain that yet. But the way composition works in these approaches is key. Imperative still has its value, but likely as an implementation detail between a functional/declarative high-level language and its low-level implementation on a machine. I know that\u2019s controversial. Please @ me! :-)"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "I have lots more to say about this, but that\u2019s already a lot to read so I leave it at that for now."
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "text",
                                "text": "I\u2019ve been thinking about this for a while, but more focused on data formats and structuring data and trying to stay away from the typical programming issues like interoperability for now. I came to believe that a lot of the issues we\u2019re trying to solve are self-made and we need to break out of our own context to find better solutions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U8A5MS6R1",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "26b85fcb-f9f5-4a2d-a560-53321655e66b",
        "type": "message",
        "text": "<@UEQ6M68H0> I\u2019ve only used Quicktime. Maybe Youtube will do a good job of transcoding/compressing once you upload it?",
        "user": "ULM3U6275",
        "ts": "1577199470.103500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ORy9a",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UEQ6M68H0"
                            },
                            {
                                "type": "text",
                                "text": " I\u2019ve only used Quicktime. Maybe Youtube will do a good job of transcoding/compressing once you upload it?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577070542.049700",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "296d33df-a012-4c5d-9a38-c5a6592d24e1",
        "type": "message",
        "text": "Yes, YouTube will transcode the video. Alternatively, you can use `ffmpeg` in the terminal to compress and re-encode, or a GUI tool like Handbrake. Let me know if you'd like tips on this.\n\nQuicktime is a good way to capture, but it's not perfect \u2014 IIRC, it captures at 30fps. I use OBS with a custom configuration to get an _almost_ flawless 60fps capture, though that might be overkill for demoing something that's not highly animated. (I'd love to find a way to get a _perfectly_ color-accurate 60fps video \u2014\u00a0if anyone reading this knows how, tell me!)",
        "user": "UC2A2ARPT",
        "ts": "1577201829.103700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Nv6qa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, YouTube will transcode the video. Alternatively, you can use "
                            },
                            {
                                "type": "text",
                                "text": "ffmpeg",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in the terminal to compress and re-encode, or a GUI tool like Handbrake. Let me know if you'd like tips on this.\n\nQuicktime is a good way to capture, but it's not perfect \u2014 IIRC, it captures at 30fps. I use OBS with a custom configuration to get an "
                            },
                            {
                                "type": "text",
                                "text": "almost",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " flawless 60fps capture, though that might be overkill for demoing something that's not highly animated. (I'd love to find a way to get a "
                            },
                            {
                                "type": "text",
                                "text": "perfectly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " color-accurate 60fps video \u2014\u00a0if anyone reading this knows how, tell me!)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577070542.049700",
        "parent_user_id": "UEQ6M68H0"
    },
    {
        "client_msg_id": "6c06994c-d9e1-473b-a156-25cd6d39ccc1",
        "type": "message",
        "text": "I like the change in emphasis from duplication to composition models!\n\nYour footnotes get inlined in the same column as the prose even on my laptop, and the result is confusing. The footnote for 'affordance' appears above its real usage, for example. If I shrink my font size I see it on the right column and it looks nice. But it looks like you designed this page for an even wider screen than I have?!\n\n&gt; If it doesn't look like an the elephant in the room, perhaps the elephant _is_ the room.\n:smile:",
        "user": "UCUSW7WVD",
        "ts": "1577207074.104000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1577207134.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xe2G",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I like the change in emphasis from duplication to composition models!\n\nYour footnotes get inlined in the same column as the prose even on my laptop, and the result is confusing. The footnote for 'affordance' appears above its real usage, for example. If I shrink my font size I see it on the right column and it looks nice. But it looks like you designed this page for an even wider screen than I have?!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If it doesn't look like an the elephant in the room, perhaps the elephant "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the room."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "8ea81d43-6ea1-4f55-b023-bac945307666",
        "type": "message",
        "text": "Switching to the substance: would the use of many 'e's in this comment worry you as duplication? What about the presence of a function for sorting on your computer vs mine? These are silly examples (hopefully you agree), but since you're expanding the range of duplication you worry about, I'm wondering how you decide where to draw the boundaries of what constitutes a 'system'.",
        "user": "UCUSW7WVD",
        "ts": "1577207933.104300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M50oh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Switching to the substance: would the use of many 'e's in this comment worry you as duplication? What about the presence of a function for sorting on your computer vs mine? These are silly examples (hopefully you agree), but since you're expanding the range of duplication you worry about, I'm wondering how you decide where to draw the boundaries of what constitutes a 'system'."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "a61f909a-a28b-4015-9e48-e0c94910ffe3",
        "type": "message",
        "text": "\"Is it really true that sort cannot be expressed in a pure form and decorated to fit into any context?\"\n\nIf all of the contexts are only trivially different from one another, then this would be practical. However, \"any context\" covers a lot more ground than that. In the worst case, the decoration could grow to be as complex as the sort source code itself, and the decoration may also be tightly coupled to the details of the sort implementation. So you can have cases where it is simpler and cleaner to just reimplement sort from scratch for the specific context.\n\nFor example, if the context involves dependent types and program verification, then the sort algorithm needs a type which proves that the output is sorted, and that type will be tightly coupled to the implementation. If the context is Rust, then the sort algorithm is required to be memory safe, and must pass the borrow checker.\n\nIf the context is APL/J/K, then the sort operator needs to return a list of indices, not the sorted list itself.\n\nWhat if the data to be sorted is distributed across multiple machines and is too large to fit into memory? What if the context is a pure functional language with persistent functional data structures? You need different sort algorithms for different contexts.",
        "user": "UJN1TAYEQ",
        "ts": "1577212267.104500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1577214575.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+P=V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Is it really true that sort cannot be expressed in a pure form and decorated to fit into any context?\"\n\nIf all of the contexts are only trivially different from one another, then this would be practical. However, \"any context\" covers a lot more ground than that. In the worst case, the decoration could grow to be as complex as the sort source code itself, and the decoration may also be tightly coupled to the details of the sort implementation. So you can have cases where it is simpler and cleaner to just reimplement sort from scratch for the specific context.\n\nFor example, if the context involves dependent types and program verification, then the sort algorithm needs a type which proves that the output is sorted, and that type will be tightly coupled to the implementation. If the context is Rust, then the sort algorithm is required to be memory safe, and must pass the borrow checker.\n\nIf the context is APL/J/K, then the sort operator needs to return a list of indices, not the sorted list itself.\n\nWhat if the data to be sorted is distributed across multiple machines and is too large to fit into memory? What if the context is a pure functional language with persistent functional data structures? You need different sort algorithms for different contexts."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "17de9e8e-afdc-4186-8b45-3461744930e5",
        "type": "message",
        "text": "<@U5STGTB3J> - thanks for the detailed thoughts. Interesting stuff.\n&gt;  We design data formats like programming languages. There\u2019s is no room for ambiguity. By design. Maybe there should be.\nThis is something that I agree with. We need less 'gear like fitting' and more biochemistry like flexibility. You still have the receptors and tags that bind to each other but in general there's more flexibility in how coupling happens - and if something doesn't fit it just kind of floats around (where it can be observed) rather than crashing and terminating. I think tuple spaces kind of explore some of this 'tagged items in a pool' model. However I think really tight fitting couplings with little tolerance become harder to scale up orders of magnitude. Notice how we tend to be much more flexible in service APIs (protocol buffers are designed to be backwards compatible) compared to function types.\n\n&gt;  I came to believe that a lot of the issues we\u2019re trying to solve are self-made and we need to break out of our own context to find better solutions.\nCouldn't agree more :smile:",
        "user": "U8A5MS6R1",
        "ts": "1577222225.105500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "k8Bxk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " - thanks for the detailed thoughts. Interesting stuff.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " We design data formats like programming languages. There\u2019s is no room for ambiguity. By design. Maybe there should be."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is something that I agree with. We need less 'gear like fitting' and more biochemistry like flexibility. You still have the receptors and tags that bind to each other but in general there's more flexibility in how coupling happens - and if something doesn't fit it just kind of floats around (where it can be observed) rather than crashing and terminating. I think tuple spaces kind of explore some of this 'tagged items in a pool' model. However I think really tight fitting couplings with little tolerance become harder to scale up orders of magnitude. Notice how we tend to be much more flexible in service APIs (protocol buffers are designed to be backwards compatible) compared to function types.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " I came to believe that a lot of the issues we\u2019re trying to solve are self-made and we need to break out of our own context to find better solutions."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Couldn't agree more "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UFLN9JFRT",
                    "UHWC9PXBL",
                    "UJBAJNFLK"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "6a0373e3-6664-44f3-a17b-cb4ca5d74b11",
        "type": "message",
        "text": "<@U5STGTB3J> You haven't mentioned this \"blog chain\" as far as I can see:\n<https://stefan-lesser.com/2019/12/24/a-future-of-programming/>",
        "user": "UE6EFEPTQ",
        "ts": "1577227635.106800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M41",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " You haven't mentioned this \"blog chain\" as far as I can see:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://stefan-lesser.com/2019/12/24/a-future-of-programming/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577227635.106800",
        "reply_count": 23,
        "reply_users_count": 5,
        "latest_reply": "1577975053.350800",
        "reply_users": [
            "UE6EFEPTQ",
            "UCUSW7WVD",
            "U5STGTB3J",
            "UJ6LDMMN0",
            "UC2A2ARPT"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U8A5MS6R1",
                    "UJ6LDMMN0"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "10cafb11-2c98-4879-aa58-655645b6993b",
        "type": "message",
        "text": "I agree with all of it I think .. although I'm not sure about this one:\n\n&gt; *Less, but better &gt; complete*\n&gt; \n&gt; A small tool that works well for a single domain is more valuable than a generic tool that tries to be everything to everyone. A working solution that delivers value to a small group of people is valuable, even if it is not as expressive as a general programming language.",
        "user": "UE6EFEPTQ",
        "ts": "1577227671.106900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "mDD+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with all of it I think .. although I'm not sure about this one:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Less, but better > complete",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\nA small tool that works well for a single domain is more valuable than a generic tool that tries to be everything to everyone. A working solution that delivers value to a small group of people is valuable, even if it is not as expressive as a general programming language."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577227635.106800",
        "parent_user_id": "UE6EFEPTQ"
    },
    {
        "client_msg_id": "dcc1d6f3-2f7a-4bc5-b4cb-bd4ab8750eb8",
        "type": "message",
        "text": "<@UCUSW7WVD>\n&gt; Your footnotes get inlined in the same column as the prose even on my laptop, and the result is confusing.\nThanks for reporting this! For narrow widths the sidenote text should appear below the main text, not above. Looks like I'll be spending some 'quality time' with CSS shortly :scream:",
        "user": "U8A5MS6R1",
        "ts": "1577227691.107100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W9aH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your footnotes get inlined in the same column as the prose even on my laptop, and the result is confusing."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks for reporting this! For narrow widths the sidenote text should appear below the main text, not above. Looks like I'll be spending some 'quality time' with CSS shortly "
                            },
                            {
                                "type": "emoji",
                                "name": "scream"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1"
    },
    {
        "client_msg_id": "e4a7d72e-cee6-4a77-944f-370dde073794",
        "type": "message",
        "text": "Why not try to be general at first, and see how it goes? Shame to add this restriction from the start!",
        "user": "UE6EFEPTQ",
        "ts": "1577227816.107300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RJSR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Why not try to be general at first, and see how it goes? Shame to add this restriction from the start!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577227635.106800",
        "parent_user_id": "UE6EFEPTQ"
    },
    {
        "client_msg_id": "e86e1bf0-3e94-4835-bfb4-c9cc72dfc389",
        "type": "message",
        "text": "Are you thinking of a DSL-like system?",
        "user": "UE6EFEPTQ",
        "ts": "1577227836.107500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Yri",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are you thinking of a DSL-like system?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577227635.106800",
        "parent_user_id": "UE6EFEPTQ"
    },
    {
        "client_msg_id": "4c271435-1e66-4ff4-86c2-afc018e259e7",
        "type": "message",
        "text": "&gt;  would the use of many 'e's in this comment worry you as duplication?\nNo. Assembling symbols or literals doesn't seem to quite fit the same category, but I can't put my finger on why.\n&gt;  What about the presence of a function for sorting on your computer vs mine?\nNo - that seems fine too. Now if we couldn't copy a function even from my computer to yours, even if we wanted to, that would worry me. It's really the manual production of the artifact that\n\nThese are good questions in the context of the write-up. While I'm taking an extreme position there (only one sort everywhere, yeah!) I'm not really against recreating stuff when you want to, but rather when you 'have to'. (Technically I could pipe stuff from my program into the `sort` command, but there's some serious trade-offs). I feel the composition models are weak where you 'have to' way more often than you should.",
        "user": "U8A5MS6R1",
        "ts": "1577228249.107700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ERv",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " would the use of many 'e's in this comment worry you as duplication?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No. Assembling symbols or literals doesn't seem to quite fit the same category, but I can't put my finger on why.\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " What about the presence of a function for sorting on your computer vs mine?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "No - that seems fine too. Now if we couldn't copy a function even from my computer to yours, even if we wanted to, that would worry me. It's really the manual production of the artifact that\n\nThese are good questions in the context of the write-up. While I'm taking an extreme position there (only one sort everywhere, yeah!) I'm not really against recreating stuff when you want to, but rather when you 'have to'. (Technically I could pipe stuff from my program into the "
                            },
                            {
                                "type": "text",
                                "text": "sort",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " command, but there's some serious trade-offs). I feel the composition models are weak where you 'have to' way more often than you should."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1577178650.059300",
        "parent_user_id": "U8A5MS6R1",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UFLN9JFRT"
                ],
                "count": 2
            }
        ]
    }
]