[
    {
        "client_msg_id": "77fed21b-7521-4b81-be21-fce57ae05001",
        "type": "message",
        "text": "In the Beads language i redesigned the syntax for regular expressions, and it transpiles 1:1 with existing syntax, but uses a much easier to read syntax. Regular expressions are no match for the fancy Parse operator in Red, or the fabulous Icon string matching language (a sequel to SNOBOL and SPITBOL), but for use with JS, being able to define regular expressions more gracefully is a nice feature IMHO. The horrible original syntax was motivated by the intense pressure on the original unix designers to keep character count low as they typed on a model 33 teletype.",
        "user": "UEQ6M68H0",
        "ts": "1575070607.315700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEQ6M68H0",
            "ts": "1575070624.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v90g",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the Beads language i redesigned the syntax for regular expressions, and it transpiles 1:1 with existing syntax, but uses a much easier to read syntax. Regular expressions are no match for the fancy Parse operator in Red, or the fabulous Icon string matching language (a sequel to SNOBOL and SPITBOL), but for use with JS, being able to define regular expressions more gracefully is a nice feature IMHO. The horrible original syntax was motivated by the intense pressure on the original unix designers to keep character count low as they typed on a model 33 teletype."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574880983.245400",
        "parent_user_id": "ULM3U6275"
    },
    {
        "client_msg_id": "66a4675a-f737-41fa-b44b-c52b13470514",
        "type": "message",
        "text": "FWIW, it's not uncommon for a data type to contain both canonical and non-canonical instances, but there to be a run-time method to canonicalize and data structures that canonicalize on the way in. Types for file paths usually work that way, as do shapes like rectangles where there are multiple equivalent representations.\n\nAlso, for URLs, probably the best way to canonicalize is to look for <https://en.wikipedia.org/wiki/Canonical_link_element>",
        "user": "UFEQUBNNT",
        "ts": "1575145980.316000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFEQUBNNT",
            "ts": "1575146063.000000"
        },
        "attachments": [
            {
                "title": "Canonical link element",
                "title_link": "https://en.wikipedia.org/wiki/Canonical_link_element",
                "from_url": "https://en.wikipedia.org/wiki/Canonical_link_element",
                "author_name": "Wikipedia",
                "author_link": "https://en.wikipedia.org/",
                "text": "A canonical link element is an HTML element that helps webmasters prevent duplicate content issues in search engine optimization by specifying the \"canonical\" or \"preferred\" version of a web page. It is described in RFC 6596, which went live in April 2012.",
                "fallback": "wikipedia: Canonical link element",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png",
                "id": 1,
                "original_url": "https://en.wikipedia.org/wiki/Canonical_link_element"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4gnK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "FWIW, it's not uncommon for a data type to contain both canonical and non-canonical instances, but there to be a run-time method to canonicalize and data structures that canonicalize on the way in. Types for file paths usually work that way, as do shapes like rectangles where there are multiple equivalent representations.\n\nAlso, for URLs, probably the best way to canonicalize is to look for "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Canonical_link_element"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574951564.258100",
        "parent_user_id": "UBN9AFS0N"
    }
]