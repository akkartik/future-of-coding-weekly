[
    {
        "client_msg_id": "152c9928-a343-4fe7-ac59-3a4fd0865e74",
        "type": "message",
        "text": "I'm not actually familiar with how audio/MIDI programming actually works.\n\nIs it \"real time\" in the sense that you program it *as* it is running or being used? Or in the sense that you are capturing or manipulating sound in real time?\n\nOr is the programming is done ahead of time (e.g. program it, then run it), but relates to real-world timing which *will* be relevant when it is run?",
        "user": "UAVCC2X70",
        "ts": "1574728598.175800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1574728727.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "af7Ah",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not actually familiar with how audio/MIDI programming actually works.\n\nIs it \"real time\" in the sense that you program it "
                            },
                            {
                                "type": "text",
                                "text": "as",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " it is running or being used? Or in the sense that you are capturing or manipulating sound in real time?\n\nOr is the programming is done ahead of time (e.g. program it, then run it), but relates to real-world timing which "
                            },
                            {
                                "type": "text",
                                "text": "will",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " be relevant when it is run?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1573264632.251900",
        "parent_user_id": "UAVCC2X70"
    },
    {
        "client_msg_id": "97846122-1e64-4d07-be0b-175727c748b9",
        "type": "message",
        "text": "What do you mean by graphics as first class? The ability to draw in the window? Or display image files?",
        "user": "U8A5MS6R1",
        "ts": "1574745880.176900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X1S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What do you mean by graphics as first class? The ability to draw in the window? Or display image files?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574624756.123700",
        "parent_user_id": "UFEQUBNNT"
    },
    {
        "client_msg_id": "4b9d4f31-f248-4161-aa1c-f36bdb82423a",
        "type": "message",
        "text": "Well... Hmmm... All of that! :wink: You choose. But I guess Doug wanted to focus in the fact that the raw material you handle with Audio (and MIDI) is stuff that happens at given times in the real world. Hence \"Real Time\" programming.",
        "user": "UJ6LDMMN0",
        "ts": "1574749411.177100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "48B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Well... Hmmm... All of that! "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": " You choose. But I guess Doug wanted to focus in the fact that the raw material you handle with Audio (and MIDI) is stuff that happens at given times in the real world. Hence \"Real Time\" programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1573264632.251900",
        "parent_user_id": "UAVCC2X70"
    },
    {
        "client_msg_id": "d24677e8-9d26-4c83-b166-aa7419065b2c",
        "type": "message",
        "text": "<https://www.apress.com/gp/book/9781430219484>",
        "user": "UJBAJNFLK",
        "ts": "1574757269.177300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Coders at Work - Reflections on the Craft of Programming | Peter Seibel | Apress",
                "title_link": "https://www.apress.com/gp/book/9781430219484",
                "text": "Peter Seibel interviews 15 of the most interesting computer programmers alive today in Coders at Work, offering a companion volume to Apress\u2019s highly acclaimed best-seller Founders at Work by Jessica Livingston. As the words \u201cat work\u201d suggest, Peter Seibel focuses on how his interviewees tackle the...",
                "fallback": "Coders at Work - Reflections on the Craft of Programming | Peter Seibel | Apress",
                "from_url": "https://www.apress.com/gp/book/9781430219484",
                "service_icon": "https://www.apress.com/favicon.ico",
                "service_name": "apress.com",
                "id": 1,
                "original_url": "https://www.apress.com/gp/book/9781430219484"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rdU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.apress.com/gp/book/9781430219484"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574694345.141000",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1::skin-tone-4",
                "users": [
                    "UBN9AFS0N"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "06f8c564-6f3c-49c3-a632-445bed0b6f52",
        "type": "message",
        "text": "> Is it \"real time\" in the sense that you program it *as* it is running or being used?\nI would call this \"live programming\". Live programming can also be real time programming, especially since it is popular for musical performances.",
        "user": "UJN1TAYEQ",
        "ts": "1574785848.197800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJN1TAYEQ",
            "ts": "1574785934.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/G8",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is it \"real time\" in the sense that you program it "
                            },
                            {
                                "type": "text",
                                "text": "as",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " it is running or being used?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would call this \"live programming\". Live programming can also be real time programming, especially since it is popular for musical performances."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1573264632.251900",
        "parent_user_id": "UAVCC2X70"
    },
    {
        "client_msg_id": "99908f44-d292-4ebe-b848-0e473bc60b64",
        "type": "message",
        "text": "Let me share with you something really controversial which came into my mind.\n\nOrigins of the idea:\n\n\u2022 Code duplication is better then using the wrong abstraction\n\u2022 Every system evolves, its abstractions evolve, they come and go\n\nAlso, I think it is not too bad to refer to abstractions as units (like in Unit tests). I also think about abstractions as an \u201cextracted\u201d \u201cstep in the process\u201d, aka \u201cnew policy\u201d in the system, which is \u201csome kind of a restriction\u201d.\n\nWhat I see in my codebase that introducing ANY abstraction has pros and cons. In terms of new (LAYERS!) abstractions (which hide the sides from each other) there are things which can be expressed EASIER/SHORTER/TERSER (these are the things the developer probably thinks and reasons about) BUT, there might be things in future which are not easier/shorter/terser, on the contrary HARDER/LONGER/MORE VERBOSE.\n\nOne of my points is that the business logic kind of things (which would be nice to abstract away) are going to change in softwares evolution, it is just a matter of time. That means, there will be things which were just impossible to see are coming and now we have extra (layers of) abstractions in our way.\n\nSure, we have to refactor! We have to\n\n1. reuse the \u201ccorrupted\u201d / \u201cwrongly evolved\u201d abstractions for creating new ones [OR]\n2. (a.) dump the old (b.) just find something completely new which respects both the old and new requirements",
        "user": "UL3CJ7YKC",
        "ts": "1574787700.220400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1574787960.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cc25",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Let me share with you something really controversial which came into my mind.\n\nOrigins of the idea:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Code duplication is better then using the wrong abstraction"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Every system evolves, its abstractions evolve, they come and go"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAlso, I think it is not too bad to refer to abstractions as units (like in Unit tests). I also think about abstractions as an \u201cextracted\u201d \u201cstep in the process\u201d, aka \u201cnew policy\u201d in the system, which is \u201csome kind of a restriction\u201d.\n\nWhat I see in my codebase that introducing ANY abstraction has pros and cons. In terms of new (LAYERS!) abstractions (which hide the sides from each other) there are things which can be expressed EASIER/SHORTER/TERSER (these are the things the developer probably thinks and reasons about) BUT, there might be things in future which are not easier/shorter/terser, on the contrary HARDER/LONGER/MORE VERBOSE.\n\nOne of my points is that the business logic kind of things (which would be nice to abstract away) are going to change in softwares evolution, it is just a matter of time. That means, there will be things which were just impossible to see are coming and now we have extra (layers of) abstractions in our way.\n\nSure, we have to refactor! We have to\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "reuse the \u201ccorrupted\u201d / \u201cwrongly evolved\u201d abstractions for creating new ones [OR]"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "(a.) dump the old (b.) just find something completely new which respects both the old and new requirements"
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1574787700.220400",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1574841102.233100",
        "reply_users": [
            "UBSMEUXAA",
            "UNKSN1MRQ"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "99908f44-d292-4ebe-b848-0e473bc60b64",
        "type": "message",
        "text": "\nSure, if 1. is the case it\u2019s no problem I\u2019m happy, the original abstraction is reused I don\u2019t feel so bad, \u201cit did worth it!\u201c. But usually this is not the part I am afraid of. And also my point is, that it is only matter of time when reuse won\u2019t be possible with these updated abstractions and I must just dump. Requirements changed so much and IN SUCH A WAY + IN SUCH AN ORDER, it is just literally EASIER to dump the existing (layers) of abstractions to get to the goal.\n\nAnother point: knowing this happens all the time it feels wrong to think a lot about \u201ccomplicated\u201d abstractions which will help me in future. Earlier, I thought it is not a problem to sit and think a lot about these \u201cpartially good abstractions\u201d, because I thought they will be useful. Also, reusing these \u201chalf baked\u201d solutions seemed OK and justifiable. Now it feels like chasing a shadow and betting too much on catching it.\n\n2.(b): it happens, I am OK with it.\n\nBut here is the worst point:\n2.(a): getting rid of the old abstraction(s).\n\nIt is insanely hard! And it is weird why it is\u2026 Entangled code, changed meanings! Ill-evolved abstractions both in test and in production code! Whaaat?! I think that is the part we should do something about.\n\n\u201cHalf baked abstractions\u201d feel like boundaries for safety (code reuse is also safety: \u201cnot to forget this case\u201d-safety). But boundaries are rigid. It feels to me a \u201cSacrificing flexibility for safety\u201d. Sure, abstractions also do have \u201cmeaning\u201d, but this meaning alters over time (the dirty part, not the clean part) and sometimes the \u201cstuff\u201d is abstracted away is more like a fast changing \u201cprocess\u201d without real boundaries and not like an \u201centity\u201d / unit / \u201cnoun\u201d with clear boundaries. If it was a String its OK, it is a clean abstraction. My problem is with the \u201cintermediate stuff\u201d which are more like steps (which are more likely to change) in a process not a real entity like \u201cAnIdiotAdapterFromXToYAfterZHappenedButBlah\u201d. Abstractions feel declarative and rigid. Lack of abstractions feels imperative and flexible.\n\nSo with all this what I am thinking about is this:\nThe production code should be as flexible (dirty, ugly, duplicated, etc.) as possible, with SHALLOW (layers of) abstractions (shallow not equals low complexity). It feels a bit like \u201ccomposition over inheritance\u201d aka \u201cfuck and duplicate over using defaults you wont be able to delete later + you have to duplicate later no matter what\u201d.\n\nOn the other hand it seems to be a good idea to have a nice set of integration tests with \u201cfull coverage\u201d which tests DO SHARE a lot of abstractions for being able to describe \u201call the RAW cases\u201d. (By raw I mean no/less intermediate stuff.)\nMaybe asserting on invariants in tests (and making these asserts reusable in test abstractions) is more maintainable then evolving and maintaining abstractions of production code.\n\nI might be 110% wrong. I am quite sure if I\u2019d do this I\u2019d pray for abstractions I did not introduce \u2026 Complexity does this all the time. The reason I feel its something else now is that its not complexity itself which ruins me (and my code) but the ORDER OF STEPS I get there.",
        "user": "UL3CJ7YKC",
        "ts": "1574787700.220500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1574788029.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Y=iPP",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSure, if 1. is the case it\u2019s no problem I\u2019m happy, the original abstraction is reused I don\u2019t feel so bad, \u201cit did worth it!\u201c. But usually this is not the part I am afraid of. And also my point is, that it is only matter of time when reuse won\u2019t be possible with these updated abstractions and I must just dump. Requirements changed so much and IN SUCH A WAY + IN SUCH AN ORDER, it is just literally EASIER to dump the existing (layers) of abstractions to get to the goal.\n\nAnother point: knowing this happens all the time it feels wrong to think a lot about \u201ccomplicated\u201d abstractions which will help me in future. Earlier, I thought it is not a problem to sit and think a lot about these \u201cpartially good abstractions\u201d, because I thought they will be useful. Also, reusing these \u201chalf baked\u201d solutions seemed OK and justifiable. Now it feels like chasing a shadow and betting too much on catching it.\n\n2.(b): it happens, I am OK with it.\n\nBut here is the worst point:\n2.(a): getting rid of the old abstraction(s).\n\nIt is insanely hard! And it is weird why it is\u2026 Entangled code, changed meanings! Ill-evolved abstractions both in test and in production code! Whaaat?! I think that is the part we should do something about.\n\n\u201cHalf baked abstractions\u201d feel like boundaries for safety (code reuse is also safety: \u201cnot to forget this case\u201d-safety). But boundaries are rigid. It feels to me a \u201cSacrificing flexibility for safety\u201d. Sure, abstractions also do have \u201cmeaning\u201d, but this meaning alters over time (the dirty part, not the clean part) and sometimes the \u201cstuff\u201d is abstracted away is more like a fast changing \u201cprocess\u201d without real boundaries and not like an \u201centity\u201d / unit / \u201cnoun\u201d with clear boundaries. If it was a String its OK, it is a clean abstraction. My problem is with the \u201cintermediate stuff\u201d which are more like steps (which are more likely to change) in a process not a real entity like \u201cAnIdiotAdapterFromXToYAfterZHappenedButBlah\u201d. Abstractions feel declarative and rigid. Lack of abstractions feels imperative and flexible.\n\nSo with all this what I am thinking about is this:\nThe production code should be as flexible (dirty, ugly, duplicated, etc.) as possible, with SHALLOW (layers of) abstractions (shallow not equals low complexity). It feels a bit like \u201ccomposition over inheritance\u201d aka \u201cfuck and duplicate over using defaults you wont be able to delete later + you have to duplicate later no matter what\u201d.\n\nOn the other hand it seems to be a good idea to have a nice set of integration tests with \u201cfull coverage\u201d which tests DO SHARE a lot of abstractions for being able to describe \u201call the RAW cases\u201d. (By raw I mean no/less intermediate stuff.)\nMaybe asserting on invariants in tests (and making these asserts reusable in test abstractions) is more maintainable then evolving and maintaining abstractions of production code.\n\nI might be 110% wrong. I am quite sure if I\u2019d do this I\u2019d pray for abstractions I did not introduce \u2026 Complexity does this all the time. The reason I feel its something else now is that its not complexity itself which ruins me (and my code) but the ORDER OF STEPS I get there."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574787700.220500",
        "reply_count": 52,
        "reply_users_count": 4,
        "latest_reply": "1575651104.121900",
        "reply_users": [
            "UCUSW7WVD",
            "UHDQ62M4P",
            "UL3CJ7YKC",
            "UAVCC2X70"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "da64faf1-18aa-4ded-9cbd-6ecb9a720f34",
        "type": "message",
        "text": "That is a bit long though. :smile: Sorry. <@UCUSW7WVD> <@UDKTZSD6H>",
        "user": "UL3CJ7YKC",
        "ts": "1574787724.220900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1574787749.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PmtZD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is a bit long though. "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " Sorry. "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UDKTZSD6H"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        "client_msg_id": "297ca664-47dd-418f-b296-b24b82306679",
        "type": "message",
        "text": "Thanks, that's the term I was looking for: \"Live Programming\"\n\nI guess it's unreasonable not to expect people to interpret \"X programming\" to mean \"programming _for_ X\", and thus we need separate terminology for when programming _is_ X (e.g. \"live\" and \"visual\" programming as opposed to \"real-time\" and \"graphical\" programming)",
        "user": "UAVCC2X70",
        "ts": "1574788341.221400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1574875281.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oge4n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks, that's the term I was looking for: \"Live Programming\"\n\nI guess it's unreasonable not to expect people to interpret \"X programming\" to mean \"programming "
                            },
                            {
                                "type": "text",
                                "text": "for",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " X\", and thus we need separate terminology for when programming "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " X (e.g. \"live\" and \"visual\" programming as opposed to \"real-time\" and \"graphical\" programming)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1573264632.251900",
        "parent_user_id": "UAVCC2X70"
    },
    {
        "client_msg_id": "985be55a-bb03-46d8-9740-fd81a50aa026",
        "type": "message",
        "text": "I'm not sure why this is controversial outside of a lot (maybe most) programmers wanting universal low risk solutions and \"best practices\" to dominate coding.  Complex abstractions can also help people appear more senior in some cases to justify higher salaries :slightly_smiling_face:.\n\nThat kind of thinking can help in CS programs and bigger corporate software companies, but if you read things from truly skilled programmers they usually have these more \"controversial\" opinions.  One of my favorite examples of this is John Carmack on Inlined code (<http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html>)  It is relatively simple advice but might run counter to someone who follows the dogma of always having small functions.\n\nSome anti-OOP, or pro functional rhetoric fits into this, so does \"YAGNI\" (which is generally anti-abstraction) although it runs counter to another coding acronym which is \"DRY\".",
        "user": "UBSMEUXAA",
        "ts": "1574792679.221900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "John Carmack on Inlined Code",
                "title_link": "http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html",
                "text": "(Here begins a comment written by John Carmack in 2014, about an email he sent to a programmers\u2019 mailing list in 2007.)",
                "fallback": "John Carmack on Inlined Code",
                "from_url": "http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html",
                "service_name": "number-none.com",
                "id": 1,
                "original_url": "http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YHK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure why this is controversial outside of a lot (maybe most) programmers wanting universal low risk solutions and \"best practices\" to dominate coding.  Complex abstractions can also help people appear more senior in some cases to justify higher salaries "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nThat kind of thinking can help in CS programs and bigger corporate software companies, but if you read things from truly skilled programmers they usually have these more \"controversial\" opinions.  One of my favorite examples of this is John Carmack on Inlined code ("
                            },
                            {
                                "type": "link",
                                "url": "http://number-none.com/blow/blog/programming/2014/09/26/carmack-on-inlined-code.html"
                            },
                            {
                                "type": "text",
                                "text": ")  It is relatively simple advice but might run counter to someone who follows the dogma of always having small functions.\n\nSome anti-OOP, or pro functional rhetoric fits into this, so does \"YAGNI\" (which is generally anti-abstraction) although it runs counter to another coding acronym which is \"DRY\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574787700.220400",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UL3CJ7YKC",
                    "UHDQ62M4P"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "101C4AA1-6E56-48C1-9EDF-13AF0EC7CAE5",
        "type": "message",
        "text": "i feel like this discussion is why i\u2019d like to see a language/compiler/IDE that treats code editing as a sequence of transformations that get saved. it\u2019s the best argument i think for structural editing: if you have semantic understanding of the syntax changes you\u2019re making, \u201cundoing\u201d an abstraction would be a simple edit to the history where you undo the abstraction, or an append case where you \u201cunroll\u201d it into the result of the abstraction. eg: \u201cinline\u201d a function in one command to replace all calls with the function\u2019s body with the called arguments filled in",
        "user": "UHWC9PXBL",
        "ts": "1574794252.227300",
        "team": "T5TCAFTA9",
        "thread_ts": "1574794252.227300",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1574906767.250600",
        "reply_users": [
            "UL3CJ7YKC",
            "UJN1TAYEQ",
            "UHWC9PXBL"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UL3CJ7YKC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "51B27A84-2704-4F17-A1CA-E451C36E76F5",
        "type": "message",
        "text": "<https://twitter.com/4lpine/status/1199384410199449600?s=21> new developments on the react/gatsby side of visual programming",
        "user": "UHWC9PXBL",
        "ts": "1574794558.227900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UHWC9PXBL",
            "ts": "1574794574.000000"
        },
        "attachments": [
            {
                "fallback": "<https://twitter.com/4lpine|@4lpine>: \u2b21 Introducing Blocks (alpha)!\n\nAn open source, JSX-based visual editor that we're building.\n\n:female-technologist: Import JSX\n:frame_with_picture: Drag and drop components\n:control_knobs: Change props and styling\n\ud83e\udde9 Add your own blocks\n:heart_eyes_cat: Export production-ready code\n\n<https://blocks-ui.com> <https://pbs.twimg.com/ext_tw_video_thumb/1199384319547957248/pu/img/rXouSmoxkbCwS95t.jpg>",
                "ts": 1574790501,
                "author_name": "John Otander",
                "author_link": "https://twitter.com/4lpine/status/1199384410199449600",
                "author_icon": "https://pbs.twimg.com/profile_images/1685588137/thumb_normal.jpg",
                "author_subname": "@4lpine",
                "text": "\u2b21 Introducing Blocks (alpha)!\n\nAn open source, JSX-based visual editor that we're building.\n\n:female-technologist: Import JSX\n:frame_with_picture: Drag and drop components\n:control_knobs: Change props and styling\n\ud83e\udde9 Add your own blocks\n:heart_eyes_cat: Export production-ready code\n\n<https://blocks-ui.com>",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/4lpine/status/1199384410199449600?s=21",
                "thumb_url": "https://pbs.twimg.com/ext_tw_video_thumb/1199384319547957248/pu/img/rXouSmoxkbCwS95t.jpg",
                "thumb_width": 1080,
                "thumb_height": 720,
                "video_html_width": 1080,
                "video_html_height": 720,
                "video_html": "<video controls poster=\"https://pbs.twimg.com/ext_tw_video_thumb/1199384319547957248/pu/img/rXouSmoxkbCwS95t.jpg\" width=\"1080\" height=\"720\"><source type=\"video/mp4\" src=\"https://video.twimg.com/ext_tw_video/1199384319547957248/pu/vid/1080x720/-cOntq0nl5KTErXE.mp4?tag=10\"></video>",
                "id": 1,
                "original_url": "https://twitter.com/4lpine/status/1199384410199449600?s=21",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "thread_ts": "1574794558.227900",
        "reply_count": 2,
        "reply_users_count": 2,
        "latest_reply": "1574803326.230900",
        "reply_users": [
            "UC2A2ARPT",
            "UHWC9PXBL"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "40D91A32-598E-4AC9-8CE0-52AFE09FF5AA",
        "type": "message",
        "text": "Also reminds me a bit to Uncle Bobs Transformation Priority Premise",
        "user": "UL3CJ7YKC",
        "ts": "1574794668.228800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1574794767.000000"
        },
        "thread_ts": "1574794252.227300",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "08bf33c2-14d4-485e-a803-232638f846c3",
        "type": "message",
        "text": "I know the distinction is _wherever you want to draw it_, but I think this falls more under the umbrella of visual design rather than visual programming. * shrug *",
        "user": "UC2A2ARPT",
        "ts": "1574794707.229000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zb7bc",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I know the distinction is "
                            },
                            {
                                "type": "text",
                                "text": "wherever you want to draw it",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but I think this falls more under the umbrella of visual design rather than visual programming. * shrug *"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574794558.227900",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "19739d54-7aca-4b70-bf0a-87e75f6de5b4",
        "type": "message",
        "text": "I don't follow all the details, but you're right that this subject is interesting to me.\n\n1. As <@UBSMEUXAA> pointed out above, not trusting abstractions seems not so much an extraordinary idea but more just a secret truth that we don't talk about in polite company.\n2. Among hard-core TDD folks there's a school of thought that's the exact opposite of yours: make sure to keep tests entirely devoid of abstraction, to counteract any tendencies for complexity creep and over-abstraction in production code. I subscribe to this idea, though there's always a question of how far to take \"no abstractions\". Do we avoid all standard libraries? Do we skip the language and just program in machine code? My current rule of thumb is that I can use any abstractions from production code, but I am extremely selective about creating test-only abstractions. Since this means production code is often used for test setup, it's very important to be very explicit in each test about the component under test.\n3. Maintaining control over abstractions shouldn't imply avoiding them entirely. Just to 'stay loose' mentally. Any abstraction can be questioned or taken out at any time.\n4. At the risk of repeating myself, you should check out my notion of white-box tests: <http://akkartik.name/post/tracing-tests>. Rather than have tests run sub-components and make assertions on their behavior, I always run the whole program, emitting a trace of domain-specific events (facts deduced by the program), namespaced by different conceptual sub-components. Then different tests make assertions on the state of the trace. Fine-grained unit tests may focus on just traces pertaining to a specific namespace, while coarse-grained integration tests may look at a different namespace. Traces are an abstraction-busting device: tests no longer care about details of _how_ facts are deduced, they only focus on _what_ facts are deduced. And this permits radical changes to abstractions without needing to modify tests.\n5. You should also check out my notion of layers: <http://akkartik.name/post/wart-layers>. Layers are an abstraction-busting device for gradually inserting code tastefully into a skeleton of a program. They're often useful for recapitulating a cleaned-up history of a program's evolution so that newcomers have access to _always working_ copies of earlier, simpler snapshots. One thing I find myself using layers to do is track _alternatives_. When things were simple some sub-system was implemented one way. As features were added the old way got replaced. But it's still really useful for conveying the core idea. I keep the old implementation around in earlier layers, and replace it in later layers. That way the codebase continues to exercise both alternatives rather than let the old way accumulate rust in a git log somewhere.\n\nAnyway, I keep repeating myself about traces and layers, so apologies to those who are sick of hearing about them. But I really think they're super valuable ideas. Certainly they're 2 of the 3 best ideas I've ever had, and I don't expect to add to that list for the rest of my life.",
        "user": "UCUSW7WVD",
        "ts": "1574800292.230400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1574814319.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "an4V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't follow all the details, but you're right that this subject is interesting to me.\n\n1. As "
                            },
                            {
                                "type": "user",
                                "user_id": "UBSMEUXAA"
                            },
                            {
                                "type": "text",
                                "text": " pointed out above, not trusting abstractions seems not so much an extraordinary idea but more just a secret truth that we don't talk about in polite company.\n2. Among hard-core TDD folks there's a school of thought that's the exact opposite of yours: make sure to keep tests entirely devoid of abstraction, to counteract any tendencies for complexity creep and over-abstraction in production code. I subscribe to this idea, though there's always a question of how far to take \"no abstractions\". Do we avoid all standard libraries? Do we skip the language and just program in machine code? My current rule of thumb is that I can use any abstractions from production code, but I am extremely selective about creating test-only abstractions. Since this means production code is often used for test setup, it's very important to be very explicit in each test about the component under test.\n3. Maintaining control over abstractions shouldn't imply avoiding them entirely. Just to 'stay loose' mentally. Any abstraction can be questioned or taken out at any time.\n4. At the risk of repeating myself, you should check out my notion of white-box tests: "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/tracing-tests"
                            },
                            {
                                "type": "text",
                                "text": ". Rather than have tests run sub-components and make assertions on their behavior, I always run the whole program, emitting a trace of domain-specific events (facts deduced by the program), namespaced by different conceptual sub-components. Then different tests make assertions on the state of the trace. Fine-grained unit tests may focus on just traces pertaining to a specific namespace, while coarse-grained integration tests may look at a different namespace. Traces are an abstraction-busting device: tests no longer care about details of "
                            },
                            {
                                "type": "text",
                                "text": "how",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " facts are deduced, they only focus on "
                            },
                            {
                                "type": "text",
                                "text": "what",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " facts are deduced. And this permits radical changes to abstractions without needing to modify tests.\n5. You should also check out my notion of layers: "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/wart-layers"
                            },
                            {
                                "type": "text",
                                "text": ". Layers are an abstraction-busting device for gradually inserting code tastefully into a skeleton of a program. They're often useful for recapitulating a cleaned-up history of a program's evolution so that newcomers have access to "
                            },
                            {
                                "type": "text",
                                "text": "always working",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " copies of earlier, simpler snapshots. One thing I find myself using layers to do is track "
                            },
                            {
                                "type": "text",
                                "text": "alternatives",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". When things were simple some sub-system was implemented one way. As features were added the old way got replaced. But it's still really useful for conveying the core idea. I keep the old implementation around in earlier layers, and replace it in later layers. That way the codebase continues to exercise both alternatives rather than let the old way accumulate rust in a git log somewhere.\n\nAnyway, I keep repeating myself about traces and layers, so apologies to those who are sick of hearing about them. But I really think they're super valuable ideas. Certainly they're 2 of the 3 best ideas I've ever had, and I don't expect to add to that list for the rest of my life."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1574787700.220500",
        "parent_user_id": "UL3CJ7YKC",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UBSMEUXAA",
                    "UL3CJ7YKC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "6ACE4897-D580-4D1F-9F4D-9384256F5898",
        "type": "message",
        "text": "i agree",
        "user": "UHWC9PXBL",
        "ts": "1574803326.230900",
        "team": "T5TCAFTA9",
        "thread_ts": "1574794558.227900",
        "parent_user_id": "UHWC9PXBL"
    }
]