[
    {
        "client_msg_id": "b8678494-3421-4088-bc38-74ca380ab331",
        "type": "message",
        "text": "The software that is released seems fast enough, but what about the programs that never get written? Some behavior is very easy to model precisely using maths but trying to implement the modeling language bogs you down in low-level details. It would be nice to be able to experiment with reasonable performance on a supercomputer without having to worry so much about making programs usable on a regular computer.\nOne example of this is FRP which took a while to run well for a limited set of programs. However, the model is way more expressive than what gets implemented.",
        "user": "UKB1S7ZMY",
        "ts": "1572739072.024700",
        "team": "T5TCAFTA9"
    },
    {
        "client_msg_id": "1e88af02-af29-49cc-9d97-ecba8bd620db",
        "type": "message",
        "text": "What kind of events?\n\nI assume you're not taking about code triggered events, since those can be triggered by code.\n\nJava has something called \"Robot\" which lets you control the mouse and keyboard programmatically (for \"testing purposes\")",
        "user": "UAVCC2X70",
        "ts": "1572741455.025000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1572741468.000000"
        },
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "f1b4c692-2618-4161-bc61-09099d7ad3be",
        "type": "message",
        "text": "<@UAVCC2X70>: \"the only real difference is WHEN the processing occurs -- otherwise it's all *just code* with no fundamental difference. Separating code into different \"kinds\" of things for each \"time\" (e.g. functions vs macros) is absolutely NOT intrinsic to that kind of phased processing\"\n\nI disagree. The reason that stages exist is that *we need different representations of the program at different times*. That's why there are different kinds of things in different stages.\n\nIn early dialects of Lisp, FEXPRs were the original version of macros, and there was no stage restriction. Everything happened in one stage. This meant you couldn't compile Lisp, you could only interpret an abstract syntax tree. In order to compile Lisp into efficient machine code or VM code, the compiler *changes the representation of the program* to a form that runs faster, but the compiled form doesn't support macro expansion. So it was necessary for Lisp to add a macro expansion stage. When FEXPRs are restricted to running in the macro expansion stage, they are called MACROs.\n\nThe reason that Curv has so many stages is that a Curv program transitions across *5 different representations*, and certain operations on code are only possible on certain program representations: source code -&gt; VM code -&gt; shape value -&gt; GLSL shader program -&gt; GPU machine code.",
        "user": "UJN1TAYEQ",
        "ts": "1572741495.025300",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "22a170d2-9bb8-4231-b1a2-6230b7e5b1ea",
        "type": "message",
        "text": "Sure, convenience is definitely good. But just purely to answer the original question: Yes, the boundaries between compile time and run time, and functions and macros, etc, is completely 100% artificial.\n\nSuper practical, successful, proven, convenient, etc? Absolutely! But fundamental or inevitable? Absolutely not!",
        "user": "UAVCC2X70",
        "ts": "1572743139.025500",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "2889a26d-a277-4f94-a8c7-0db39898cd25",
        "type": "message",
        "text": "Just watched that video about collapsing towers of interpreters -- great stuff! Thanks for sharing!",
        "user": "UAVCC2X70",
        "ts": "1572744026.026400",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "fcddcfcd-bc0b-469a-b2cb-0ae932bfc5a1",
        "type": "message",
        "text": "I feel that I've given a good basic argument, with several examples of where the boundaries between stages (such as compile time and run time) are fundamental and inevitable. You all don't know Curv, but the FEXPR example is pretty well understood.",
        "user": "UJN1TAYEQ",
        "ts": "1572744782.026600",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "54c3af0c-afbb-4bd3-9a0b-f1c7416d760e",
        "type": "message",
        "text": "<@UJN1TAYEQ> - I 100% agree, but with a *heavy* footnote that \"such as\" is not the same as \"which can only possibly be accomplished in terms of\".\n\nAnd that's my entire point: that the separation and phases are necessary, but there's nothing fundamental about how or where that separation is defined, or who or what gets to draw those lines.\n\nWhen you do it yourself in your own code, it's just code transforming code. But if it's mandated by a separate program beyond your control, then it's called \"a compiler\" (and the hard lines are called a \"programming language\"). *That* part is not _fundamentally_ necessary.",
        "user": "UAVCC2X70",
        "ts": "1572746041.027000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1572747631.000000"
        },
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "77a482d8-7b12-4700-819d-f0b5f3a81b91",
        "type": "message",
        "text": "As for different representations (e.g. the \"3-lisp\" complexity), that sounds like a real mess to have to deal with, so that advice is very appreciated!\n\nBut also, I see no reason that wisdom cannot be applied in any context (e.g. not just a compiler) where code manipulates / generates other code.",
        "user": "UAVCC2X70",
        "ts": "1572748454.031800",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "6b7a3334-1ff5-4922-b580-b2034259cb2d",
        "type": "message",
        "text": "I'm actually thinking that Racket is probably the best compromise at the intersection of all this. It enforces separation through layers of \"language\", but lets you be in control of defining them how you like.\n\nHypothetically, I bet you could even make your own language/syntax for specifying languages ... though I'm honestly not sure how practical that would actually be.",
        "user": "UAVCC2X70",
        "ts": "1572748746.033300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1572748957.000000"
        },
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "2bfb3962-e525-4b42-9775-b538e2a41134",
        "type": "message",
        "text": "My impression is that the Xerox Alto was a minicomputer, comparable to a PDP-11 minicomputer, and was distinguished by specialized hardware like a mouse, a bitmap display, and ethernet. The Alto fit in a small cabinet. IBM mainframes of that era filled a room. I think that the true analog of an Alto-like computer today would be FoC projects that use specialized hardware to prototype new ways for people to interact with computers. A really good example would be <http://dynamicland.org|dynamicland.org>, which is Alan Kay's current project.",
        "user": "UJN1TAYEQ",
        "ts": "1572749022.035400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572749022.035400",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1572771172.039000",
        "reply_users": [
            "UJ6LDMMN0"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "735ffd65-694d-491f-bf16-28356809fdd8",
        "type": "message",
        "text": "&gt; Is there a formalization to add and validate constraints on the valid intervals in which particular events can be emitted in the system?\n\nThis sounds like the raison d'\u00eatre of state machines.",
        "user": "UC2A2ARPT",
        "ts": "1572758585.035800",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "f6e2a0ff-249f-4bdb-8dba-6f21be2ba74b",
        "type": "message",
        "text": "&gt; I mean there might be multiple services/objects around waiting for messages and due the combinatorical explosion we can't enumerate all the possible sequences of events.\n\nIf those services or objects all share a thread of execution, then (possibly nested) state machines and their ilk are pretty much the bread and butter of organizing asynchrony.\n\nIf there's any kind of parallelism happening (whether locally or across a network), then you're entering into the domain of the CAP theorem, and can pull out the coordination schemes like Raft or Paxos and the guarantees like linearizability and serializability. These are the standard and _proven_ (in that they're formally verifiable and rigorous) means of reasoning about distributed systems. Though good luck guaranteeing that your implementation is perfectly correct \u2014 cosmic rays and whatnot.",
        "user": "UC2A2ARPT",
        "ts": "1572758973.036400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "2c8b1fac-750f-4b07-a2d1-b749179ede6b",
        "type": "message",
        "text": "This stuff is all programming language-agnostic \u2014 it's just the way we talk about properties of distributed software that emerge from the laws of physics.",
        "user": "UC2A2ARPT",
        "ts": "1572759059.036600",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "5c20e3d6-b03d-4e40-89ff-aa22d65213c4",
        "type": "message",
        "text": "Let's start a thread for this discussion, rather than creating a lot of scrollback for the whole channel. Here's <@UKB1S7ZMY>'s prompt:\n\n&gt; IIRC Xerox PARC &amp; co used the most powerful computers available at the time to \"invent the future\": the graphical environments and programming languages regular people use now.\n&gt; What would be the equivalent today?\n&gt; My (naive) impression is that programming language and HCI labs don't seem to make use of 64 core processors with a 100 GB of RAM and GPU computing to similarly invent the future.",
        "user": "UC2A2ARPT",
        "ts": "1572759144.037500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1572759167.000000"
        },
        "thread_ts": "1572759144.037500",
        "reply_count": 67,
        "reply_users_count": 11,
        "latest_reply": "1573601074.362700",
        "reply_users": [
            "UC2A2ARPT",
            "UJ6LDMMN0",
            "UJN1TAYEQ",
            "UBN9AFS0N",
            "ULM3U6275",
            "UE6EFEPTQ",
            "UKB1S7ZMY",
            "U6FKVSVCK",
            "UPDJV04FR",
            "U5STGTB3J",
            "UC6997THT"
        ],
        "subscribed": true,
        "last_read": "1573601074.362700",
        "reactions": [
            {
                "name": "pray",
                "users": [
                    "U5STGTB3J",
                    "UAL7940NM"
                ],
                "count": 2
            },
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "UPDJV04FR"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "a8c6ac30-c5aa-45a6-b4ac-6c8eaf0d9439",
        "type": "message",
        "text": "The way I think of this is... what hardware can be purchased or built (or even conceptualized) that stands a good chance of inevitably going mainstream in the future. That's what the Alto and Dynabook and Memex were in the past. Here are some things that fit that criteria today:\n\n\u2022 VR goggles\n\u2022 AR goggles\n\u2022 Augmented hearing devices\n\u2022 Dynamicland (h/t <@UJN1TAYEQ>)\n\u2022 worn tactile feedback devices\n\u2022 anti-grav / hover\n\u2022 foldable screens\n\u2022 micrometer-accurate device positioning / orientation awareness\n\u2022 extreme battery efficiency, low heat production\n\u2022 hyper sensitive microphones with fantastic signal/noise and extreme frequency response\n\u2022 quantum computers\n\u2022 gigapixel resolution still and video cameras\n\u2022 centimeter-scale GPS\n\u2022 hemi and full spherical cameras\n\u2022 stereoscopic cameras\n\u2022 metamaterials\n\u2022 $1/kg to LEO\n\u2022 vacation homes at L1-L5\n\u2022 the fucking holodeck\n\nYou get the idea. My point is \u2014 I see no shortage of opportunities to apply the model \"spend enough money and imagination today, and you can work on the technology that'll be ubiquitous in 10-30 years\"",
        "user": "UC2A2ARPT",
        "ts": "1572759643.037800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1572759830.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL",
                    "UKB1S7ZMY",
                    "UFB8STN7K",
                    "UMWF81HTP"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "ac5f0dd6-9ce3-46b9-9c16-7a1bcd23b6a6",
        "type": "message",
        "text": "Yes, the point is learning. You should almost always be able to glean at least one bit of new information no matter who you talk to that makes it worthwhile",
        "user": "UMVFWPZ36",
        "ts": "1572761766.038200",
        "team": "T5TCAFTA9",
        "thread_ts": "1572282098.317700",
        "parent_user_id": "UPV1HUCBH"
    },
    {
        "client_msg_id": "02536acc-2a89-4e52-bfc3-75cf99ba2b84",
        "type": "message",
        "text": "I thought about Dynamicland too as an example of expensive hardware for testing some future of programming!",
        "user": "UJ6LDMMN0",
        "ts": "1572771172.039000",
        "team": "T5TCAFTA9",
        "thread_ts": "1572749022.035400",
        "parent_user_id": "UJN1TAYEQ"
    },
    {
        "client_msg_id": "02dd2d83-f006-499c-b426-582ea841f2a0",
        "type": "message",
        "text": "Sorry to ask, but what \"LEO\" and \"L1-L5\" mean? Not sure it is that important, but a least I will learn something new! :wink:",
        "user": "UJ6LDMMN0",
        "ts": "1572771488.039200",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "9353B788-B241-4E29-A57C-9CB378E8021D",
        "type": "message",
        "text": "Words like \u201cnecessary\u201d and \u201cinevitable\u201d refer to tacit requirements. A Turing-complete language doesn\u2019t need any add-on for doing computations, but additional requirements can make macro-like processing phases necessary. I see such features as a form of modularization. Macros can be considered compiler plugins, for example, but also as tools for implementing DSLs.",
        "user": "UJBAJNFLK",
        "ts": "1572777058.052000",
        "team": "T5TCAFTA9",
        "thread_ts": "1571972846.216600",
        "parent_user_id": "UHWC9PXBL"
    },
    {
        "client_msg_id": "95A27AFA-01A8-4A56-B422-CEEAEA2705DD",
        "type": "message",
        "text": "<@UFPPABQ7P> just general verification. Yes exactly, I imagine a service/object like a state machine and my problem is that if there is a lot of them on top level then it is quite impossible to introduce a top level state machine (like hieararchical) without the combinatorical explosion :boom: .\n\nWhat I would like to do instead is add constraints on the valid ordering of events and \n1. I would make sure the code really implements it. (Eg. if there is a constraint like: the eventstream can start off with E1 or there won't be any E1 in stream; I make sure the service emitting E1 is the first to emit events in my implementation and there is no other valid context in which the service is prompted to emit E1)\n2. I would enumerate all the eventstreams(event ordering) with the constrains to make sure there is no ordering I missed / I forgot about.\n\nIt reminds me a lot to automata theory/regexes, but to me they are closer to state machines.\n\nTo me state machines are \"clean\" and easy and what I am looking for is how to make \"cleaner\" the \"dirty (combinatorical) space above top level clean state machines\" via temporal constrains. By temporal I mean constraints on ordering (check out Temporal Logic, especially Computational Tree Logic).\n\nI deeply believe adding/expressing constraints on ordering is REALLY easy compared to other techniques for verification. Furthermore, constraints on ordering of events has a lot to do the meaning of the software (for me), and it seems nice to me to make it explicit.",
        "user": "UL3CJ7YKC",
        "ts": "1572778068.067400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "F1F1D27D-9CC7-4648-AD96-5C0B26F84A75",
        "type": "message",
        "text": "<@UAVCC2X70> I meant Events like messages between any separate Objects / Services. It can be a method call, it can be an event listened by another service, it does not matter. The only thing matters information gets through boundaries: making the clean/easy state machines/objects/services interacting with each other which is dirty and combinatorical because the timings (events emitted) are not constrained (at all).",
        "user": "UL3CJ7YKC",
        "ts": "1572778403.073300",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "6038c52c-136a-4a67-95b5-c233e452c350",
        "type": "message",
        "text": "I asked this question to Alan recently, and here were my takeaways:\n\nOne important thing is to have a pretty full picture of the ongoing trends in CS software and hardware. They had this at PARC because their team included hardware and software specialists. All together they were up on all the literature. If you can pretty accurately predict the trends, it's usually not to hard to buy it today. However it may not be processing power or storage that's the key. For example Dynamicland buys very expensive projectors to \"buy\" the future of AR and VR",
        "user": "U5TCAFTD3",
        "ts": "1572779225.073600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5TCAFTD3",
            "ts": "1572779265.000000"
        },
        "thread_ts": "1572723679.497200",
        "parent_user_id": "UKB1S7ZMY",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UBKNXPBAB"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "44449A79-27F9-44BE-B58E-7D2AFF105F80",
        "type": "message",
        "text": "<@UC2A2ARPT> yes, state machines are quite good, but my problem arises when there are many of them and I don't know how to add timing/event ordering constraints to enumerate all the valid possibilities.",
        "user": "UL3CJ7YKC",
        "ts": "1572780113.075800",
        "team": "T5TCAFTA9",
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "81BC0503-36C0-4E14-A452-0DB8EAABAAF1",
        "type": "message",
        "text": "<https://github.com/davidkpiano/xstate/issues/287>\n\nHere is one of my old questions in the topic. XState is a really cool State Machine lib.",
        "user": "UL3CJ7YKC",
        "ts": "1572780862.077000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UL3CJ7YKC",
            "ts": "1572780880.000000"
        },
        "thread_ts": "1572709118.479700",
        "parent_user_id": "UL3CJ7YKC"
    },
    {
        "client_msg_id": "c15bb4ad-402b-4b66-ae45-c562178f5f64",
        "type": "message",
        "text": "<@UJ6LDMMN0> LEO is Low Earth Orbit and L1-L5 are Lagrange points: gravitationally stable locations in outer space within the Earth-Moon system. These are not part of my FoC vision yet; clearly I'm not thinking big enough.",
        "user": "UJN1TAYEQ",
        "ts": "1572783163.077300",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "UKB1S7ZMY"
                ],
                "count": 1
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "last_quarter_moon_with_face",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "f47d22e0-c8f5-470c-b579-190da890e268",
        "type": "message",
        "text": "I can open another thread if it make sense, but I want to introduce a different direction on things to explore the FoC without spending too much. Let's say today I buy the highest spec gamer PC I can buy, thorwing pseudo random numbers here: 64 core i9, 64GB of RAM, 2TB SSD, highest spec graphics card.\nNow compare those specs with the xerox alto:\n\nBit-mapped black and white display sized 606x808 (the same dimensions as a regular (8.5\"x11\") sheet of paper, aligned vertically)\n5.8 MHz CPU\n128KB of memory (at the cost of $4000)\n2.5MB removable cartridge hard drive",
        "user": "UBN9AFS0N",
        "ts": "1572787811.077700",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "827aedcf-e738-45b9-806f-0ecdcb689d90",
        "type": "message",
        "text": "if someone wants to do the orders of magnitude improvements it would be nice, but it's pretty clear that pharo today is not the same orders of magnitude better than the hardware improvements.",
        "user": "UBN9AFS0N",
        "ts": "1572787861.077900",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "2944c746-f28b-4523-bd5a-3681130f7929",
        "type": "message",
        "text": "We have advanced, but for each step we added much more complexity and non performance abstractions. I really believe that buying the future to today and program with future tools today is a really good idea, but another thing to do is to create abstractions and tools that reduce the complexity and performance issues of today's hardware (which is incredible) and take advantage of it.",
        "user": "UBN9AFS0N",
        "ts": "1572787962.078100",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "3ed141cf-e6a6-456d-af07-febb4d310e84",
        "type": "message",
        "text": "another direction is taking advantage of the possibilities of devices working together. Right now on the table I'm on there are two laptops, 3 smartphones and a tablet. There's nothing interesting I can easily do with the 6 supercomputers I have idling at arms length.",
        "user": "UBN9AFS0N",
        "ts": "1572788115.078300",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "ULM3U6275",
                    "UE6EFEPTQ"
                ],
                "count": 2
            },
            {
                "name": "bulb",
                "users": [
                    "UDJ2TKB99"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3efd4d2a-fa23-4eca-a1b3-f6449ada9b63",
        "type": "message",
        "text": "my tl;dr: we have supercomputers and seamless connectivity already, it's not expensive and we are not taking advantage of them. We can go buy expensive future technology, but we should also try to take more advantage of the awesome technology we have today (and that's cheaper/free more accessible to more people)",
        "user": "UBN9AFS0N",
        "ts": "1572788210.078500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "ULM3U6275",
                    "UE6EFEPTQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "ec6a004a-06d1-4603-80a5-ac4aefd04425",
        "type": "message",
        "text": "what if as Sun Microsystems said  \"The network is the computer.\" :slightly_smiling_face:",
        "user": "UBN9AFS0N",
        "ts": "1572788455.078700",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "dff07711-162b-4fc8-8781-19b50436e1ec",
        "type": "message",
        "text": "Let's put it as an analogy, instead of seeing what we can do with faster cars, we can *also* try to solve the traffic jam :stuck_out_tongue:",
        "user": "UBN9AFS0N",
        "ts": "1572792063.079000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1572792075.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "436083d9-c985-450c-b525-dd1c48a592ae",
        "type": "message",
        "text": "also with bikes or public transport, exploring/improving alternatives should be as productive as going further in the main dimension",
        "user": "UBN9AFS0N",
        "ts": "1572792138.079300",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "61DA70C8-86E2-4AD7-9427-AC9399DC20C5",
        "type": "message",
        "text": "<@UBN9AFS0N> \u201cThere's nothing interesting I can easily do with the 6 supercomputers I have idling at arms length.\u201d Exactly. If the argument is that faster computers enable us to make better tools, why haven\u2019t significantly better tools appeared over the last several orders of magnitude in computer performance improvements?",
        "user": "ULM3U6275",
        "ts": "1572795118.080500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "ULM3U6275",
            "ts": "1572795979.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1::skin-tone-4",
                "users": [
                    "UBN9AFS0N"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b07b3173-614b-4e71-a3d4-ca4e78961732",
        "type": "message",
        "text": "I'm building the FoC on nRF51 chips alongside my pocket supercomputer! I believe we have to to cut out all the crap and start again.",
        "user": "UE6EFEPTQ",
        "ts": "1572797201.081400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1572797361.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "936aefc7-646f-4f8d-9ecb-07a03b05d63f",
        "type": "message",
        "text": "And after building with 1802 chips as a kid, I feel guiltily lazy having the luxury of a 32bit Cortex M0 as my baseline, but you gotta give yourself a bit of a break!",
        "user": "UE6EFEPTQ",
        "ts": "1572797340.081600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1572797378.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "3b354b36-bc9e-47c1-9fe1-cb8f41137b71",
        "type": "message",
        "text": "I hadn't considered things like VR at all, much less any of your other suggestions <@UM0EHL7JQ>. Thanks for the inspiring list. \nIt's also my feeling that we just don't have the programming models to exploit what we currently have though.",
        "user": "UKB1S7ZMY",
        "ts": "1572800912.082000",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "664de18e-93f4-4e6b-b7e3-9345d53ddc28",
        "type": "message",
        "text": "Lynx will run on the cloud, which means it'll make cloud scale general purpose computing accessible to an everyday person with zero configuration",
        "user": "U6FKVSVCK",
        "ts": "1572801657.082200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U6FKVSVCK",
            "ts": "1572801697.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "786c7170-c6b8-4726-ae59-6e91f4117058",
        "type": "message",
        "text": "I am excited to see what people will invent with it",
        "user": "U6FKVSVCK",
        "ts": "1572801760.082500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "e59c2401-2011-4660-933e-e37e92f5cf49",
        "type": "message",
        "text": "<@U6FKVSVCK> is there something online to check lynx?",
        "user": "UBN9AFS0N",
        "ts": "1572802477.082700",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "7a824d79-e133-4767-913d-e553accfacc6",
        "type": "message",
        "text": "I wonder, for example, what new things could be done with \"a huge amount of computational resources spent for an affordably short period of time\". You want (comparatively, relative to personal computing) a galactically huge calculation done, but you need it ready in under a second.",
        "user": "U6FKVSVCK",
        "ts": "1572802728.082900",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "c1aa412a-a687-4b60-8174-d2771b26b560",
        "type": "message",
        "text": "<@UBN9AFS0N> <http://Lynxtool.com|Lynxtool.com> has a pitch and mock up. A non public demo will be ready in a few days if nothing goes wrong",
        "user": "U6FKVSVCK",
        "ts": "1572802801.083100",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "733085ca-cda8-4597-9616-cea3b41235e1",
        "type": "message",
        "text": "looks great, love some of the solutions you use for abstracting, choices and iteration",
        "user": "UBN9AFS0N",
        "ts": "1572803983.083500",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U6FKVSVCK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "28d8b397-17f2-49c5-bbfb-feb47c6274a0",
        "type": "message",
        "text": "That looks very cool, <@U6FKVSVCK>! Have you considered modeling time like in FRP?",
        "user": "UKB1S7ZMY",
        "ts": "1572808375.085100",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "D7C0FF2A-470C-4186-A00D-87FB0D082A3D",
        "type": "message",
        "text": "For me, better software abstractions are far more valuable than 10x or 100x in hw performance. \n\nFor example, most of the time I\u2019ve spent on my project has been reimplementing the abstractions we were used to for desktop app development in Javascript for the browser and none of this work would have been helped by significantly faster hardware.",
        "user": "ULM3U6275",
        "ts": "1572808717.090900",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJ6LDMMN0",
                    "U6FKVSVCK"
                ],
                "count": 2
            },
            {
                "name": "upside_down_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "4a4f51f1-36e4-4388-b5a9-7ec887e16859",
        "type": "message",
        "text": "And there is also the problem that, we now have \"futurist hardware\" but we don't fully use them for programming. I mean, I learned programming on terminals with monochrome text display and a keyboard, using emacs to edit streams of characters and compile them with the command line, then execute the results, and eventually debugging it with a text debugger. Nearly 30 years after I do nearly the same now, without fully exploiting the \"futurist hardware\" we have now (i.e. graphical display and the mouse) for programming. Our programming tasks still always come down to editing text streams. So I guess there is work to do on this, and better futuristic hardware or maximum performance won't help. Even if I found very exciting new dynamic medium \u00e0 la DynamicLand as new ways to create/programm stuff.",
        "user": "UJ6LDMMN0",
        "ts": "1572811414.091400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "ef53d9e4-aa44-4f5f-8744-53bfe918c4a8",
        "type": "message",
        "text": "My only hope for better hardware in the future (the future forwards from the 80s when I was doing the hoping) was that people would be freed from programming models that _cared about keeping the machine happy_! But still we program in imperative languages and have used up all that power in a tottering Babelesque tower of shite.",
        "user": "UE6EFEPTQ",
        "ts": "1572813927.091600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UE6EFEPTQ",
            "ts": "1572813984.000000"
        },
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "F9B0DF34-24D1-4FAA-880A-D0DD8825BA10",
        "type": "message",
        "text": "I\u2019d add storage and bandwidth to the list of resources to target at a high level. If everyone had 1PB of storage at home, we should all just have e.g. a local copy of Wikipedia. Maybe a web index too. Then search queries could be near instant. ",
        "user": "UPDJV04FR",
        "ts": "1572817567.094400",
        "team": "T5TCAFTA9",
        "thread_ts": "1572759144.037500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a4e72fd0-3583-4ae1-89ac-fdda79737dbd",
        "type": "message",
        "text": "This paper looks useful for understanding how to visually represent code:\n\"Unifying Textual and Visual: a Theoretical  Account of the Visual Perception of Programming Languages\"\n<http://recherche.enac.fr/~conversy/research/papers/onward2014-langVis.pdf>",
        "user": "UP3FH4CLU",
        "ts": "1572818207.096100",
        "team": "T5TCAFTA9",
        "thread_ts": "1572818207.096100",
        "reply_count": 6,
        "reply_users_count": 3,
        "latest_reply": "1572866956.103200",
        "reply_users": [
            "UC2A2ARPT",
            "UJ6LDMMN0",
            "UPU0YJ1CM"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UC2A2ARPT",
                    "UFB8STN7K",
                    "UJUQESQ1Z",
                    "UD31LGQKB",
                    "UPVBV34EL"
                ],
                "count": 5
            }
        ]
    },
    {
        "client_msg_id": "848C5E99-5137-489E-B460-3C6A9C80F119",
        "type": "message",
        "text": "This Conversy paper is also good: <https://hal.inria.fr/hal-00737414>",
        "user": "UC2A2ARPT",
        "ts": "1572818286.096900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "A visual perception account of programming languages : finding the natural science in the art",
                "title_link": "https://hal.inria.fr/hal-00737414",
                "text": "There is no agreed set of grounded principles on which to rely to analyze and discuss code representations. I propose a combination of Semiotic of Graphics and ScanVis. I discovered that this unifying framework brings together many aspects of visual layout and appearance of programming languages. We describe how the framework applies to programming languages, which is not obvious and has never been done before. We show how to use the framework to compare representation of code by relying on sound arguments. Finally, we use the framework to devise design principles to help generate new representations. Relying on such a framework can help researchers and designers invent better languages with respect to this concern. This work also suggests that the gap between textual and graphical languages is narrow, and that true visual languages should rely on the capability of the human visual system.",
                "fallback": "A visual perception account of programming languages : finding the natural science in the art",
                "from_url": "https://hal.inria.fr/hal-00737414",
                "service_name": "hal.inria.fr",
                "id": 1,
                "original_url": "https://hal.inria.fr/hal-00737414"
            }
        ],
        "thread_ts": "1572818207.096100",
        "parent_user_id": "UP3FH4CLU"
    }
]