[
    {
        "client_msg_id": "A3843500-59F9-42B2-A2CE-526A2ACD2E2B",
        "type": "message",
        "text": "Are there any languages that make fluid use of linguistic context, as in overloading variables/symbols, type-specific sub-languages/operations/functions? I brainstorm here just because variable names tend to get long and complicated in any language, making thought too verbose. For instance, \u2018Maybe Int = Just Int | Nothing\u2019 seems incredibly verbose for something that gets passed around a lot in Haskell.\n\nSo if there is anything that makes variables/function names/types easier within specific contexts \u2014at the cost of readability but making experimentation easy \u2014 that would be greatly appreciated",
        "user": "USUMN6XLH",
        "ts": "1582695411.037800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dbo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Are there any languages that make fluid use of linguistic context, as in overloading variables/symbols, type-specific sub-languages/operations/functions? I brainstorm here just because variable names tend to get long and complicated in any language, making thought too verbose. For instance, \u2018Maybe Int = Just Int | Nothing\u2019 seems incredibly verbose for something that gets passed around a lot in Haskell.\n"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "text",
                                "text": "So if there is anything that makes variables/function names/types easier within specific contexts \u2014at the cost of readability but making experimentation easy \u2014 that would be greatly appreciated"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1582757598.042400",
        "reply_users": [
            "UFB8STN7K",
            "UJBAJNFLK",
            "UEQ6M68H0"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "b33c702a-2fc6-4dbb-83c2-4e8e642e34f2",
        "type": "message",
        "text": "most theorem provers I think fall into this category, e.g.  lean <https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#notation>",
        "user": "UFB8STN7K",
        "ts": "1582697396.038000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NZ8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "most theorem provers I think fall into this category, e.g.  lean "
                            },
                            {
                                "type": "link",
                                "url": "https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#notation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "parent_user_id": "USUMN6XLH",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "USUMN6XLH"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "0F83D36F-C2CA-4453-B962-30AB582194C2",
        "type": "message",
        "text": "seems the paper above is directly claiming emperical evidence doesn't support Papert's constructionist learning theory\n\n\n<https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)|https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)>",
        "user": "UC6997THT",
        "ts": "1582709487.041300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "image_url": "https://upload.wikimedia.org/wikipedia/commons/6/67/Seymour_Papert.png",
                "image_width": 237,
                "image_height": 246,
                "image_bytes": 131872,
                "title": "Constructionism (learning theory)",
                "title_link": "https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)",
                "from_url": "https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)",
                "author_name": "Wikipedia",
                "author_link": "https://en.wikipedia.org/",
                "text": "Constructionist learning is when learners construct mental models to understand the world around them. Constructionism advocates student-centered, discovery learning where students use information they already know to acquire more knowledge. Students learn through participation in project-based learning where they make connections between different ideas and areas of knowledge facilitated by the teacher through coaching rather than using lectures or step-by-step guidance. Further, constructionism holds that learning can happen most effectively when people are active in making tangible objects in the real world. In this sense, constructionism is connected with experiential learning and builds on Jean Piaget's epistemological theory of constructivism.Seymour Papert defined constructionism in a proposal to the National Science Foundation titled Constructionism: A New Opportunity for Elementary Science Education as follows:\n\nThe word constructionism is a mnemonic for two aspects of the theory of science education underlying this project. From constructivist theories of psychology we take a view of learning as a reconstruction rather than as a transmission of knowledge. Then we extend the idea of manipulative materials to the idea that learning is most effective when part of an activity the learner experiences as constructing a meaningful product.\nSome scholars have tried to describe constructionism as a \"learning-by-making\" formula but, as Seymour Papert and Idit Harel say at the start of Situating Constructionism, it should be considered \"much richer and more multifaceted, and very much deeper in its implications than could be conveyed by any such formula.\"Papert's ideas became well known through the publication of his seminal book Mindstorms: Children, Computers, and Powerful Ideas (Basic Books, 1980). Papert described children creating programs in the Logo educational programming language. He likened their learning to living in a \"mathland\" where learning mathematical ideas is as natural as learning French while living in France.",
                "fallback": "wikipedia: Constructionism (learning theory)",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/wikipedia.png",
                "id": 1,
                "original_url": "https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qZcFe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "seems the paper above is directly claiming emperical evidence doesn't support Papert's constructionist learning theory\n"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)",
                                "text": "https://en.m.wikipedia.org/wiki/Constructionism_(learning_theory)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582289745.236200",
        "parent_user_id": "UC6997THT"
    },
    {
        "client_msg_id": "7d11ba70-a274-4f2f-a3d1-1e34eb1b9807",
        "type": "message",
        "text": "In my digital scientific notation Leibniz (<https://github.com/khinsen/leibniz>), I have tried to imitate the habits of the mathematical/scientific literature: every text introduces its whole notation explicitly, without any defaults nor any reuse of notation from other texts. If you want to write anything in Leibniz, you have to compose your linguistic context explicitly. There are no hierarchical namespaces either, intentionally, to discourage the building of large reusable libraries that nobody can fully understand anymore.",
        "user": "UJBAJNFLK",
        "ts": "1582710751.041600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "khinsen/leibniz",
                "title_link": "https://github.com/khinsen/leibniz",
                "text": "A Digital Scientific Notation. Contribute to khinsen/leibniz development by creating an account on GitHub.",
                "fallback": "GitHub: khinsen/leibniz",
                "thumb_url": "https://avatars1.githubusercontent.com/u/94934?s=400&v=4",
                "from_url": "https://github.com/khinsen/leibniz",
                "thumb_width": 157,
                "thumb_height": 157,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/khinsen/leibniz"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+8GyI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In my digital scientific notation Leibniz ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/khinsen/leibniz"
                            },
                            {
                                "type": "text",
                                "text": "), I have tried to imitate the habits of the mathematical/scientific literature: every text introduces its whole notation explicitly, without any defaults nor any reuse of notation from other texts. If you want to write anything in Leibniz, you have to compose your linguistic context explicitly. There are no hierarchical namespaces either, intentionally, to discourage the building of large reusable libraries that nobody can fully understand anymore."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "parent_user_id": "USUMN6XLH",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "USUMN6XLH"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ce0515eb-ac60-467d-aa34-0a13aaf4b7a5",
        "type": "message",
        "text": "languages which can overwrite code like Lisp can of course overload symbols, and is well known to be one of the most flexible languages around. Postscript also allows for redefinition of symbols freely. But the king of brevity in terms of languages is perennially FORTH, whose programmers take delight in rewriting the meaning of + temporarily, and the results are incredibly impressive in both speed and compactness. The problem with FORTH is that it is basically a write-only language, and it is super hard to understand your own code a month later, much less other people's code, because you have to keep in your mind what is on the stack, and how many operators are consumed by each operand. Another language which is highly flexible is Red/Rebol.\n\nIn my efforts to develop my Beads language i have moved in the complete opposite direction so that any feature which makes things harder to read is removed, and the whole thrust is to make programs minimal while promoting clarity. For example + in JS means add OR could mean string concat; i use + for add, and &amp; for concat so you can't mix them by mistake (or cause ruinous implied type conversions which JS does so readily).",
        "user": "UEQ6M68H0",
        "ts": "1582757598.042400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZsJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "languages which can overwrite code like Lisp can of course overload symbols, and is well known to be one of the most flexible languages around. Postscript also allows for redefinition of symbols freely. But the king of brevity in terms of languages is perennially FORTH, whose programmers take delight in rewriting the meaning of + temporarily, and the results are incredibly impressive in both speed and compactness. The problem with FORTH is that it is basically a write-only language, and it is super hard to understand your own code a month later, much less other people's code, because you have to keep in your mind what is on the stack, and how many operators are consumed by each operand. Another language which is highly flexible is Red/Rebol.\n\nIn my efforts to develop my Beads language i have moved in the complete opposite direction so that any feature which makes things harder to read is removed, and the whole thrust is to make programs minimal while promoting clarity. For example + in JS means add OR could mean string concat; i use + for add, and & for concat so you can't mix them by mistake (or cause ruinous implied type conversions which JS does so readily)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1582695411.037800",
        "parent_user_id": "USUMN6XLH"
    }
]