[
    {
        "client_msg_id": "4e22348d-d803-40bf-9c37-69365ff1ae52",
        "type": "message",
        "text": "<https://www.unison.cloud/|Unison Cloud> is looking for beta users, <https://unison-lang.org/at-work|fill out this short questionaire> if interested\n\n&gt; Unison Cloud offers a managed pool of cloud-based Unison nodes that can execute distributed computations. There's no separate packaging or deployment step. To use it, just call a function, passing it the distributed computation you want to run. For instance, the below example forks two parallel computations on randomly chosen locations in the default pool. Calling <https://share.unison-lang.org/@unison/p/code/latest/namespaces/public/cloud/latest|cloud.run> will serialize this computation, sync any missing dependencies on the fly, and run it in the cloud.\n&gt;  \n&gt; main = do\n&gt;  r = cloud.run do\n&gt;   t1 = Remote.forkAt !pool.default '(1 + 1)\n&gt;   t2 = Remote.forkAt !pool.default '(2 + 2)\n&gt;   Remote.await t1 + Remote.await t2\n&gt;  printLine (\"Result was: \" ++ Nat.toText r)\n&gt;  \n&gt; The <https://share.unison-lang.org/@unison/p/code/latest/namespaces/public/cloud/latest|current unison.cloud API> is tailored for batch computations (as in Hadoop or Spark or miscellaneous ETL jobs), but we plan to add support for launching async background jobs, recurring or scheduled jobs, resilient long-running workflows (as in <https://temporal.io|Temporal>), and *autoscaled resilient microservices*.\n&gt;  \n&gt; We'd like to work with folks who have ideas for use cases in any of these areas and who are willing to work with us on some pilot project using Unison and Unison Cloud.",
        "user": "UBN9AFS0N",
        "ts": "1673515136.291669",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SAMXY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.unison.cloud/",
                                "text": "Unison Cloud"
                            },
                            {
                                "type": "text",
                                "text": " is looking for beta users, "
                            },
                            {
                                "type": "link",
                                "url": "https://unison-lang.org/at-work",
                                "text": "fill out this short questionaire"
                            },
                            {
                                "type": "text",
                                "text": " if interested\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Unison Cloud offers a managed pool of cloud-based Unison nodes that can execute distributed computations. There's no separate packaging or deployment step. To use it, just call a function, passing it the distributed computation you want to run. For instance, the below example forks two parallel computations on randomly chosen locations in the default pool. Calling "
                            },
                            {
                                "type": "link",
                                "url": "https://share.unison-lang.org/@unison/p/code/latest/namespaces/public/cloud/latest",
                                "text": "cloud.run",
                                "unsafe": true
                            },
                            {
                                "type": "text",
                                "text": " will serialize this computation, sync any missing dependencies on the fly, and run it in the cloud.\n \nmain = do\n r = cloud.run do\n  t1 = Remote.forkAt !pool.default '(1 + 1)\n  t2 = Remote.forkAt !pool.default '(2 + 2)\n  Remote.await t1 + Remote.await t2\n printLine (\"Result was: \" ++ Nat.toText r)\n \nThe "
                            },
                            {
                                "type": "link",
                                "url": "https://share.unison-lang.org/@unison/p/code/latest/namespaces/public/cloud/latest",
                                "text": "current unison.cloud API",
                                "unsafe": true
                            },
                            {
                                "type": "text",
                                "text": " is tailored for batch computations (as in Hadoop or Spark or miscellaneous ETL jobs), but we plan to add support for launching async background jobs, recurring or scheduled jobs, resilient long-running workflows (as in "
                            },
                            {
                                "type": "link",
                                "url": "https://temporal.io",
                                "text": "Temporal"
                            },
                            {
                                "type": "text",
                                "text": "), and "
                            },
                            {
                                "type": "text",
                                "text": "autoscaled resilient microservices",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".\n \nWe'd like to work with folks who have ideas for use cases in any of these areas and who are willing to work with us on some pilot project using Unison and Unison Cloud."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9"
    },
    {
        "client_msg_id": "A2029EA6-FED1-4E79-AA99-F095A82A078F",
        "type": "message",
        "text": "&gt; An online IDE for visual programming in Prolog\n<https://github.com/toblotron/praxis-ide|https://github.com/toblotron/praxis-ide>",
        "user": "U0378MDUG1Y",
        "ts": "1673541112.784699",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ipLg",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An online IDE for visual programming in Prolog"
                            }
                        ],
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://github.com/toblotron/praxis-ide",
                                "text": "https://github.com/toblotron/praxis-ide"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1673541112.784699",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1673552856.473889",
        "reply_users": [
            "U02U0AS3J49"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "sunglasses",
                "users": [
                    "U02U0AS3J49"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "da91ecf6-92ba-4cf7-a649-0cf1394ba4b1",
        "type": "message",
        "text": "I'm currently working on adding lists to my blockly-based IDE for s(CASP). But it restricts people to unary and binary predicates, so it's not applicable to a real Prolog language, yet. I keep thinking it might be worth building a block language for generic prologs, if I could come up with a decent way of letting the user generate n-ary predicates. Seeing any uptake on Praxis?",
        "user": "U02U0AS3J49",
        "ts": "1673552856.473889",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3CL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm currently working on adding lists to my blockly-based IDE for s(CASP). But it restricts people to unary and binary predicates, so it's not applicable to a real Prolog language, yet. I keep thinking it might be worth building a block language for generic prologs, if I could come up with a decent way of letting the user generate n-ary predicates. Seeing any uptake on Praxis?"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1673541112.784699",
        "parent_user_id": "U0378MDUG1Y"
    }
]