[
    {
        "client_msg_id": "35bc1195-2627-4a7d-a6b7-3cc6e4493e23",
        "type": "message",
        "text": "What's the general consensus on node based scripting?\n\nI'm intrigued by Unreal's Blueprint node based scripting tools - they seem easy to use, but if you want to do anything complex then (for me) it becomes very messy very quickly. However with the general move in the past 10 years or so to more functional programming and serverless etc then perhaps it makes sense. Small components that can be wired together visually feels _easy_, or _right_?\n\nDarklang is another example with extrapolates the complexities of the underlying system allowing you to just write some pseudo node based (at least when I last looked at it) components that are easily wired up together.\n\nI'm an iOS engineer by trade, and it feels that something like Darklang / node based coding could end up matching nicely with SwiftUI's declarative syntax for UI.",
        "user": "U04R4M6M90U",
        "ts": "1677704589.530519",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "noXQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What's the general consensus on node based scripting?\n\nI'm intrigued by Unreal's Blueprint node based scripting tools - they seem easy to use, but if you want to do anything complex then (for me) it becomes very messy very quickly. However with the general move in the past 10 years or so to more functional programming and serverless etc then perhaps it makes sense. Small components that can be wired together visually feels "
                            },
                            {
                                "type": "text",
                                "text": "easy",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", or "
                            },
                            {
                                "type": "text",
                                "text": "right",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "?\n\nDarklang is another example with extrapolates the complexities of the underlying system allowing you to just write some pseudo node based (at least when I last looked at it) components that are easily wired up together.\n\nI'm an iOS engineer by trade, and it feels that something like Darklang / node based coding could end up matching nicely with SwiftUI's declarative syntax for UI."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "reply_count": 7,
        "reply_users_count": 6,
        "latest_reply": "1677829514.260379",
        "reply_users": [
            "U018FSM8G3Z",
            "UA14TGLTC",
            "U04R4M6M90U",
            "U01JNTE35QS",
            "U04MTMF6Y4W",
            "U0296ACR13M"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "b298ead8-0559-4808-bfbe-47fb34afebdd",
        "type": "message",
        "text": "The main benefit of node based programming, or \"node and wire\", in my observation, is that is saves users from parsing. Mentally parsing code into an AST is difficult. It requires literacy. Node-and-wire makes the parsing explicit.\n\nThe downside is that reading and writing the graph is much less efficient for a literate author.",
        "user": "U018FSM8G3Z",
        "ts": "1677706041.460879",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CPsx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The main benefit of node based programming, or \"node and wire\", in my observation, is that is saves users from parsing. Mentally parsing code into an AST is difficult. It requires literacy. Node-and-wire makes the parsing explicit.\n\nThe downside is that reading and writing the graph is much less efficient for a literate author."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U04R4M6M90U"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "ca7438c9-9425-4fe7-b2ea-425c5876abfc",
        "type": "message",
        "text": "If it's just parsing, then block-based or structured editors should have the same advantages.\n\nA potential advantage of a node system (though maybe not realized in practice) is using layout so that some conceptual aspect of the system is well modelled: often nodes below depend on nodes above.  Compare with the text of say imperative programs text in which conditional branching gets squished and functional programs are often worse with the conceptual reduction tree split up across lots of definitions.\n\nMore than anything, I think node based systems have extra space to interweave intermediate results with the authored scaffolding.",
        "user": "UA14TGLTC",
        "ts": "1677744974.481629",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QGNC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If it's just parsing, then block-based or structured editors should have the same advantages.\n\nA potential advantage of a node system (though maybe not realized in practice) is using layout so that some conceptual aspect of the system is well modelled: often nodes below depend on nodes above.  Compare with the text of say imperative programs text in which conditional branching gets squished and functional programs are often worse with the conceptual reduction tree split up across lots of definitions.\n\nMore than anything, I think node based systems have extra space to interweave intermediate results with the authored scaffolding."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "U04R4M6M90U"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "B1B545CC-1784-4552-B5A0-D4DE491DDCCD",
        "type": "message",
        "text": "I wonder if it also makes you code in a different more modularised way. Smaller chunks of code rather than sprawling classes. It\u2019s a mindset shift of course, but it may make your code \u201cbetter\u201d",
        "user": "U04R4M6M90U",
        "ts": "1677764796.440399",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MU82X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I wonder if it also makes you code in a different more modularised way. Smaller chunks of code rather than sprawling classes. "
                            },
                            {
                                "type": "text",
                                "text": "It\u2019s"
                            },
                            {
                                "type": "text",
                                "text": " a mindset shift of course, but it may make your code \u201cbetter\u201d"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U"
    },
    {
        "client_msg_id": "e626d0a1-6b34-40cd-85cd-facb267f35d3",
        "type": "message",
        "text": "We have been building a live programming environment with a node based visual model for the last 6 years now. There are a few advantages which text based systems dont have, IMHO:\n1. Reuse by bringing in visual blocks that are prebuilt.\n2. Unified interface for multiple aspects such as for performance, debugging, inspection of state and live values along with programming.\n3. Zoomability (we are not yet doing this) : Different tiles can have different levels of zoom, and that can make for a very interesting interface.\nWe have built a good number of production apps using our own platform, so the pros and cons of the approach are quite well understood by us. For things that are assembly oriented (composition by reusing work done by others, I think visual programming is quite elegant). For algorithmic thinking it would need to be augmented with other modes (in our system you can write new functions in any language that compiles to wasm, plus also write web components and bring them in).",
        "user": "U01JNTE35QS",
        "ts": "1677779757.651809",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "t+L9f",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We have been building a live programming environment with a node based visual model for the last 6 years now. There are a few advantages which text based systems dont have, IMHO:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Reuse by bringing in visual blocks that are prebuilt."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Unified interface for multiple aspects such as for performance, debugging, inspection of state and live values along with programming."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Zoomability (we are not yet doing this) : Different tiles can have different levels of zoom, and that can make for a very interesting interface."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "We have built a good number of production apps using our own platform, so the pros and cons of the approach are quite well understood by us. For things that are assembly oriented (composition by reusing work done by others, I think visual programming is quite elegant). For algorithmic thinking it would need to be augmented with other modes (in our system you can write new functions in any language that compiles to wasm, plus also write web components and bring them in)."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U017SHBAFE3",
                    "U04MTMF6Y4W"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "40E50120-4256-4C99-AF82-BB656E4E8ADD",
        "type": "message",
        "text": "+1 to what Vijay said about modularity and reuse. Generally a smaller command set means more distinction between elements (different colors and shapes for values, functions, math). Dragging out a node highlights where it could go and \u201ctype errors\u201d if connected wrong. That\u2019s more difficult as an environment becomes more open (less predictable ). \n\nUnreal\u2019s primary target has been large game studios, where there are often developers writing algorimic code but outputting nodes to be tuned by other teams. <https://ludiq.io/blog/bolt-2|Bolt> is an interesting example where both happen at the same time. \n\nNone of this is unique to nodes; though they might give a better spatial view",
        "user": "U04MTMF6Y4W",
        "ts": "1677805588.617409",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SxxAz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "+1 to what Vijay said about modularity and reuse. Generally a smaller command set means more distinction between elements (different colors and shapes for values, functions, math). Dragging out a node highlights where it could go and \u201ctype errors\u201d if connected wrong. That\u2019s more difficult as an environment becomes more open (less predictable ). \n\nUnreal\u2019s primary target has been large game studios, where there are often developers writing algorimic code but outputting nodes to be tuned by other teams. "
                            },
                            {
                                "type": "link",
                                "url": "https://ludiq.io/blog/bolt-2",
                                "text": "Bolt"
                            },
                            {
                                "type": "text",
                                "text": " is an interesting example where both happen at the same time. \n\nNone of this is unique to nodes; though they might give a better spatial view"
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U04MTMF6Y4W",
            "ts": "1677828578.000000"
        },
        "attachments": [
            {
                "from_url": "https://ludiq.io/blog/bolt-2",
                "image_url": "https://ludiq.io/assets/images/_1200x630_crop_center-center_none/Bolt2Mockup_181025_224643.png",
                "image_width": 1200,
                "image_height": 630,
                "image_bytes": 177518,
                "id": 1,
                "original_url": "https://ludiq.io/blog/bolt-2",
                "fallback": "Ludiq: Bolt 2: First Look | Ludiq Blog - Ludiq",
                "text": "C# Generation, Classes and more...",
                "title": "Bolt 2: First Look | Ludiq Blog - Ludiq",
                "title_link": "https://ludiq.io/blog/bolt-2",
                "service_name": "Ludiq"
            }
        ],
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "U01JNTE35QS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "7dcb6b0e-a9cf-48db-a0b1-8bd7fc58806d",
        "type": "message",
        "text": "I think the main benefits of node based programming is in control and data flow readability, debugging and live programming. It's natural to fit in rich node visualizations like <http://enso.org|enso.org> does. However, I feel that you'd always want the node based language to be domains specific. Just projecting a general purpose language to nodes leads to too large graphs, low productivity and bad maintainability. And you should always be able to type in arithmetic expression. Much easier to read and type \" 1 + 2 * 3\" than have 5! nodes on the graph. Actually I think that it would be best for text to be the primary editing tool, but then have a generated graph for visualization and debugging.",
        "user": "U0296ACR13M",
        "ts": "1677824446.769759",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oTq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the main benefits of node based programming is in control and data flow readability, debugging and live programming. It's natural to fit in rich node visualizations like "
                            },
                            {
                                "type": "link",
                                "url": "http://enso.org",
                                "text": "enso.org"
                            },
                            {
                                "type": "text",
                                "text": " does. However, I feel that you'd always want the node based language to be domains specific. Just projecting a general purpose language to nodes leads to too large graphs, low productivity and bad maintainability. And you should always be able to type in arithmetic expression. Much easier to read and type \" 1 + 2 * 3\" than have 5! nodes on the graph. Actually I think that it would be best for text to be the primary editing tool, but then have a generated graph for visualization and debugging."
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U04MTMF6Y4W",
                    "U016VUZGUUQ"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "BC0893EE-209C-4BA8-9058-5B94CFA94EBC",
        "type": "message",
        "text": "I should mention, there were also a lot of interesting thoughts from a similar question I had a few days ago <https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549|https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549>. <@U04R4M6M90U> ",
        "user": "U04MTMF6Y4W",
        "ts": "1677829514.260379",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c48R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I should mention, there were also a lot of interesting thoughts from a similar question I had a few days ago "
                            },
                            {
                                "type": "link",
                                "url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549",
                                "text": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549"
                            },
                            {
                                "type": "text",
                                "text": ". "
                            },
                            {
                                "type": "user",
                                "user_id": "U04R4M6M90U"
                            },
                            {
                                "type": "text",
                                "text": " "
                            }
                        ]
                    }
                ]
            }
        ],
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "from_url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549",
                "ts": "1676896876.997549",
                "author_id": "U04MTMF6Y4W",
                "channel_id": "C5T9GPWFL",
                "channel_team": "T5TCAFTA9",
                "channel_name": "thinking-together",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "message_blocks": [
                    {
                        "team": "T5TCAFTA9",
                        "channel": "C5T9GPWFL",
                        "ts": "1676896876.997549",
                        "message": {
                            "blocks": [
                                {
                                    "type": "rich_text",
                                    "block_id": "1c6k",
                                    "elements": [
                                        {
                                            "type": "rich_text_section",
                                            "elements": [
                                                {
                                                    "type": "text",
                                                    "text": "I\u2019m curious \u201cwhere\u201d people think of visual in visual programming being. For context, I spend a lot of time in tools like Houdini, Solidworks, Cavalry, and After Effects. Some of them have more access to computation than others, but the biggest difference between those and Processing or threejs is a large \u201cstandard library\u201d of functions. \nOn the other hand, building a website with live feedback or scripting in a REPL seem like a very different experience from just writing the same code in notepad. I wonder if visual programming is all just \u201cdebug views\u201d rather than the specific presence of a GUI. And if so, what does that mean for generalized visual languages or environments?"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    }
                ],
                "id": 1,
                "original_url": "https://futureofcoding.slack.com/archives/C5T9GPWFL/p1676896876997549",
                "fallback": "[February 20th, 2023 4:41 AM] foc214: I\u2019m curious \u201cwhere\u201d people think of visual in visual programming being. For context, I spend a lot of time in tools like Houdini, Solidworks, Cavalry, and After Effects. Some of them have more access to computation than others, but the biggest difference between those and Processing or threejs is a large \u201cstandard library\u201d of functions. \nOn the other hand, building a website with live feedback or scripting in a REPL seem like a very different experience from just writing the same code in notepad. I wonder if visual programming is all just \u201cdebug views\u201d rather than the specific presence of a GUI. And if so, what does that mean for generalized visual languages or environments?",
                "text": "I\u2019m curious \u201cwhere\u201d people think of visual in visual programming being. For context, I spend a lot of time in tools like Houdini, Solidworks, Cavalry, and After Effects. Some of them have more access to computation than others, but the biggest difference between those and Processing or threejs is a large \u201cstandard library\u201d of functions. \nOn the other hand, building a website with live feedback or scripting in a REPL seem like a very different experience from just writing the same code in notepad. I wonder if visual programming is all just \u201cdebug views\u201d rather than the specific presence of a GUI. And if so, what does that mean for generalized visual languages or environments?",
                "author_name": "Ibro",
                "author_link": "https://futureofcoding.slack.com/team/U04MTMF6Y4W",
                "author_icon": "https://avatars.slack-edge.com/2023-02-03/4741999414086_8c94f74e0c435c77e517_48.png",
                "author_subname": "Ibro",
                "mrkdwn_in": [
                    "text"
                ],
                "footer": "Thread in #thinking-together"
            }
        ],
        "thread_ts": "1677704589.530519",
        "parent_user_id": "U04R4M6M90U"
    }
]