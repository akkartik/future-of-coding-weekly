[
    {
        "client_msg_id": "344fb001-9d12-4ba8-8a77-17b008cf1338",
        "type": "message",
        "text": "How much intersection/overlap do you think there is between Future of Coding and Tools for Thought \"movements\"?",
        "user": "UBN9AFS0N",
        "ts": "1622980122.044800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "z2VZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How much intersection/overlap do you think there is between Future of Coding and Tools for Thought \"movements\"?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "reply_count": 10,
        "reply_users_count": 9,
        "latest_reply": "1623019960.065700",
        "reply_users": [
            "U013ZLJARC7",
            "UBN9AFS0N",
            "U021MR7BK2Q",
            "UCUSW7WVD",
            "U5STGTB3J",
            "USH01JEDQ",
            "UJ6LDMMN0",
            "U01T2PC8LBA",
            "U016VUZGUUQ"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1623009483.051900"
    },
    {
        "client_msg_id": "377b216f-9b60-4869-ad4b-a1ee60838388",
        "type": "message",
        "text": "Feels like quite a bit. Why?",
        "user": "U013ZLJARC7",
        "ts": "1622985392.045000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2Jq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Feels like quite a bit. Why?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "b4a81c26-a595-4252-a2b9-f0ab15744883",
        "type": "message",
        "text": "I was thinking how much computation is in tools of thought and how much knowledge management there is in future of coding",
        "user": "UBN9AFS0N",
        "ts": "1622986062.045200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TR5Sq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was thinking how much computation is in tools of thought and how much knowledge management there is in future of coding"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UC2A2ARPT",
                    "U013ZLJARC7"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "630805c7-9eb6-4f94-857d-f7f8bbee3383",
        "type": "message",
        "text": "I think the intersection of both may be the most interesting part",
        "user": "UBN9AFS0N",
        "ts": "1622986108.045400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "It1C",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the intersection of both may be the most interesting part"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01FAFPDFL4",
                    "U01R76LELBT"
                ],
                "count": 2
            },
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "FED5B20C-9D67-4E49-8A54-7638C8DB9856",
        "type": "message",
        "text": "What do you gain from being able to run a program in reverse? Just looking at <@UC2A2ARPT>\u2019s Hest but curious more generally",
        "user": "U01R76LELBT",
        "ts": "1622986722.046000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01R76LELBT",
            "ts": "1622986736.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x+v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What do you gain from being able to run a program in reverse? Just looking at "
                            },
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "\u2019s Hest but curious more generally"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622986722.046000",
        "reply_count": 3,
        "reply_users_count": 3,
        "latest_reply": "1623028900.065900",
        "reply_users": [
            "UDQBTJ211",
            "UC2A2ARPT",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "e5a8c612-16fc-4298-8c60-754309824290",
        "type": "message",
        "text": "Yes! In my opinion development environments could be a lot more like Roam Research and the like: We have functions, each function references other functions and is referenced by other functions, thus shaping a graph of functions. So why not make this graph the structure of the environment, rather than some more or less arbitrary folders and files.",
        "user": "U021MR7BK2Q",
        "ts": "1622989475.048900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ERIE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes! In my opinion development environments could be a lot more like Roam Research and the like: We have functions, each function references other functions and is referenced by other functions, thus shaping a graph of functions. So why not make this graph the structure of the environment, rather than some more or less arbitrary folders and files."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bca09df0-9995-4e96-8a34-9754cf9aceaf",
        "type": "message",
        "text": "You can go from a bug (or any effect), to it's cause",
        "user": "UDQBTJ211",
        "ts": "1622990028.049100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UMxd4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You can go from a bug (or any effect), to it's cause"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622986722.046000",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "290886ee-9a8f-41cb-bbbb-4b7912f98064",
        "type": "message",
        "text": "This thread seems relevant (thanks <@U5STGTB3J>): <https://twitter.com/vgr/status/1401253631073034241|https://twitter.com/vgr/status/1401253631073034241>",
        "user": "UCUSW7WVD",
        "ts": "1622994343.049300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/vgr|@vgr>: I once attended a talk about \u201ccoding kata.\u201d I don\u2019t think the idea ever took off. It works even worse with hardware. \n\nSomething about engineering seems to defy learning through abstract formal exercises of growing combinatorial complexity. Like music scales or kata. Wonder why.",
                "ts": 1622919874,
                "author_name": "Venkatesh Rao",
                "author_link": "https://twitter.com/vgr/status/1401253631073034241",
                "author_icon": "https://pbs.twimg.com/profile_images/1370911119213162497/6L-PJwti_normal.jpg",
                "author_subname": "@vgr",
                "text": "I once attended a talk about \u201ccoding kata.\u201d I don\u2019t think the idea ever took off. It works even worse with hardware. \n\nSomething about engineering seems to defy learning through abstract formal exercises of growing combinatorial complexity. Like music scales or kata. Wonder why.",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/vgr/status/1401253631073034241",
                "id": 1,
                "original_url": "https://twitter.com/vgr/status/1401253631073034241",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9yOU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This thread seems relevant (thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": "): "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/vgr/status/1401253631073034241",
                                "text": "https://twitter.com/vgr/status/1401253631073034241"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "033f2f6d-6f99-4acd-9261-785b845431e8",
        "type": "message",
        "text": "For me the future of programming is about making it simpler for everyone, especially people without technology backgrounds, to take advantage of computation and the powerful devices we carry around with us all the time.\n\nI consider a tool for thought something that literally helps us think. Not attempting to do the thinking for us, or automate away thinking, but augmenting and enhancing our capabilities to understand, ideate, and explore. We stay in control, and our cognitive abilities are amplified.\n\nAfter all, people who use tools like Roam Research are \u201cjust\u201d modeling certain parts of their individual thinking process and the tool gives them an environment to structure their thoughts in, which is remarkably similar to designing a data model, except that it requires much more flexibility and dynamism than what we computer people think of when we talk about a \u201cdata model\u201d.\n\nFrom that perspective the overlap is huge. I do acknowledge, however, that this is just a narrow definition of both tools for thought and the future of programming, and there are plenty of other areas to explore in both.",
        "user": "U5STGTB3J",
        "ts": "1622995391.049700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ASx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For me the future of programming is about making it simpler for everyone, especially people without technology backgrounds, to take advantage of computation and the powerful devices we carry around with us all the time.\n\nI consider a tool for thought something that literally helps us think. Not attempting to do the thinking for us, or automate away thinking, but augmenting and enhancing our capabilities to understand, ideate, and explore. We stay in control, and our cognitive abilities are amplified.\n\nAfter all, people who use tools like Roam Research are \u201cjust\u201d modeling certain parts of their individual thinking process and the tool gives them an environment to structure their thoughts in, which is remarkably similar to designing a data model, except that it requires much more flexibility and dynamism than what we computer people think of when we talk about a \u201cdata model\u201d.\n\nFrom that perspective the overlap is huge. I do acknowledge, however, that this is just a narrow definition of both tools for thought and the future of programming, and there are plenty of other areas to explore in both."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "9B8A43B6-0133-4A0F-9061-9AC1C710C764",
        "type": "message",
        "text": "I'd suspect both communities (FoC ToT) feel a nigh hopeless mess swirling in their head, and simultaneously a borderline New Age faith in breakthroughs that are available in that very same head \u2013 if they could just locate a catalyst, a seed crystal",
        "user": "USH01JEDQ",
        "ts": "1622997907.051500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/i/F",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd suspect both communities (FoC ToT) feel a nigh hopeless mess swirling in their head, and simultaneously a borderline New Age faith in breakthroughs that are available in that very same head \u2013 if they could just locate a catalyst, a seed crystal"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "2fb0240d-d246-45dc-9d9e-4a105af36f86",
        "type": "message",
        "text": "I don't know the Tools for Thoughts movement very well, but I guess that it can help improve programming activities which are still too often limited to raw text code editing, even if you can write some specification doc, with design and system architecture represented visually, etc. But as programming activity is - hmm - a thought process, it has to be improvable with better tools for thoughts.\n\nSo one can dream of a programming environment that provides tools for the \"thinking\" of the programming artifacts that are being created, and the way the thoughts are recorded/shown to be deeply connected to the actual programming artifacts.\n\nI mean, when we start a new relatively complex project, we often start by discussing and thinking by drawing sketches on a whiteboard. Then we move to our computer writing code to bring the architecture/design to life. But the connection between the \"thoughts artifacts\" and the system is lost. Why not having tools that help us keep the too connected?",
        "user": "UJ6LDMMN0",
        "ts": "1623009483.051900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4+sM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know the Tools for Thoughts movement very well, but I guess that it can help improve programming activities which are still too often limited to raw text code editing, even if you can write some specification doc, with design and system architecture represented visually, etc. But as programming activity is - hmm - a thought process, it has to be improvable with better tools for thoughts.\n\nSo one can dream of a programming environment that provides tools for the \"thinking\" of the programming artifacts that are being created, and the way the thoughts are recorded/shown to be deeply connected to the actual programming artifacts.\n\nI mean, when we start a new relatively complex project, we often start by discussing and thinking by drawing sketches on a whiteboard. Then we move to our computer writing code to bring the architecture/design to life. But the connection between the \"thoughts artifacts\" and the system is lost. Why not having tools that help us keep the too connected?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "dd50d8c9-8043-4bbd-a708-d2b01a42876b",
        "type": "message",
        "text": "There's full-blown _reverse execution_, which is code that can run forwards and backwards. This is hard.\n\nThen there's just _rewind_ (as I call it), which is just capturing and restoring past program states. (This is what the game Braid does, and what I'm planning to do for Hest, and I believe what omniscient debuggers do, and what you can easily do with immutable data structures a la Elm's time-travel debugging.)\n\n\u2022 Both would let you run some code, stop, rewind a bit, make some changes, go forward again, rewind again, make more changes, etc. It would give you a programming experience that's sort of like editing music in a DAW, or editing a video in a <https://en.wikipedia.org/wiki/Non-linear_editing|nonlinear editor>.\n\u2022 <@UA14TGLTC> had a neat idea (hope this is okay to share) about using reverse execution as a way to start with some data in a desired final form, and to build backwards towards the inputs needed to get it in that form, interactively.\n\u2022 A difficult thing about pure reverse execution is that you can't have a function that would return the same result for two different inputs. For example, you can't have a function that does a multiply by zero (because you'd get the same result for any finite input). You need each input to uniquely map to an output. But \u2014 and this is wild \u2014\u00a0if you can achieve this property in hardware, reversible computers can be <https://en.wikipedia.org/wiki/Reversible_computing#Reversibility|vastly more energy efficient> than non-reversible computers, because of thermodynamics: less information is being \"lost\", so there's less heat (entropy) as a result. (Vast simplification \u2014 others here could probably summarize this better than me)",
        "user": "UC2A2ARPT",
        "ts": "1623015832.052100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1623016055.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6d1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's full-blown "
                            },
                            {
                                "type": "text",
                                "text": "reverse execution",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which is code that can run forwards and backwards. This is hard.\n\nThen there's just "
                            },
                            {
                                "type": "text",
                                "text": "rewind ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "(as I call it),"
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "which is just capturing and restoring past program states. (This is what the game Braid does, and what I'm planning to do for Hest, and I believe what omniscient debuggers do, and what you can easily do with immutable data structures a la Elm's time-travel debugging.)\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Both would let you run some code, stop, rewind a bit, make some changes, go forward again, rewind again, make more changes, etc. It would give you a programming experience that's sort of like editing music in a DAW, or editing a video in a "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://en.wikipedia.org/wiki/Non-linear_editing",
                                        "text": "nonlinear editor"
                                    },
                                    {
                                        "type": "text",
                                        "text": "."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "user",
                                        "user_id": "UA14TGLTC"
                                    },
                                    {
                                        "type": "text",
                                        "text": " had a neat idea (hope this is okay to share) about using reverse execution as a way to start with some data in a desired final form, and to build backwards towards the inputs needed to get it in that form, interactively."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "A difficult thing about pure reverse execution is that you can't have a function that would return the same result for two different inputs. For example, you can't have a function that does a multiply by zero (because you'd get the same result for any finite input). You need each input to uniquely map to an output. But \u2014 and this is wild \u2014\u00a0if you can achieve this property in hardware, reversible computers can be "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://en.wikipedia.org/wiki/Reversible_computing#Reversibility",
                                        "text": "vastly more energy efficient"
                                    },
                                    {
                                        "type": "text",
                                        "text": " than non-reversible computers, because of thermodynamics: less information is being \"lost\", so there's less heat (entropy) as a result. (Vast simplification \u2014 others here could probably summarize this better than me)"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1622986722.046000",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "1741f3d0-dc3a-4ef5-bf3b-c25f3ab824b4",
        "type": "message",
        "text": "Is there a Tools for Thought community (slack, discord, etc.)? Seems a little more broadly spread out between different app communities like Roam etc.\n\nThe overlap is as pointed out substantial, but the approach of either side look like they start from different philosophies. Projects that show up in Future of Coding seem to emphasize tangible experimentation with the _process_ of engineering, often from a bottom-up approach (i.e. what are the small composable pieces and the processes that construct them). On the other hand, Zettelkasten systems and other such approaches are more top-down, in the style of trying to understand or create a specification, and in general maneuvering in graph-like space of ideas rather than lower-level processes with causal chains.\n\nMeeting in the middle is the natural next step, but I wonder where the emphasis should be placed. Are we missing an interface between thought and implementation, due to the tremendous difficulty of translation as pointed out by many already? Are the two sides not melded enough, or instead are they not well-separated enough? Is there a missing calculus of thought somewhere floating in this space? Would love to explore these areas with anyone interested, or hear about any other interesting endeavors along these lines.",
        "user": "U01T2PC8LBA",
        "ts": "1623016579.052700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01T2PC8LBA",
            "ts": "1623016599.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8iY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Is there a Tools for Thought community (slack, discord, etc.)? Seems a little more broadly spread out between different app communities like Roam etc.\n\nThe overlap is as pointed out substantial, but the approach of either side look like they start from different philosophies. Projects that show up in Future of Coding seem to emphasize tangible experimentation with the "
                            },
                            {
                                "type": "text",
                                "text": "process",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of engineering, often from a bottom-up approach (i.e. what are the small composable pieces and the processes that construct them). On the other hand, Zettelkasten systems and other such approaches are more top-down, in the style of trying to understand or create a specification, and in general maneuvering in graph-like space of ideas rather than lower-level processes with causal chains.\n\nMeeting in the middle is the natural next step, but I wonder where the emphasis should be placed. Are we missing an interface between thought and implementation, due to the tremendous difficulty of translation as pointed out by many already? Are the two sides not melded enough, or instead are they not well-separated enough? Is there a missing calculus of thought somewhere floating in this space? Would love to explore these areas with anyone interested, or hear about any other interesting endeavors along these lines."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "fefda11e-2301-4c64-8924-9e3b6703d578",
        "type": "message",
        "text": "<@USH01JEDQ> I feel personally attacked. :D\n\nBut seriously, I agree the intersection is very large. To me, they're both fundamentally about representing (and manipulating) ideas in digital form. I've been thinking about them as different aspects of the same problem for a while now.",
        "user": "U016VUZGUUQ",
        "ts": "1623019960.065700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ir5W/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "USH01JEDQ"
                            },
                            {
                                "type": "text",
                                "text": " I feel personally attacked. :D\n\nBut seriously, I agree the intersection is very large. To me, they're both fundamentally about representing (and manipulating) ideas in digital form. I've been thinking about them as different aspects of the same problem for a while now."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622980122.044800",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "be2a89a6-01e5-4fc9-b990-a43802dea997",
        "type": "message",
        "text": "Been summoned. :smiling_imp:  Often a person wants to answer \"how did this happen?\"  Reverse execution is one way to go back, which suffers from having too much detail usually.  So it's good to take the, usually incorrect, \"how can is this even possible\" value and just follow its data-flow but with surrounding context because (1) you're probably looking for a control flow branch not taken and (2) the data-flow tree itself is liable to be extra bushy yet easily pruned.  In contrast, stepping forward has the problem that a lot of initialization/configuration happens, especially in framework code, which is noisy and mostly irrelevant.\n\nAnd for pure reverse execution, the trick is to automatically lift functions so that they pass whatever data is necessary to run in reverse in a hidden channel.  In general `f' x = (f x, x)` works, but sometimes you can use shortcuts.  But then you might as well use checkpoints like most people do.  And the `f'` above isn't so useful since it's referentially transparent and the whole point is that you want to look inside `f`.",
        "user": "UA14TGLTC",
        "ts": "1623028900.065900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "quA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Been summoned. "
                            },
                            {
                                "type": "emoji",
                                "name": "smiling_imp"
                            },
                            {
                                "type": "text",
                                "text": "  Often a person wants to answer \"how did this happen?\"  Reverse execution is one way to go back, which suffers from having too much detail usually.  So it's good to take the, usually incorrect, \"how can is this even possible\" value and just follow its data-flow but with surrounding context because (1) you're probably looking for a control flow branch not taken and (2) the data-flow tree itself is liable to be extra bushy yet easily pruned.  In contrast, stepping forward has the problem that a lot of initialization/configuration happens, especially in framework code, which is noisy and mostly irrelevant.\n\nAnd for pure reverse execution, the trick is to automatically lift functions so that they pass whatever data is necessary to run in reverse in a hidden channel.  In general "
                            },
                            {
                                "type": "text",
                                "text": "f' x = (f x, x)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " works, but sometimes you can use shortcuts.  But then you might as well use checkpoints like most people do.  And the "
                            },
                            {
                                "type": "text",
                                "text": "f'",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " above isn't so useful since it's referentially transparent and the whole point is that you want to look inside "
                            },
                            {
                                "type": "text",
                                "text": "f",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622986722.046000",
        "parent_user_id": "U01R76LELBT"
    }
]