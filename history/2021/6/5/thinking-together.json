[
    {
        "type": "message",
        "text": "This is a great episode, with touches on many topics. One of them was so much in collision with my own ideas for the future of coding that I am tempted to launch a discussion on it. It's the notion of an \"escape hatch\" from a programming environment.\n\nOverall, there's too much of a \"let's build a universe\" attitude in computing, and the idea of a programming environment ideally being complete and mostly closed is a reflection of it. I don't want  an escape hatch for going elsewhere if I absolutely have to. I want bridges to other programming environments, for my own use and for connecting with other people's work.\n\nMy idea of the future of coding is more like living in physical space. I live in a house, which has multiple rooms. In some rooms, I do things alone, in others with family members. The house is part of a neighborhood, where I do things with neighbours. The neighborhood is part of a town, and so on. Each compartment provides just the right environment for some activity, but none locks me in, wishing for an escape hatch.",
        "user": "UJBAJNFLK",
        "ts": "1622882372.038900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "[June 4th, 2021 3:26 AM] ivanreese: <https://futureofcoding.org/episodes/050|Episode 50> (:birthday:) of the Future of Coding podcast is out now.\n\nToday, the guest is <https://maryrosecook.com|Mary Rose Cook>, among whose thousand-and-one side projects you'll find <http://islalanguage.org|Isla> and <http://codelauren.com|Code Lauren>. Both are experimental programming environments with their own bespoke languages, focussed on learnability and visualization. In the case of Code Lauren, we also see another theme of Mary's work \u2014 taking the largely invisible processing done by compilers / interpreters and making it visible and interactive. Mary also made a totally awful game that I hate so much, but to find out what that is you'll just have to listen to the show (or read the largely unedited transcript \u2014 again, sorry Jack).",
                "ts": "1622769994.043600",
                "author_id": "UC2A2ARPT",
                "author_subname": "Ivan Reese",
                "channel_id": "CCL5VVBAN",
                "channel_name": "share-your-work",
                "is_msg_unfurl": true,
                "is_thread_root_unfurl": true,
                "text": "<https://futureofcoding.org/episodes/050|Episode 50> (:birthday:) of the Future of Coding podcast is out now.\n\nToday, the guest is <https://maryrosecook.com|Mary Rose Cook>, among whose thousand-and-one side projects you'll find <http://islalanguage.org|Isla> and <http://codelauren.com|Code Lauren>. Both are experimental programming environments with their own bespoke languages, focussed on learnability and visualization. In the case of Code Lauren, we also see another theme of Mary's work \u2014 taking the largely invisible processing done by compilers / interpreters and making it visible and interactive. Mary also made a totally awful game that I hate so much, but to find out what that is you'll just have to listen to the show (or read the largely unedited transcript \u2014 again, sorry Jack).",
                "author_name": "Ivan Reese",
                "author_link": "https://futureofcoding.slack.com/team/UC2A2ARPT",
                "author_icon": "https://secure.gravatar.com/avatar/6f94d2ed5e188be9865a531021b0afcd.jpg?s=48&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0013-48.png",
                "mrkdwn_in": [
                    "text"
                ],
                "color": "D0D0D0",
                "from_url": "https://futureofcoding.slack.com/archives/CCL5VVBAN/p1622769994043600?thread_ts=1622769994043600&cid=CCL5VVBAN",
                "is_share": true,
                "footer": "Thread in #share-your-work"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EGd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is a great episode, with touches on many topics. One of them was so much in collision with my own ideas for the future of coding that I am tempted to launch a discussion on it. It's the notion of an \"escape hatch\" from a programming environment.\n\nOverall, there's too much of a \"let's build a universe\" attitude in computing, and the idea of a programming environment ideally being complete and mostly closed is a reflection of it. I don't want  an escape hatch for going elsewhere if I absolutely have to. I want bridges to other programming environments, for my own use and for connecting with other people's work.\n\nMy idea of the future of coding is more like living in physical space. I live in a house, which has multiple rooms. In some rooms, I do things alone, in others with family members. The house is part of a neighborhood, where I do things with neighbours. The neighborhood is part of a town, and so on. Each compartment provides just the right environment for some activity, but none locks me in, wishing for an escape hatch."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "reply_count": 8,
        "reply_users_count": 5,
        "latest_reply": "1622968614.044100",
        "reply_users": [
            "UCUSW7WVD",
            "UJBAJNFLK",
            "UDQBTJ211",
            "UML4ZEKDK",
            "UA14TGLTC"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UE1JQM9HQ",
                    "UML4ZEKDK"
                ],
                "count": 2
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7",
                    "UJ6LDMMN0",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "fda6ba1c-e250-4782-98f5-fec69c97d12c",
        "type": "message",
        "text": "Do you want existing software to have this room property? Or do you want some set of independent universes to choose \"standards for interoperability\"? I think we have the second already, and to the extent it fails it's because of the first problem. So let's talk about the first problem.\n\nBuilding a passage/wormhole between two rooms/universes is hard. Even for the programmers who built this one room you're in now. Nobody wants to make it easier, because that's even harder. Nobody wants it enough to put in the work, because everybody grew up living in a single room just like you. So it won't happen until somebody somewhere starts building it into software they didn't write, without asking for permission. We have to make it scalable to hack on unfamiliar codebases in incompatible ways.",
        "user": "UCUSW7WVD",
        "ts": "1622903548.039100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6lf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Do you want existing software to have this room property? Or do you want some set of independent universes to choose \"standards for interoperability\"? I think we have the second already, and to the extent it fails it's because of the first problem. So let's talk about the first problem.\n\nBuilding a passage/wormhole between two rooms/universes is hard. Even for the programmers who built this one room you're in now. Nobody wants to make it easier, because that's even harder. Nobody wants it enough to put in the work, because everybody grew up living in a single room just like you. So it won't happen until somebody somewhere starts building it into software they didn't write, without asking for permission. We have to make it scalable to hack on unfamiliar codebases in incompatible ways."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "129111ed-191f-42ed-9e18-3f95585ad7e4",
        "type": "message",
        "text": "What I am hoping for as a first step is a change of attitude. Stop talking about escape hatches, start talking about bridges.\n\nYes, interoperability is hard, even more so if you want to retrofit it. So let's start with new environments, which is what many us in this space are working on or dreaming of.\n\nIt's actually happening. A nice example: <https://github.com/JuliaInterop>. What I want is more of that. More effort for making systems interoperable.",
        "user": "UJBAJNFLK",
        "ts": "1622904867.039300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "Julia Interop",
                "title_link": "https://github.com/JuliaInterop",
                "text": "Easy interoperability between Julia and not Julia. Julia Interop has 16 repositories available. Follow their code on GitHub.",
                "fallback": "GitHub: Julia Interop",
                "from_url": "https://github.com/JuliaInterop",
                "thumb_url": "https://avatars.githubusercontent.com/u/20260648?s=280&v=4",
                "thumb_width": 159,
                "thumb_height": 159,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/JuliaInterop"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6Y2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What I am hoping for as a first step is a change of attitude. Stop talking about escape hatches, start talking about bridges.\n\nYes, interoperability is hard, even more so if you want to retrofit it. So let's start with new environments, which is what many us in this space are working on or dreaming of.\n\nIt's actually happening. A nice example: "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/JuliaInterop"
                            },
                            {
                                "type": "text",
                                "text": ". What I want is more of that. More effort for making systems interoperable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "cf57db71-c249-4e25-ab23-6b2e9bbbd056",
        "type": "message",
        "text": "That library looks like an example of my second option. That can certainly work! It becomes a problem more of social organization, learning about n black boxes, getting them to interoperate, opening issues. Submitting patches to n black boxes has some scaling issues for most people.\n\n&gt; let's start with new environments\n\nDid you mean new environments interoperating with existing ones? That still has scaling issues if you care about multiple existing ones.\n\nNew environments interoperating with other new ones = hard yes! If anyone cares.",
        "user": "UCUSW7WVD",
        "ts": "1622908556.039700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LtrgH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That library looks like an example of my second option. That can certainly work! It becomes a problem more of social organization, learning about n black boxes, getting them to interoperate, opening issues. Submitting patches to n black boxes has some scaling issues for most people.\n\n> let's start with new environments\n\nDid you mean new environments interoperating with existing ones? That still has scaling issues if you care about multiple existing ones.\n\nNew environments interoperating with other new ones = hard yes! If anyone cares."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "0a01d17b-99f2-400b-ab8b-d83457e305fd",
        "type": "message",
        "text": "I think \"new interoperating with existing ones\" is the most reasonable starting point, because the new players have the highest motivation to connect to the \"old world\". As in the case of Julia. And yes, this has scaling issues. But if it leads to competitive advantages (\"I picked Julia because it has all those nice bridges to other languages\"), it can lead to the change of attitude that is needed.\n\nAll-to-all bridging without scaling issues requires infrastructure support, and then adoption of that infrastructure. The only attempt I am aware of is Oracle's GraalVM/Truffle combo. Which requires re-implementing all languages, but apparently makes this relatively straightforward for JVM languages.",
        "user": "UJBAJNFLK",
        "ts": "1622918641.040600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gLfcB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think \"new interoperating with existing ones\" is the most reasonable starting point, because the new players have the highest motivation to connect to the \"old world\". As in the case of Julia. And yes, this has scaling issues. But if it leads to competitive advantages (\"I picked Julia because it has all those nice bridges to other languages\"), it can lead to the change of attitude that is needed.\n\nAll-to-all bridging without scaling issues requires infrastructure support, and then adoption of that infrastructure. The only attempt I am aware of is Oracle's GraalVM/Truffle combo. Which requires re-implementing all languages, but apparently makes this relatively straightforward for JVM languages."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UML4ZEKDK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b34e6115-2e77-4c6f-8827-6f164cfe42c4",
        "type": "message",
        "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like. He was a language Cake which I haven't looked at but at first glance looks a bit like Cambria",
        "user": "UDQBTJ211",
        "ts": "1622926274.041100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3sy+X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like. He was a language Cake which I haven't looked at but at first glance looks a bit like Cambria"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "0ae4552c-7bdd-4864-b8ba-ca227e003081",
        "type": "message",
        "text": "&gt; I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like.\nWhen I first read Stephen's paper, it was quite an eye-opening moment for me... :smile: It pushed me to start a community to share and discuss ideas like this around user control and interoperability. Perhaps some other resources in the catalog there (<https://malleable.systems/catalog/>) will be of interest as well.",
        "user": "UML4ZEKDK",
        "ts": "1622932397.041700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UML4ZEKDK",
            "ts": "1622932422.000000"
        },
        "attachments": [
            {
                "title": "Catalog | Malleable Systems Collective",
                "title_link": "https://malleable.systems/catalog/",
                "text": "The Malleable Systems Collective catalogs and experiments with malleable software and systems that reset the balance of power in computing",
                "fallback": "Catalog | Malleable Systems Collective",
                "thumb_url": "https://malleable.systems/meta/android-chrome-512x512.png",
                "from_url": "https://malleable.systems/catalog/",
                "thumb_width": 512,
                "thumb_height": 512,
                "service_icon": "https://malleable.systems/meta/apple-touch-icon.png",
                "service_name": "malleable.systems",
                "id": 1,
                "original_url": "https://malleable.systems/catalog/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "U44o/",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I just read Stephen Kell's paper The Mythical Matched Modules, it examines what a practical solution to this interop problem might look like."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I first read Stephen's paper, it was quite an eye-opening moment for me... "
                            },
                            {
                                "type": "emoji",
                                "name": "smile"
                            },
                            {
                                "type": "text",
                                "text": " It pushed me to start a community to share and discuss ideas like this around user control and interoperability. Perhaps some other resources in the catalog there ("
                            },
                            {
                                "type": "link",
                                "url": "https://malleable.systems/catalog/"
                            },
                            {
                                "type": "text",
                                "text": ") will be of interest as well."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK"
    },
    {
        "client_msg_id": "5318bbff-568e-407f-aa71-b8b3d3d77852",
        "type": "message",
        "text": "There's a painful absence of tooling for the \"integration domain\" (as Stephen calls it) in software today. Such tools would connect and unify existing languages, ecosystems, and modules, just like the wires in circuit design: they unify parts from many different sources into something new without requiring coordination or agreement between the parts themselves.\n\nIf it were (on the order of) adding wires from module / language A to B, we'd see an explosion of software reuse. It should not matter what language some useful bit of code is written in, but unfortunately today, language boundaries create high walls.",
        "user": "UML4ZEKDK",
        "ts": "1622933005.042200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qJG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There's a painful absence of tooling for the \"integration domain\" (as Stephen calls it) in software today. Such tools would connect and unify existing languages, ecosystems, and modules, just like the wires in circuit design: they unify parts from many different sources into something new without requiring coordination or agreement between the parts themselves.\n\nIf it were (on the order of) adding wires from module / language A to B, we'd see an explosion of software reuse. It should not matter what language some useful bit of code is written in, but unfortunately today, language boundaries create high walls."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "e2bd0c65-125b-4662-ae3e-9231d874f052",
        "type": "message",
        "text": "To bridge to C, SWIG has served me well.  <http://swig.org/>",
        "user": "UA14TGLTC",
        "ts": "1622968614.044100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LT4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "To bridge to C, SWIG has served me well.  "
                            },
                            {
                                "type": "link",
                                "url": "http://swig.org/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1622882372.038900",
        "parent_user_id": "UJBAJNFLK",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UJ6LDMMN0",
                    "UJBAJNFLK"
                ],
                "count": 2
            }
        ]
    }
]