[
    {
        "client_msg_id": "AA5F579E-4016-4CEB-8EC3-C429A658C35D",
        "type": "message",
        "text": "I keep hearing about how Common Lisp has insanely cool tooling but struggling to find examples. Anyone have any links?",
        "user": "U01R76LELBT",
        "ts": "1624541467.166400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2/JhA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I keep hearing about how Common Lisp has insanely cool tooling but struggling to find examples. Anyone have any links?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "reply_count": 5,
        "reply_users_count": 4,
        "latest_reply": "1624717227.170700",
        "reply_users": [
            "U01362XBSNA",
            "UGWUJUZHT",
            "UUQ2EQW21",
            "UT60XSVCN"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "d8a11850-f29b-46dd-a31e-f1eff7ef133e",
        "type": "message",
        "text": "SLY (<https://github.com/joaotavora/sly>) and SLIME is a good place to start. I played around a bit with SLY last year and it has some pretty cool features such as stickers",
        "user": "U01362XBSNA",
        "ts": "1624543332.167000",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "joaotavora/sly",
                "title_link": "https://github.com/joaotavora/sly",
                "text": "Sylvester the Cat's Common Lisp IDE. Contribute to joaotavora/sly development by creating an account on GitHub.",
                "fallback": "GitHub: joaotavora/sly",
                "image_url": "https://opengraph.githubassets.com/b0ef10f8183ef0d9a3ed2a5a85b9d648b6cc339294146ef61fc90f08e6f7593a/joaotavora/sly",
                "image_width": 500,
                "image_height": 250,
                "from_url": "https://github.com/joaotavora/sly",
                "image_bytes": 126771,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/joaotavora/sly"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PJPn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "SLY ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/joaotavora/sly"
                            },
                            {
                                "type": "text",
                                "text": ") and SLIME is a good place to start. I played around a bit with SLY last year and it has some pretty cool features such as stickers"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "4448aee0-f9bd-4c9b-813f-1660146bfd3f",
        "type": "message",
        "text": "I would suggest looking at 3 lisp IDEs:\n\na) Lispworks (very well integrated set of tools)\nb) emacs + slime (contains *everything*, see, esp. org-mode)\nc) Racket\n\nThen, you need to know what it is that you want to accomplish: [+]\n1) rapid prototyping, or,\n2) compilation.\n\nEarly lisps emphasized 1, CL emphasizes 2 but has more 1 than most languages (see, for example, restarts).\n\n[Asides: Debugging is easier when the debugger language is the same as the language being debugged.  Debugging is facilitated when a language has no syntax and is expression-based. Debugging is facilitated when the debugger and the language being debugged are the same thing.]\n\n<http://www.lispworks.com/products/index.html>\n<https://orgmode.org/>\n<https://racket-lang.org/>\n\n[+] I contend that you don\u2019t want both at once.  [IMO, 1 and 2 are different views on 0 (The Solution/Design)].",
        "user": "UGWUJUZHT",
        "ts": "1624590750.168700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Org Mode",
                "title_link": "https://orgmode.org/",
                "text": "Org-mode. Complex so you don't have to be. A versatile organisational system with immense capabilities.",
                "fallback": "Org Mode",
                "image_url": "https://orgmode.org/resources/img/social-card.png",
                "image_width": 500,
                "image_height": 250,
                "from_url": "https://orgmode.org/",
                "image_bytes": 106184,
                "service_icon": "https://orgmode.org/resources/img/favicons/apple-touch-icon.png",
                "service_name": "orgmode.org",
                "id": 1,
                "original_url": "https://orgmode.org/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZD0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would suggest looking at 3 lisp IDEs:\n\na) Lispworks (very well integrated set of tools)\nb) emacs + slime (contains *everything*, see, esp. org-mode)\nc) Racket\n\nThen, you need to know what it is that you want to accomplish: [+]\n1) rapid prototyping, or,\n2) compilation.\n\nEarly lisps emphasized 1, CL emphasizes 2 but has more 1 than most languages (see, for example, restarts).\n\n[Asides: Debugging is easier when the debugger language is the same as the language being debugged.  Debugging is facilitated when a language has no syntax and is expression-based. Debugging is facilitated when the debugger and the language being debugged are the same thing.]\n\n"
                            },
                            {
                                "type": "link",
                                "url": "http://www.lispworks.com/products/index.html"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://orgmode.org/"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://racket-lang.org/"
                            },
                            {
                                "type": "text",
                                "text": "\n\n[+] I contend that you don\u2019t want both at once.  [IMO, 1 and 2 are different views on 0 (The Solution/Design)]."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "3abfca8e-97cd-45e0-9455-b5827b16fc33",
        "type": "message",
        "text": "<https://github.com/vlime/vlime>",
        "user": "UUQ2EQW21",
        "ts": "1624632804.169400",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "vlime/vlime",
                "title_link": "https://github.com/vlime/vlime",
                "text": "A Common Lisp dev environment for Vim (and Neovim) - vlime/vlime",
                "fallback": "GitHub: vlime/vlime",
                "image_url": "https://opengraph.githubassets.com/fcd35079462783e388de6e530331a977c108151ada25289a69a3a43bba0aafb5/vlime/vlime",
                "image_width": 500,
                "image_height": 250,
                "from_url": "https://github.com/vlime/vlime",
                "image_bytes": 39311,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/vlime/vlime"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M=W",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://github.com/vlime/vlime"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "e1106364-3952-457b-b2d0-68008ff6f77e",
        "type": "message",
        "text": "I haven't tried this one yet; but I've been meaning to....",
        "user": "UUQ2EQW21",
        "ts": "1624632817.169700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bDl",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven't tried this one yet; but I've been meaning to...."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "parent_user_id": "U01R76LELBT"
    },
    {
        "client_msg_id": "a53a4955-8404-482c-82c8-4b95cc62d5af",
        "type": "message",
        "text": "Seconding SLY, I use it every day. It is great. Another interesting piece of software is clouseau: <https://www.youtube.com/watch?v=-1LzFxTbU9E|https://www.youtube.com/watch?v=-1LzFxTbU9E>\n\nI actually don't think the tooling for CL is all that great, as a user of the language. Most of the interesting workflows, etc that you can do aren't so much provided by tooling as augmented by tooling. More or less all the functionality exposed by stuff like SLY (including the debugger) is part of the base language standard. And I think that's the really interesting part about CL if you're trying to learn from it.\n\nIn particular, CL is designed as a whole to support interactive workflows, there's no one design decision you can point to here, but the combination of how it is image-based, the package system, use of late-binding, the ability to have dynamic binding, all work together to make it possible. It would be quite difficult to replicate what CL does without any one of those things. (Though it seems like clojure has managed to to some extent? I haven't used it so I don't know)\n\nTake the example of editing your code while it's running: a common workflow when working with event driven code (a webserver, game, etc) is to have the event loop running, and then recompile event handlers as you change them so that you can mould the program on the fly. For that to be possible you need to be able to patch out the function calls in the old code to point to new code, and the CL runtime supports this, since it's runtime is image-based\u2014all functions work this way, any file related metadata is incidental.\n\nAnother example is post-mortem debugging. I actually learnt this term from a C programmer, and it's considered a pretty esoteric technique. Debugging coredumps after your program crashes. In CL, this workflow doesn't warrant a term because that is just how everyone writes code\u2014you let your program fail, it drops into the debugger, and then you fix the issue and move on. In particular the conditions and restarts system In addition to the ability to recompile stuff on the fly is necessary here, and the former is implemented with dynamically bound (so-called \"special\") variables.\n\nAs a final note, while I said the tooling in CL isn't all that amazing, I meant that in absolute terms. I would say it's about par with other ecosystems that have put work into tooling. The interesting thing is that CL tooling is mostly (entirely?) hobby projects, whereas for example, stuff like asan, dtrace, or rr that let you replicate these workflows in other languages are multimillion dollar projects. So CL lets people be very productive when building tooling around the language, because it provides the tools to build tooling.\n\nIf you're interested in what the debugger workflow looks like, this is a good series walking through it: <https://malisper.me/debugging-lisp-part-1-recompilation/|https://malisper.me/debugging-lisp-part-1-recompilation/>",
        "user": "UT60XSVCN",
        "ts": "1624717227.170700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UT60XSVCN",
            "ts": "1624717465.000000"
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Clouseau - The McCLIM inspector - Online Lisp Meeting #6, 05.08.2020",
                "title_link": "https://www.youtube.com/watch?v=-1LzFxTbU9E",
                "author_name": "Online Lisp Meetings",
                "author_link": "https://www.youtube.com/c/OnlineLispMeetings",
                "thumb_url": "https://i.ytimg.com/vi/-1LzFxTbU9E/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Clouseau - The McCLIM inspector - Online Lisp Meeting #6, 05.08.2020",
                "video_html": "<iframe width=\"400\" height=\"300\" src=\"https://www.youtube.com/embed/-1LzFxTbU9E?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 300,
                "from_url": "https://www.youtube.com/watch?v=-1LzFxTbU9E",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=-1LzFxTbU9E"
            },
            {
                "service_name": "malisper.me",
                "title": "Debugging Lisp Part 1: Recompilation - malisper.me",
                "title_link": "https://malisper.me/debugging-lisp-part-1-recompilation/",
                "text": "This post is the start of a series on how to debug Common Lisp code, specifically with Emacs, Slime, and SBCL. If you do not understand Common Lisp, you should still be able to follow along and recognize just how powerful the facilities provided by the Common Lisp debugger are. Nathan Marz asked me to [\u2026]",
                "fallback": "malisper.me: Debugging Lisp Part 1: Recompilation - malisper.me",
                "image_url": "https://malisper.me/wp-content/uploads/2015/07/ezgif.com-crop.gif",
                "ts": 1436243858,
                "from_url": "https://malisper.me/debugging-lisp-part-1-recompilation/",
                "image_width": 456,
                "image_height": 250,
                "image_bytes": 1070363,
                "service_icon": "https://malisper.me/wp-content/uploads/fbrfg/apple-touch-icon.png",
                "id": 2,
                "original_url": "https://malisper.me/debugging-lisp-part-1-recompilation/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zMw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Seconding SLY, I use it every day. It is great. Another interesting piece of software is clouseau: "
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=-1LzFxTbU9E",
                                "text": "https://www.youtube.com/watch?v=-1LzFxTbU9E"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI actually don't think the tooling for CL is all that great, as a user of the language. Most of the interesting workflows, etc that you can do aren't so much provided by tooling as augmented by tooling. More or less all the functionality exposed by stuff like SLY (including the debugger) is part of the base language standard. And I think that's the really interesting part about CL if you're trying to learn from it.\n\nIn particular, CL is designed as a whole to support interactive workflows, there's no one design decision you can point to here, but the combination of how it is image-based, the package system, use of late-binding, the ability to have dynamic binding, all work together to make it possible. It would be quite difficult to replicate what CL does without any one of those things. (Though it seems like clojure has managed to to some extent? I haven't used it so I don't know)\n\nTake the example of editing your code while it's running: a common workflow when working with event driven code (a webserver, game, etc) is to have the event loop running, and then recompile event handlers as you change them so that you can mould the program on the fly. For that to be possible you need to be able to patch out the function calls in the old code to point to new code, and the CL runtime supports this, since it's runtime is image-based\u2014all functions work this way, any file related metadata is incidental.\n\nAnother example is post-mortem debugging. I actually learnt this term from a C programmer, and it's considered a pretty esoteric technique. Debugging coredumps after your program crashes. In CL, this workflow doesn't warrant a term because that is just how everyone writes code\u2014you let your program fail, it drops into the debugger, and then you fix the issue and move on. In particular the conditions and restarts system In addition to the ability to recompile stuff on the fly is necessary here, and the former is implemented with dynamically bound (so-called \"special\") variables.\n\nAs a final note, while I said the tooling in CL isn't all that amazing, I meant that in absolute terms. I would say it's about par with other ecosystems that have put work into tooling. The interesting thing is that CL tooling is mostly (entirely?) hobby projects, whereas for example, stuff like asan, dtrace, or rr that let you replicate these workflows in other languages are multimillion dollar projects. So CL lets people be very productive when building tooling around the language, because it provides the tools to build tooling.\n\nIf you're interested in what the debugger workflow looks like, this is a good series walking through it: "
                            },
                            {
                                "type": "link",
                                "url": "https://malisper.me/debugging-lisp-part-1-recompilation/",
                                "text": "https://malisper.me/debugging-lisp-part-1-recompilation/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1624541467.166400",
        "parent_user_id": "U01R76LELBT"
    }
]