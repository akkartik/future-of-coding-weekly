[
    {
        "client_msg_id": "463a5248-8b0d-45f4-8be2-f329b36147c1",
        "type": "message",
        "text": "I was going through Marshall Lochbaum's BQN (<https://mlochbaum.github.io/BQN/>) and was \"gazing into the abyss\" thats the self hosted compiler. At this point it occurred to me that programming languages go through inordinate amounts of syntactic differentiation to distinguish between different tokens in a programming language. This leads to escaping mechanisms within strings, and also notions of operator precedence in the case of APL like languages. Most of this is a result of tools -- early versions of editors were not structural.\n\nHas anyone thought of/looked at examples of what programming would be like if one added a secondary layer of say range based annotations on top of strings (basically a *rich text* like notation) that would make it much easier to parse/disambiguate tokens and semantics?  The only thing that springs to mind is Chuch Moore's colorForth.",
        "user": "U01JNTE35QS",
        "ts": "1623634589.119200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JNTE35QS",
            "ts": "1623634621.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "48oE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was going through Marshall Lochbaum's BQN ("
                            },
                            {
                                "type": "link",
                                "url": "https://mlochbaum.github.io/BQN/"
                            },
                            {
                                "type": "text",
                                "text": ") and was \"gazing into the abyss\" thats the self hosted compiler. At this point it occurred to me that programming languages go through inordinate amounts of syntactic differentiation to distinguish between different tokens in a programming language. This leads to escaping mechanisms within strings, and also notions of operator precedence in the case of APL like languages. Most of this is a result of tools -- early versions of editors were not structural.\n\nHas anyone thought of/looked at examples of what programming would be like if one added a secondary layer of say range based annotations on top of strings (basically a "
                            },
                            {
                                "type": "text",
                                "text": "rich text",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " like notation) that would make it much easier to parse/disambiguate tokens and semantics?  The only thing that springs to mind is Chuch Moore's colorForth."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "reply_count": 13,
        "reply_users_count": 5,
        "latest_reply": "1623734145.123400",
        "reply_users": [
            "UPHDH2F0C",
            "UA14TGLTC",
            "UJBAJNFLK",
            "U01JNTE35QS",
            "UMVFWPZ36"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "type": "message",
        "text": "I guess tag UI fields are a solution to a similar problem?",
        "files": [
            {
                "id": "F025LM4MA64",
                "created": 1623635918,
                "timestamp": 1623635918,
                "name": "image.png",
                "title": "image.png",
                "mimetype": "image/png",
                "filetype": "png",
                "pretty_type": "PNG",
                "user": "UPHDH2F0C",
                "editable": false,
                "size": 4722,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F025LM4MA64/image.png",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F025LM4MA64/download/image.png",
                "thumb_64": "https://files.slack.com/files-tmb/T5TCAFTA9-F025LM4MA64-10a7a36c1e/image_64.png",
                "thumb_80": "https://files.slack.com/files-tmb/T5TCAFTA9-F025LM4MA64-10a7a36c1e/image_80.png",
                "thumb_360": "https://files.slack.com/files-tmb/T5TCAFTA9-F025LM4MA64-10a7a36c1e/image_360.png",
                "thumb_360_w": 360,
                "thumb_360_h": 106,
                "thumb_480": "https://files.slack.com/files-tmb/T5TCAFTA9-F025LM4MA64-10a7a36c1e/image_480.png",
                "thumb_480_w": 480,
                "thumb_480_h": 141,
                "thumb_160": "https://files.slack.com/files-tmb/T5TCAFTA9-F025LM4MA64-10a7a36c1e/image_160.png",
                "original_w": 597,
                "original_h": 175,
                "thumb_tiny": "AwAOADDR285yaXbz1NLRQAm33NLRRQAUUUUAf//Z",
                "permalink": "https://futureofcoding.slack.com/files/UPHDH2F0C/F025LM4MA64/image.png",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F025LM4MA64-9d596c8902",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=B70",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess tag UI fields are a solution to a similar problem?"
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "UPHDH2F0C",
        "display_as_bot": false,
        "ts": "1623635988.119400",
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01JNTE35QS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "db47ecb8-9232-4eea-9716-e7470d286d40",
        "type": "message",
        "text": "The trick with rich text is editor integration.  Got to love levels of escaping!  I swear I once had the string `\"\\\\\\\\\\\\\"`.  On the balance the best solution is to have different kinds of escapes for the same sort of thing so as to avoid interference.  You don't need to be Perl/Ruby crazy about it either.  Lua's long string syntax is great `[[No problem with \"quotes\" here.]]` because `[[because [[this]] kind nests without trouble]]` and in case of real nonsense you can use extra special equal sign brackets: `[===[With some opens ([[) some closes (]]) and whatever else ]==] except the following does end it: ]===]`.  Use as many equal signs as makes you comfortable.",
        "user": "UA14TGLTC",
        "ts": "1623646028.119900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vFMxC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The trick with rich text is editor integration.  Got to love levels of escaping!  I swear I once had the string "
                            },
                            {
                                "type": "text",
                                "text": "\"\\\\\\\\\\\\\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  On the balance the best solution is to have different kinds of escapes for the same sort of thing so as to avoid interference.  You don't need to be Perl/Ruby crazy about it either.  Lua's long string syntax is great "
                            },
                            {
                                "type": "text",
                                "text": "[[No problem with \"quotes\" here.]]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " because "
                            },
                            {
                                "type": "text",
                                "text": "[[because [[this]] kind nests without trouble]]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and in case of real nonsense you can use extra special equal sign brackets: "
                            },
                            {
                                "type": "text",
                                "text": "[===[With some opens ([[) some closes (]]) and whatever else ]==] except the following does end it: ]===]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ".  Use as many equal signs as makes you comfortable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "38d3869a-d8da-4355-8acf-d110a744db54",
        "type": "message",
        "text": "&gt; Most of this is a result of tools -- early versions of editors were not structural.\nIt's not just a result of tools. All formal notations of the pre-computing age (think mathematics) were designed, by necessity, to be parsed visually by human readers, without the help of any tools. Operator precedence, for example, clearly goes back to that era.",
        "user": "UJBAJNFLK",
        "ts": "1623662772.120100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJBAJNFLK",
            "ts": "1623662890.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O1Iuq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most of this is a result of tools -- early versions of editors were not structural."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt's not just a result of tools. All formal notations of the pre-computing age (think mathematics) were designed, by necessity, to be parsed visually by human readers, without the help of any tools. Operator precedence, for example, clearly goes back to that era."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "fd162e92-58fc-4420-8a33-91507a74d446",
        "type": "message",
        "text": "Agreed Konrad. My statement also included pencil and paper as tools.",
        "user": "U01JNTE35QS",
        "ts": "1623686509.120500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "XWYD9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Agreed Konrad. My statement also included pencil and paper as tools."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "66799f99-885d-4c28-a674-3f12ce99e6d3",
        "type": "message",
        "text": "I would say I work in this neighborhood. I believe there is a fork in PLs  between 1D and 2D (and more) notations.",
        "user": "UMVFWPZ36",
        "ts": "1623719761.121400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AlrRj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I would say I work in this neighborhood. I believe there is a fork in PLs  between 1D and 2D (and more) notations."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6244a1f8-e2dd-4f34-ba8e-64d72e39fbeb",
        "type": "message",
        "text": "All TIOBE langs are 1D. Parsed in linear order one token at a time.",
        "user": "UMVFWPZ36",
        "ts": "1623719783.121600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0f8j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "All TIOBE langs are 1D. Parsed in linear order one token at a time."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "1317efbe-5adf-4d1c-9adf-9f370032a337",
        "type": "message",
        "text": "If you break those assumptions (ie multiple read heads, moving along both X and Y axis), you can do different things",
        "user": "UMVFWPZ36",
        "ts": "1623719835.121800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fa98",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you break those assumptions (ie multiple read heads, moving along both X and Y axis), you can do different things"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "c1a86809-3188-4b29-b5f1-ea8f99644621",
        "type": "message",
        "text": "For example, you can have languages where what looks like secondary notation (text underline, font color, font size) actually are meaningful and change the semantics of the code",
        "user": "UMVFWPZ36",
        "ts": "1623719913.122000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MBPd=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For example, you can have languages where what looks like secondary notation (text underline, font color, font size) actually are meaningful and change the semantics of the code"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "716e2d71-2824-4fe6-acf4-8d8ca96eec2e",
        "type": "message",
        "text": "Yup -- this is extremely interesting. Also has parallels to ligatures being used for example for charting",
        "user": "U01JNTE35QS",
        "ts": "1623720771.122200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rLU4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yup -- this is extremely interesting. Also has parallels to ligatures being used for example for charting"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "2c793895-f71c-4497-b37b-d55be6d16c38",
        "type": "message",
        "text": "<https://www.fontshop.com/families/ff-chartwell>",
        "user": "U01JNTE35QS",
        "ts": "1623720820.122400",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "FontShop",
                "title": "FF Chartwell Font",
                "title_link": "https://www.fontshop.com/families/ff-chartwell",
                "text": "FF Chartwell is a typeface designed by Travis Kochel, and is available for Desktop, App, and ePub. Try, buy and download these fonts now!",
                "fallback": "FontShop: FF Chartwell Font",
                "image_url": "https://www.fontshop.com/meta_images/family/2952632.jpg",
                "from_url": "https://www.fontshop.com/families/ff-chartwell",
                "image_width": 476,
                "image_height": 250,
                "image_bytes": 28541,
                "service_icon": "https://www.fontshop.com/favicon.ico",
                "id": 1,
                "original_url": "https://www.fontshop.com/families/ff-chartwell"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SRo3R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://www.fontshop.com/families/ff-chartwell"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "854f62f3-6b18-4a58-a8e2-cf9d9c58492c",
        "type": "message",
        "text": "I'm thinking of doing a stack based version of APL along these lines (or maybe k)",
        "user": "U01JNTE35QS",
        "ts": "1623720867.122700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hZD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm thinking of doing a stack based version of APL along these lines (or maybe k)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "11734ce2-9a4f-4a29-8149-3ac05eaceb36",
        "type": "message",
        "text": "<@UMVFWPZ36>\n&gt; I believe there is a fork in PLs\u00a0between 1D and 2D (and more) notations.\nMost PLs' user interface (what a programmer has access to) is the 1D text representation. Lisps also give access to the AST level. Forth and friends give access to an ASL level (L = list rather than T = tree). Spreadsheets are 2D only. There is a lot of space for experimentation, which I why I like your tree notation experiments, though I am pretty sure I haven't grasped its potential yet.",
        "user": "UJBAJNFLK",
        "ts": "1623734021.123100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7mK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UMVFWPZ36"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I believe there is a fork in PLs\u00a0between 1D and 2D (and more) notations."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Most PLs' user interface (what a programmer has access to) is the 1D text representation. Lisps also give access to the AST level. Forth and friends give access to an ASL level (L = list rather than T = tree). Spreadsheets are 2D only. There is a lot of space for experimentation, which I why I like your tree notation experiments, though I am pretty sure I haven't grasped its potential yet."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "3d35ae36-bf9b-4bc5-8c34-50b7714d678f",
        "type": "message",
        "text": "&gt;  (text underline, font color, font size)\nThe two traps to avoid there are (1) accessibility issues (Daltonians etc.) and (2) changing user expectations. Syntax highlighting in text editors has created the expectation that text attributes have no semantics.",
        "user": "UJBAJNFLK",
        "ts": "1623734145.123400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Ibq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": " (text underline, font color, font size)"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The two traps to avoid there are (1) accessibility issues (Daltonians etc.) and (2) changing user expectations. Syntax highlighting in text editors has created the expectation that text attributes have no semantics."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1623634589.119200",
        "parent_user_id": "U01JNTE35QS"
    }
]