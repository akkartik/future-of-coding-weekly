[
    {
        "client_msg_id": "529EDF8D-008A-4952-A1F4-8155C379E6DA",
        "type": "message",
        "text": "can\u2019t wait for those videos!",
        "user": "UHWC9PXBL",
        "ts": "1609982350.425300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4AzGr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "can\u2019t wait for those videos!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609955935.423800",
        "parent_user_id": "UD6EXQVM0"
    },
    {
        "type": "message",
        "text": "(deep breath) herewith my very-informal-first-draft intro / manifesto for zero, the programming language I'm working on. If any of this resonates either positively or negatively, I would love to know more ! In particular, I welcome challenges to any ideas expressed here, to see if they can stand up (or if I can make them stand up). If there's interest, I'll post a demo video of where I am with the implementation.",
        "files": [
            {
                "id": "F01J5SV96PL",
                "created": 1609998967,
                "timestamp": 1609998967,
                "name": "n\u00f8\u00f8b-zero.pdf",
                "title": "n\u00f8\u00f8b-zero.pdf",
                "mimetype": "application/pdf",
                "filetype": "pdf",
                "pretty_type": "PDF",
                "user": "U01JTCA3KS4",
                "editable": false,
                "size": 125999,
                "mode": "hosted",
                "is_external": false,
                "external_type": "",
                "is_public": true,
                "public_url_shared": false,
                "display_as_bot": false,
                "username": "",
                "url_private": "https://files.slack.com/files-pri/T5TCAFTA9-F01J5SV96PL/n____b-zero.pdf",
                "url_private_download": "https://files.slack.com/files-pri/T5TCAFTA9-F01J5SV96PL/download/n____b-zero.pdf",
                "thumb_pdf": "https://files.slack.com/files-tmb/T5TCAFTA9-F01J5SV96PL-18c2efe820/n____b-zero_thumb_pdf.png",
                "thumb_pdf_w": 909,
                "thumb_pdf_h": 1286,
                "permalink": "https://futureofcoding.slack.com/files/U01JTCA3KS4/F01J5SV96PL/n____b-zero.pdf",
                "permalink_public": "https://slack-files.com/T5TCAFTA9-F01J5SV96PL-467105f6fa",
                "is_starred": false,
                "has_rich_preview": false
            }
        ],
        "upload": false,
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=KEVR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(deep breath) herewith my very-informal-first-draft intro / manifesto for zero, the programming language I'm working on. If any of this resonates either positively or negatively, I would love to know more ! In particular, I welcome challenges to any ideas expressed here, to see if they can stand up (or if I can make them stand up). If there's interest, I'll post a demo video of where I am with the implementation."
                            }
                        ]
                    }
                ]
            }
        ],
        "user": "U01JTCA3KS4",
        "display_as_bot": false,
        "ts": "1609998978.426800",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1609999540.000000"
        },
        "thread_ts": "1609998978.426800",
        "reply_count": 32,
        "reply_users_count": 4,
        "latest_reply": "1610100556.435600",
        "reply_users": [
            "UCUSW7WVD",
            "UA14TGLTC",
            "U01JTCA3KS4",
            "UD6EXQVM0"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "UML4ZEKDK",
                    "U012RSHGTFY"
                ],
                "count": 3
            },
            {
                "name": "eyes",
                "users": [
                    "UN06QADNV"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c746c696-292f-4aa1-8819-ebfb777a9e85",
        "type": "message",
        "text": "Definitely interesting. I like thinking about the idea maze in the neighborhood of what you call features. Stuff like AOP[1], FOP[2], Literate programming. You choose to make features run-time entities and therefore immutable, and as a result the namespace of features will get polluted over time. The way I program I mostly care about decomposing programs for comprehension rather than deployment, and so I allow features to be modified: <http://akkartik.name/post/wart-layers>. Is this deploy-time flexibility intended to support your live-coding use case?\n\n[1] <https://en.wikipedia.org/wiki/Aspect-oriented_programming>\n[2] <https://en.wikipedia.org/wiki/Feature-oriented_programming>",
        "user": "UCUSW7WVD",
        "ts": "1610004581.427400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1610005631.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "B5O",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Definitely interesting. I like thinking about the idea maze in the neighborhood of what you call features. Stuff like AOP[1], FOP[2], Literate programming. You choose to make features run-time entities and therefore immutable, and as a result the namespace of features will get polluted over time. The way I program I mostly care about decomposing programs for comprehension rather than deployment, and so I allow features to be modified: "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/wart-layers"
                            },
                            {
                                "type": "text",
                                "text": ". Is this deploy-time flexibility intended to support your live-coding use case?\n\n[1] "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Aspect-oriented_programming"
                            },
                            {
                                "type": "text",
                                "text": "\n[2] "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Feature-oriented_programming"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "4986535e-a908-4f6a-8422-ea8662783d96",
        "type": "message",
        "text": "Some smaller comments on other features (pun intended).\n\n* Returning immediately when the named result is assigned to is an interesting idea I've never considered before. Do you plan to support multiple named results? I'd played with this idea in my project[1] which is a _lot_ more imperative/low-level/parsimonious. But I eventually reverted to a more conventional `return` keyword just so I could easily detect code paths that failed to return all results. I'm curious if you consider multiple results to be too difficult in a pure functional context.\n\n* I like the free syntax for declaring functions. It'll be interesting to see how you go about parsing function calls. Inform 7[2] may have some insights, if you aren't already aware of it.\n\n* The combination of array polymorphism with your other features is most interesting. Particularly live coding support. I'm not an expert on APL and its descendants, all the way down to Gilad Bracha's _ShapeRank_[3].\n\n[1] <https://github.com/akkartik/mu>\n[2] <https://en.wikipedia.org/wiki/Inform>\n[3] <https://2020.splashcon.org/details/splash-2020-rebase/26/A-Ray-of-Hope-Array-Programming-for-the-21st-Century>",
        "user": "UCUSW7WVD",
        "ts": "1610005521.427600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1610005583.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CSyf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Some smaller comments on other features (pun intended).\n\n* Returning immediately when the named result is assigned to is an interesting idea I've never considered before. Do you plan to support multiple named results? I'd played with this idea in my project[1] which is a "
                            },
                            {
                                "type": "text",
                                "text": "lot",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " more imperative/low-level/parsimonious. But I eventually reverted to a more conventional "
                            },
                            {
                                "type": "text",
                                "text": "return",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " keyword just so I could easily detect code paths that failed to return all results. I'm curious if you consider multiple results to be too difficult in a pure functional context.\n\n* I like the free syntax for declaring functions. It'll be interesting to see how you go about parsing function calls. Inform 7[2] may have some insights, if you aren't already aware of it.\n\n* The combination of array polymorphism with your other features is most interesting. Particularly live coding support. I'm not an expert on APL and its descendants, all the way down to Gilad Bracha's "
                            },
                            {
                                "type": "text",
                                "text": "ShapeRank",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "[3].\n\n[1] "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/akkartik/mu"
                            },
                            {
                                "type": "text",
                                "text": "\n[2] "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Inform"
                            },
                            {
                                "type": "text",
                                "text": "\n[3] "
                            },
                            {
                                "type": "link",
                                "url": "https://2020.splashcon.org/details/splash-2020-rebase/26/A-Ray-of-Hope-Array-Programming-for-the-21st-Century"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "0fa8a4d8-a7f1-4a9d-8b48-68de2462559a",
        "type": "message",
        "text": "Hot takes...\nFeature Modularity \u2014 With isolation, sounds great.\nFirst-class Representation of Time-Domain Behaviour \u2014 Got me reading.\nOmniscient Debugging \u2014 Love it.\n\n(Note that the goal of generating a trace from every running program runs counter to the goals of performance and responsiveness. We did not say any of this would be easy, merely that we believe it to be possible.) \u2014 Debugging and running are usually different activities; moreover, the surface being debugged is usually a lot smaller than all that's running.  And with somewhat pure semantics, you can generate traces lazily.  It's all hard, but not impossible.",
        "user": "UA14TGLTC",
        "ts": "1610005592.428200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wzbm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hot takes...\nFeature Modularity \u2014 With isolation, sounds great.\nFirst-class Representation of Time-Domain Behaviour \u2014 Got me reading.\nOmniscient Debugging \u2014 Love it.\n\n(Note that the goal of generating a trace from every running program runs counter to the goals of performance and responsiveness. We did not say any of this would be easy, merely that we believe it to be possible.) \u2014 Debugging and running are usually different activities; moreover, the surface being debugged is usually a lot smaller than all that's running.  And with somewhat pure semantics, you can generate traces lazily.  It's all hard, but not impossible."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "217bbe04-fb9d-4248-a879-63a93d09f8c4",
        "type": "message",
        "text": "<@UCUSW7WVD> <@UA14TGLTC> thanks for reading ! and thanks for the links, there goes my coding for the day :slightly_smiling_face:",
        "user": "U01JTCA3KS4",
        "ts": "1610008862.428600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610010087.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GaX/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " thanks for reading ! and thanks for the links, there goes my coding for the day "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "624a2577-3c2b-404e-ac9d-aff8ff43ad31",
        "type": "message",
        "text": "<@UCUSW7WVD> 1) yes, multiple result values should be easy enough to do, just put them in brackets; I'm also considering 'partial assignment', eg. if I have a structure, I can just set one or more of its members, leaving the rest unchanged; this would mean something like \"return x unchanged, except for property p, which should be set to y\"",
        "user": "U01JTCA3KS4",
        "ts": "1610009029.428800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tYCJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " 1) yes, multiple result values should be easy enough to do, just put them in brackets; I'm also considering 'partial assignment', eg. if I have a structure, I can just set one or more of its members, leaving the rest unchanged; this would mean something like \"return x unchanged, except for property p, which should be set to y\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "9f088d46-29f2-4d33-bcda-79b46f990047",
        "type": "message",
        "text": "2) the parser for free-syntax is definitely a bit gnarly; I just went ahead and wrote it brute-force. It's super dumb and slow, but since it only has to run on a very small amount of code (the feature you're writing) it doesn't matter. Or at least that's what I'm hoping :wink:",
        "user": "U01JTCA3KS4",
        "ts": "1610009113.429000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "e+cp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "2) the parser for free-syntax is definitely a bit gnarly; I just went ahead and wrote it brute-force. It's super dumb and slow, but since it only has to run on a very small amount of code (the feature you're writing) it doesn't matter. Or at least that's what I'm hoping "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "5d8802fd-fc89-4fd4-8a7e-a3cc35bd707b",
        "type": "message",
        "text": "3) the array stuff is informed by APL/R/S, as well as some experience with machine-learning (numpy, pytorch). So far I've only really considered 1-D arrays, but it should be generalisable. I'm considering restricting it to only 1- 2- and 3-D tensors, forcing everything else to be packaged in structs so semantic information doesn't get lost. Fundamentally, any hierarachy of structures containing only numbers should be convertable to and from an N-D tensor. Really need to pick a problem to throw at it and see what comes out.",
        "user": "U01JTCA3KS4",
        "ts": "1610009197.429200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610009292.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "htsH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "3) the array stuff is informed by APL/R/S, as well as some experience with machine-learning (numpy, pytorch). So far I've only really considered 1-D arrays, but it should be generalisable. I'm considering restricting it to only 1- 2- and 3-D tensors, forcing everything else to be packaged in structs so semantic information doesn't get lost. Fundamentally, any hierarachy of structures containing only numbers should be convertable to and from an N-D tensor. Really need to pick a problem to throw at it and see what comes out."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "c1543581-6f25-433c-9bfb-4adf9506e2e6",
        "type": "message",
        "text": "4) features - I'd read some stuff on AOP and FOP, but most of what I've read was about adding AOP/FOP on top of an OOP layer, which I consider not really solving the basic problem of exploding complexity. zero's approach is to just chuck out OOP as a bad idea (sorry Bjarne !), and come at the problem afresh - it's like \"C with features\" instead of \"C with objects and features\".",
        "user": "U01JTCA3KS4",
        "ts": "1610009487.429600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610010477.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2SpI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "4) features - I'd read some stuff on AOP and FOP, but most of what I've read was about adding AOP/FOP on top of an OOP layer, which I consider not really solving the basic problem of exploding complexity. zero's approach is to just chuck out OOP as a bad idea (sorry Bjarne !), and come at the problem afresh - it's like \"C with features\" instead of \"C with objects and features\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "72deba0d-bdb9-4c16-85c2-625a62520b1d",
        "type": "message",
        "text": "The reason to make features immutable is the huge benefit you get in reasoning about changes to things, particularly the data model (you express changes to data structures, which gives you automatic backwards and cross-compability), and compilation (you already have ASTs and code for 99% of the application, so why rebuild it all to change one line of code ?). However there are parts of features (such as names, or function-structure) that can be changed without changing their semantics - there was a cool language project I saw which stored everything as structural hashes, rather than text names - so for example, one could modify an existing feature to add an intervention point to override, without breaking it.",
        "user": "U01JTCA3KS4",
        "ts": "1610009626.429800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610010563.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M26n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason to make features immutable is the huge benefit you get in reasoning about changes to things, particularly the data model (you express changes to data structures, which gives you automatic backwards and cross-compability), and compilation (you already have ASTs and code for 99% of the application, so why rebuild it all to change one line of code ?). However there are parts of features (such as names, or function-structure) that can be changed without changing their semantics - there was a cool language project I saw which stored everything as structural hashes, rather than text names - so for example, one could modify an existing feature to add an intervention point to override, without breaking it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "24330608-d0a9-4da4-98a8-c672527f0029",
        "type": "message",
        "text": "Being able to switch features on and off in a very fluid way at runtime is core to the appeal of the concept - when the program does something that displeases the user, they should be able to say \"why did you do X ?\" and receive answer saying \"feature F made me do it\" and respond with \"well, turn feature F off then, and try again\", or \"let's modify feature F with an exception for this case, and try again\".",
        "user": "U01JTCA3KS4",
        "ts": "1610009819.430000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "O2pR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Being able to switch features on and off in a very fluid way at runtime is core to the appeal of the concept - when the program does something that displeases the user, they should be able to say \"why did you do X ?\" and receive answer saying \"feature F made me do it\" and respond with \"well, turn feature F off then, and try again\", or \"let's modify feature F with an exception for this case, and try again\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "79d00cd8-ca59-4bb5-b836-6409337a314c",
        "type": "message",
        "text": "the features I need when climbing a rock face with my AR headset are different from those when ordering a delivery pizza or riding a motorbike, is another way of thinking about it",
        "user": "U01JTCA3KS4",
        "ts": "1610009879.430200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610009899.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YxEG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "the features I need when climbing a rock face with my AR headset are different from those when ordering a delivery pizza or riding a motorbike, is another way of thinking about it"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "bd025b50-7a42-498b-9c04-218c764b7aad",
        "type": "message",
        "text": "<@UA14TGLTC> what do you mean by 'isolation' ?",
        "user": "U01JTCA3KS4",
        "ts": "1610010139.430700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "idR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " what do you mean by 'isolation' ?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "e5ea1461-938f-43c7-b993-3d15d08b9be7",
        "type": "message",
        "text": "Also, yeah, this all aims at the idea that every program in the wild is potentially modifiable by the user, which means some kind of reconstructable trace is required even for release versions. So whenever a user is displeased with the running of their program, they can replicate the run precisely later on, and either they or another coder can pinpoint the issue and the fix (which becomes a new feature). The idea of \"a program that does not allow this\" is rejected by the design goals.",
        "user": "U01JTCA3KS4",
        "ts": "1610010368.430900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IZm8/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, yeah, this all aims at the idea that every program in the wild is potentially modifiable by the user, which means some kind of reconstructable trace is required even for release versions. So whenever a user is displeased with the running of their program, they can replicate the run precisely later on, and either they or another coder can pinpoint the issue and the fix (which becomes a new feature). The idea of \"a program that does not allow this\" is rejected by the design goals."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "4531c2b8-0d41-40b9-8cdb-0de0a4409145",
        "type": "message",
        "text": "By \"isolation,\" I mean \"specify precisely what context the feature applies in.\"  So I want the feature active here, but not there.  Contrast open classes where adding a feature to them makes the feature visible everywhere or say Ruby refinements <https://docs.ruby-lang.org/en/2.4.0/syntax/refinements_rdoc.html> whose semantics is sufficiently weird that I don't think anyone ever uses them.  (False!  In my 433 gems that I happen to have handy, 126 matches across 103 files.)",
        "user": "UA14TGLTC",
        "ts": "1610013739.431400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "VNQI8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "By \"isolation,\" I mean \"specify precisely what context the feature applies in.\"  So I want the feature active here, but not there.  Contrast open classes where adding a feature to them makes the feature visible everywhere or say Ruby refinements "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.ruby-lang.org/en/2.4.0/syntax/refinements_rdoc.html"
                            },
                            {
                                "type": "text",
                                "text": " whose semantics is sufficiently weird that I don't think anyone ever uses them.  (False!  In my 433 gems that I happen to have handy, 126 matches across 103 files.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "ccae7eb0-4da2-4fe5-8046-4c797c787c45",
        "type": "message",
        "text": "Gotcha. Yes, I have a plan (though not specified / implemented yet) to be able to specify precisely where a modifier (on/after/before/replace) applies, using an 'in' construct; i.e. something like\nin var1 &lt;&lt; task1(param1, ...)\n    in var2 &lt;&lt; task2(param2, ...)\n       after var3 &lt;&lt; task3(param3, ...)\n           &lt;modification&gt;",
        "user": "U01JTCA3KS4",
        "ts": "1610019605.431600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01JTCA3KS4",
            "ts": "1610019624.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ru/Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Gotcha. Yes, I have a plan (though not specified / implemented yet) to be able to specify precisely where a modifier (on/after/before/replace) applies, using an 'in' construct; i.e. something like\nin var1 << task1(param1, ...)\n    in var2 << task2(param2, ...)\n       after var3 << task3(param3, ...)\n           <modification>"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    },
    {
        "client_msg_id": "7c5275a2-a94a-483b-ad28-ab1427faa5d3",
        "type": "message",
        "text": "The right formulation should also allow subsequent features to modify that decision (make it more / less general depending on other conditions) so the above isn't the final form, but that's sort of the idea.",
        "user": "U01JTCA3KS4",
        "ts": "1610019778.431900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cIY",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The right formulation should also allow subsequent features to modify that decision (make it more / less general depending on other conditions) so the above isn't the final form, but that's sort of the idea."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1609998978.426800",
        "parent_user_id": "U01JTCA3KS4"
    }
]