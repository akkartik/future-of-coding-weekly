[
    {
        "client_msg_id": "cc545dcc-3ce1-461e-8e7d-0ac3893e9ff1",
        "type": "message",
        "text": "&gt; I posit that a truly comprehensible programming environment - one forever and by design devoid of dark corners and mysterious, voodoo-encouraging subtle malfunctions - must obey this rule:\u00a0the programmer is expected to inhabit the bedrock abstraction level. And thus, the latter must be <http://akkartik.name/post/habitability|habitable>.\n<http://www.loper-os.org/?p=55> (inline link mine)",
        "user": "UCUSW7WVD",
        "ts": "1620867412.166800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1620867426.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LkY9",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I posit that a truly comprehensible programming environment - one forever and by design devoid of dark corners and mysterious, voodoo-encouraging subtle malfunctions - must obey this rule:\u00a0the programmer is expected to inhabit the bedrock abstraction level. And thus, the latter must be "
                            },
                            {
                                "type": "link",
                                "url": "http://akkartik.name/post/habitability",
                                "text": "habitable"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "http://www.loper-os.org/?p=55"
                            },
                            {
                                "type": "text",
                                "text": " (inline link mine)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "reply_count": 7,
        "reply_users_count": 6,
        "latest_reply": "1621193370.174400",
        "reply_users": [
            "U016VUZGUUQ",
            "U015902ESJC",
            "U013ZLJARC7",
            "UJN1TAYEQ",
            "UCUSW7WVD",
            "UJBAJNFLK"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UHWC9PXBL",
                    "U015902ESJC",
                    "UJBAJNFLK",
                    "UMHG81CBH"
                ],
                "count": 4
            },
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e0f3c9c0-c04e-4e5b-b662-087d8fc9ad64",
        "type": "message",
        "text": "I predict that if you actually try to build a machine with an instruction set isomorphic to a high level language, it will never reach the reliability we demand from hardware. Most likely, it will be implemented in something like microcode and we'll immediately land right back where we started. I'd rather see a focus on formal verification, probably of higher-level virtual machines built on simple and therefore easy-to-model hardware.\n\nI think the reference to \"atomic operations\" is quite deep. A layer of abstraction that provides truly atomic operations is indistinguishable from a bedrock layer to anything built on it. A lot of my thinking on how to layer things is built on this idea...",
        "user": "U016VUZGUUQ",
        "ts": "1620881564.167200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Sgi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I predict that if you actually try to build a machine with an instruction set isomorphic to a high level language, it will never reach the reliability we demand from hardware. Most likely, it will be implemented in something like microcode and we'll immediately land right back where we started. I'd rather see a focus on formal verification, probably of higher-level virtual machines built on simple and therefore easy-to-model hardware.\n\nI think the reference to \"atomic operations\" is quite deep. A layer of abstraction that provides truly atomic operations is indistinguishable from a bedrock layer to anything built on it. A lot of my thinking on how to layer things is built on this idea..."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "065bdcc7-8f00-427a-88cc-1dce1db72d73",
        "type": "message",
        "text": "I'm curious what reliability you are referring to. An instruction set isomorphic language can be made reliable in the sense of 1) consistent execution 2) predictable execution every bit as much as we count on the hardware in those two ways. It probably won't look exactly like what we think of as a high level language today. In fact, it may be quite different. You can only allow certain \"clearly understandable\" abstractions and maintain the isomorphism. I think this is what <@UCUSW7WVD> is attempting to explore with Mu and why there is so much focus on the hardware, the general 1:1 relationship between language statements and translation into hardware instructions and other design constraints.\n\nMy question is can such a isomorphic language be made in such a way that it would be high level enough and useful enough to be commonly used within a well understood domain?",
        "user": "U015902ESJC",
        "ts": "1620882594.167400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cLasi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm curious what reliability you are referring to. An instruction set isomorphic language can be made reliable in the sense of 1) consistent execution 2) predictable execution every bit as much as we count on the hardware in those two ways. It probably won't look exactly like what we think of as a high level language today. In fact, it may be quite different. You can only allow certain \"clearly understandable\" abstractions and maintain the isomorphism. I think this is what "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " is attempting to explore with Mu and why there is so much focus on the hardware, the general 1:1 relationship between language statements and translation into hardware instructions and other design constraints.\n\nMy question is can such a isomorphic language be made in such a way that it would be high level enough and useful enough to be commonly used within a well understood domain?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "e994d4d3-09fe-498b-826e-2912d637f459",
        "type": "message",
        "text": "<https://tumbleweed.nu/r/lm-3/uv/cadr.html>",
        "user": "U013ZLJARC7",
        "ts": "1620898559.167800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NX3/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://tumbleweed.nu/r/lm-3/uv/cadr.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            },
            {
                "name": "exploding_head",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a10cd007-e9c2-451c-9359-dd6fe34d26e4",
        "type": "message",
        "text": "&gt; A\u00a0*bedrock abstraction* level is found in every man-made system.\u00a0\u00a0No\u00a0recoverable\u00a0failure, no matter how catastrophic, will ever demand intelligent intervention below it.\nMy experience with programming early 8-bit microprocessors is that, when programming in assembly language, you did indeed have access to a bedrock abstraction level, as defined above.\n\nThere is no accessible bedrock abstraction level in modern computers. Machine code programming on a modern Intel based motherboard happens at an abstraction level far above the bedrock, and below you are many dark corners and mysterious voodoo-encouraging subtle malfunctions. The UEFI is stealing cycles from the OS to do who knows what, the firmware for the microcode and the mysterious intel management engine are encrypted, and security flaws like Spectre and Meltdown require intelligent intervention at a level that is inaccessible to the owner of the computer. I think the author agrees with this.\n\nI don't agree that the invention of compilers in the 1950's was a mistake. Twenty years later, in the 1970's, CPU instruction set architectures were still being designed with the needs of assembly language programmers in mind. A key design goal was \"orthogonality\" &lt;<https://en.wikipedia.org/wiki/Orthogonal_instruction_set>&gt;. The existence of compilers didn't prevent architectures like the PDP-11 from being designed. I think the author agrees, since they mention RISC as the beginning of \"braindead architectures\".\n\nBut RISC wasn't primarily about compilers, it was primarily about making CPUs faster and more efficient, and prioritizing that goal above the goal of making the ISA comfortable for assembly programmers.\n\nSo here's my question. Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?",
        "user": "UJN1TAYEQ",
        "ts": "1620913179.168600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "c1GF",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "bedrock abstraction",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " level is found in every man-made system.\u00a0\u00a0No\u00a0recoverable\u00a0failure, no matter how catastrophic, will ever demand intelligent intervention below it."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My experience with programming early 8-bit microprocessors is that, when programming in assembly language, you did indeed have access to a bedrock abstraction level, as defined above.\n\nThere is no accessible bedrock abstraction level in modern computers. Machine code programming on a modern Intel based motherboard happens at an abstraction level far above the bedrock, and below you are many dark corners and mysterious voodoo-encouraging subtle malfunctions. The UEFI is stealing cycles from the OS to do who knows what, the firmware for the microcode and the mysterious intel management engine are encrypted, and security flaws like Spectre and Meltdown require intelligent intervention at a level that is inaccessible to the owner of the computer. I think the author agrees with this.\n\nI don't agree that the invention of compilers in the 1950's was a mistake. Twenty years later, in the 1970's, CPU instruction set architectures were still being designed with the needs of assembly language programmers in mind. A key design goal was \"orthogonality\" <"
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Orthogonal_instruction_set"
                            },
                            {
                                "type": "text",
                                "text": ">. The existence of compilers didn't prevent architectures like the PDP-11 from being designed. I think the author agrees, since they mention RISC as the beginning of \"braindead architectures\".\n\nBut RISC wasn't primarily about compilers, it was primarily about making CPUs faster and more efficient, and prioritizing that goal above the goal of making the ISA comfortable for assembly programmers.\n\nSo here's my question. Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9739eb54-4790-4328-9033-350933e5f4c5",
        "type": "message",
        "text": "<@UJN1TAYEQ>:\n&gt; Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?\nProbably. For me the inescapable implication is: think about habitability (and safety), and don't focus on performance to the exclusion of all else.\n\nI don't understand why people get so excited about performance and forget Wirth's Law:\n&gt; software is getting slower more rapidly than hardware is becoming faster.\nYou think the M1 is fast? Just wait a couple of years!\n\nA substrate that will run so fast that you don't have to think about what you run on it is the very definition of an externality. Exponential curves consume all slack. No matter how large the supply of Buffalo is, it's finite. Thinking of a resource as infinite makes no sense. That way lies religion and the Singularity.\n\nHas Apple said anything about how they've tried to mitigate side-channel attacks on hardware optimizations? If they've just focused on making everything faster like everyone else, they're likely open to similar attacks?\n\n\"Reality is that which, when you stop believing in it, doesn't go away.\" -- Philip K Dick",
        "user": "UCUSW7WVD",
        "ts": "1620914323.169000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCUSW7WVD",
            "ts": "1620914438.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qwul",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJN1TAYEQ"
                            },
                            {
                                "type": "text",
                                "text": ":\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Suppose we start over, and build a new computer architecture from scratch. Is there not a fundamental tradeoff between making the new system as fast as an Apple M1, vs providing a bedrock abstraction level that is both accessible to the programmer, and habitable?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nProbably. For me the inescapable implication is: think about habitability (and safety), and don't focus on performance to the exclusion of all else.\n\nI don't understand why people get so excited about performance and forget Wirth's Law:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "software",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is getting slower more rapidly than "
                            },
                            {
                                "type": "text",
                                "text": "hardware",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is becoming faster."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYou think the M1 is fast? Just wait a couple of years!\n\nA substrate that will run so fast that you don't have to think about what you run on it is the very definition of an externality. Exponential curves consume all slack. No matter how large the supply of Buffalo is, it's finite. Thinking of a resource as infinite makes no sense. That way lies religion and the Singularity.\n\nHas Apple said anything about how they've tried to mitigate side-channel attacks on hardware optimizations? If they've just focused on making everything faster like everyone else, they're likely open to similar attacks?\n\n\"Reality is that which, when you stop believing in it, doesn't go away.\" -- Philip K Dick"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c05f1c4b-5fc2-4ee1-9ad3-67d966ae758a",
        "type": "message",
        "text": "Wondering if the notion of \"bedrock\" still makes sense in a world where most computers are virtual to some degree. From the exchanges above, I'd conclude that the bedrock level is the first programmable level of abstraction just above non-programmable hardware. In some contexts (e.g. cybersecurity), that's relevant. For many others, it isn't.\nI'd be perfectly happy to fully inhabit a higher level of abstraction, and leave the lower programmable levels to other species of inhabitants. I see the main problem with today's platforms in the unclear borderlines between levels and in the intentional obfuscation of lower levels.",
        "user": "UJBAJNFLK",
        "ts": "1621149075.173800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Up+s",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Wondering if the notion of \"bedrock\" still makes sense in a world where most computers are virtual to some degree. From the exchanges above, I'd conclude that the bedrock level is the first programmable level of abstraction just above non-programmable hardware. In some contexts (e.g. cybersecurity), that's relevant. For many others, it isn't.\nI'd be perfectly happy to fully inhabit a higher level of abstraction, and leave the lower programmable levels to other species of inhabitants. I see the main problem with today's platforms in the unclear borderlines between levels and in the intentional obfuscation of lower levels."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5a871435-8b29-45f2-82de-86e827127446",
        "type": "message",
        "text": "<@UJBAJNFLK> I'm thinking about a version of my language that runs in WASM, using (some subset of) WASI to interface to the hardware and OS. In that context, WASM and WASI are the \"bedrock\" abstraction level, since you can't go any lower.",
        "user": "UJN1TAYEQ",
        "ts": "1621193370.174400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gcHxT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I'm thinking about a version of my language that runs in WASM, using (some subset of) WASI to interface to the hardware and OS. In that context, WASM and WASI are the \"bedrock\" abstraction level, since you can't go any lower."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1620867412.166800",
        "parent_user_id": "UCUSW7WVD"
    }
]