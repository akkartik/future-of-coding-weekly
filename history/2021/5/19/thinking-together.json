[
    {
        "client_msg_id": "fb9213fc-26a2-4b80-94de-bdaa72c23c54",
        "type": "message",
        "text": "An interesting quote from an HN thread about Xanadu \"The brilliance of TBL is the W3 is half assed in just the right ways to make it not yet another unused visual language or mind map format.\" What's a term for \"half assed in just the right ways\"? Is there really such a thing?",
        "user": "UMVFWPZ36",
        "ts": "1621455059.002300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UMVFWPZ36",
            "ts": "1621455165.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZL0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "An interesting quote from an HN thread about Xanadu \"The brilliance of TBL is the W3 is half assed in just the right ways to make it not yet another unused visual language or mind map format.\" What's a term for \"half assed in just the right ways\"? Is there really such a thing?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "reply_count": 22,
        "reply_users_count": 8,
        "latest_reply": "1621754828.019300",
        "reply_users": [
            "UEBG0NPDK",
            "UKJGU23KP",
            "UA14TGLTC",
            "UBN9AFS0N",
            "UJBAJNFLK",
            "U8A5MS6R1",
            "UG0EL18H3",
            "U5STGTB3J"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1621754828.019300"
    },
    {
        "client_msg_id": "649d0aed-7d3e-44d0-85e8-7f7a1d51df4b",
        "type": "message",
        "text": "I think that\u2019s the wrong sentiment in the same way that many misunderstand the real lesson of \u201cworse is better.\u201d Things that appear ideal on some axes are often poor on others and depending on the context, perfect on axis A and bad on axis B is much worse than just ok in both.",
        "user": "UEBG0NPDK",
        "ts": "1621455646.003100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xCD7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think that\u2019s the wrong sentiment in the same way that many misunderstand the real lesson of \u201cworse is better.\u201d Things that appear ideal on some axes are often poor on others and depending on the context, perfect on axis A and bad on axis B is much worse than just ok in both."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "UC2A2ARPT",
                    "UA14TGLTC",
                    "UJBAJNFLK",
                    "UPD5QQW81"
                ],
                "count": 5
            },
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            },
            {
                "name": "100",
                "users": [
                    "U5STGTB3J"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5c0d2eff-e993-4f2e-923c-500ebb9b2fdd",
        "type": "message",
        "text": "being \u201chalf-assed\u201d compared to the perfect solution often allows for more freedom of movement on axes that may be far more important to the audience",
        "user": "UEBG0NPDK",
        "ts": "1621455713.003300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEBG0NPDK",
            "ts": "1621459416.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "G6N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "being \u201chalf-assed\u201d compared to the perfect solution often allows for more freedom of movement on axes that may be far more important to the audience"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "UC2A2ARPT",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "BE521762-0BF9-4FD5-988C-7AC433B46F92",
        "type": "message",
        "text": "The word \u201ctractable\u201d comes to mind, though I\u2019m not sure if it\u2019s appropriate.",
        "user": "UKJGU23KP",
        "ts": "1621459321.004400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lnE0R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The word \u201ctractable\u201d comes to mind, though I\u2019m not sure if it\u2019s appropriate."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "c7b18e16-6a7e-4c52-a833-6d15a37b2210",
        "type": "message",
        "text": "See also JSON eventually winning out over all the XMLs for day-to-day use.",
        "user": "UA14TGLTC",
        "ts": "1621473254.005300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D=WEK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "See also JSON eventually winning out over all the XMLs for day-to-day use."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "7010c1ef-8e2c-4b86-856d-1c50df083bc7",
        "type": "message",
        "text": "A thought: The original web browser for NeXT had an editor too, other ports skipped the editor and shipped the browser only. The fact that they could do that, and also the fact that HTML was so \"half-assed\"/simple made it easier to port the browser to more platforms making it easier to adopt, use and contribute to it, contributing to its momentum.\n\nThe downside is that it cemented the web as a consumption medium for most :confused:\n\nThe NeXT version had the editor because NeXT made it easy to add one, other plaforms didn't so nobody made the effort and a browser was \"good enough\". We may push the blame one level below: If other platforms made it easier to embed an editor then the browser ports would have it.\n\nCareful what you make hard/impossible to do, it may bite you one layer above :stuck_out_tongue:",
        "user": "UBN9AFS0N",
        "ts": "1621506790.005600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1621507586.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f/o",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A thought: The original web browser for NeXT had an editor too, other ports skipped the editor and shipped the browser only. The fact that they could do that, and also the fact that HTML was so \"half-assed\"/simple made it easier to port the browser to more platforms making it easier to adopt, use and contribute to it, contributing to its momentum.\n\nThe downside is that it cemented the web as a consumption medium for most "
                            },
                            {
                                "type": "emoji",
                                "name": "confused"
                            },
                            {
                                "type": "text",
                                "text": "\n\nThe NeXT version had the editor because NeXT made it easy to add one, other plaforms didn't so nobody made the effort and a browser was \"good enough\". We may push the blame one level below: If other platforms made it easier to embed an editor then the browser ports would have it.\n\nCareful what you make hard/impossible to do, it may bite you one layer above "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC",
                    "UJBAJNFLK",
                    "UMVFWPZ36"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "fef11631-b291-47fd-aedd-c5af5591255f",
        "type": "message",
        "text": "Bidirectional links require coordination, more storage and open the gate for spam and DoS attacks, it's not that it wasn't attempted on the web: <https://html.spec.whatwg.org/#ping>\n\nIt's kind of ironic that searching for the original backlink concept on blogs is full of SEO \"hacks\" and can't find the original non spamy content :slightly_smiling_face:",
        "user": "UBN9AFS0N",
        "ts": "1621507321.006100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UBN9AFS0N",
            "ts": "1621507475.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gnEs",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Bidirectional links require coordination, more storage and open the gate for spam and DoS attacks, it's not that it wasn't attempted on the web: "
                            },
                            {
                                "type": "link",
                                "url": "https://html.spec.whatwg.org/#ping"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt's kind of ironic that searching for the original backlink concept on blogs is full of SEO \"hacks\" and can't find the original non spamy content "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "cry",
                "users": [
                    "UA14TGLTC",
                    "UMVFWPZ36"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "5b91693f-d106-4d84-81dc-610acf5ccd05",
        "type": "message",
        "text": "In an unrestricted network, bidirectional links are indeed problematic. In a bounded network, such as a Wiki, they are great. Something I'd like to see explored is the space in between. For example, a Wiki federation with shared bidirectional links managed as a commons. Just imagine such a federation around Wikipedia, with the bar to entry set very high.",
        "user": "UJBAJNFLK",
        "ts": "1621513919.006800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N8Wwb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In an unrestricted network, bidirectional links are indeed problematic. In a bounded network, such as a Wiki, they are great. Something I'd like to see explored is the space in between. For example, a Wiki federation with shared bidirectional links managed as a commons. Just imagine such a federation around Wikipedia, with the bar to entry set very high."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36",
                    "U8A5MS6R1"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "cb23cc56-b479-4117-be6c-fe5e4a093483",
        "type": "message",
        "text": "Google indexes all the links too so you can search for incoming links eg. <https://www.google.com/search?q=link%3Afutureofcoding.org+-site%3Afutureofcoding.org>",
        "user": "U8A5MS6R1",
        "ts": "1621536602.007500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=BSv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Google indexes all the links too so you can search for incoming links eg. "
                            },
                            {
                                "type": "link",
                                "url": "https://www.google.com/search?q=link%3Afutureofcoding.org+-site%3Afutureofcoding.org"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UFS53UWE5",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "852fbe0a-e8f6-4d9b-9639-6eea158fbf9b",
        "type": "message",
        "text": "As <@U8A5MS6R1> suggests, we could say that Google (page rank and its million extensions in particular) is the business of recognizing bidirectional ham.",
        "user": "UA14TGLTC",
        "ts": "1621559133.008000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "IGBN3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As "
                            },
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " suggests, we could say that Google (page rank and its million extensions in particular) is the business of recognizing bidirectional ham."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "c1d925ae-2d46-48eb-b2e1-8b1a6c0590a2",
        "type": "message",
        "text": "First thing that came to mind was the notion of a minimum viable product, which I'm not sure Xanadu ever was.",
        "user": "UG0EL18H3",
        "ts": "1621564122.008200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rlq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "First thing that came to mind was the notion of a minimum viable product, which I'm not sure Xanadu ever was."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "41718FF1-BC94-45AE-82B4-9FF9365E9E81",
        "type": "message",
        "text": "<@U8A5MS6R1> I don\u2019t want to see all links pointing to Wikipedia. Only links from sites that Wikipedia considers worthy of it. Wikibooks would be a good candidate.",
        "user": "UJBAJNFLK",
        "ts": "1621573359.010200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xa9HF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " I don\u2019t want to see all links pointing to Wikipedia. Only links from sites that Wikipedia considers worthy of it. Wikibooks would be a good candidate."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U8A5MS6R1",
                    "UHWC9PXBL"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "889d343d-1eb8-4b9f-a1e2-e45bdcf4bbab",
        "type": "message",
        "text": "In other words: coarse-grained social networks. Not between people, but between communities.",
        "user": "UJBAJNFLK",
        "ts": "1621579851.010400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2LL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In other words: coarse-grained social networks. Not between people, but between communities."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "450fae5f-21ca-4d28-a527-d2171f7e6da4",
        "type": "message",
        "text": "&gt; being \u201chalf-assed\u201d compared to the perfect solution often allows for more freedom of movement on axes that may be far more important to the audience\nThere\u2019s the notion of designing something only as far as you need to, which I\u2019ve been exploring as one of the main themes in Christopher Alexander\u2019s work. Ryan Singer calls it \u201cdesign latitude\u201d. It\u2019s what pattern languages really are about: describing a design only as far as you need to in that context, leaving all the lower-level implementation details as open as possible.\n\nIn software we nowadays default to spell everything out as detailed as possible. Partly because we have to; that CPU isn\u2019t going to do anything until you present it with some proper stream of instructions, so you\u2019re required to fill in all the blanks somehow, even if you haven\u2019t figured those out in the design yet. Or \u2014 what a concept \u2014 if you\u2019d prefer not to fill these details in, but leave it to others downstream to do that.\n\nBeing able to distinguish the decisions that you need to make now from the ones you want to leave open, is something our tools today are really bad at helping us with. They usually push us towards deciding everything, even if we don\u2019t want to.",
        "user": "U5STGTB3J",
        "ts": "1621594055.010900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U5STGTB3J",
            "ts": "1621594122.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f6n",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "being \u201chalf-assed\u201d compared to the perfect solution often allows for more freedom of movement on axes that may be far more important to the audience"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThere\u2019s the notion of designing something only as far as you need to, which I\u2019ve been exploring as one of the main themes in Christopher Alexander\u2019s work. Ryan Singer calls it \u201cdesign latitude\u201d. It\u2019s what pattern languages really are about: describing a design only as far as you need to in that context, leaving all the lower-level implementation details as open as possible.\n\nIn software we nowadays default to spell everything out as detailed as possible. Partly because we have to; that CPU isn\u2019t going to do anything until you present it with some proper stream of instructions, so you\u2019re required to fill in all the blanks somehow, even if you haven\u2019t figured those out in the design yet. Or \u2014 what a concept \u2014 if you\u2019d prefer not to fill these details in, but leave it to others downstream to do that.\n\nBeing able to distinguish the decisions that you need to make now from the ones you want to leave open, is something our tools today are really bad at helping us with. They usually push us towards deciding everything, even if we don\u2019t want to."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "bf2b21a1-6db8-4208-b09c-fd69f7be926c",
        "type": "message",
        "text": "I totally agree, design should be done in the form of specifications (which can be incomplete), not implementation (which has to be executable). Better yet, aim for _composable_ specifications. That has worked out very well in mathematical descriptions (see <https://blog.khinsen.net/posts/2020/12/10/the-structure-and-interpretation-of-scientific-models/>).",
        "user": "UJBAJNFLK",
        "ts": "1621596000.011200",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "The structure and interpretation of scientific models",
                "title_link": "https://blog.khinsen.net/posts/2020/12/10/the-structure-and-interpretation-of-scientific-models/",
                "text": "It is often said that science rests on two pillars, experiment and theory. Which has lead some to propose one or two additional pillars for the computing age: simulation and data analysis. However, the _real_ two pillars of science are observations and mo...",
                "fallback": "The structure and interpretation of scientific models",
                "from_url": "https://blog.khinsen.net/posts/2020/12/10/the-structure-and-interpretation-of-scientific-models/",
                "service_name": "blog.khinsen.net",
                "id": 1,
                "original_url": "https://blog.khinsen.net/posts/2020/12/10/the-structure-and-interpretation-of-scientific-models/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UOSB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I totally agree, design should be done in the form of specifications (which can be incomplete), not implementation (which has to be executable). Better yet, aim for "
                            },
                            {
                                "type": "text",
                                "text": "composable",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " specifications. That has worked out very well in mathematical descriptions (see "
                            },
                            {
                                "type": "link",
                                "url": "https://blog.khinsen.net/posts/2020/12/10/the-structure-and-interpretation-of-scientific-models/"
                            },
                            {
                                "type": "text",
                                "text": ")."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UMVFWPZ36"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "c94b4e26-74e8-4484-b7ac-c438018c69bd",
        "type": "message",
        "text": "<@UJBAJNFLK> How does incompleteness work with specifications? I thought they\u2019re only incomplete in the sense that they are a model and not reality, so they might just completely miss certain aspects (or deliberately leave them out), but they still need to be fully coherent and precise within themselves.\n\nI don\u2019t know enough about that to judge whether I perhaps mean a different kind of incomplete. Alexander is pretty clever in pattern languages, where he uses ambiguity of language to choose words that create the right picture in our mind\u2019s eye, but such that _we_ (the \u201cuser\u201d) fill in the blanks and not _him_ (the designer). It feels like there\u2019s a (subtle?) difference there in that an incomplete specification misses something completely (or chooses to leave it out), whereas a pattern language very deliberately describes something, but in a way that is intentionally ambiguous. I\u2019m having a hard time squaring precision of specifications with ambiguity.",
        "user": "U5STGTB3J",
        "ts": "1621596831.011500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "HYnLU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " How does incompleteness work with specifications? I thought they\u2019re only incomplete in the sense that they are a model and not reality, so they might just completely miss certain aspects (or deliberately leave them out), but they still need to be fully coherent and precise within themselves.\n\nI don\u2019t know enough about that to judge whether I perhaps mean a different kind of incomplete. Alexander is pretty clever in pattern languages, where he uses ambiguity of language to choose words that create the right picture in our mind\u2019s eye, but such that "
                            },
                            {
                                "type": "text",
                                "text": "we",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (the \u201cuser\u201d) fill in the blanks and not "
                            },
                            {
                                "type": "text",
                                "text": "him",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (the designer). It feels like there\u2019s a (subtle?) difference there in that an incomplete specification misses something completely (or chooses to leave it out), whereas a pattern language very deliberately describes something, but in a way that is intentionally ambiguous. I\u2019m having a hard time squaring precision of specifications with ambiguity."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "ddfd86df-c394-425a-9173-17282a679e03",
        "type": "message",
        "text": "Take mathematical equations, which are specifications for their solutions. More specifically, equations are _constraints_ on the solutions. You can compose as many such constraints as you want. At worst, you overconstrain the solution to the point that there is no solution any more. Which means that your specifications/constraints are incoherent. But that is detectable and thus avoidable.",
        "user": "UJBAJNFLK",
        "ts": "1621603513.011700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LQn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Take mathematical equations, which are specifications for their solutions. More specifically, equations are "
                            },
                            {
                                "type": "text",
                                "text": "constraints",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " on the solutions. You can compose as many such constraints as you want. At worst, you overconstrain the solution to the point that there is no solution any more. Which means that your specifications/constraints are incoherent. But that is detectable and thus avoidable."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "de12cf2e-99c0-4804-9390-b06b8fb4eb8a",
        "type": "message",
        "text": "Ah yes, that makes sense. I was already thinking in the direction of type systems, which allow you to express such arbitrary constraints on  values, making them just as specific as you need/want them.",
        "user": "U5STGTB3J",
        "ts": "1621605223.011900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uwo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Ah yes, that makes sense. I was already thinking in the direction of type systems, which allow you to express such arbitrary constraints on  values, making them just as specific as you need/want them."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "ed62e241-9ece-40aa-9261-aabd5248d3c0",
        "type": "message",
        "text": "Yes, that's a good start. Next would be constraints on relations between values. Both same-time (e.g. two arguments to a function) and different-time (e.g. input and output of a function).",
        "user": "UJBAJNFLK",
        "ts": "1621614487.012400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "B=X",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, that's a good start. Next would be constraints on relations between values. Both same-time (e.g. two arguments to a function) and different-time (e.g. input and output of a function)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "399d1451-977b-4fdc-9173-8bcc23782369",
        "type": "message",
        "text": "<@UJBAJNFLK> I agree we want curated bidi links. I didn't mean to say \"we can do bidi links already\" but rather \"bidi links can be extracted, with some effort, from uni directional links\" and perhaps this idea can be used to build curated lists.\n\nOne big shortcoming of the web is there is no link-content stability. The link represents a way to get the content, not the content itself. A unique link should always give you the \"same thing\". In some cases this might mean the latest version of that thing, but prior versions should be linked to the latest one as well. OTOH, the original author of some content should not be required to fund availability of their stable content on some server for perpetuity.\n\nPerhaps we want a system where authors publish stable content links but availability is provided by other organizations. For large globally relevant content, large publicly funded organizations could fund availability (~wikipedia). However smaller communities could form their own organizations and fund availability of content relevant to and curated by them. As things become more relevant, content would get pinned into the zones of more and more orgs, small and large. As they become less relevant, many orgs might stop persisting the content, but archival orgs like newspapers and <http://archive.org|archive.org> might take them on. I believe IPFS (and maybe DAT?) or something similar can be a foundation of what I am describing.\n\nThis is only part of the problem though. In IPFS for instance, a link will give me a blob of bytes but making sense of it is still left to me. What's the guarantee I'll be able to assemble the perfect combination of programs that extract meaning from that blob? In 5 years? In 50 years? How can we enrich the system to do this easily and reliably?",
        "user": "U8A5MS6R1",
        "ts": "1621616233.012800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "r1edT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I agree we want curated bidi links. I didn't mean to say \"we can do bidi links already\" but rather \"bidi links can be extracted, with some effort, from uni directional links\" and perhaps this idea can be used to build curated lists.\n\nOne big shortcoming of the web is there is no link-content stability. The link represents a way to get the content, not the content itself. A unique link should always give you the \"same thing\". In some cases this might mean the latest version of that thing, but prior versions should be linked to the latest one as well. OTOH, the original author of some content should not be required to fund availability of their stable content on some server for perpetuity.\n\nPerhaps we want a system where authors publish stable content links but availability is provided by other organizations. For large globally relevant content, large publicly funded organizations could fund availability (~wikipedia). However smaller communities could form their own organizations and fund availability of content relevant to and curated by them. As things become more relevant, content would get pinned into the zones of more and more orgs, small and large. As they become less relevant, many orgs might stop persisting the content, but archival orgs like newspapers and "
                            },
                            {
                                "type": "link",
                                "url": "http://archive.org",
                                "text": "archive.org"
                            },
                            {
                                "type": "text",
                                "text": " might take them on. I believe IPFS (and maybe DAT?) or something similar can be a foundation of what I am describing.\n\nThis is only part of the problem though. In IPFS for instance, a link will give me a blob of bytes but making sense of it is still left to me. What's the guarantee I'll be able to assemble the perfect combination of programs that extract meaning from that blob? In 5 years? In 50 years? How can we enrich the system to do this easily and reliably?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "f7504e12-8b36-432b-99f0-57d00483fccb",
        "type": "message",
        "text": "A big problem of the Web is indeed that it has no notion of \"lifetime\". There is no way to ensure persistence, nor erasure of information.\n\nContent-addressing as in IPFS (not DAT, which is based on UUIDs for sharing mutable data) is a very useful ingredient for better information management. Preserving the semantics of data is a much harder problem, one that people (including myself) are actively working on in the context of preserving digital scientific knowledge. 5 years is doable today. If you aim for 50 years, there are techniques that make it possible under reasonable assumptions, such as the continued existence of virtual x86 machines.",
        "user": "UJBAJNFLK",
        "ts": "1621658862.018400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "p57",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A big problem of the Web is indeed that it has no notion of \"lifetime\". There is no way to ensure persistence, nor erasure of information.\n\nContent-addressing as in IPFS (not DAT, which is based on UUIDs for sharing mutable data) is a very useful ingredient for better information management. Preserving the semantics of data is a much harder problem, one that people (including myself) are actively working on in the context of preserving digital scientific knowledge. 5 years is doable today. If you aim for 50 years, there are techniques that make it possible under reasonable assumptions, such as the continued existence of virtual x86 machines."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "147a7315-1240-4c6e-ac03-d7573cf88ee7",
        "type": "message",
        "text": "Konrad, on the topic of long term preservation of semantics, I was thinking if we could store the mapping of `bytes` to other structures in the long term stabilized storage as well, maybe that could work?\n\nFor the short term, something like mime type tagging can work, but a mime type is just a string tag. If a blob is annotated with `image/png` we're likely to find decoders easily. However it gets harder for `text/some-custom-format`. So instead of a string tag, what if we tag a file A with a link to another permanent file B which we call the _class_ for file A. The B file would describe how to parse the content of the A. But how do we know how to parse B? Either it is well known, or it would link to another class file C, perhaps. At some point we have to agree on a small language to describe the axiomatic description `B*`  that all classes eventually link up to. The main thing would be these descriptions would have to be machine agnostic (no x86 specific stuff). However, as an optimization these class descriptions would also link to x86 _implementations_ (stored in other files) of the parsers. So if you're running on architecture X, you could find the class for the content (A -&gt; B) and then lookup implementations for X (B --(X)--&gt; F). Parsers for future architectures could be added. Also, content files can be reencoded into instances of newer classes, if needed.",
        "user": "U8A5MS6R1",
        "ts": "1621703421.018600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1621721515.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0YwSJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Konrad, on the topic of long term preservation of semantics, I was thinking if we could store the mapping of "
                            },
                            {
                                "type": "text",
                                "text": "bytes",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to other structures in the long term stabilized storage as well, maybe that could work?\n\nFor the short term, something like mime type tagging can work, but a mime type is just a string tag. If a blob is annotated with "
                            },
                            {
                                "type": "text",
                                "text": "image/png",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " we're likely to find decoders easily. However it gets harder for "
                            },
                            {
                                "type": "text",
                                "text": "text/some-custom-format",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". So instead of a string tag, what if we tag a file A with a link to another permanent file B which we call the "
                            },
                            {
                                "type": "text",
                                "text": "class",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for file A. The B file would describe how to parse the content of the A. But how do we know how to parse B? Either it is well known, or it would link to another class file C, perhaps. At some point we have to agree on a small language to describe the axiomatic description "
                            },
                            {
                                "type": "text",
                                "text": "B*",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  that all classes eventually link up to. The main thing would be these descriptions would have to be machine agnostic (no x86 specific stuff). However, as an optimization these class descriptions would also link to x86 "
                            },
                            {
                                "type": "text",
                                "text": "implementations",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (stored in other files) of the parsers. So if you're running on architecture X, you could find the class for the content (A -> B) and then lookup implementations for X (B --(X)--> F). Parsers for future architectures could be added. Also, content files can be reencoded into instances of newer classes, if needed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    },
    {
        "client_msg_id": "6decf327-76b2-45fd-86fd-df84b08161c4",
        "type": "message",
        "text": "I think the key issue is \"agree on\". We know enough enough by now to build semantic stacks with a minimalist basis that is easy to document for future generations. But there are many ways to do it and many ideological but not very fundamental arguments to distinguish between them. Humans just like bikeshedding too much to make substantial progress.",
        "user": "UJBAJNFLK",
        "ts": "1621754828.019300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eH//t",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think the key issue is \"agree on\". We know enough enough by now to build semantic stacks with a minimalist basis that is easy to document for future generations. But there are many ways to do it and many ideological but not very fundamental arguments to distinguish between them. Humans just like bikeshedding too much to make substantial progress."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1621455059.002300",
        "parent_user_id": "UMVFWPZ36"
    }
]