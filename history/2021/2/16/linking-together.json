[
    {
        "client_msg_id": "6325502f-57ea-4e8a-8c02-ec123ab14b0a",
        "type": "message",
        "text": "I think many programmers have the (correct) intuition that some kind of circular bootstrapping will unlock or manifest some deep or profound power, but unfortunately can't substantiate why this is. So metacircularity is either dismissed as pointless, or recognized as automatically profound and powerful, regardless whether it's leveraged in any meaningfully powerful way.\n\nThe powerful idea behind metacircularity (which often sensed but rarely realized) is that we can potentially leverage all the power of programming, to leverage all the power of programming. Software ~can be~ _is_ its own lever.\n\nBut this is not what you see in most \"metacircular\" software. It's usually more like using a robot-arm to control another identical robot-arm, versus using the arm on *itself* (e.g. to give itself new or improved capabilities). Less like a living cell, which contains (and thus \"is\") all its own apparatus for defining / executing / replicating itself; and more like a virus, which does not.\n\n(That's the link I see between \"living structure\", \"unfolding wholeness\", and what I called \"actual circular\" metacircularity).\n\nAn example of what I think this would look like, is software that is actually written (and subsequently interpreted or created from) _within_ *itself.*",
        "user": "UAVCC2X70",
        "ts": "1613452813.145500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1613457321.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Tao",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think many programmers have the (correct) intuition that some kind of circular bootstrapping will unlock or manifest some deep or profound power, but unfortunately can't substantiate why this is. So metacircularity is either dismissed as pointless, or recognized as automatically profound and powerful, regardless whether it's leveraged in any meaningfully powerful way.\n\nThe powerful idea behind metacircularity (which often sensed but rarely realized) is that we can potentially leverage all the power of programming, to leverage all the power of programming. Software "
                            },
                            {
                                "type": "text",
                                "text": "can be",
                                "style": {
                                    "strike": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " its own lever.\n\nBut this is not what you see in most \"metacircular\" software. It's usually more like using a robot-arm to control another identical robot-arm, versus using the arm on "
                            },
                            {
                                "type": "text",
                                "text": "itself ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "(e.g. to give itself new or improved capabilities). Less like a living cell, which contains (and thus \"is\") all its own apparatus for defining / executing / replicating itself; and more like a virus, which does not.\n\n(That's the link I see between \"living structure\", \"unfolding wholeness\", and what I called \"actual circular\" metacircularity).\n\nAn example of what I think this would look like, is software that is actually written (and subsequently interpreted or created from) "
                            },
                            {
                                "type": "text",
                                "text": "within",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "itself.",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612344518.049600",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "2afe7d1a-be6c-4d72-a0a9-d3662bbf5506",
        "type": "message",
        "text": "That's _way_ out of my expertise to argue with :slightly_smiling_face: Both the bio and CA angles. Though I'd weakly claim that CA's notion of living order includes the environment, particularly people. It feels tenuous to connect it to metacircularity.\n\nIs any software metacircular by your definition? Smalltalk?",
        "user": "UCUSW7WVD",
        "ts": "1613454213.146000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Fri7q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That's "
                            },
                            {
                                "type": "text",
                                "text": "way",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " out of my expertise to argue with "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " Both the bio and CA angles. Though I'd weakly claim that CA's notion of living order includes the environment, particularly people. It feels tenuous to connect it to metacircularity.\n\nIs any software metacircular by your definition? Smalltalk?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612344518.049600",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "caf24df6-ea7e-4819-8ac1-e51864ef03b9",
        "type": "message",
        "text": "I'd say things like SmallTalk, Forth, Lisp, Glamorous Toolkit, come the closest. The gaps are in whether it's actually _used_ that way (e.g. treating arches like bricks and building a pyramid out of them); or that it's still forced through artificial layers (like \"language\") that are taken as a given, but which are actually just one of a million possible \"interfaces\", any of which could be self-contained.\n\nMPS has the right idea, except that it provides a plethora or set-in-stone concepts, interfaces, layers, and languages for everything -- which I find highly ironic, given what is supposed to be.\n\nRacket gets an honorable mention for being the best \"make your own language, in your own language\" language; but it's very linear, and forced through the very specific paradigm of specifying, creating, etc etc, all through parsing textual language. Zero progress at escaping that, but it does it WELL.\n\nActually, Rebol / Red may do it better in some (but not all) respects. It's parsing util(s) treats not only the thing being parsed as a datastructure, but also the code doing the parsing! I think it's just called \"parse\", and there's a write-up about this that's google-able.\n\nThe principles of the moldable objects initiative (or whatever it's called) that <@UML4ZEKDK> is part of, are actually pretty in line with this stuff. I don't think it's prescriptive of what I'm talking about here, alright I think the goals overlap.",
        "user": "UAVCC2X70",
        "ts": "1613458436.146600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1613461163.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9QIIv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'd say things like SmallTalk, Forth, Lisp, Glamorous Toolkit, come the closest. The gaps are in whether it's actually "
                            },
                            {
                                "type": "text",
                                "text": "used ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "that way (e.g. treating arches like bricks and building a pyramid out of them); or that it's still forced through artificial layers (like \"language\") that are taken as a given, but which are actually just one of a million possible \"interfaces\", any of which could be self-contained.\n\nMPS has the right idea, except that it provides a plethora or set-in-stone concepts, interfaces, layers, and languages for everything -- which I find highly ironic, given what is supposed to be.\n\nRacket gets an honorable mention for being the best \"make your own language, in your own language\" language; but it's very linear, and forced through the very specific paradigm of specifying, creating, etc etc, all through parsing textual language. Zero progress at escaping that, but it does it WELL.\n\nActually, Rebol / Red may do it better in some (but not all) respects. It's parsing util(s) treats not only the thing being parsed as a datastructure, but also the code doing the parsing! I think it's just called \"parse\", and there's a write-up about this that's google-able.\n\nThe principles of the moldable objects initiative (or whatever it's called) that "
                            },
                            {
                                "type": "user",
                                "user_id": "UML4ZEKDK"
                            },
                            {
                                "type": "text",
                                "text": " is part of, are actually pretty in line with this stuff. I don't think it's prescriptive of what I'm talking about here, alright I think the goals overlap."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612344518.049600",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "1ac940be-a79b-4906-b229-abf51e24eb42",
        "type": "message",
        "text": "I do think that \"living structure\" (Purpose) _is_ the thing one is after (consciously or not), in seeking metacircularity (Mechanism); and vice versa, that metacircularity (as I've described it) is _necessarily_ how \"living structure\" (e.g. organism, business, or software extension of human capability) is achieved or constituted.\n\nMechanism:\n\nThe living thing necessarily contains it's own code (or other self-representation -- DNA is code), interpreter(s), replication, ability to replace it's bits while preserving structure &amp; identity, and all this is self-contained, ergo the living thing \"is\" / \"does\" these things / \"has\" these capabilities.\n\nPurpose:\n\nCapable of adapting, changing, preserving, etc, in a way that dynamically keeps it fit for it's purpose or environment, evolving / learning all the while. Conversely, a thing that must be painstakingly redesigned and/or thrown out once it is no longer fit (if it was even a good fit at all) for some very specific (perhaps very static) purpose it was rigorously designed for, is in essence \"dead\" at creation.\n\nEnvironment does control a metacircular software thing, because that's the whole point. A car \"that can do anything\" really means that YOU can MAKE IT do anything (for whatever \"do anything\" means). That is how it can be perfectly fit and adaptable, because it provides a means to adapt \"itself\", _including_ (by definition of being \"fully\" metacircular) those means it provides to do so.",
        "user": "UAVCC2X70",
        "ts": "1613462194.147400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1613463119.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a2Y6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I do think that \"living structure\" (Purpose) "
                            },
                            {
                                "type": "text",
                                "text": "is",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the thing one is after (consciously or not), in seeking metacircularity (Mechanism); and vice versa, that metacircularity (as I've described it) is "
                            },
                            {
                                "type": "text",
                                "text": "necessarily ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "how \"living structure\" (e.g. organism, business, or software extension of human capability) is achieved or constituted.\n\nMechanism:\n\nThe living thing necessarily contains it's own code (or other self-representation -- DNA is code), interpreter(s), replication, ability to replace it's bits while preserving structure & identity, and all this is self-contained, ergo the living thing \"is\" / \"does\" these things / \"has\" these capabilities.\n\nPurpose:\n\nCapable of adapting, changing, preserving, etc, in a way that dynamically keeps it fit for it's purpose or environment, evolving / learning all the while. Conversely, a thing that must be painstakingly redesigned and/or thrown out once it is no longer fit (if it was even a good fit at all) for some very specific (perhaps very static) purpose it was rigorously designed for, is in essence \"dead\" at creation.\n\nEnvironment does control a metacircular software thing, because that's the whole point. A car \"that can do anything\" really means that YOU can MAKE IT do anything (for whatever \"do anything\" means). That is how it can be perfectly fit and adaptable, because it provides a means to adapt \"itself\", "
                            },
                            {
                                "type": "text",
                                "text": "including",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (by definition of being \"fully\" metacircular) those means it provides to do so."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612344518.049600",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "9AEC167C-DCCE-42E4-8FD4-D7D29AD35E10",
        "type": "message",
        "text": "I've been <https://github.com/ivanreese/visual-programming-codex/blob/master/inspirations.md|saying this> for years, but now that Bartosz says it... :p\n\n<https://bartoszmilewski.com/2021/02/16/functorio/>\n\n(For once, the <https://news.ycombinator.com/item?id=26157969|HN> discussion has some <https://news.ycombinator.com/item?id=26158551|interesting> and <https://news.ycombinator.com/item?id=26158765|relatable> thoughts.)",
        "user": "UC2A2ARPT",
        "ts": "1613514848.149300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1613519286.000000"
        },
        "attachments": [
            {
                "service_name": "\u00a0\u00a0Bartosz Milewski's Programming Cafe",
                "service_url": "http://bartoszmilewski.com",
                "title": "Functorio",
                "title_link": "https://bartoszmilewski.com/2021/02/16/functorio/",
                "author_name": "Bartosz Milewski",
                "author_link": "https://bartoszmilewski.com/author/bartoszmilewski/",
                "thumb_url": "https://bartoszmilewski.files.wordpress.com/2020/12/redscienceassembler.png?fit=200%2C150",
                "thumb_width": 157,
                "thumb_height": 150,
                "text": "You might have heard people say that functional programming is more academic, and real engineering is done in imperative style. I&rsquo;m going to show you that real engineering is functional, and I&rsquo;m going to illustrate it using a computer game that is designed by engineers for engineers. It&rsquo;s a simulation game called Factorio, in which you are given resources that you have to explore, build factories that process them, create more and more complex systems, until you are finally able to launch a spaceship that may take you away from an inhospitable planet. If this is not engineering at its purest then I don&rsquo;t know what is. And yet almost all you do when playing this game has its functional programming counterparts and it can be used to teach basic concepts of not only programming but also, to some extent, category theory. So, without further ado, let&rsquo;s jump in.\nFunctions\nThe building blocks of every programming language are functions. A function takes input and produces output. In Factorio they are called assembling machines, or assemblers. Here&rsquo;s an assembler that produces copper wire.\n\nIf you bring up the info about the assembler you&rsquo;ll see the recipe that it&rsquo;s using. This one takes one copper plate and produces a pair of coils of copper wire.\n\nThis recipe is really a function signature in a strongly typed system. We see two types: copper plate and copper wire, and an arrow between them. Also, for every copper plate the assembler produces a pair of copper wires. In Haskell we would declare this function as\nmakeCopperWire :: CopperPlate -&gt; (CopperWire, CopperWire)\nNot only do we have types for different components, but we can combine types into tuples&ndash;here it&rsquo;s a homogenous pair (CopperWire, CopperWire). If you&rsquo;re not familiar with Haskell notation, here&rsquo;s what it might look like in C++:\nstd::pair makeCopperWire(CopperPlate);\nHere&rsquo;s another function signature in the form of an assembler recipe:\n\nIt takes a pair of iron plates and produces an iron gear wheel. We could write it as\nmakeGear :: (IronPlate, IronPlate) -&gt; Gear\nor, in C++,\nGear makeGear(IronPlate, IronPlate);\nMany recipes require a combination of differently typed ingredients, like the one for producing red science packs\n\nWe would declare this function as:\nmakeRedScience :: (CopperPlate, Gear) -&gt; RedScience\nPairs are examples of product types. Factorio recipes use the plus sign to denote tuples; I guess this is because we often read a sum as &ldquo;this and this&rdquo;, and &ldquo;and&rdquo; introduces a product type. The assembler requires both inputs to produce the output, so it accepts a product type. If it required either one, we&rsquo;d call it a sum type.\nWe can also tuple more than two ingredients, as in this recipe for producing electronic circuits (or green circuits, as they are commonly called)\n\nmakeGreenCircuit :: \n  (CopperWire, CopperWire, CopperWire, IronPlate) -&gt; GreenCircuit\nNow suppose that you have at your disposal the raw ingeredients: iron plates and copper plates. How would you go about producing red science or green circuits? This is where function composition kicks in. You can pass the output of the copper wire assembler as the input to the green circuit assembler. (You will still have to tuple it with an iron plate.)\n\n\nSimilarly, you can compose the gear assembler with the red science assembler.\n\n\nThe result is a new function with the following signature\nmakeRedScienceFrom :: \n    (CopperPlate, IronPlate, IronPlate) -&gt; RedScience\nAnd this is the implementation:\nmakeRedScienceFrom (cu, fe1, fe2) = \n    makeRedScience (cu, makeGear (fe1, fe2))\nYou start with one copper plate and two iron plates. You feed the iron plates to the gear assembler. You pair the resulting gear with the copper plate and pass it to the red science assembler.\nMost assemblers in Factorio take more than one argument, so I couldn&rsquo;t come up with a simpler example of composition, one that wouldn&rsquo;t require untupling and retupling. In Haskell we usually use functions in their curried form (we&rsquo;ll come back to this later), so composition is easy there.\nComposition is also a feature of a category, so we should ask the question if we can treat assemblers as arrows in a category. Their composition is obviously associative. But do we have an equivalent of an identity arrow? It is something that takes input of some type and returns it back unchanged. And indeed we have things called inserters that do exactly that. Here&rsquo;s an inserter between two assemblers.\n\nIn fact, in Factorio, you have to use an inserter for direct composition of assemblers, but that&rsquo;s an implementation detail (technically, inserting an identity function doesn&rsquo;t change anything).\nAn inserter is actually a polymorphic function, just like the identity function in Haskell\ninserter :: a -&gt; a\ninserter x = x\nIt works for any type a.\nBut the Factorio category has more structure. As we have seen, it supports finite products (tuples) of arbitrary types. Such a category is called cartesian. (We&rsquo;ll talk about the unit of this product later.)\nNotice that we have identified multiple Factorio subsystem as functions: assemblers, inserters, compositions of assemblers, etc. In a programming language they would all be just functions. If we were to design a language based on Factorio (we could call it Functorio), we would enclose the composition of assemblers into an assembler, or even make an assembler that takes two assemblers and produces their composition. That would be a higher-order assembler.\nHigher order functions\nThe defining feature of functional languages is the ability to make functions first-class objects. That means the ability to pass a function as an argument to another function, and to return a function as a result of another function. For instance, we should have a recipe for producing assemblers. And, indeed, there is such recipe. All it needs is green circuits, some gear wheels, and a few iron plates:\n\nIf Factorio were a strongly typed language all the way, there would be separate recipes for producing different assemblers (that is assemblers with different recipes). For instance, we could have:\nmakeRedScienceAssembler :: \n   (GreenCircuit, Gear, IronPlate) -&gt; RedScienceAssembler\nInstead, the recipe produces a generic assembler, and it lets the player manually set the recipe in it. In a way, the player provides one last ingredient, an element of the enumeration of all possible recipes. This enumeration is displayed as a menu of choices:\n\nAfter all, Factorio is an interactive game.\nSince we have identified the inserter as the identity function, we should have a recipe for producing it as well. And indeed there is one:\n\nDo we also have functions that take functions as arguments? In other words, recipes that use assemblers as input? Indeed we do:\n\nAgain, this recipe accepts a generic assembler that hasn&rsquo;t been assigned its own recipe yet.\nThis shows that Factorio supports higher-order functions and is indeed a functional language. What we have here is a way of treating functions (assemblers) not only as arrows between objects, but also as objects that can be produced and consumed by functions. In category theory, such objectified arrow types are called exponential objects. A category in which arrow types are represented as objects is called closed, so we can view Factorio as a cartesian closed category.\nIn a strongly typed Factorio, we could say that the object RedScienceAssembler\n\nis equivalent to its recipe\n\ntype RedScienceAssembler = \n    (CopperPlate, Gear) -&gt; RedScience\nWe could then write a higher-order recipe that produces this particular assembler as:\nmakeRedScienceAssembler :: \n     (GreenCircuit, Gear, IronPlate) \n  -&gt; ((CopperPlate, Gear) -&gt; RedScience)\nSimilarly, in a strongly typed Factorio we would replace this higher-order recipe\n\nwith the following signature\nmakeGreenScience \u2026",
                "fallback": "\u00a0\u00a0Bartosz Milewski's Programming Cafe Link: Functorio",
                "from_url": "https://bartoszmilewski.com/2021/02/16/functorio/",
                "service_icon": "https://s2.wp.com/i/webclip.png",
                "id": 2,
                "original_url": "https://bartoszmilewski.com/2021/02/16/functorio/"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "joy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I've been "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/ivanreese/visual-programming-codex/blob/master/inspirations.md",
                                "text": "saying this"
                            },
                            {
                                "type": "text",
                                "text": " for years, but now that Bartosz says it... :p\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://bartoszmilewski.com/2021/02/16/functorio/"
                            },
                            {
                                "type": "text",
                                "text": "\n\n(For once, the "
                            },
                            {
                                "type": "link",
                                "url": "https://news.ycombinator.com/item?id=26157969",
                                "text": "HN"
                            },
                            {
                                "type": "text",
                                "text": " discussion has "
                            },
                            {
                                "type": "text",
                                "text": "some",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https://news.ycombinator.com/item?id=26158551",
                                "text": "interesting"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https://news.ycombinator.com/item?id=26158765",
                                "text": "relatable"
                            },
                            {
                                "type": "text",
                                "text": " thoughts.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "reply_count": 23,
        "reply_users_count": 7,
        "latest_reply": "1613789086.003500",
        "reply_users": [
            "UC2A2ARPT",
            "U8A5MS6R1",
            "UCUSW7WVD",
            "U016VUZGUUQ",
            "UCGAK10LS",
            "U013ZLJARC7",
            "UHWC9PXBL"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UAVCC2X70",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD",
                    "U013ZLJARC7"
                ],
                "count": 2
            },
            {
                "name": "star",
                "users": [
                    "USH01JEDQ"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "1ad670fc-cf03-4daa-b81b-9c0cbe06cb1b",
        "type": "message",
        "text": "The absurd thing about this is how much I prefer looking at the pictures rather than the code. It's like Bartosz has the \"before\" and \"after\" reversed.",
        "user": "UC2A2ARPT",
        "ts": "1613515241.149900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FSBMa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The absurd thing about this is how much I prefer looking at the pictures rather than the code. It's like Bartosz has the \"before\" and \"after\" reversed."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "U8A5MS6R1",
                    "UCGAK10LS",
                    "UA14TGLTC",
                    "U01JHG5RQDQ",
                    "UHWC9PXBL"
                ],
                "count": 5
            },
            {
                "name": "joy",
                "users": [
                    "U013ZLJARC7",
                    "UML4ZEKDK"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "7c8f8d96-cecc-460d-98a1-da4e1126680a",
        "type": "message",
        "text": "I assume Factorio assemblers consume the objects you feed them?\nWhich functional languages do this?",
        "user": "U8A5MS6R1",
        "ts": "1613515591.150200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/zOL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I assume Factorio assemblers consume the objects you feed them?\nWhich functional languages do this?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "9868d073-5cbf-4742-940e-218040aab099",
        "type": "message",
        "text": "I am obliged to point out that this bit..\n\n&gt; In Factorio, the nesting of functors is drastically limited. It\u2019s possible to produce belts, and you can put them on belts, so you can have a beltful of belts,\u00a0`Belt Belt`. Similarly you can store chests inside chests. But you can\u2019t have belts of\u00a0_loaded_\u00a0belts. You can\u2019t pick a belt filled with copper plates and put it on another belt. In other words, you cannot transport beltfuls of stuff.\n... is something you can do in Hest. And it's bonkers. And it's weird. And I don't like it. It hurts to think about.\n\nAnd thanks to this article, I now know why.\n\n&gt; Realistically, that wouldn\u2019t make much sense in real world, but in Functorio, this is exactly what we need to implement monads.\nAh. Monads. Didn't see you come in. There's beer in the fridge. I'm going out. I'll be back.. later.",
        "user": "UC2A2ARPT",
        "ts": "1613515692.150400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+lIm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I am obliged to point out that this bit..\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In Factorio, the nesting of functors is drastically limited. It\u2019s possible to produce belts, and you can put them on belts, so you can have a beltful of belts,\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "Belt Belt",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Similarly you can store chests inside chests. But you can\u2019t have belts of\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "loaded",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u00a0belts. You can\u2019t pick a belt filled with copper plates and put it on another belt. In other words, you cannot transport beltfuls of stuff."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n... is something you can do in Hest. And it's bonkers. And it's weird. And I don't like it. It hurts to think about.\n\nAnd thanks to this article, I now know why.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Realistically, that wouldn\u2019t make much sense in real world, but in Functorio, this is exactly what we need to implement monads."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nAh. Monads. Didn't see you come in. There's beer in the fridge. I'm going out. I'll be back.. later."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "U8A5MS6R1",
                    "UHWC9PXBL"
                ],
                "count": 2
            },
            {
                "name": "smile",
                "users": [
                    "UAVCC2X70",
                    "UA14TGLTC",
                    "UML4ZEKDK",
                    "UHWC9PXBL"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "9f78a5d2-73c9-4fbd-bbc6-2912828dae2d",
        "type": "message",
        "text": "<@U8A5MS6R1> Bartosz talks about that in the section on Linear Types.",
        "user": "UC2A2ARPT",
        "ts": "1613515748.150600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wrkVd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U8A5MS6R1"
                            },
                            {
                                "type": "text",
                                "text": " Bartosz talks about that in the section on Linear Types."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "5f32b166-1c38-46bc-9867-60b606e612ca",
        "type": "message",
        "text": "So you're saying Hest has monads? :exploding_head:",
        "user": "U8A5MS6R1",
        "ts": "1613515903.151100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PyFg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So you're saying Hest has monads? "
                            },
                            {
                                "type": "emoji",
                                "name": "exploding_head"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1613514848.149300",
        "parent_user_id": "UC2A2ARPT"
    }
]