[
    {
        "client_msg_id": "eed10511-8b29-4adf-a84e-9379d059ecd6",
        "type": "message",
        "text": "&gt; browsers more powerful we could have avoided a lot of the js that gets written. An example I've been thinking about lately is authentication.\nPour one out for <https://en.wikipedia.org/wiki/Mozilla_Persona|Mozilla Persona>.",
        "user": "UC2A2ARPT",
        "ts": "1612923037.144200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "90l",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "browsers more powerful we could have avoided a lot of the js that gets written. An example I've been thinking about lately is authentication."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nPour one out for "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Mozilla_Persona",
                                "text": "Mozilla Persona"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612889095.142000",
        "parent_user_id": "UKDM3GLAJ"
    },
    {
        "client_msg_id": "15ee10e9-3f93-4006-a07e-7061e79db34d",
        "type": "message",
        "text": "<@UCGAK10LS> I wasn't just be silly for the sake of being silly, I was also making a point.\n\nWhat I'm saying (humor aside) is: What really is a program? What's structure? I can achieve that with exact 1:1 perfection but accomplish nothing meaningful (the print example), or have a Turing complete solution that seems like a joke on the surface, but is actually a quite practical solution (Leetcode).\n\nOf course, the first can be replaced with just print statements, and the second with just digits which is basically just a reinvention of machine code. Sounds pointless, but they fixed what's been identified as a real problem at hand.\n\nBut is the problem really in the programming language, i.e. the thing with well defined and unambiguous kinds of pieces and rules for fitting them together? Or is it the medium?\n\nHow about an editor where all the different parts of a program are composable like building blocks? Only things that \"fit together\" can go together. I think Steve Kraus did something about \"Types are shapes\", and I think someone else here did something about \"typed holes\"?\n\nAnyway, I realize I'm taking about solving the problem from there other end (and I understand the merits of textual code in \"the real world\" as it sits today), but I'm just offering a perspective that what if this was treated from the source rather than the sink?\n\nI guess that's the same question (and similar topic in a way) as to why people feel strongly one way or the other (or in different contexts) about static vs dynamic typing. Seriously also explore that thought-space and see what maps back to this one (i.e. only allowing valid syntax vs dealing with any syntax).",
        "user": "UAVCC2X70",
        "ts": "1612939912.145200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NDp",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " I wasn't just be silly for the sake of being silly, I was also making a point.\n\nWhat I'm saying (humor aside) is: What really is a program? What's structure? I can achieve that with exact 1:1 perfection but accomplish nothing meaningful (the print example), or have a Turing complete solution that seems like a joke on the surface, but is actually a quite practical solution (Leetcode).\n\nOf course, the first can be replaced with just print statements, and the second with just digits which is basically just a reinvention of machine code. Sounds pointless, but they fixed what's been identified as a real problem at hand.\n\nBut is the problem really in the programming language, i.e. the thing with well defined and unambiguous kinds of pieces and rules for fitting them together? Or is it the medium?\n\nHow about an editor where all the different parts of a program are composable like building blocks? Only things that \"fit together\" can go together. I think Steve Kraus did something about \"Types are shapes\", and I think someone else here did something about \"typed holes\"?\n\nAnyway, I realize I'm taking about solving the problem from there other end (and I understand the merits of textual code in \"the real world\" as it sits today), but I'm just offering a perspective that what if this was treated from the source rather than the sink?\n\nI guess that's the same question (and similar topic in a way) as to why people feel strongly one way or the other (or in different contexts) about static vs dynamic typing. Seriously also explore that thought-space and see what maps back to this one (i.e. only allowing valid syntax vs dealing with any syntax)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "dadf8827-5df1-41a0-a8a1-e4220e3ce8bd",
        "type": "message",
        "text": "Or how about a combination of both?\n\nMaybe one thing that could mean is code in predefined structural format like Json, Xml, Yaml, S-expressions, etc.\n\nNow, those things can have syntax errors; But the goal isn't really to have exactly no syntax errors; the goal is whatever the goal of having no syntax errors is. Maybe you can get much more from reducing 90% of the syntax problem down to an extremely regular pattern, that many relatively basic editors or validators can already help deal with.\n\nConsider the trade-offs: The range of possible syntax errors becomes a very few things, and many basic tools/editors can make that very simple to deal with (and the errors are trivially obvious when pointed out); You get well defined structure that can be made very meaningful, versus perhaps sacrificing that to some parsing strategy, etc; the format lends itself well to data transfer and various other tools that need know nothing of the \"language\". Etc.\n\nStill I understand that this might not be the direction the discussion is aimed to go in (and thus I won't continue it further here), but in all seriousness I think it's worthwhile food for thought on the topic, at least worth a mention.",
        "user": "UAVCC2X70",
        "ts": "1612941084.145400",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UAVCC2X70",
            "ts": "1612993715.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "K8Zn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Or how about a combination of both?\n\nMaybe one thing that could mean is code in predefined structural format like Json, Xml, Yaml, S-expressions, etc.\n\nNow, those things can have syntax errors; But the goal isn't really to have exactly no syntax errors; the goal is whatever the goal of having no syntax errors is. Maybe you can get much more from reducing 90% of the syntax problem down to an extremely regular pattern, that many relatively basic editors or validators can already help deal with.\n\nConsider the trade-offs: The range of possible syntax errors becomes a very few things, and many basic tools/editors can make that very simple to deal with (and the errors are trivially obvious when pointed out); You get well defined structure that can be made very meaningful, versus perhaps sacrificing that to some parsing strategy, etc; the format lends itself well to data transfer and various other tools that need know nothing of the \"language\". Etc.\n\nStill I understand that this might not be the direction the discussion is aimed to go in (and thus I won't continue it further here), but in all seriousness I think it's worthwhile food for thought on the topic, at least worth a mention."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612656314.123000",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f0ed9f28-d1aa-41c1-b82b-d1bfcc74baf6",
        "type": "message",
        "text": "<@UKDM3GLAJ> In terms of \"more powerful browsers\", major projects from giant incumbents promising secure, network distributed, platform-independent applications were developed in parallel to the modest and very much document-oriented WWW. For example, _Oak_ was a language and virtual machine targeting embedded systems developed at Sun starting in *1989*, which was eventually released (with a billion dollar marketing campaign) under the name _Java_. Most people believed in the mid-90s that the kinds of things we do now with HTML/CSS/JS would be done with Java applets. At the same time, Bell Labs released what they built after Plan9, <https://en.wikipedia.org/wiki/Inferno_(operating_system)|Inferno>, which was an OS/language/virtual machine targeting the same space that (ahem) did not get a billion dollar marketing campaign.\n\nAs for authentication, we talked back in the wayback about using an open PKI-based system to handle auth on the web, but it didn't stick. All of the messiness you see today was grown very organically, sometimes by the unilateral action of one or another vendor and sometimes through standards body design-by-committee, all of it etched in stone forever because of concerns about backwards compatibility. It's an unhappy accident of history that we ended up with everything bolted onto a document viewer. :man-shrugging::skin-tone-2:",
        "user": "U013ZLJARC7",
        "ts": "1612948276.146500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6kg58",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UKDM3GLAJ"
                            },
                            {
                                "type": "text",
                                "text": " In terms of \"more powerful browsers\", major projects from giant incumbents promising secure, network distributed, platform-independent applications were developed in parallel to the modest and very much document-oriented WWW. For example, "
                            },
                            {
                                "type": "text",
                                "text": "Oak",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " was a language and virtual machine targeting embedded systems developed at Sun starting in "
                            },
                            {
                                "type": "text",
                                "text": "1989",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", which was eventually released (with a billion dollar marketing campaign) under the name "
                            },
                            {
                                "type": "text",
                                "text": "Java",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". Most people believed in the mid-90s that the kinds of things we do now with HTML/CSS/JS would be done with Java applets. At the same time, Bell Labs released what they built after Plan9, "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Inferno_(operating_system)",
                                "text": "Inferno"
                            },
                            {
                                "type": "text",
                                "text": ", which was an OS/language/virtual machine targeting the same space that (ahem) did not get a billion dollar marketing campaign.\n\nAs for authentication, we talked back in the wayback about using an open PKI-based system to handle auth on the web, but it didn't stick. All of the messiness you see today was grown very organically, sometimes by the unilateral action of one or another vendor and sometimes through standards body design-by-committee, all of it etched in stone forever because of concerns about backwards compatibility. It's an unhappy accident of history that we ended up with everything bolted onto a document viewer. "
                            },
                            {
                                "type": "emoji",
                                "name": "man-shrugging",
                                "skin_tone": 2
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612889095.142000",
        "parent_user_id": "UKDM3GLAJ"
    }
]