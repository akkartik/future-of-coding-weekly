[
    {
        "client_msg_id": "15f48639-87ce-4173-b5b3-952b651b28a8",
        "type": "message",
        "text": "One thing I've wondered about version control is what a system would look like that focussed on getting the code back to a previous state rather than the pervasive model of linear development towards some goal",
        "user": "URLP9FWR3",
        "ts": "1630137575.005900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lTe",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One thing I've wondered about version control is what a system would look like that focussed on getting the code back to a previous state rather than the pervasive model of linear development towards some goal"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "reply_count": 48,
        "reply_users_count": 5,
        "latest_reply": "1630226101.035300",
        "reply_users": [
            "URLP9FWR3",
            "UDQBTJ211",
            "UCUSW7WVD",
            "UJZS8UUJV",
            "UP00ZLX6G"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT",
                    "UCUSW7WVD",
                    "UA14TGLTC"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "862bf890-a10f-47ba-833b-a3b967662ced",
        "type": "message",
        "text": "So I kept coming back to\n&gt; Normally people would just represent this change over time in the code itself\nThat is, why use something related to VCS as we know it for this purpose? I was thinking \u201cwe only ever actually run the most recent version of the code\u201d and then realized that\u2019s not true when I thought of migrating a cluster: then you have multiple versions of the same code running at once and (potentially) interacting with each other. Your system has to be thought of as including these different versions. Tangental but maybe relevant.",
        "user": "UJZS8UUJV",
        "ts": "1630181786.014200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uwJV5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So I kept coming back to\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Normally people would just represent this change over time in the code itself"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That is, why use something related to VCS as we know it for this purpose? I was thinking \u201cwe only ever actually run the most recent version of the code\u201d and then realized that\u2019s not true when I thought of migrating a cluster: then you have multiple versions of the same code running at once and (potentially) interacting with each other. Your system has to be thought of as including these different versions. Tangental but maybe relevant."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9e52c395-46c6-4cf9-bdbf-4257e16cdb8f",
        "type": "message",
        "text": "It's not true when making music either. Making music is just as valid a use of code as making databases",
        "user": "URLP9FWR3",
        "ts": "1630181951.014400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "tpRT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It's not true when making music either. Making music is just as valid a use of code as making databases"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "03635351-ba76-426a-bf2a-142dc9d89f66",
        "type": "message",
        "text": "maybe more valid as we'll always make music.",
        "user": "URLP9FWR3",
        "ts": "1630182037.014600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=F6a1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "maybe more valid as we'll always make music."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "2909ca8f-272f-452f-9b33-af8974d20942",
        "type": "message",
        "text": "Yeah, I\u2019m all for artistic programming",
        "user": "UJZS8UUJV",
        "ts": "1630182258.014900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sCUf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, I\u2019m all for artistic programming"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "d5de6e98-0f99-4fff-9123-f4b18d3a04ef",
        "type": "message",
        "text": "More generally:\n\u2022 Drawing boundaries is an essential aspect of design. Boundaries allow you to make progress by making simplifying assumptions about a temporary area of concern. \"Practical\" programming often draws a box around \"what's running in the computer right now\". VCS conventionally lies outside that boundary.\n\u2022 Boundaries can also stifle creativity. Questioning boundaries is a super useful activity, as is happening in this thread.",
        "user": "UCUSW7WVD",
        "ts": "1630182374.015100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xU5p",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "More generally:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Drawing boundaries is an essential aspect of design. Boundaries allow you to make progress by making simplifying assumptions about a temporary area of concern. \"Practical\" programming often draws a box around \"what's running in the computer right now\". VCS conventionally lies outside that boundary."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Boundaries can also stifle creativity. Questioning boundaries is a super useful activity, as is happening in this thread."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UJZS8UUJV"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "9adadac8-c209-4810-bac6-3c21b641ba08",
        "type": "message",
        "text": "I have a problem I'd appreciate thoughts on, particularly from aficionados of visual programming. But it requires some setup, if you'll bear with me.. (see thread)",
        "user": "UCUSW7WVD",
        "ts": "1630187035.033600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0OZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have a problem I'd appreciate thoughts on, particularly from aficionados of visual programming. But it requires some setup, if you'll bear with me.. (see thread)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "reply_count": 5,
        "reply_users_count": 3,
        "latest_reply": "1630269783.036400",
        "reply_users": [
            "UCUSW7WVD",
            "UDQBTJ211",
            "UJZS8UUJV"
        ],
        "is_locked": false,
        "subscribed": false
    },
    {
        "client_msg_id": "2e18a0ae-5206-4367-a51d-6ec57c3d2f1c",
        "type": "message",
        "text": "My Mu project (<https://github.com/akkartik/mu>) is building a computing stack up from machine code. The _goal_ is partly to figure out why people don't do real prototyping more often. We all know we should throw the first one away, but we rarely do so. The _hypothesis_ is that we'd be better about throwing the first one away if _rewriting_ was less risky. By the time the prototyping phase ends, a prototype often tacitly encodes lots of information that is risky to rewrite.\n\nTo falsify this hypothesis, I want to make it super easy to turn any manual run into a reproducible automated _test_. If all the tacit knowledge had tests (stuff you naturally did as you built features), rewriting would become a non-risky activity, even if it still requires some effort.\n\nTurning manual tests into automated ones requires carefully tracking _dependencies_ and _outlawing side-effects_. In Mu, functions that modify the screen always take a screen object. That way I can start out with a manual test on the real screen, and easily swap in a fake screen to automate the test. Which brings us to my problem:\n\n&gt; *How do you represent screens in a test?*\nCurrently I represent 2D screens as 2D arrays of characters. That is doable a lot of the time, but complicates many scenarios:\n\u2022 Character attributes. If I want to check the foreground or background color, I currently use primitives like `check-screen-in-bg` which ignores spaces in a 2D array, but checks that non-spaces match the given background attribute. In practice this leads frequently to tests that separately check characters and then go back to check colors and other attributes.\n\u2022 Non-text. Checking pixels scales poorly, either line at a time or pixel at a time. I've tried ideas like separate buffers for text vs pixels, so that at least text continues to test easily.\n\u2022 Proportional fonts. Treating the screen as a grid of characters works only when each character is the same width. If widths differ I end up having to go back to treating characters as collections of pixels.\n\u2022 Unicode. A font like unifont (<http://unifoundry.com/unifont/index.html>) is mostly fixed-width, but lots of graphemes (e.g. Chinese, Japanese, Korean, Indian) still require double-width to render. That takes us back to the problems of proportional fonts.\nCan people think of solutions to any of these bullets in a text-based language? Or a more powerful non-text representation?",
        "user": "UCUSW7WVD",
        "ts": "1630187041.033700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "GNU Unifont Glyphs",
                "title_link": "http://unifoundry.com/unifont/index.html",
                "text": "GNU Unifont free software utilities",
                "fallback": "GNU Unifont Glyphs",
                "from_url": "http://unifoundry.com/unifont/index.html",
                "service_icon": "http://unifoundry.com/favicon.ico",
                "service_name": "unifoundry.com",
                "id": 2,
                "original_url": "http://unifoundry.com/unifont/index.html"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "X+sE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My Mu project ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/akkartik/mu"
                            },
                            {
                                "type": "text",
                                "text": ") is building a computing stack up from machine code. The "
                            },
                            {
                                "type": "text",
                                "text": "goal",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is partly to figure out why people don't do real prototyping more often. We all know we should throw the first one away, but we rarely do so. The "
                            },
                            {
                                "type": "text",
                                "text": "hypothesis",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " is that we'd be better about throwing the first one away if "
                            },
                            {
                                "type": "text",
                                "text": "rewriting",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " was less risky. By the time the prototyping phase ends, a prototype often tacitly encodes lots of information that is risky to rewrite.\n\nTo falsify this hypothesis, I want to make it super easy to turn any manual run into a reproducible automated "
                            },
                            {
                                "type": "text",
                                "text": "test",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". If all the tacit knowledge had tests (stuff you naturally did as you built features), rewriting would become a non-risky activity, even if it still requires some effort.\n\nTurning manual tests into automated ones requires carefully tracking "
                            },
                            {
                                "type": "text",
                                "text": "dependencies",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "outlawing side-effects",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". In Mu, functions that modify the screen always take a screen object. That way I can start out with a manual test on the real screen, and easily swap in a fake screen to automate the test. Which brings us to my problem:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "How do you represent screens in a test?",
                                "style": {
                                    "bold": true
                                }
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCurrently I represent 2D screens as 2D arrays of characters. That is doable a lot of the time, but complicates many scenarios:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Character attributes. If I want to check the foreground or background color, I currently use primitives like "
                                    },
                                    {
                                        "type": "text",
                                        "text": "check-screen-in-bg",
                                        "style": {
                                            "code": true
                                        }
                                    },
                                    {
                                        "type": "text",
                                        "text": " which ignores spaces in a 2D array, but checks that non-spaces match the given background attribute. In practice this leads frequently to tests that separately check characters and then go back to check colors and other attributes."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Non-text. Checking pixels scales poorly, either line at a time or pixel at a time. I've tried ideas like separate buffers for text vs pixels, so that at least text continues to test easily."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Proportional fonts. Treating the screen as a grid of characters works only when each character is the same width. If widths differ I end up having to go back to treating characters as collections of pixels."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Unicode. A font like unifont ("
                                    },
                                    {
                                        "type": "link",
                                        "url": "http://unifoundry.com/unifont/index.html"
                                    },
                                    {
                                        "type": "text",
                                        "text": ") is mostly fixed-width, but lots of graphemes (e.g. Chinese, Japanese, Korean, Indian) still require double-width to render. That takes us back to the problems of proportional fonts."
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nCan people think of solutions to any of these bullets in a text-based language? Or a more powerful non-text representation?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "168c6ef7-ff27-4480-8de0-d91206a82fdc",
        "type": "message",
        "text": "I think I disagree - creativity thrives off boundaries. Unbound creativity is noise",
        "user": "URLP9FWR3",
        "ts": "1630187884.034100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xPIC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think I disagree - creativity thrives off boundaries. Unbound creativity is noise"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "4b717c1f-ff64-45a8-8b09-28accce4ff01",
        "type": "message",
        "text": "Creativity is about pushing against and beyond boundaries but you still need the boundaries",
        "user": "URLP9FWR3",
        "ts": "1630187954.034300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YixQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Creativity is about pushing against and beyond boundaries but you still need the boundaries"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "e63622ef-21ca-4434-a94d-37bab82b0aa6",
        "type": "message",
        "text": "I agree :slightly_smiling_face:",
        "user": "UCUSW7WVD",
        "ts": "1630188011.034500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5ss3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "URLP9FWR3"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e5dae83a-5627-4f43-9ab4-acaca96697cd",
        "type": "message",
        "text": "As a hack, I wonder if you could use Continuous Integration (eg, github actions, CircleCI) to generate visualisations/aural representations, as you commit code (maybe generate new branches for units of time if need be)\u2026so you can see snapshots of your past in whatever visual/aural form you\u2019d like, to better \u201csee\u201d where you want to scrub back in time to. So to jump to a point in time, you\u2019d just do `git reset --hard [sha]` . Interactive rebasing could work too, as long as CI regenerates the snapshots",
        "user": "UP00ZLX6G",
        "ts": "1630194537.034800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D3lI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "As a hack, I wonder if you could use Continuous Integration (eg, github actions, CircleCI) to generate visualisations/aural representations, as you commit code (maybe generate new branches for units of time if need be)\u2026so you can see snapshots of your past in whatever visual/aural form you\u2019d like, to better \u201csee\u201d where you want to scrub back in time to. So to jump to a point in time, you\u2019d just do "
                            },
                            {
                                "type": "text",
                                "text": "git reset --hard [sha]",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " . Interactive rebasing could work too, as long as CI regenerates the snapshots"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3"
    },
    {
        "client_msg_id": "db8eee76-a81c-430f-9720-4dcfafb11408",
        "type": "message",
        "text": "If you are talking about live coding music like an algorave then I think you want something that somehow projects the code into a low dimensional space. In this space, \"commits\" would just be waypoint markers that are set down. So you could mark where your verse/chorus is then explore freely and get some sense of when you were getting back close to where you were.\n\nWhile this appears ridiculous at first I've seen some really impressive dimensional reduction things on Chris Olah's blog. If you also limit yourself in terms of starting dimensionality this might work and could really add something to a live coding performance to see the path that the performer took.\n\nI went to an algorave where there was a performance by two people editing the same code. They had two cursors and their edits showed up in different colours. It meant you could see exactly how each of them was remixing each others lines and how they were both contributing. It really added to it.",
        "user": "UDQBTJ211",
        "ts": "1630226101.035300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "2oC1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "If you are talking about live coding music like an algorave then I think you want something that somehow projects the code into a low dimensional space. In this space, \"commits\" would just be waypoint markers that are set down. So you could mark where your verse/chorus is then explore freely and get some sense of when you were getting back close to where you were.\n\nWhile this appears ridiculous at first I've seen some really impressive dimensional reduction things on Chris Olah's blog. If you also limit yourself in terms of starting dimensionality this might work and could really add something to a live coding performance to see the path that the performer took.\n\nI went to an algorave where there was a performance by two people editing the same code. They had two cursors and their edits showed up in different colours. It meant you could see exactly how each of them was remixing each others lines and how they were both contributing. It really added to it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630137575.005900",
        "parent_user_id": "URLP9FWR3",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "97b95415-9a50-4d87-bef9-db0b91954be2",
        "type": "message",
        "text": "My instinct would be to accept that you are ultimately going to be checking pixels and see how far you can get with that. For example, saving draw calls instead of raw pixel values, tracking dirty regions/some kind of copy-on-write. Combining some zealous saving of state with some amount of recalculating can be pretty efficient.",
        "user": "UDQBTJ211",
        "ts": "1630227238.035500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7cFH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My instinct would be to accept that you are ultimately going to be checking pixels and see how far you can get with that. For example, saving draw calls instead of raw pixel values, tracking dirty regions/some kind of copy-on-write. Combining some zealous saving of state with some amount of recalculating can be pretty efficient."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "1c61128e-37b9-4c82-bd88-222ae1235f7e",
        "type": "message",
        "text": "Oh I'm actually not thinking about performance. I meant it's hard to make tests that are self evident when they're about pixel events. Extremely long lines, etc.",
        "user": "UCUSW7WVD",
        "ts": "1630242618.035900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MrmLj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh I'm actually not thinking about performance. I meant it's hard to make tests that are self evident when they're about pixel events. Extremely long lines, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "b4537ed1-e8f9-4507-9cc8-66a418291405",
        "type": "message",
        "text": "So you\u2019ve already decided you need to test for all these things, right? You\u2019re just trying to figure out the best way to model the state of the screen to cover all these cases?",
        "user": "UJZS8UUJV",
        "ts": "1630268797.036200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KIz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So you\u2019ve already decided you need to test for all these things, right? You\u2019re just trying to figure out the best way to model the state of the screen to cover all these cases?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "6a434f02-e79d-492c-bd39-5bdf297e5121",
        "type": "message",
        "text": "Yeah. It's even just the syntax. In a complex app drawing to screen what's the cleanest way to represent desired screen state in the interface and get nice error messages (that use that representation) on test failure.",
        "user": "UCUSW7WVD",
        "ts": "1630269783.036400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "nVn0n",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah. It's even just the syntax. In a complex app drawing to screen what's the cleanest way to represent desired screen state in the interface and get nice error messages (that use that representation) on test failure."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1630187035.033600",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJZS8UUJV"
                ],
                "count": 1
            }
        ]
    }
]