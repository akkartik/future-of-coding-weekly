[
    {
        "client_msg_id": "6012ca88-2e7a-48fa-b86a-014462995c29",
        "type": "message",
        "text": "What minimal, universal AST specifications exist? Which are best?\n\nSoftware that deals with code in multiple languages usually needs to handle that code in a common format. But trying to capture complete language semantics for all languages in a single format seems hopeless. Instead, we\u2019re faced with a trade-off between the variety of languages we represent and the thoroughness of the representation. On one end, text data is essentially entirely universal (caveat: encodings), but is very low level. On the other extreme, a given language compiler\u2019s AST format fully represents semantics, but only for that one language. There are also some complete AST formats for families of closely related languages. Language-independent compiler IRs like the LLVM IR represent code in many different languages, but I think their usefulness is limited because they require irreversible transformations (they always would, right?).\n\nI\u2019m interested in the spot just above text: interface specifications that can represent code as basic data structures for _nearly_ all languages, with little to no specification of semantics. So generally little more than a tree spec with room left for language-specific data.\n\nI\u2019m only aware a few specifications like that:\n\n\u2022 as a baseline, s-expressions (not the textual format, just the concept of nested lists)\n\u2022 Babelfish\u2019s <https://github.com/bblfsh/documentation/blob/master/uast/uast-specification-v2.md|UAST> \u2014 they lost their web domain, so presumed dead\n\u2022 unifiedjs\u2019s <https://github.com/syntax-tree/unist|unist> \u2014 I\u2019m thinking of adopting this for my structure editor because its ecosystem seems healthy and my project is in JavaScript, but to date it\u2019s largely used for markup languages\nDo you know of any similar specifications? What are other projects using? Are you in a different spot on the trade-off spectrum?",
        "user": "UJZS8UUJV",
        "ts": "1629824355.111500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJZS8UUJV",
            "ts": "1629824444.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TYmt",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What minimal, universal AST specifications exist? Which are best?\n\nSoftware that deals with code in multiple languages usually needs to handle that code in a common format. But trying to capture complete language semantics for all languages in a single format seems hopeless. Instead, we\u2019re faced with a trade-off between the variety of languages we represent and the thoroughness of the representation. On one end, text data is essentially entirely universal (caveat: encodings), but is very low level. On the other extreme, a given language compiler\u2019s AST format fully represents semantics, but only for that one language. There are also some complete AST formats for families of closely related languages. Language-independent compiler IRs like the LLVM IR represent code in many different languages, but I think their usefulness is limited because they require irreversible transformations (they always would, right?).\n\nI\u2019m interested in the spot just above text: interface specifications that can represent code as basic data structures for "
                            },
                            {
                                "type": "text",
                                "text": "nearly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " all languages, with little to no specification of semantics. So generally little more than a tree spec with room left for language-specific data.\n\nI\u2019m only aware a few specifications like that:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "as a baseline, s-expressions (not the textual format, just the concept of nested lists)"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Babelfish\u2019s "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://github.com/bblfsh/documentation/blob/master/uast/uast-specification-v2.md",
                                        "text": "UAST"
                                    },
                                    {
                                        "type": "text",
                                        "text": " \u2014 they lost their web domain, so presumed dead"
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "unifiedjs\u2019s "
                                    },
                                    {
                                        "type": "link",
                                        "url": "https://github.com/syntax-tree/unist",
                                        "text": "unist"
                                    },
                                    {
                                        "type": "text",
                                        "text": " \u2014 I\u2019m thinking of adopting this for my structure editor because its ecosystem seems healthy and my project is in JavaScript, but to date it\u2019s largely used for markup languages"
                                    }
                                ]
                            }
                        ],
                        "style": "bullet",
                        "indent": 0,
                        "border": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nDo you know of any similar specifications? What are other projects using? Are you in a different spot on the trade-off spectrum?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "reply_count": 22,
        "reply_users_count": 5,
        "latest_reply": "1630002447.002000",
        "reply_users": [
            "UJZS8UUJV",
            "UJBAJNFLK",
            "UCUSW7WVD",
            "UMVFWPZ36",
            "U02BBHT50KD"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "dc16ab65-8cc7-45be-99a1-defaf4949aaa",
        "type": "message",
        "text": "On disk, I just store those data structures as JSON, but it could be any serialization language if you have a parser for it. unist (#3 above) has the same philosophy.",
        "user": "UJZS8UUJV",
        "ts": "1629843767.115700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJZS8UUJV",
            "ts": "1629843777.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "9fF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "On disk, I just store those data structures as JSON, but it could be any serialization language if you have a parser for it. unist (#3 above) has the same philosophy."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    },
    {
        "client_msg_id": "c50a6be8-aa7a-4317-9a9d-53db5ab80438",
        "type": "message",
        "text": "This might be more relevant to interop: <https://dion.systems/blog_0002_roadmap.html>",
        "user": "UCUSW7WVD",
        "ts": "1629850983.116000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SMzog",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This might be more relevant to interop: "
                            },
                            {
                                "type": "link",
                                "url": "https://dion.systems/blog_0002_roadmap.html"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "627de68c-4b3a-4f6b-b8ac-836f93a79193",
        "type": "message",
        "text": "<@UCUSW7WVD> nice, seems like their doing something in this zone, I\u2019m going to hop on their discord",
        "user": "UJZS8UUJV",
        "ts": "1629855791.116200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fc+3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " nice, seems like their doing something in this zone, I\u2019m going to hop on their discord"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV",
        "reactions": [
            {
                "name": "heart",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "95f6942a-9e09-42c3-95b6-19e624d5a7b1",
        "type": "message",
        "text": "A bit of personal experience in this space: In the first iteration of my <https://github.com/khinsen/leibniz|Digital Scientific Notation Leibniz> (which is _not_ a programming language, but still a formal language with syntax and semantics), I opted for an XML representation of the AST in order to permit processing Leibniz code more easily, without having to implement a parser. I picked XML over s-expressions because of better tooling support in various languages, and XML over JSON because of the richer structuring possibilities.\n\nI had no intention of doing anything one could call universal, but then, XML or s-expressions may well be as close to universal as one can get: a tree structure. Now I wonder: is there anything beyond the tree structure that is universal about ASTs?",
        "user": "UJBAJNFLK",
        "ts": "1629874875.116800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "GitHub - khinsen/leibniz: A Digital Scientific Notation",
                "title_link": "https://github.com/khinsen/leibniz",
                "text": "A Digital Scientific Notation. Contribute to khinsen/leibniz development by creating an account on GitHub.",
                "fallback": "GitHub: GitHub - khinsen/leibniz: A Digital Scientific Notation",
                "image_url": "https://opengraph.githubassets.com/48dcfb0752b7e92d108bc8c38626e09e155ae50941de71f9cf9f29e16faaa42d/khinsen/leibniz",
                "image_width": 500,
                "image_height": 250,
                "from_url": "https://github.com/khinsen/leibniz",
                "image_bytes": 93813,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/khinsen/leibniz"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "o64M",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "A bit of personal experience in this space: In the first iteration of my "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/khinsen/leibniz",
                                "text": "Digital Scientific Notation Leibniz"
                            },
                            {
                                "type": "text",
                                "text": " (which is "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " a programming language, but still a formal language with syntax and semantics), I opted for an XML representation of the AST in order to permit processing Leibniz code more easily, without having to implement a parser. I picked XML over s-expressions because of better tooling support in various languages, and XML over JSON because of the richer structuring possibilities.\n\nI had no intention of doing anything one could call universal, but then, XML or s-expressions may well be as close to universal as one can get: a tree structure. Now I wonder: is there anything beyond the tree structure that is universal about ASTs?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U027P92A0N5",
                    "UMVFWPZ36"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "ca6e41e2-976a-4073-a389-096f0c649445",
        "type": "message",
        "text": "<https://en.wikipedia.org/wiki/Concatenative_programming_language>\nmight be relevant.",
        "user": "U02BBHT50KD",
        "ts": "1629876986.117100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bmU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Concatenative_programming_language"
                            },
                            {
                                "type": "text",
                                "text": "\nmight be relevant."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    },
    {
        "client_msg_id": "9067674e-f26e-4537-99ee-dcd1d54dabfe",
        "type": "message",
        "text": "Indeed. Forth and Factor (the only concatenative languages I know a bit) pose the same challenge for a universal AST as Common Lisp with its reader macros: how to handle languages that permit extending the parser?",
        "user": "UJBAJNFLK",
        "ts": "1629898076.117700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "sXSII",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Indeed. Forth and Factor (the only concatenative languages I know a bit) pose the same challenge for a universal AST as Common Lisp with its reader macros: how to handle languages that permit extending the parser?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    },
    {
        "client_msg_id": "d4ecfabc-4a24-4e3b-bc4b-dbe7c908a7d5",
        "type": "message",
        "text": "<@U02BBHT50KD> is the parser extension Konrad mentioned what you were suggesting there? (I thought for a second you meant the ASTs in those langs aren\u2019t well represented as trees?)\n\n<@UJBAJNFLK> what could I search for learn more about that?",
        "user": "UJZS8UUJV",
        "ts": "1629945438.000100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cletD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U02BBHT50KD"
                            },
                            {
                                "type": "text",
                                "text": " is the parser extension Konrad mentioned what you were suggesting there? (I thought for a second you meant the ASTs in those langs aren\u2019t well represented as trees?)\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " what could I search for learn more about that?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    },
    {
        "client_msg_id": "6230b275-d15d-4972-ad83-a711a0cf91a3",
        "type": "message",
        "text": "I meant to say that it is possible to have a stack of words and atoms as an another form of AST. I have been working on some sort of translator from clojure to concatenative language (in-house language based on joy) some time ago. And that was surprisingly nice.",
        "user": "U02BBHT50KD",
        "ts": "1629965799.000700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SXZd",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I meant to say that it is possible to have a stack of words and atoms as an another form of AST. I have been working on some sort of translator from clojure to concatenative language (in-house language based on joy) some time ago. And that was surprisingly nice."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJZS8UUJV"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8152d2df-57a8-4c96-b84f-56a8a1a3ff9b",
        "type": "message",
        "text": "<@UJZS8UUJV> Check out <https://lisper.in/reader-macros|Reader Macros in Common Lisp>, <https://docs.factorcode.org/content/article-parsing-words.html|Parsing words> from the Factor documentation, and <https://forth-standard.org/standard/core/PARSE|PARSE> from the Forth standard. All three are extension mechanisms for the language's parser, implemented in the language itself. Which means that a complete parser for either of these languages must include an implementation of the entire language.\nIn Common Lisp, this is not much of an issue except if you want to write a code processing tool in a different language. There is a well-defined representation of code after parsing, which is the level at which macros work. Moreover, reader macros are a rare in practice.\nFor Forth and Factor, parser extensions are very common and basically mean that there is no notion of an AST at all. As an example, consider the <https://docs.factorcode.org/content/article-xml.html|XML parser> in Factor. It allows you to embed XML documents in Factor code, not as a string but as a syntax extension. Superficially, Factor code is a just a sequence of space-delimited words, but with embedded XML, it starts to look very different.",
        "user": "UJBAJNFLK",
        "ts": "1629965842.000900",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Reader Macros in Common Lisp",
                "title_link": "https://lisper.in/reader-macros",
                "text": "Essays on programming, technology and other things",
                "fallback": "Reader Macros in Common Lisp",
                "from_url": "https://lisper.in/reader-macros",
                "service_name": "lisper.in",
                "id": 1,
                "original_url": "https://lisper.in/reader-macros"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dlfes",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJZS8UUJV"
                            },
                            {
                                "type": "text",
                                "text": " Check out "
                            },
                            {
                                "type": "link",
                                "url": "https://lisper.in/reader-macros",
                                "text": "Reader Macros in Common Lisp"
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.factorcode.org/content/article-parsing-words.html",
                                "text": "Parsing words"
                            },
                            {
                                "type": "text",
                                "text": " from the Factor documentation, and "
                            },
                            {
                                "type": "link",
                                "url": "https://forth-standard.org/standard/core/PARSE",
                                "text": "PARSE"
                            },
                            {
                                "type": "text",
                                "text": " from the Forth standard. All three are extension mechanisms for the language's parser, implemented in the language itself. Which means that a complete parser for either of these languages must include an implementation of the entire language.\nIn Common Lisp, this is not much of an issue except if you want to write a code processing tool in a different language. There is a well-defined representation of code after parsing, which is the level at which macros work. Moreover, reader macros are a rare in practice.\nFor Forth and Factor, parser extensions are very common and basically mean that there is no notion of an AST at all. As an example, consider the "
                            },
                            {
                                "type": "link",
                                "url": "https://docs.factorcode.org/content/article-xml.html",
                                "text": "XML parser"
                            },
                            {
                                "type": "text",
                                "text": " in Factor. It allows you to embed XML documents in Factor code, not as a string but as a syntax extension. Superficially, Factor code is a just a sequence of space-delimited words, but with embedded XML, it starts to look very different."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    },
    {
        "client_msg_id": "907a9c59-4dd1-46bd-bb38-500c777768a5",
        "type": "message",
        "text": "<@UJBAJNFLK> thanks!",
        "user": "UJZS8UUJV",
        "ts": "1630002447.002000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "D=dHk",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " thanks!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1629824355.111500",
        "parent_user_id": "UJZS8UUJV"
    }
]