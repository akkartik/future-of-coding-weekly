[
    {
        "client_msg_id": "7d3ad29d-d034-47ba-a260-20ba2722f790",
        "type": "message",
        "text": "&gt; I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions\nUsing the same abstraction does not mean requiring the same constraints.\nAnd continuing with graphics as an example, things like feature flags for OpenGL are used all the time to provide different feature sets depending on hardware capability.\nSimilarly, Erlang and most actor models have ways to query the available resources for a particular process. Smalltalk has this as well.\n\n&gt; In some cases\u00a0(most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.\nIt is a matter of opinion about what is interesting...\nThe fact that I can still use my laptop if one of the GPU's fails seems pretty damn useful to me personally, even if the experience is degraded.\nIn the network case, variable bitrate video is also extremely interesting. If my network is suddenly over saturated or degraded, I used to not be able to play a video on Youtube at all, or my video call would be disconnected.\nWith variable bitrate streaming, the quality is simply lowered.... Same abstraction, that has built in semantics for heterogenous capabilities (dynamically changing capability btw)",
        "user": "U01661S9F34",
        "ts": "1611097341.039800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oVO",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Using the same abstraction does not mean requiring the same constraints.\nAnd continuing with graphics as an example, things like feature flags for OpenGL are used all the time to provide different feature sets depending on hardware capability.\nSimilarly, Erlang and most actor models have ways to query the available resources for a particular process. Smalltalk has this as well.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In some cases\u00a0(most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It is a matter of opinion about what is interesting...\nThe fact that I can still use my laptop if one of the GPU's fails seems pretty damn useful to me personally, even if the experience is degraded.\nIn the network case, variable bitrate video is also extremely interesting. If my network is suddenly over saturated or degraded, I used to not be able to play a video on Youtube at all, or my video call would be disconnected.\nWith variable bitrate streaming, the quality is simply lowered.... Same abstraction, that has built in semantics for heterogenous capabilities (dynamically changing capability btw)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c220ef54-f3f5-4371-be33-7582c2bcf558",
        "type": "message",
        "text": "Not all applications can gracefully downgrade, and a ton of effort goes into supporting that.  For example, Cyberpunk 2077 got delisted because it actually wasn't playable on last generation console hardware.  If your discrete GPU dies and you're playing the game on PC it will be unplayable (either functionally or actually due to lack of capabilities).  You could apply the same logic to machine learning training and other GPU tasks that require high compute.  Also its great that your laptop keeps running, but I'm not sure how a distributed systems approach in a user land application programming language fixes that?  Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?",
        "user": "UBSMEUXAA",
        "ts": "1611098365.040000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yy8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not all applications can gracefully downgrade, and a ton of effort goes into supporting that.  For example, Cyberpunk 2077 got delisted because it actually wasn't playable on last generation console hardware.  If your discrete GPU dies and you're playing the game on PC it will be unplayable (either functionally or actually due to lack of capabilities).  You could apply the same logic to machine learning training and other GPU tasks that require high compute.  Also its great that your laptop keeps running, but I'm not sure how a distributed systems approach in a user land application programming language fixes that?  Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "ab4cdd85-4083-46b3-8c9c-f641fd8a6d20",
        "type": "message",
        "text": "Not all distributed databases are usable if the network failure is bad enough, That doesn't mean the abstraction is wrong.\nThere are always failure cases that cannot be recovered from. It does not mean using an abstraction of heterogenous and distributed computing is a bad model (your original point iiuc).\n\n&gt; Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?\nThis is exactly what things like micro-kernels and Docker do. IPC is a form of distributed abstraction.",
        "user": "U01661S9F34",
        "ts": "1611099503.040200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611099546.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rY88",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not all distributed databases are usable if the network failure is bad enough, That doesn't mean the abstraction is wrong.\nThere are always failure cases that cannot be recovered from. It does not mean using an abstraction of heterogenous and distributed computing is a bad model (your original point iiuc).\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe the idea is it could make it easier for driver and kernel developers to implement local failsafe?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This is exactly what things like micro-kernels and Docker do. IPC is a form of distributed abstraction."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "44b84b21-59d1-4efa-ada4-640286fa2b5b",
        "type": "message",
        "text": "&gt; I'm not sure how a distributed systems approach in a user land application programming language fixes that?\nThe point of exposing these to the user application level is that the application can have a say in how the failure is handled. Cyberpunk 2077 maybe can't run if the GPU fails, but Microsoft Word still can. You want to allow both options.",
        "user": "U01661S9F34",
        "ts": "1611099909.040500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6pt4",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm not sure how a distributed systems approach in a user land application programming language fixes that?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The point of exposing these to the user application level is that the application can have a say in how the failure is handled. Cyberpunk 2077 maybe can't run if the GPU fails, but Microsoft Word still can. You want to allow both options."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7157016a-e883-41ac-83ae-2252a1171f75",
        "type": "message",
        "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?  What features of distributed programming are generally not necessary for local hardware? GPU programmers do have to handle device removed (<https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios>), which could mean try to reinitialize and reload, and that could mean using a different device, but it also could mean crash or quit.  I'm focused on GPUs because I'm a graphics programmer, but I imagine you could apply this to any specific hardware (storage, audio, etc.) Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?",
        "user": "UBSMEUXAA",
        "ts": "1611100075.040700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Handle device removed scenarios in Direct3D 11 - UWP applications",
                "title_link": "https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios",
                "text": "This topic explains how to recreate the Direct3D and DXGI device interface chain when the graphics adapter is removed or reinitialized.",
                "fallback": "Handle device removed scenarios in Direct3D 11 - UWP applications",
                "thumb_url": "https://docs.microsoft.com/en-us/media/logos/logo-ms-social.png",
                "from_url": "https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://docs.microsoft.com/favicon.ico",
                "service_name": "docs.microsoft.com",
                "id": 1,
                "original_url": "https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oNGC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?  What features of distributed programming are generally not necessary for local hardware? GPU programmers do have to handle device removed ("
                            },
                            {
                                "type": "link",
                                "url": "https://docs.microsoft.com/en-us/windows/uwp/gaming/handling-device-lost-scenarios"
                            },
                            {
                                "type": "text",
                                "text": "), which could mean try to reinitialize and reload, and that could mean using a different device, but it also could mean crash or quit.  I'm focused on GPUs because I'm a graphics programmer, but I imagine you could apply this to any specific hardware (storage, audio, etc.) Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "7dc7324a-aaa7-4f12-83ea-213383291892",
        "type": "message",
        "text": "Similarly for security models. In docker or CGroups situation, you may or may not have access to a system resource depending on the security policy. Your application can decide how to handle that. Your database may try to set up a database on a certain file system, but if it doesn't have access, maybe it falls back to a memory backed store.",
        "user": "U01661S9F34",
        "ts": "1611100088.041000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6=wgV",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Similarly for security models. In docker or CGroups situation, you may or may not have access to a system resource depending on the security policy. Your application can decide how to handle that. Your database may try to set up a database on a certain file system, but if it doesn't have access, maybe it falls back to a memory backed store."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c7169fa7-721d-49d0-85d2-5cb9e936fe32",
        "type": "message",
        "text": "&gt; I'm focused on GPUs because I'm a graphics programmer\nI'm a database programmer, so this is fun to compare perspectives :slightly_smiling_face:",
        "user": "U01661S9F34",
        "ts": "1611100154.041200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l=C9",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm focused on GPUs because I'm a graphics programmer"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm a database programmer, so this is fun to compare perspectives "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "0caa8245-cd6e-4307-b0fa-b36dae537064",
        "type": "message",
        "text": "&gt; I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?\n&gt; Maybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?\nMicrokernels are the best practical example I can think of that try to do exactly this: <http://www.microkernel.info>\n\nIt's more about security and reliability. It does have a performance cost. (Which I'm sure sounds like pure pain to a GPU programmer lol)",
        "user": "U01661S9F34",
        "ts": "1611100637.041500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "daZ",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I'm stuck on... What do we get if we treat a local machine like a distributed system?\nMaybe the issue is this all handled at OS level, should be to implement the OS in a different way rather than try to abstract over all OS APIs?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Microkernels are the best practical example I can think of that try to do exactly this: "
                            },
                            {
                                "type": "link",
                                "url": "http://www.microkernel.info"
                            },
                            {
                                "type": "text",
                                "text": "\n\nIt's more about security and reliability. It does have a performance cost. (Which I'm sure sounds like pure pain to a GPU programmer lol)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "09485a9a-648f-4b64-88eb-a5e706eacf00",
        "type": "message",
        "text": "Your example about cloud GPU is already here as well, That's basically what Google Stadia is.",
        "user": "U01661S9F34",
        "ts": "1611100790.041700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ACQ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your example about cloud GPU is already here as well, That's basically what Google Stadia is."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "6fd185d5-f122-481f-8111-b2b189512e1f",
        "type": "message",
        "text": "When I started the thread I was thinking about all the ways in which non-programmable processors (built out of programmable components!) hide inside our computers. It's a place for bugs and especially security issues to hide. It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them. I said \"distributed computing\" just because it was the closest term I could think of, but it did pull in unintended connotations that it's been interesting to see explored :slightly_smiling_face:",
        "user": "UCUSW7WVD",
        "ts": "1611100992.041900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YxL+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I started the thread I was thinking about all the ways in which non-programmable processors (built out of programmable components!) hide inside our computers. It's a place for bugs and especially security issues to hide. It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them. I said \"distributed computing\" just because it was the closest term I could think of, but it did pull in unintended connotations that it's been interesting to see explored "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c05cd72c-64e2-48dc-96ca-bb04345a5437",
        "type": "message",
        "text": "&gt; It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them.\nThis sounds like the idea of a microkernel taken to the level of firmware / BIOS / UEFI. Sounds like an awesome research project to explore :star-struck:",
        "user": "U01661S9F34",
        "ts": "1611101248.042100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GbtsE",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It might be an interesting exercise to ask how we might bootstrap a computer from a single tiny bit of RAM, either by building hardcoded circuits or requiring an upstream device to initialize them."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This sounds like the idea of a microkernel taken to the level of firmware / BIOS / UEFI. Sounds like an awesome research project to explore "
                            },
                            {
                                "type": "emoji",
                                "name": "star-struck"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "64fec974-b687-4041-af2e-b5bbf2abe382",
        "type": "message",
        "text": "I'm also reminded of a podcast I listened to a while ago: <https://oxide.computer/podcast/on-the-metal-3-ron-minnich/>\nGoogle does some of this kind of thing on their servers, and also on chrome-books with U-root. (Trusting trust type stuff at the firmware level.)\nIt's frustratingly difficult because the hardware vendors do not want this. It has taken companies like Google, Facebook, and Amazon to strong arm them into opening up their firmware more....",
        "user": "U01661S9F34",
        "ts": "1611101846.042300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611101886.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LKj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm also reminded of a podcast I listened to a while ago: "
                            },
                            {
                                "type": "link",
                                "url": "https://oxide.computer/podcast/on-the-metal-3-ron-minnich/"
                            },
                            {
                                "type": "text",
                                "text": "\nGoogle does some of this kind of thing on their servers, and also on chrome-books with U-root. (Trusting trust type stuff at the firmware level.)\nIt's frustratingly difficult because the hardware vendors do not want this. It has taken companies like Google, Facebook, and Amazon to strong arm them into opening up their firmware more...."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "33ee2ad4-b990-4d48-945a-d89a0db68292",
        "type": "message",
        "text": "Also, Alan Kay's quote as mentioned by <@U0112C10V4Y>\n&gt; \"Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine.\"\nI remember talking to <@UCUSW7WVD> about this exact quote a while ago.\nThe closest modern equivalent we have is probably FPGAs.",
        "user": "U01661S9F34",
        "ts": "1611102388.042700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01661S9F34",
            "ts": "1611102411.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qdN5V",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, Alan Kay's quote as mentioned by "
                            },
                            {
                                "type": "user",
                                "user_id": "U0112C10V4Y"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\"Another example: all the Parc personal computers of various kinds were microcoded, and in the latter 70s you could sit down to any of them to e.g. run Smalltalk, whose image would be sent from a server, and the machine type would select the special microcode for the Smalltalk VM on that machine.\""
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I remember talking to "
                            },
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " about this exact quote a while ago.\nThe closest modern equivalent we have is probably FPGAs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a6af23b1-8478-4ebc-8b40-ab801f0ff0bb",
        "type": "message",
        "text": "Yeah I was probably being way too specific about what the definition of distributed system is now that we're explicitly talking about distributed systems *within* hardware. Back to the original post, what I know of FPGA architecture, it's laid out in a similar way as MFM",
        "user": "UBSMEUXAA",
        "ts": "1611107643.043300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "YsU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I was probably being way too specific about what the definition of distributed system is now that we're explicitly talking about distributed systems "
                            },
                            {
                                "type": "text",
                                "text": "within ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "hardware. Back to the original post, what I know of FPGA architecture, it's laid out in a similar way as MFM"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD",
                    "U01661S9F34"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "df78a7fd-2762-4560-9e6c-0388da7e24cf",
        "type": "message",
        "text": "I have a question, and maybe it is already something that exists. But I do not know and hence asking here (also kind of food for thought). I was wondering if there is any language which has been designed from ground up to make mathematical formalism as a first class citizen. Precisely I was thinking some kind of way to write set builder notation and then built-in functions to perform and  generate (here the generate word is used in a double meaning, think about generators, as some of those operations can generate infinite data) basic operations, such that intersection, union, sigma algebra, and such?\n\nIt is something I am thinking. As having something like this will open up doors to programming into a lot of mathematical domains pretty accessible. Topology, Measure theory, Order Theory, Category Theory etc. etc.",
        "user": "UPVBV34EL",
        "ts": "1611150525.049900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MxJi",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have a question, and maybe it is already something that exists. But I do not know and hence asking here (also kind of food for thought). I was wondering if there is any language which has been designed from ground up to make mathematical formalism as a first class citizen. Precisely I was thinking some kind of way to write set builder notation and then built-in functions to perform and  generate (here the generate word is used in a double meaning, think about generators, as some of those operations can generate infinite data) basic operations, such that intersection, union, sigma algebra, and such?\n\nIt is something I am thinking. As having something like this will open up doors to programming into a lot of mathematical domains pretty accessible. Topology, Measure theory, Order Theory, Category Theory etc. etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "reply_count": 9,
        "reply_users_count": 8,
        "latest_reply": "1611360200.014900",
        "reply_users": [
            "U013ZLJARC7",
            "UJBAJNFLK",
            "UPVBV34EL",
            "U01AD80KMLK",
            "U019CPED6T1",
            "UFPRPSA4S",
            "UA14TGLTC",
            "UDKTZSD6H"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "713b303c-1949-4efc-abcb-f94346956fbb",
        "type": "message",
        "text": "Consider Agda, for example this recursive set tutorial:\n<https://people.inf.elte.hu/divip/AgdaTutorial/Sets.Recursive.html#1>",
        "user": "U013ZLJARC7",
        "ts": "1611151281.050600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1AO2x",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Consider Agda, for example this recursive set tutorial:\n"
                            },
                            {
                                "type": "link",
                                "url": "https://people.inf.elte.hu/divip/AgdaTutorial/Sets.Recursive.html#1"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "parent_user_id": "UPVBV34EL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UPVBV34EL",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "658bd53a-c78b-4091-bf71-6bcf16e59d9e",
        "type": "message",
        "text": "Not sure anything corresponds exactly to what you are looking for, but Lean (<https://leanprover.github.io/about/>) is certainly worth a look, as are other proof-oriented languages such as Coq's (<https://coq.inria.fr/>) underlying language Gallina. Computer algebra systems are another candidate. Axiom (<https://github.com/daly/axiom>) is huge but also the most likely to contain what you are looking for. There are also more specialized systems popular in specific branches of mathematics, which unfortunately I don't know much about.",
        "user": "UJBAJNFLK",
        "ts": "1611151484.050800",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "daly/axiom",
                "title_link": "https://github.com/daly/axiom",
                "text": "Axiom is a free, open source computer algebra system - daly/axiom",
                "fallback": "GitHub: daly/axiom",
                "thumb_url": "https://avatars0.githubusercontent.com/u/1325?s=400&v=4",
                "from_url": "https://github.com/daly/axiom",
                "thumb_width": 100,
                "thumb_height": 100,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/daly/axiom"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rgyz",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not sure anything corresponds exactly to what you are looking for, but Lean ("
                            },
                            {
                                "type": "link",
                                "url": "https://leanprover.github.io/about/"
                            },
                            {
                                "type": "text",
                                "text": ") is certainly worth a look, as are other proof-oriented languages such as Coq's ("
                            },
                            {
                                "type": "link",
                                "url": "https://coq.inria.fr/"
                            },
                            {
                                "type": "text",
                                "text": ") underlying language Gallina. Computer algebra systems are another candidate. Axiom ("
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/daly/axiom"
                            },
                            {
                                "type": "text",
                                "text": ") is huge but also the most likely to contain what you are looking for. There are also more specialized systems popular in specific branches of mathematics, which unfortunately I don't know much about."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "parent_user_id": "UPVBV34EL",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UPVBV34EL"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3ee7c4ff-656c-4891-b8f6-131d1f44f46d",
        "type": "message",
        "text": "Thanks both of you. I will look into them. Also, interesting to see what it (may) take to build such a system with an extension / library system built in so that people can take the basic system as extend it to the domain they are interested into",
        "user": "UPVBV34EL",
        "ts": "1611159230.051400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8lb8u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks both of you. I will look into them. Also, interesting to see what it (may) take to build such a system with an extension / library system built in so that people can take the basic system as extend it to the domain they are interested into"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "428706f6-f824-4758-ae23-72383902223b",
        "type": "message",
        "text": "I was reading some text vs. binary file arguments and one thing that kept coming up was that text files are easier to recover when they get corrupted. I've got a couple of questions regarding this and would like to hear your thoughts:\n1. When did you have to deal with corrupted files and what was causing the corruption? \n2. How did the corruption look like (single swapped bits, part of the file missing, ...)? \nMy current line of thought is that small errors in binary files could simply be corrected by adding redundency to the format (crc etc.) and larger missing parts wouldn't be easy to recover from in text formats as well. Therefore the argument wouldn't make much sense. I'm curious what you might have experienced as I can't remember to have seen corrupted files in the last couple of years.",
        "user": "UAL7940NM",
        "ts": "1611164461.059600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bsZK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I was reading some text vs. binary file arguments and one thing that kept coming up was that text files are easier to recover when they get corrupted. I've got a couple of questions regarding this and would like to hear your thoughts:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "When did you have to deal with corrupted files and what was causing the corruption? "
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "How did the corruption look like (single swapped bits, part of the file missing, ...)? "
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My current line of thought is that small errors in binary files could simply be corrected by adding redundency to the format (crc etc.) and larger missing parts wouldn't be easy to recover from in text formats as well. Therefore the argument wouldn't make much sense. I'm curious what you might have experienced as I can't remember to have seen corrupted files in the last couple of years."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "reply_count": 10,
        "reply_users_count": 10,
        "latest_reply": "1611222408.004800",
        "reply_users": [
            "U01AD80KMLK",
            "U0112C10V4Y",
            "UHWC9PXBL",
            "U016VUZGUUQ",
            "UJBAJNFLK",
            "UAL7940NM",
            "UL5AX4G2H",
            "UCUSW7WVD",
            "U013ZLJARC7",
            "UBN9AFS0N"
        ],
        "subscribed": true,
        "last_read": "1611222408.004800"
    },
    {
        "client_msg_id": "9308061a-2e54-46ea-b2ac-a804c46d37de",
        "type": "message",
        "text": "Fortran was designed to do exactly that",
        "user": "U01AD80KMLK",
        "ts": "1611166813.059800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "gmLYm",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Fortran was designed to do exactly that"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "62755443-ab0d-4efe-be41-0b3257e6225f",
        "type": "message",
        "text": "I saw corrupted files frequently, mostly when they are coming from the network and were cut in the middle, or when a stream wasn't working well, but also as part of memory dumps where some parts of the memory was written over etc.",
        "user": "U01AD80KMLK",
        "ts": "1611166920.060000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "0cQR",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I saw corrupted files frequently, mostly when they are coming from the network and were cut in the middle, or when a stream wasn't working well, but also as part of memory dumps where some parts of the memory was written over etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "23642152-f4df-4c5b-8918-444c46cedfe9",
        "type": "message",
        "text": "In some ways the distinction between text and binary is arbitrary. Text files just have a whole ecosystem of tools that are able to parse (and display) the bits in a certain way. I expect any issues of corruption or error-correction would equally apply to both.",
        "user": "U0112C10V4Y",
        "ts": "1611168319.060200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0112C10V4Y",
            "ts": "1611168406.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "FKdW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In some ways the distinction between text and binary is arbitrary. Text files just have a whole ecosystem of tools that are able to parse (and display) the bits in a certain way. I expect any issues of corruption or error-correction would equally apply to both."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "7f0b8183-932e-4a8d-9fab-093b41c4e82e",
        "type": "message",
        "text": "text files often indicate (to some extent) human-readable files and human-readable files have a lot of redundancy built in\u2014all human languages do",
        "user": "UHWC9PXBL",
        "ts": "1611169133.063400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "/KT",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "text files often indicate (to some extent) human-readable files and human-readable files have a lot of redundancy built in\u2014all human languages do"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "dbab5ca7-b28d-477b-b1c6-3c7b4490aa75",
        "type": "message",
        "text": "Yep. When a human reads a file, they can eyeball it to see if it looks corrupt, make a guess at what it should have looked like, and manually patch it. With binary files, usually your parser just barfs. All the recovery steps a human performs have to be programmed in.\n\nAs to the actual question, the only time I can remember personally was from downloading ISOs: s couple of them failed their hash check and had to be re-downloaded. Bad disk dismounts are the other classic case, with a broader category of bad disk write/flush handling that can leave a file in weird states (<https://danluu.com/file-consistency/|https://danluu.com/file-consistency/>). TBH I wouldn't want to hand-restore one of those files either.",
        "user": "U016VUZGUUQ",
        "ts": "1611169930.064200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "OB=Jr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yep. When a human reads a file, they can eyeball it to see if it looks corrupt, make a guess at what it should have looked like, and manually patch it. With binary files, usually your parser just barfs. All the recovery steps a human performs have to be programmed in.\n\nAs to the actual question, the only time I can remember personally was from downloading ISOs: s couple of them failed their hash check and had to be re-downloaded. Bad disk dismounts are the other classic case, with a broader category of bad disk write/flush handling that can leave a file in weird states ("
                            },
                            {
                                "type": "link",
                                "url": "https://danluu.com/file-consistency/",
                                "text": "https://danluu.com/file-consistency/"
                            },
                            {
                                "type": "text",
                                "text": "). TBH I wouldn't want to hand-restore one of those files either."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "26a14fed-0e9c-47c9-af96-d0a92dc91be5",
        "type": "message",
        "text": "Corrupted files have always been part of my digital life. The main cause: software bugs. Number two: aborted computation jobs, usually due to resource limitations on batch systems.\n\nFor programs that write serialized output, a corrupted file is usually just truncated. That is usuallyl recoverable. But when working on large binary files, random-access modification is quite frequent and can result in just about any mistake.",
        "user": "UJBAJNFLK",
        "ts": "1611170449.064400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CQ4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Corrupted files have always been part of my digital life. The main cause: software bugs. Number two: aborted computation jobs, usually due to resource limitations on batch systems.\n\nFor programs that write serialized output, a corrupted file is usually just truncated. That is usuallyl recoverable. But when working on large binary files, random-access modification is quite frequent and can result in just about any mistake."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "14c2a04f-f5ec-4986-a04c-ca839ce9b5f0",
        "type": "message",
        "text": "Question for anyone in the know - was there ever a formal system description of the RealTalk system powering DynamicLand? My current understanding has mostly been pieced together from tweets and a few of <@UCL9Q87P0>'s more detailed blogposts. As I currently understand it, the system functions mostly as a federated Linda-like tuple space where wishes and claims are evaluated 60 times a sec and acted upon, and there is a base set of verbs and nouns (mostly related to the hardware) that are implemented in the system.",
        "user": "U0112C10V4Y",
        "ts": "1611171731.065400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "d2M2",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Question for anyone in the know - was there ever a formal system description of the RealTalk system powering DynamicLand? My current understanding has mostly been pieced together from tweets and a few of "
                            },
                            {
                                "type": "user",
                                "user_id": "UCL9Q87P0"
                            },
                            {
                                "type": "text",
                                "text": "'s more detailed blogposts. As I currently understand it, the system functions mostly as a federated Linda-like tuple space where wishes and claims are evaluated 60 times a sec and acted upon, and there is a base set of verbs and nouns (mostly related to the hardware) that are implemented in the system."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611171731.065400",
        "reply_count": 51,
        "reply_users_count": 10,
        "latest_reply": "1611469293.027000",
        "reply_users": [
            "UFPPABQ7P",
            "U01JNTE35QS",
            "U0112C10V4Y",
            "UBSMEUXAA",
            "UA14TGLTC",
            "UBM0S2AN4",
            "UDQBTJ211",
            "UBN1G4C1J",
            "UHWC9PXBL",
            "UBJGA440K"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "a7b16269-e760-40e6-84e0-85e7d236e825",
        "type": "message",
        "text": "Not to my knowledge is there anything online as a specification, because the system was constantly changing and being experimented with.",
        "user": "UFPPABQ7P",
        "ts": "1611171860.065500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "74KDa",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Not to my knowledge is there anything online as a specification, because the system was constantly changing and being experimented with."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611171731.065400",
        "parent_user_id": "U0112C10V4Y"
    },
    {
        "client_msg_id": "b0019a0d-396e-4a3d-b252-524cfeb2099a",
        "type": "message",
        "text": "I understand that it's implemented as a superset of Lua which probably was getting desugared to Lua. IIRC from my convos with Joshua Horowitz is that the whole system (a couple years ago at least) has one system input \"time\" which advances everything else forwards.",
        "user": "UFPPABQ7P",
        "ts": "1611172030.065700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "5z00j",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I understand that it's implemented as a superset of Lua which probably was getting desugared to Lua. IIRC from my convos with Joshua Horowitz is that the whole system (a couple years ago at least) has one system input \"time\" which advances everything else forwards."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611171731.065400",
        "parent_user_id": "U0112C10V4Y"
    },
    {
        "client_msg_id": "268d3782-fb59-47a9-a369-137a2111ea87",
        "type": "message",
        "text": "There is a photograph of the source of the realtalk system in one of Bret Victors tweets. I believe it used either Ohm or OMeta as the parsing system.",
        "user": "U01JNTE35QS",
        "ts": "1611172680.065900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "cfcH",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "There is a photograph of the source of the realtalk system in one of Bret Victors tweets. I believe it used either Ohm or OMeta as the parsing system."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611171731.065400",
        "parent_user_id": "U0112C10V4Y"
    },
    {
        "client_msg_id": "640460a7-9844-400a-be1a-49d775b2828e",
        "type": "message",
        "text": "I mentioned this in a other thread but Pure Lang has many pieces that make it useful for both symbolic and computational mathematics",
        "user": "U019CPED6T1",
        "ts": "1611173424.066100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MaRtW",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I mentioned this in a other thread but Pure Lang has many pieces that make it useful for both symbolic and computational mathematics"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611150525.049900",
        "parent_user_id": "UPVBV34EL"
    },
    {
        "client_msg_id": "16a81eb0-96d5-4347-826a-585577fed99b",
        "type": "message",
        "text": "My understanding is mostly from \"Background of Realtalk\" section from Omar's \"<https://omar.website/posts/notes-from-dynamicland-geokit/|Notes from DynamicLand: Geokit>\". Looks like while they've been fairly quiet recently they are still continuing on with research.",
        "user": "U0112C10V4Y",
        "ts": "1611173915.066300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0112C10V4Y",
            "ts": "1611173928.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "CBng",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My understanding is mostly from \""
                            },
                            {
                                "type": "text",
                                "text": "Background of Realtalk",
                                "style": {
                                    "unlink": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\" section from Omar's \""
                            },
                            {
                                "type": "link",
                                "url": "https://omar.website/posts/notes-from-dynamicland-geokit/",
                                "text": "Notes from DynamicLand: Geokit"
                            },
                            {
                                "type": "text",
                                "text": "\". Looks like while they've been fairly quiet recently they are still continuing on with research."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611171731.065400",
        "parent_user_id": "U0112C10V4Y"
    },
    {
        "client_msg_id": "ad8e184e-e8b8-4f37-9dfe-207901cca3e0",
        "type": "message",
        "text": "<@U0112C10V4Y> The \"advantage\" of text files is that characters are encoded individually and each character only takes a couple of bytes. If there's an incorrect byte, the corruption is limited to at most two characters. In binary encodings, a single error (e.g. in a length field) can corrupt everything that follows.\n\nBut you're right, text files are basically a subset of binary files and all advantages they have could also be achieved in other (non-text) formats.",
        "user": "UAL7940NM",
        "ts": "1611174856.066600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Gr/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U0112C10V4Y"
                            },
                            {
                                "type": "text",
                                "text": " The \"advantage\" of text files is that characters are encoded individually and each character only takes a couple of bytes. If there's an incorrect byte, the corruption is limited to at most two characters. In binary encodings, a single error (e.g. in a length field) can corrupt everything that follows.\n\nBut you're right, text files are basically a subset of binary files and all advantages they have could also be achieved in other (non-text) formats."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM"
    },
    {
        "client_msg_id": "b121c834-fc1a-482c-afa7-abe2ee21268d",
        "type": "message",
        "text": "I think <@U016VUZGUUQ> nailed it with \"they can eyeball it\". It's less of a theoretical math problem and more of a pragmatic \"how long does it take you to figure out exactly what the file should be and what it is\".\n\nI worked at a data storage company so we'd corrupt binary stuff all the time in dev, it was really hard to tell what was broken when it was binary.  I really wanted to, but never got around to, a to_json serializer so I could see system state in a structured, textual format.",
        "user": "UL5AX4G2H",
        "ts": "1611175067.066800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "a/3Ua",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I think "
                            },
                            {
                                "type": "user",
                                "user_id": "U016VUZGUUQ"
                            },
                            {
                                "type": "text",
                                "text": " nailed it with \"they can eyeball it\". It's less of a theoretical math problem and more of a pragmatic \"how long does it take you to figure out exactly what the file should be and what it is\".\n\nI worked at a data storage company so we'd corrupt binary stuff all the time in dev, it was really hard to tell what was broken when it was binary.  I really wanted to, but never got around to, a to_json serializer so I could see system state in a structured, textual format."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611164461.059600",
        "parent_user_id": "UAL7940NM",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    }
]