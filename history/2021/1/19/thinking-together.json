[
    {
        "client_msg_id": "2755eafa-69e7-4584-8132-bb897f7e98c5",
        "type": "message",
        "text": "The joy of slack for threaded messages.. Sorry, will do.",
        "user": "U01JNTE35QS",
        "ts": "1611014750.036000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "KyZv7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The joy of slack for threaded messages.. Sorry, will do."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610831250.020300",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "2a851420-faa1-4a8f-9ba1-33d0b91ef61c",
        "type": "message",
        "text": "Yeah, and every group has its own rules, to add to the confusion. Sorry about that.",
        "user": "UCUSW7WVD",
        "ts": "1611015905.036200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oLXo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah, and every group has its own rules, to add to the confusion. Sorry about that."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610831250.020300",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "d4399ae9-5b1a-4a9c-a77d-97fa289457af",
        "type": "message",
        "text": "(Seriously.  I just click follow on pretty much everything here.)",
        "user": "UA14TGLTC",
        "ts": "1611031860.036500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8ZUFZ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(Seriously.  I just click follow on pretty much everything here.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610831250.020300",
        "parent_user_id": "U01JNTE35QS"
    },
    {
        "client_msg_id": "93bf6ac1-f548-4e9d-8fc4-d35845236c45",
        "type": "message",
        "text": "That video is depressing, considering that what we have today in terms of \"personal dynamic media\" is at the same time more complicated and more limited. As far as I can see, even today's Smalltalks (Squeak, Pharo) don't support this.",
        "user": "UJBAJNFLK",
        "ts": "1611050680.037000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "x4Mb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "That video is depressing, considering that what we have today in terms of \"personal dynamic media\" is at the same time more complicated and more limited. As far as I can see, even today's Smalltalks (Squeak, Pharo) don't support this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "U013ZLJARC7"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b043e7c0-a0f4-463a-bb7a-7daddbd89796",
        "type": "message",
        "text": "<@UCUSW7WVD> sure, will post here when I get it working. I'm using <https://github.com/michaelengel/crosstalk> as a base, with modifications to support the smalltalk version used above",
        "user": "U0112C10V4Y",
        "ts": "1611079635.037300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0112C10V4Y",
            "ts": "1611079678.000000"
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "michaelengel/crosstalk",
                "title_link": "https://github.com/michaelengel/crosstalk",
                "text": "Smalltalk-80 bare metal implementation for the Raspberry Pi - michaelengel/crosstalk",
                "fallback": "GitHub: michaelengel/crosstalk",
                "thumb_url": "https://avatars1.githubusercontent.com/u/21115737?s=400&v=4",
                "from_url": "https://github.com/michaelengel/crosstalk",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/michaelengel/crosstalk"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "V7il",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCUSW7WVD"
                            },
                            {
                                "type": "text",
                                "text": " sure, will post here when I get it working. I'm using "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/michaelengel/crosstalk"
                            },
                            {
                                "type": "text",
                                "text": " as a base, with modifications to support the smalltalk version used above"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "08128cd8-e262-4695-8d76-b667f7b3961b",
        "type": "message",
        "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions (especially something as high level as an actor model) because the constraints and failure cases tend to be wildly different",
        "user": "UBSMEUXAA",
        "ts": "1611081030.037700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Oi7Pf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't believe it is particularly useful to equate heterogeneous computing with distributed computing and use the same abstractions (especially something as high level as an actor model) because the constraints and failure cases tend to be wildly different"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCUSW7WVD"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "3ba188d4-a687-49e9-93b5-d65703557c89",
        "type": "message",
        "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies",
        "user": "UBSMEUXAA",
        "ts": "1611081432.037900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "JT2L",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "242e9f16-05a1-43db-8e10-da27218f10b1",
        "type": "message",
        "text": "but in a true distributed system (you usually) care about robustness for potentially many machines that have much different uptime requirements than a consumer device",
        "user": "UBSMEUXAA",
        "ts": "1611081494.038100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lVNuG",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "but in a true distributed system (you usually) care about robustness for potentially many machines that have much different uptime requirements than a consumer device"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "617f0be9-0e7f-46d8-b113-3c2a1ecc5d33",
        "type": "message",
        "text": "<@UBSMEUXAA> I'm going to play devils advocate here :smiling_imp:\n&gt; I don't know of any consumer hardware that will continue to run if say, its GPU just dies\nI have a direct counter example:\nI have two GPU's in my laptop, the one bundled with my CPU, and an \"external\" Nvidia card. The Nvidia card regularly has driver failures and my laptop falls back to the on die graphics card.\n\nThis is almost seamless, and very much a distributed system. OS kernels handle these kind of driver failures all the time, and they are conceptually very similar to a distributed database that experiences a network partition.\n\nSome more extreme examples are Plan9 \"everything is a file\" and EMACS TRAMP. Both are examples of abstractions that cross both file system and network boundaries with similar semantics and error cases.\n\nreferring back to my earlier story about my National Science Foundation work, there was one group of grad students working on GPU's, and another group working on distributed graph algorithms on AWS. We were part of the same umbrella project, and regularly exchanged ideas about how to solve problems.\n\nThe constraints and failure cases are not wildly different at all imo.",
        "user": "U01661S9F34",
        "ts": "1611094589.038500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PCx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UBSMEUXAA"
                            },
                            {
                                "type": "text",
                                "text": " I'm going to play devils advocate here "
                            },
                            {
                                "type": "emoji",
                                "name": "smiling_imp"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't know of any consumer hardware that will continue to run if say, its GPU just dies"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I have a direct counter example:\nI have two GPU's in my laptop, the one bundled with my CPU, and an \"external\" Nvidia card. The Nvidia card regularly has driver failures and my laptop falls back to the on die graphics card.\n\nThis is almost seamless, and very much a distributed system. OS kernels handle these kind of driver failures all the time, and they are conceptually very similar to a distributed database that experiences a network partition.\n\nSome more extreme examples are Plan9 \"everything is a file\" and EMACS TRAMP. Both are examples of abstractions that cross both file system and network boundaries with similar semantics and error cases.\n\nreferring back to my earlier story about my National Science Foundation work, there was one group of grad students working on GPU's, and another group working on distributed graph algorithms on AWS. We were part of the same umbrella project, and regularly exchanged ideas about how to solve problems.\n\nThe constraints and failure cases are not wildly different at all imo."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "8717415b-b8c6-4f2c-8e3d-5d1a450ff38a",
        "type": "message",
        "text": "Sure, and there are ways in modern graphics APIs to explicitly manage that there are multiple GPUs. The thing is it's very rare that they have symmetrical capabilities, so if you have a work load that actually needs that Nvidia hardware and you switch to intel integrated graphics, you'll have a worse experience. A language with an actor model that abstracts heterogeneous hardware and treats it as a homogeneous distributed system won't really solve that",
        "user": "UBSMEUXAA",
        "ts": "1611095229.038800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xgj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Sure, and there are ways in modern graphics APIs to explicitly manage that there are multiple GPUs. The thing is it's very rare that they have symmetrical capabilities, so if you have a work load that actually needs that Nvidia hardware and you switch to intel integrated graphics, you'll have a worse experience. A language with an actor model that abstracts heterogeneous hardware and treats it as a homogeneous distributed system won't really solve that"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "9e93a320-2a09-4a6d-8194-2d0388a319ef",
        "type": "message",
        "text": "And making the cases where it doesn't matter easier doesn't really help anyone I guess? I mean potentially there is an interesting abstraction of a \"command buffer\" (a circular ring buffer that could look a little bit like messages in actor model systems) and an actor could be an explicit piece of defined hardware that has specific capabilities (both fixed function and code) but programming models and capabilities of different hardware are different enough that I'm not sure how useful it would be",
        "user": "UBSMEUXAA",
        "ts": "1611095638.039000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ZEIg",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "And making the cases where it doesn't matter easier doesn't really help anyone I guess? I mean potentially there is an interesting abstraction of a \"command buffer\" (a circular ring buffer that could look a little bit like messages in actor model systems) and an actor could be an explicit piece of defined hardware that has specific capabilities (both fixed function and code) but programming models and capabilities of different hardware are different enough that I'm not sure how useful it would be"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c313c10f-cbf6-440c-8d92-5604ef3be2ec",
        "type": "message",
        "text": "Maybe there is a interesting use case where you can use local or remote compute for the same task and its entirely invisible (don't have a GPU and it automatically uses a cloud GPU)",
        "user": "UBSMEUXAA",
        "ts": "1611095963.039200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "R+HU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe there is a interesting use case where you can use local or remote compute for the same task and its entirely invisible (don't have a GPU and it automatically uses a cloud GPU)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c35d6805-0613-4a4a-a325-935a33d679bb",
        "type": "message",
        "text": "Also device hang\\device lost due to a driver crash is not the same as an actual hardware failure.  The OS will recover from that, and as a system wide resource it doesn't practically make sense for applications to handle that.  In some cases  (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.  Laptops switch regularly but desktops will by default have embedded GPUs turned off, and don't have the same switching capabilities.  Consoles and smartphone generally have one GPU as part of an SOC, etc.",
        "user": "UBSMEUXAA",
        "ts": "1611096758.039400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8QFi8",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also device hang\\device lost due to a driver crash is not the same as an actual hardware failure.  The OS will recover from that, and as a system wide resource it doesn't practically make sense for applications to handle that.  In some cases  (most of the interesting ones) a discrete GPU failing and falling back to an embedded GPU is effectively a not working computer.  Laptops switch regularly but desktops will by default have embedded GPUs turned off, and don't have the same switching capabilities.  Consoles and smartphone generally have one GPU as part of an SOC, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    },
    {
        "client_msg_id": "c7b460b6-f300-4b6a-8203-150f0dd47a1d",
        "type": "message",
        "text": "The reason I bring up command buffer as an abstraction is because new consoles have custom I/O hardware that uses a GPU style command buffer model for I/O requests, with the assumption that modern games will be making I/O requests at a similar rate they make draw calls.  Game engines also generally use command buffers to send commands to a render thread (running on another core on the CPU) to drive rendering on the GPU.  It works great when you are mostly pushing data/commands to another device, not so great for frequent two way communication though, because this pattern tends to be used in systems with high-throughput and high latency (relatively speaking, high latency for a GPU is still really low compared to an HTTP request)",
        "user": "UBSMEUXAA",
        "ts": "1611097179.039600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "F2Sn9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The reason I bring up command buffer as an abstraction is because new consoles have custom I/O hardware that uses a GPU style command buffer model for I/O requests, with the assumption that modern games will be making I/O requests at a similar rate they make draw calls.  Game engines also generally use command buffers to send commands to a render thread (running on another core on the CPU) to drive rendering on the GPU.  It works great when you are mostly pushing data/commands to another device, not so great for frequent two way communication though, because this pattern tends to be used in systems with high-throughput and high latency (relatively speaking, high latency for a GPU is still really low compared to an HTTP request)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1610778816.014400",
        "parent_user_id": "UCUSW7WVD"
    }
]