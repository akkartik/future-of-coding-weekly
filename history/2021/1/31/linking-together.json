[
    {
        "client_msg_id": "ef33cb94-1d15-4959-9e74-62ab9ee18960",
        "type": "message",
        "text": "I agree with <@UBN9AFS0N> in that people like this have their mind already made up, and they're just looking for intrinsically biased responses to validate their own biased position.\n\nI have spent my professional career working in LabVIEW, although I know other languages like F#, Racket, Python, et. al., and LabVIEW is, in my opinion, the current most general purpose visual programming language. So I have dealt with these biases a lot, often in person and unfortunately in interviews. It's honestly a pretty rough ride being a professional visual programmer when 98% of your industry colleagues think your tool is a joke and not \"real\" programming.\n\nIf I respond here to the person's tweet, I believe they are asking the wrong questions. I don't think I would make an argument about visual programming necessarily being more \"concise and readable\", nor do I have a particular example that stands out as being one that would be readable in a visual programming environment and unreadable in a text-based one (for one, which language?). For one, I don't even know how you compare conciseness and readability. Those comparisons are ill-formed when comparing two text-based languages.\n\nThe context in which to discuss visual programming is that it is just as valid (no more valid or less valid) than text-based programming. The real cornerstones are of representation and paradigms, again, just like how one compares text-based programming. When I think of what language to use (beyond technicalities), I like to think in paradigms and which one is best suited to represent the problems I have.\n\nAdditionally, visual languages more readily provide live feedback, and so this is also where the argument gets lost, because visual programming tends to blur the line between program, the program running, and viewing the program in either of these states. When I program LabVIEW, I do not even have a compile step. It's compiling all the time, running type propagation to let me know what's broken, allows me to (by default) debug a running program by touching the data, etc. Yes, you can do this in a text-based environment, but I think the visual environment invites this more and makes it easier.\n\nSo when I think of visual programming, I personally think of concurrency, dataflow, visual feedback, touching my program, etc.",
        "user": "U01L1TTFP62",
        "ts": "1612077405.033900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I85er",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I agree with "
                            },
                            {
                                "type": "user",
                                "user_id": "UBN9AFS0N"
                            },
                            {
                                "type": "text",
                                "text": " in that people like this have their mind already made up, and they're just looking for intrinsically biased responses to validate their own biased position.\n\nI have spent my professional career working in LabVIEW, although I know other languages like F#, Racket, Python, et. al., and LabVIEW is, in my opinion, the current most general purpose visual programming language. So I have dealt with these biases a lot, often in person and unfortunately in interviews. It's honestly a pretty rough ride being a professional visual programmer when 98% of your industry colleagues think your tool is a joke and not \"real\" programming.\n\nIf I respond here to the person's tweet, I believe they are asking the wrong questions. I don't think I would make an argument about visual programming necessarily being more \"concise and readable\", nor do I have a particular example that stands out as being one that would be readable in a visual programming environment and unreadable in a text-based one (for one, which language?). For one, I don't even know how you compare conciseness and readability. Those comparisons are ill-formed when comparing two text-based languages.\n\nThe context in which to discuss visual programming is that it is just as valid (no more valid or less valid) than text-based programming. The real cornerstones are of representation and paradigms, again, just like how one compares text-based programming. When I think of what language to use (beyond technicalities), I like to think in paradigms and which one is best suited to represent the problems I have.\n\nAdditionally, visual languages more readily provide live feedback, and so this is also where the argument gets lost, because visual programming tends to blur the line between program, the program running, and viewing the program in either of these states. When I program LabVIEW, I do not even have a compile step. It's compiling all the time, running type propagation to let me know what's broken, allows me to (by default) debug a running program by touching the data, etc. Yes, you can do this in a text-based environment, but I think the visual environment invites this more and makes it easier.\n\nSo when I think of visual programming, I personally think of concurrency, dataflow, visual feedback, touching my program, etc."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612032903.026500",
        "parent_user_id": "UBSMEUXAA",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJ6LDMMN0"
                ],
                "count": 1
            },
            {
                "name": "bulb",
                "users": [
                    "UDQBTJ211"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d94ea10d-d00c-415e-9c9c-d709aef09407",
        "type": "message",
        "text": "<@USH01JEDQ> The layers comment is great. I always think of building my program at layers. That's why LabVIEW, when done _properly_, can be rather beautiful. I work a lot with hardware, so the layered approach is natural. Hardware drivers wrapped in classes wrapped in state machines wrapped in actors.",
        "user": "U01L1TTFP62",
        "ts": "1612077550.034100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "dEo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "USH01JEDQ"
                            },
                            {
                                "type": "text",
                                "text": " The layers comment is great. I always think of building my program at layers. That's why LabVIEW, when done "
                            },
                            {
                                "type": "text",
                                "text": "properly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", can be rather beautiful. I work a lot with hardware, so the layered approach is natural. Hardware drivers wrapped in classes wrapped in state machines wrapped in actors."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612032903.026500",
        "parent_user_id": "UBSMEUXAA"
    },
    {
        "client_msg_id": "ed626e6f-3309-4266-9ea5-3c60e39bfe5c",
        "type": "message",
        "text": "Hmm... The thread contains the usual arguments and positions that seem to be set in stone. In my opinion, there are good arguments on both sides of the VPL vs. textual PL argument when you filter the irrelevant nonsense out (e.g. \"I can type faster than I can drag nodes\").\n\nGenerally, the discussion is about whether relations between parts of the system should be displayed visually (e.g. by lines connecting blocks) or implicitly by having the same name in two places (e.g. function declaration and function usage). The latter approach requires the programmer to imagine the structure in their head, which requires talent and experience to do well.\n\nHumans are great at understanding spacial structure, so explicitly showing that structure does make sense. If you don't want to take my word for it, look at all the UML stuff or programmers drawing pictures to communicate their ideas.\n\nOn the other hand, showing ALL relations doesn't scale, just as stated in the twitter post that started the discussion. Take a `utils` lib in your project as an example. It is used almost everywhere and disturbs the relevant project structure when shown visually.\nIn my opinion, the crucial point is focus and abstraction. I believe that visually showing \"the bigger picture\" can really help understand a project, especially when it's large. It's just that you can't plot all relationships between all parts on a 2D canvas and expect people to understand it. That's also not what programmers using textual PLs have in mind when they think about the system. It's ok to hide some details in order communicate the higher-level dependencies.\n\nAnother important part is perspective. For code I've written, I have a pretty good mental model and probably don't need to actually see the structure on screen. If I need to understand someone else's project (or my projects from 3 years ago), it's really beneficial to have that overview available. This social issue is probably more important than the technical ones. Experienced programmers and people who mostly work on the projects they created don't benefit from VPL as much as beginners and people trying to understand existing stuff.\n\nI believe that the optimum is somewhere between textual PLs and current VPLs. Being able to choose between different views (see Projectional Editing) seems to make a lot of sense. Additionally, I'd like to see a system where users can specify which parts should be shown visually and which ones shouldn't be. Think of this like a street map where as you zoom out, only the most important streets are shown.",
        "user": "UAL7940NM",
        "ts": "1612090695.034300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Bwy",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm... The thread contains the usual arguments and positions that seem to be set in stone. In my opinion, there are good arguments on both sides of the VPL vs. textual PL argument when you filter the irrelevant nonsense out (e.g. \"I can type faster than I can drag nodes\").\n\nGenerally, the discussion is about whether relations between parts of the system should be displayed visually (e.g. by lines connecting blocks) or implicitly by having the same name in two places (e.g. function declaration and function usage). The latter approach requires the programmer to imagine the structure in their head, which requires talent and experience to do well.\n\nHumans are great at understanding spacial structure, so explicitly showing that structure does make sense. If you don't want to take my word for it, look at all the UML stuff or programmers drawing pictures to communicate their ideas.\n\nOn the other hand, showing ALL relations doesn't scale, just as stated in the twitter post that started the discussion. Take a "
                            },
                            {
                                "type": "text",
                                "text": "utils",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " lib in your project as an example. It is used almost everywhere and disturbs the relevant project structure when shown visually.\nIn my opinion, the crucial point is focus and abstraction. I believe that visually showing \"the bigger picture\" can really help understand a project, especially when it's large. It's just that you can't plot all relationships between all parts on a 2D canvas and expect people to understand it. That's also not what programmers using textual PLs have in mind when they think about the system. It's ok to hide some details in order communicate the higher-level dependencies.\n\nAnother important part is perspective. For code I've written, I have a pretty good mental model and probably don't need to actually see the structure on screen. If I need to understand someone else's project (or my projects from 3 years ago), it's really beneficial to have that overview available. This social issue is probably more important than the technical ones. Experienced programmers and people who mostly work on the projects they created don't benefit from VPL as much as beginners and people trying to understand existing stuff.\n\nI believe that the optimum is somewhere between textual PLs and current VPLs. Being able to choose between different views (see Projectional Editing) seems to make a lot of sense. Additionally, I'd like to see a system where users can specify which parts should be shown visually and which ones shouldn't be. Think of this like a street map where as you zoom out, only the most important streets are shown."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612032903.026500",
        "parent_user_id": "UBSMEUXAA",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "D9E09BBC-B181-418F-AADF-05E6A251BC89",
        "type": "message",
        "text": "<@U01AD80KMLK> The best forum would be <http://unisonlanguage.slack.com|unisonlanguage.slack.com>.",
        "user": "UJBAJNFLK",
        "ts": "1612116081.035800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "GXC4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U01AD80KMLK"
                            },
                            {
                                "type": "text",
                                "text": " The best forum would be "
                            },
                            {
                                "type": "link",
                                "url": "http://unisonlanguage.slack.com",
                                "text": "unisonlanguage.slack.com"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1611837265.011600",
        "parent_user_id": "UBN9AFS0N"
    },
    {
        "client_msg_id": "7fdcfda6-41b8-4704-9653-31d27d179560",
        "type": "message",
        "text": "this was a fun thing to read, Alan Kay\u2019s reply:\n\n<https://www.quora.com/Should-web-browsers-have-stuck-to-being-document-viewers>",
        "user": "UAJKEBGP8",
        "ts": "1612118402.036300",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "Should web browsers have stuck to being document viewers? - Quora",
                "title_link": "https://www.quora.com/Should-web-browsers-have-stuck-to-being-document-viewers",
                "text": "Actually quite the opposite, if \u201cdocument\u201d means an imitation of old static text media (and later including pictures, and audio and video recordings). It was being willing to settle for an overly simple text format and formatting scheme \u2014 \u201cfor con...",
                "fallback": "Should web browsers have stuck to being document viewers? - Quora",
                "from_url": "https://www.quora.com/Should-web-browsers-have-stuck-to-being-document-viewers",
                "service_icon": "https://www.quora.com/favicon.ico",
                "service_name": "quora.com",
                "id": 1,
                "original_url": "https://www.quora.com/Should-web-browsers-have-stuck-to-being-document-viewers"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "oKcK",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "this was a fun thing to read, Alan Kay\u2019s reply:\n\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.quora.com/Should-web-browsers-have-stuck-to-being-document-viewers"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612118402.036300",
        "reply_count": 3,
        "reply_users_count": 2,
        "latest_reply": "1612129557.037200",
        "reply_users": [
            "UC2A2ARPT",
            "UAJKEBGP8"
        ],
        "subscribed": false,
        "reactions": [
            {
                "name": "star",
                "users": [
                    "USH01JEDQ"
                ],
                "count": 1
            },
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "b93959d7-fa9f-4c74-8a63-97ef49226523",
        "type": "message",
        "text": "For anyone who missed it, this is in reply to <https://twitter.com/kocienda/status/1355344814166876163|a tweet> from Ken Kocienda (who worked on the original Safari team at Apple)",
        "user": "UC2A2ARPT",
        "ts": "1612122938.036700",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/kocienda|@kocienda>: Web browsers are not operating systems or application development environments. They\u2019re document viewers. The effort to make them into something more than that has been one of the biggest wrong turns in the history of computing.",
                "ts": 1611974359,
                "author_name": "Ken Kocienda",
                "author_link": "https://twitter.com/kocienda/status/1355344814166876163",
                "author_icon": "https://pbs.twimg.com/profile_images/1136694654198374400/VPn5kLdk_normal.jpg",
                "author_subname": "@kocienda",
                "text": "Web browsers are not operating systems or application development environments. They\u2019re document viewers. The effort to make them into something more than that has been one of the biggest wrong turns in the history of computing.",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/kocienda/status/1355344814166876163",
                "id": 1,
                "original_url": "https://twitter.com/kocienda/status/1355344814166876163",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "T5bO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "For anyone who missed it, this is in reply to "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/kocienda/status/1355344814166876163",
                                "text": "a tweet"
                            },
                            {
                                "type": "text",
                                "text": " from Ken Kocienda (who worked on the original Safari team at Apple)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612118402.036300",
        "parent_user_id": "UAJKEBGP8"
    },
    {
        "client_msg_id": "55c0d124-da56-4a09-b7b8-eedef2da7b42",
        "type": "message",
        "text": "&gt; My complaints about the web and the web browsers have been about how poorly they were thought about and implemented, and how weak are both the functionalities of web content and the means for going forward and fixing as many of the most critical mistakes as possible.\nSo it seems Alan is burying the lede a bit, and actually agrees with Ken, albeit arriving at that point from a different start.\n\nGiven the web we got (not the web we wanted), it is a mistake to try to retrofit it into an app platform, especially in such an ad hoc / incremental / design-by-accretion way. Short of a time machine, though, I'm not sure how we get that web of objects with end-user editing we ought to have.\n\nAs an aside, this bit stuck out:\n\n&gt; One of the great realizations of the early Unix was that the *kernel* of an OS \u2014 and essentially the only part that should be in \u201csupervisor mode\u201d \u2014 would only manage\u00a0_*time*_\u00a0(quanta for interleaved computations) and\u00a0_*space*_(memory allocation and levels) and\u00a0_*encapsulation*_\u00a0(processes) \u2014 everything else should be expressible in the general vanilla processes of the system.\nThat's what game engines are (naturally). But game engines also don't have to worry as much about all the security, IO, hardware, and other baggage of modern OSes. That means game engines end up being quite pure articulations of that \"time + space + process\" conceptual structure, and I really feel that when working with them. (And others seem to too \u2014 quite a few game developers even pass it through to the player via gameplay. Thinking of games like Roblox, Minecraft, Sim[x], etc.)",
        "user": "UC2A2ARPT",
        "ts": "1612124083.037000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "DiLwc",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "My complaints about the web and the web browsers have been about how poorly they were thought about and implemented, and how weak are both the functionalities of web content and the means for going forward and fixing as many of the most critical mistakes as possible."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSo it seems Alan is burying the lede a bit, and actually agrees with Ken, albeit arriving at that point from a different start.\n\nGiven the web we got (not the web we wanted), it is a mistake to try to retrofit it into an app platform, especially in such an ad hoc / incremental / design-by-accretion way. Short of a time machine, though, I'm not sure how we get that web of objects with end-user editing we ought to have.\n\nAs an aside, this bit stuck out:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "One of the great realizations of the early Unix was that the *kernel* of an OS \u2014 and essentially the only part that should be in \u201csupervisor mode\u201d \u2014 would only manage\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "time",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u00a0(quanta for interleaved computations) and\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "space",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "(memory allocation and levels) and\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "encapsulation",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u00a0(processes) \u2014 everything else should be expressible in the general vanilla processes of the system."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThat's what game engines are (naturally). But game engines also don't have to worry as much about all the security, IO, hardware, and other baggage of modern OSes. That means game engines end up being quite pure articulations of that \"time + space + process\" conceptual structure, and I really feel that when working with them. (And others seem to too \u2014 quite a few game developers even pass it through to the player via gameplay. Thinking of games like Roblox, Minecraft, Sim[x], etc.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612118402.036300",
        "parent_user_id": "UAJKEBGP8"
    },
    {
        "client_msg_id": "03023af3-25ca-44e3-bea6-bc0ed3c4c5ca",
        "type": "message",
        "text": "yeah agreed, the term \u2018web browser\u2019 is very specific to current assumptions. The HTML / CSS / JS paradigm. Then people debate if the browser should do more or less, but often by focusing on the current set of assumptions instead of starting from first principles.\n\nIf you started from first principles, you may not really even need a browser. Or rather, it\u2019d be something way different and the use of that word / naming may be inaccurate!",
        "user": "UAJKEBGP8",
        "ts": "1612129557.037200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "064R",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah agreed, the term \u2018web browser\u2019 is very specific to current assumptions. The HTML / CSS / JS paradigm. Then people debate if the browser should do more or less, but often by focusing on the current set of assumptions instead of starting from first principles.\n\nIf you started from first principles, you may not really even need a browser. Or rather, it\u2019d be something way different and the use of that word / naming may be inaccurate!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1612118402.036300",
        "parent_user_id": "UAJKEBGP8"
    }
]