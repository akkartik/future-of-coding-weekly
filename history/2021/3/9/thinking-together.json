[
    {
        "client_msg_id": "49ddc907-a94e-470a-91b2-1152689199aa",
        "type": "message",
        "text": "I feel like I've been long deceived by the traditional definition of a mathematical relation as \"a set of tuples\". This is the definition used in \"relational languages\" like SQL and Prolog, but in the context of programming, it seems much more intuitive for relations to be defined by formulas (e.g. `y = x + 1` or `x + y &lt; z`), where the fundamental units of data are *variables*, not *tuples*. This is not just a cosmetic difference: you can _re-use_ variables across different formulas (e.g. `y = x + 1` and `z = 2x`), and suddenly a division of the program into \"tuples\" and \"tables\" no longer makes sense, because it obscures formulas and groups variables (columns) according to whim, not truth. Indeed, if you don't have tuples *you don't need to worry about \"keys\" and \"normalization\"* (as you do in relational DBs), because the formulas _directly_ express the dependencies between variables (columns). This leaves me deeply confused as to why in the logic &amp; relational programming community, I've never seen anyone challenging the notion of tuples. <http://minikanren.org/|miniKanren> and <https://en.wikipedia.org/wiki/Constraint_programming|constraint programming> (but *NOT* \"constraint logic programming\") are the only relational language families I know of that are based on variables &amp; formulas, not tuples. (I'm not an expert in these languages, but I'm investigating them.)\n\n*Bonus fact 1:* the <https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model|EAV model> (popular in recent years) doesn't solve normalization problems, because sometimes you truly want a large number of variables (columns) to be interdependent, e.g. `x = 2y = 3z = 4t`. EAV still maintains the indirection of tuples and tables, it just restricts the number of variables (columns) to 3.\n\n*Bonus fact 2:* the tuple model isn't even necessary for _plain old data_, where you might argue \"there are no underlying formulas\". There is definitely still a formula involved! The tuple (1542, \"Nick\") can be expressed by the formula: `if customerID = 1542 then name = \"Nick\"`. (Of course, in a GUI you'd use a table to present this data, but presentation concerns are orthogonal to the underlying data model.)",
        "user": "UCGAK10LS",
        "ts": "1615252973.136100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615260266.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "el2Z",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I feel like I've been long deceived by the traditional definition of a mathematical relation as \"a set of tuples\". This is the definition used in \"relational languages\" like SQL and Prolog, but in the context of programming, it seems much more intuitive for relations to be defined by formulas (e.g. "
                            },
                            {
                                "type": "text",
                                "text": "y = x + 1",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " or "
                            },
                            {
                                "type": "text",
                                "text": "x + y < z",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), where the fundamental units of data are "
                            },
                            {
                                "type": "text",
                                "text": "variables",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", not "
                            },
                            {
                                "type": "text",
                                "text": "tuples",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". This is not just a cosmetic difference: you can "
                            },
                            {
                                "type": "text",
                                "text": "re-use",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " variables across different formulas (e.g. "
                            },
                            {
                                "type": "text",
                                "text": "y = x + 1",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "z = 2x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), and suddenly a division of the program into \"tuples\" and \"tables\" no longer makes sense, because it obscures formulas and groups variables (columns) according to whim, not truth. Indeed, if you don't have tuples "
                            },
                            {
                                "type": "text",
                                "text": "you don't need to worry about \"keys\" and \"normalization\"",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (as you do in relational DBs), because the formulas "
                            },
                            {
                                "type": "text",
                                "text": "directly",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " express the dependencies between variables (columns). This leaves me deeply confused as to why in the logic & relational programming community, I've never seen anyone challenging the notion of tuples. "
                            },
                            {
                                "type": "link",
                                "url": "http://minikanren.org/",
                                "text": "miniKanren"
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Constraint_programming",
                                "text": "constraint programming"
                            },
                            {
                                "type": "text",
                                "text": " (but "
                            },
                            {
                                "type": "text",
                                "text": "NOT",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " \"constraint logic programming\") are the only relational language families I know of that are based on variables & formulas, not tuples. (I'm not an expert in these languages, but I'm investigating them.)\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Bonus fact 1:",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model",
                                "text": "EAV model"
                            },
                            {
                                "type": "text",
                                "text": " (popular in recent years) doesn't solve normalization problems, because sometimes you truly want a large number of variables (columns) to be interdependent, e.g. "
                            },
                            {
                                "type": "text",
                                "text": "x = 2y = 3z = 4t",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". EAV still maintains the indirection of tuples and tables, it just restricts the number of variables (columns) to 3.\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Bonus fact 2: ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "the tuple model isn't even necessary for "
                            },
                            {
                                "type": "text",
                                "text": "plain old data",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", where you might argue \"there are no underlying formulas\". There is definitely still a formula involved! The tuple (1542, \"Nick\") can be expressed by the formula: "
                            },
                            {
                                "type": "text",
                                "text": "if customerID = 1542 then name = \"Nick\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". (Of course, in a GUI you'd use a table to present this data, but presentation concerns are orthogonal to the underlying data model.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "reply_count": 63,
        "reply_users_count": 6,
        "latest_reply": "1615766771.186300",
        "reply_users": [
            "UEBG0NPDK",
            "UCGAK10LS",
            "UA14TGLTC",
            "U013ZLJARC7",
            "UJBAJNFLK",
            "U5STGTB3J"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "551a7087-a0be-443c-b3ce-bfba06a0ae23",
        "type": "message",
        "text": "expressions are much more difficult to work with, since their structure is inherently variable in both length and depth",
        "user": "UEBG0NPDK",
        "ts": "1615256142.136500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iv6",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "expressions are much more difficult to work with, since their structure is inherently variable in both length and depth"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "314ca6e3-e988-443d-8d2d-4be105e8bb32",
        "type": "message",
        "text": "writing generic procedures for the common relational operators is a lot more work and will eventually take you to a place where you want a \u201ccommon data model\u201d",
        "user": "UEBG0NPDK",
        "ts": "1615256275.136700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UEBG0NPDK",
            "ts": "1615256325.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f18mU",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "writing generic procedures for the common relational operators is a lot more work and will eventually take you to a place where you want a \u201ccommon data model\u201d"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0089741c-c0eb-47a0-b4a2-a961c5f0d346",
        "type": "message",
        "text": "which will _probably_ end up looking like tuples",
        "user": "UEBG0NPDK",
        "ts": "1615256340.137100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fg2=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "which will "
                            },
                            {
                                "type": "text",
                                "text": "probably",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " end up looking like tuples"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "27852591-9b49-4ab7-83c2-ddb4835e75b9",
        "type": "message",
        "text": "&gt; expressions are much more difficult to work with\nThat sounds like a UI design challenge, which I'm ready to take on :slightly_smiling_face:. They might not work in a text-file-based language, but that's no concern to me.\n\n&gt; writing generic procedures for the common relational operators is a lot more work and will eventually take you to a place where you want a \u201ccommon data model\u201d\nI don't understand this part. Are you talking about implementation concerns or something else?",
        "user": "UCGAK10LS",
        "ts": "1615256489.137300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vxx",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "expressions are much more difficult to work with"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThat sounds like a UI design challenge, which I'm ready to take on "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". They might not work in a text-file-based language, but that's no concern to me.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "writing generic procedures for the common relational operators is a lot more work and will eventually take you to a place where you want a \u201ccommon data model\u201d"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI don't understand this part. Are you talking about implementation concerns or something else?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "d87b533d-5302-4be6-a3c0-914c696baa7d",
        "type": "message",
        "text": "yeah sorry, I was thinking of the implementation level",
        "user": "UEBG0NPDK",
        "ts": "1615256527.137500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "TqrC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "yeah sorry, I was thinking of the implementation level"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b517756b-79f4-4435-aee2-93443a098407",
        "type": "message",
        "text": "In general I'm ready to deal with as much implementation complexity as is needed. I'm trying to build a human-centered language, that's all that matters!",
        "user": "UCGAK10LS",
        "ts": "1615256592.137700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "P/CL9",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In general I'm ready to deal with as much implementation complexity as is needed. I'm trying to build a human-centered language, that's all that matters!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "30f4dbb1-31d9-48ed-b4bb-d77216fc54fb",
        "type": "message",
        "text": "It\u2019s hard to outright ignore implementation complexity, because it means you need to innovate on even more things - not just novel UIs and interactions and mental models, but also novel algorithms and foundations. Each one of which is easily a black hole problem :slightly_smiling_face:\n\nI\u2019d be really curious to see how you\u2019d do a relational join over arbitrary expressions",
        "user": "UEBG0NPDK",
        "ts": "1615256801.137900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Yv64",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "It\u2019s hard to outright ignore implementation complexity, because it means you need to innovate on even more things - not just novel UIs and interactions and mental models, but also novel algorithms and foundations. Each one of which is easily a black hole problem "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI\u2019d be really curious to see how you\u2019d do a relational join over arbitrary expressions"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "heavy_plus_sign",
                "users": [
                    "UFPPABQ7P"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "5c05d8c1-feb7-4d6a-942a-225247415efe",
        "type": "message",
        "text": "I\u2019m not sure you really get away from normalization and keys. In your plain old data example, you\u2019re explicitly stating the key (ID). I _think_ you can\u2019t escape defining identity somewhere and for normalization you either have defined access paths or you don\u2019t. In the former, you\u2019re some level of denormalized, in the latter you\u2019re in something like 6th normal form.",
        "user": "UEBG0NPDK",
        "ts": "1615257038.138100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "M0Bz7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m not sure you really get away from normalization and keys. In your plain old data example, you\u2019re explicitly stating the key (ID). I "
                            },
                            {
                                "type": "text",
                                "text": "think",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " you can\u2019t escape defining identity somewhere and for normalization you either have defined access paths or you don\u2019t. In the former, you\u2019re some level of denormalized, in the latter you\u2019re in something like 6th normal form."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2e63d74e-43fb-4699-99c5-0d66fac9d0d2",
        "type": "message",
        "text": "you could argue the user doesn\u2019t need to think about it, but that\u2019s really saying the user can dig their own hole as deep as they want (same is true in SQL and the others too, it\u2019s more than happy to let you do crazy combinations of normalization and identity, e.g. regex joins)",
        "user": "UEBG0NPDK",
        "ts": "1615257242.138300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "455",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "you could argue the user doesn\u2019t need to think about it, but that\u2019s really saying the user can dig their own hole as deep as they want (same is true in SQL and the others too, it\u2019s more than happy to let you do crazy combinations of normalization and identity, e.g. regex joins)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "51c29240-9dee-4e42-9b2c-19211d09da0b",
        "type": "message",
        "text": "\u201ca human-centered language\u201d is likely as much about guiding people toward something that helps them manage complexity as it is about letting them do something \u201cnaturally.\u201d",
        "user": "UEBG0NPDK",
        "ts": "1615257412.138600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Z58u",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\u201ca human-centered language\u201d is likely as much about guiding people toward something that helps them manage complexity as it is about letting them do something \u201cnaturally.\u201d"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UA14TGLTC",
                    "UJBAJNFLK",
                    "U013ZLJARC7",
                    "UCUSW7WVD",
                    "U015V233CFL"
                ],
                "count": 5
            }
        ]
    },
    {
        "client_msg_id": "7ac63423-19f6-4660-a231-e2e57e3b3bae",
        "type": "message",
        "text": "there\u2019s a really interesting tension between giving the user what they want and trying to steer them clear of pits of failure",
        "user": "UEBG0NPDK",
        "ts": "1615257465.138800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bQunX",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "there\u2019s a really interesting tension between giving the user what they want and trying to steer them clear of pits of failure"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "100",
                "users": [
                    "UJBAJNFLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "a5f45d2f-6879-422c-ac62-99a8960c502a",
        "type": "message",
        "text": "tuples force a kind of consistency that expressions don\u2019t and that means there are fewer places for misunderstandings to hide",
        "user": "UEBG0NPDK",
        "ts": "1615257584.139000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "v3NLx",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "tuples force a kind of consistency that expressions don\u2019t and that means there are fewer places for misunderstandings to hide"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "8175627d-2252-492a-b77a-99e653896163",
        "type": "message",
        "text": "I plan to start thinking about execution efficiency only after I've developed a full \"beta\" of a programming language that achieves my goals for the user experience. The biggest risk to my project is that I sacrifice the vision due to short-term implementation worries.\n\nAnother reason why I'm holding off: the hardware landscape is changing constantly. One big upcoming change: there will be AI accelerators on the market in a few years, which are quite literally parallel dataflow machines, so I'm not worried about how my language scales on an Intel CPU :slightly_smiling_face:. At least some of those accelerators will be feature-ful enough that they can run more than neural networks, in the same way that we now use GPUs for more than 3D graphics. And further: the biggest advantage of dataflow hardware may not even be the parallelism but the pure implementation _simplicity_ of mapping a dataflow-like language to dataflow hardware, rather than von Neumann hardware. It's not fully clear what the \"assembly language of a TPU\" will end up looking like, but I bet it's good at executing joins :wink:.\n\nPoint is: I think there will be plenty of compute power available to run whatever language I end up with, even if we have to wait a few years. I don't plan to be pushing efficiency on x86 CPUs within the next 5 years of development.\n\nBut this may be a digression. I'll read your other points, hold on :slightly_smiling_face:.",
        "user": "UCGAK10LS",
        "ts": "1615257662.139200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615257691.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "8Uu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I plan to start thinking about execution efficiency only after I've developed a full \"beta\" of a programming language that achieves my goals for the user experience. The biggest risk to my project is that I sacrifice the vision due to short-term implementation worries.\n\nAnother reason why I'm holding off: the hardware landscape is changing constantly. One big upcoming change: there will be AI accelerators on the market in a few years, which are quite literally parallel dataflow machines, so I'm not worried about how my language scales on an Intel CPU "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". At least some of those accelerators will be feature-ful enough that they can run more than neural networks, in the same way that we now use GPUs for more than 3D graphics. And further: the biggest advantage of dataflow hardware may not even be the parallelism but the pure implementation"
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "simplicity",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " ",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "of mapping a dataflow-like language to dataflow hardware, rather than von Neumann hardware. It's not fully clear what the \"assembly language of a TPU\" will end up looking like, but I bet it's good at executing joins "
                            },
                            {
                                "type": "emoji",
                                "name": "wink"
                            },
                            {
                                "type": "text",
                                "text": ".\n\nPoint is: I think there will be plenty of compute power available to run whatever language I end up with, even if we have to wait a few years. I don't plan to be pushing efficiency on x86 CPUs within the next 5 years of development.\n\nBut this may be a digression. I'll read your other points, hold on "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "U01AD80KMLK"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "e91cce0a-5a9a-4258-9ad0-e8887490266e",
        "type": "message",
        "text": "&gt; I\u2019m not sure you really get away from normalization and keys. In your plain old data example, you\u2019re explicitly stating the key (ID).\nYes, but the key _emerges naturally_ from the data. The idea is: if you write an equation that expresses `x` as a function of `y` and `z`, then those become the (compound) key that identifies an x. But keys aren't an actual language construct, and neither are tables, and therefore it's impossible to come up with \"badly-designed tables\", unlike in SQL or Prolog, where you can lump arbitrary values together and call them a tuple.",
        "user": "UCGAK10LS",
        "ts": "1615257881.139500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "hUFy",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m not sure you really get away from normalization and keys. In your plain old data example, you\u2019re explicitly stating the key (ID)."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, but the key "
                            },
                            {
                                "type": "text",
                                "text": "emerges naturally",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " from the data. The idea is: if you write an equation that expresses "
                            },
                            {
                                "type": "text",
                                "text": "x",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " as a function of "
                            },
                            {
                                "type": "text",
                                "text": "y",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "z",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then those become the (compound) key that identifies an x. But keys aren't an actual language construct, and neither are tables, and therefore it's impossible to come up with \"badly-designed tables\", unlike in SQL or Prolog, where you can lump arbitrary values together and call them a tuple."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "e3b5d79f-2c4b-4cde-bec4-9b4901ac01f7",
        "type": "message",
        "text": "So in contrast, I'd say that it's SQL that allows users to dig holes wrt. their data model, and this proposal takes away the shovel.",
        "user": "UCGAK10LS",
        "ts": "1615257958.139700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615257964.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "eca",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So in contrast, I'd say that it's SQL that allows users to dig holes wrt. their data model, and this proposal takes away the shovel."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a20d4d75-d5de-4bf8-8252-ac0ebdbb7ff6",
        "type": "message",
        "text": "that works out to 6th normal form then, which I\u2019m a big fan of :slightly_smiling_face:",
        "user": "UEBG0NPDK",
        "ts": "1615257983.140000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "+RmH3",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that works out to 6th normal form then, which I\u2019m a big fan of "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "928bad24-12b6-4164-82bf-3243a369cf88",
        "type": "message",
        "text": "Perhaps it is an implicit, mandated normal form, sure :slightly_smiling_face:",
        "user": "UCGAK10LS",
        "ts": "1615258046.140200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rtkSB",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Perhaps it is an implicit, mandated normal form, sure "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5b801489-7746-41c0-8538-c8003d8eb1e9",
        "type": "message",
        "text": "so in this world, data is all purely represented by code that must be run",
        "user": "UEBG0NPDK",
        "ts": "1615258107.140400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N=I",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "so in this world, data is all purely represented by code that must be run"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b5c354d8-6bcd-4a35-bee3-9759aaffb91c",
        "type": "message",
        "text": "that\u2019ll lead to some really cool research around how you compress that and make it reasonable to transmit to whatever coprocessor it\u2019s running on",
        "user": "UEBG0NPDK",
        "ts": "1615258196.140600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pa4zC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that\u2019ll lead to some really cool research around how you compress that and make it reasonable to transmit to whatever coprocessor it\u2019s running on"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "e0c6b239-24d3-4c3b-8544-502b351c5e36",
        "type": "message",
        "text": "Oh, and I didn't mention it in my original post, but in the envisioned model of relational programming, there is no such thing as a \"data structure\" (not even lists), since data structures re-introduce tuples and tables and all their problems. Data structures (and functions) would emerge naturally by linking variables together through formulas (or you might call them _constraints_). I'm still working out what the UI to this will look like of course, and that's probably the biggest challenge :slightly_smiling_face:",
        "user": "UCGAK10LS",
        "ts": "1615258322.140800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qTdS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Oh, and I didn't mention it in my original post, but in the envisioned model of relational programming, there is no such thing as a \"data structure\" (not even lists), since data structures re-introduce tuples and tables and all their problems. Data structures (and functions) would emerge naturally by linking variables together through formulas (or you might call them "
                            },
                            {
                                "type": "text",
                                "text": "constraints",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "). I'm still working out what the UI to this will look like of course, and that's probably the biggest challenge "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "3ea8393e-2202-4bce-9a12-8c8a9de613de",
        "type": "message",
        "text": "&gt; so in this world, data is all purely represented by code that must be run\nYeah :slightly_smiling_face:",
        "user": "UCGAK10LS",
        "ts": "1615258364.141000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "bvG=",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "so in this world, data is all purely represented by code that must be run"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c42150f5-2f6b-4fc2-949a-19474160add3",
        "type": "message",
        "text": "The question of \"_when_ does the code run\" is an important implementation question, but again this is something I'll deal with after I get the UX right.",
        "user": "UCGAK10LS",
        "ts": "1615258411.141200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3mzve",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "The question of \""
                            },
                            {
                                "type": "text",
                                "text": "when",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " does the code run\" is an important implementation question, but again this is something I'll deal with after I get the UX right."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9dadf014-3553-4a2d-9e21-9fedca0e1e21",
        "type": "message",
        "text": "&gt; there is no such thing as a \u201cdata structure\u201d\nSo how do I ask for the name of customer 10? Or how would I model that a player has a hand of 5 cards?",
        "user": "UEBG0NPDK",
        "ts": "1615258452.141400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "AbW",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "there is no such thing as a \u201cdata structure\u201d"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "So how do I ask for the name of customer 10? Or how would I model that a player has a hand of 5 cards?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ca65e82b-7ba2-4e48-8d71-d69418ff8bb2",
        "type": "message",
        "text": "one thing I could never figure out is how you\u2019d get rid of things that have sets of other things",
        "user": "UEBG0NPDK",
        "ts": "1615258502.141600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Xaw",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "one thing I could never figure out is how you\u2019d get rid of things that have sets of other things"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c77558b8-3144-460e-aca7-5c970dc62ab6",
        "type": "message",
        "text": "```customerID = 10\nprint customerName```\n(My language won't have print statements, that's just for illustration.)\nSee my previous <#C5T9GPWFL|thinking-together> post on \"function calling\". It's deeply related in a non-obvious way :slightly_smiling_face:",
        "user": "UCGAK10LS",
        "ts": "1615258550.141800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615258594.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=1jQ",
                "elements": [
                    {
                        "type": "rich_text_preformatted",
                        "elements": [
                            {
                                "type": "text",
                                "text": "customerID = 10\nprint customerName"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "(My language won't have print statements, that's just for illustration.)\nSee my previous "
                            },
                            {
                                "type": "channel",
                                "channel_id": "C5T9GPWFL"
                            },
                            {
                                "type": "text",
                                "text": " post on \"function calling\". It's deeply related in a non-obvious way "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0127327c-e4bd-4f8a-b202-2c3b61ea2c56",
        "type": "message",
        "text": "ah yes",
        "user": "UEBG0NPDK",
        "ts": "1615258652.142500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RZtzo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "ah yes"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a154bb7d-f6f9-43c2-aecc-c242dfd63c52",
        "type": "message",
        "text": "how about the card one?",
        "user": "UEBG0NPDK",
        "ts": "1615258667.142700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Qyj8S",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "how about the card one?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "07e344d9-8fc1-45f9-9dbd-83d4c4a0b401",
        "type": "message",
        "text": "imagining that cards are just numbers for simplicity",
        "user": "UEBG0NPDK",
        "ts": "1615258692.142900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kWJ",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "imagining that cards are just numbers for simplicity"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "65ee2fa2-752e-4267-bc45-15e026b4735d",
        "type": "message",
        "text": "&gt; how would I model that a player has a hand of 5 cards?\nYou'd do it similarly to a Prolog relation `holds(Player, Card)`, except the \"connections\" between datums are stored implicitly in global (UUID-based) variables, rather than via a named \"predicate\". You'd have two variables, `player` and `cardInHand`. When you constrain `player` to a value, e.g. `player = \"Nick\"`, `cardInHand` will have five values, one representing each card. You could \"print\" all five values, or use them as part of a larger calculation.\n\n&gt; one thing I could never figure out is how you\u2019d get rid of things that have sets of other things\nI'm planning a model of mutability based on <https://link.springer.com/chapter/10.1007/978-3-642-24206-9_16|Dedalus>, i.e. _*accretion*_ instead of mutation (buzzword thanks to <@U013ZLJARC7> and Rich Hickey). So you express the \"new set\" as a function of the \"old set\".",
        "user": "UCGAK10LS",
        "ts": "1615259031.143100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615259581.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lpq",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "how would I model that a player has a hand of 5 cards?"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nYou'd do it similarly to a Prolog relation "
                            },
                            {
                                "type": "text",
                                "text": "holds(Player, Card)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", except the \"connections\" between datums are stored implicitly in global (UUID-based) variables, rather than via a named \"predicate\". You'd have two variables, "
                            },
                            {
                                "type": "text",
                                "text": "player",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "cardInHand",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". When you constrain "
                            },
                            {
                                "type": "text",
                                "text": "player",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to a value, e.g. "
                            },
                            {
                                "type": "text",
                                "text": "player = \"Nick\"",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", "
                            },
                            {
                                "type": "text",
                                "text": "cardInHand",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " will have five values, one representing each card. You could \"print\" all five values, or use them as part of a larger calculation.\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "one thing I could never figure out is how you\u2019d get rid of things that have sets of other things"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nI'm planning a model of mutability based on "
                            },
                            {
                                "type": "link",
                                "url": "https://link.springer.com/chapter/10.1007/978-3-642-24206-9_16",
                                "text": "Dedalus"
                            },
                            {
                                "type": "text",
                                "text": ", i.e. "
                            },
                            {
                                "type": "text",
                                "text": "accretion",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " instead of mutation (buzzword thanks to "
                            },
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " and Rich Hickey). So you express the \"new set\" as a function of the \"old set\"."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "0e92b52a-a76b-4dbd-9590-e1f6f00a36a2",
        "type": "message",
        "text": "reminds me a bit of the constraint propagation networks that <@UA14TGLTC> did really cool stuff with",
        "user": "UEBG0NPDK",
        "ts": "1615259237.143500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "kpC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "reminds me a bit of the constraint propagation networks that "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " did really cool stuff with"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9adc9a39-0510-4b1f-abfb-d462de17e8eb",
        "type": "message",
        "text": "Yeah this is a form of constraint programming. So are Prolog rules, for that matter :slightly_smiling_face:. I'll definitely like to hear what <@UA14TGLTC> thinks if he's dabbled in it.",
        "user": "UCGAK10LS",
        "ts": "1615259435.143700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "MgZ5B",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah this is a form of constraint programming. So are Prolog rules, for that matter "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". I'll definitely like to hear what "
                            },
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " thinks if he's dabbled in it."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "9af56451-b4be-4820-8f9a-9bd1010561b3",
        "type": "message",
        "text": "I guess I've been summoned.  :smiling_imp:  I'll answer any specific question: not just three.  Let me share some idle thoughts with the small advantage that I want to give this stuff another serious go soon, so it's been on my mind.\n\nThe idea I liked best about constraint propagation networks is defining the network (system of equations) entirely independently of how any of it gets resolved.  It helps with...\n\n\"hardware landscape is changing constantly\" \u2014 Don't commit to an evaluation strategy until you really know what you want to do.  Focus instead on interface and sense making.  Have a really rich system for exploring toy models, then use black boxes for the big tricky bits.\n\nI don't think very much about computational complexity.  If it's too hard calculate, the answer is probably random and not worth knowing.  I mean worst case optimization is always terrible because you're essentially finding something random: no structure beyond exhaustive search.  For instance graph-database join problems come up because pruning is happening in the wrong order or you don't have a good search heuristic.\n\n\"6th normal form\" \u2014 Think hash-tables with compound keys.  In most cases, they offer a better way to think about things tables of tuples because they show functional dependencies and entity-relationship cardinalities.  (Given a suit and a rank, you have a card.)\n\n\"mutability\" \u2014 Make time first-class and the rest follows.  Another way to think about it is that there is no time only another space-like dimension.\n\nUnordered and ordered collections are entirely different beasts.  Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things.",
        "user": "UA14TGLTC",
        "ts": "1615261652.144300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7uFBL",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I guess I've been summoned.  "
                            },
                            {
                                "type": "emoji",
                                "name": "smiling_imp"
                            },
                            {
                                "type": "text",
                                "text": "  I'll answer any specific question: not just three.  Let me share some idle thoughts with the small advantage that I want to give this stuff another serious go soon, so it's been on my mind.\n\nThe idea I liked best about constraint propagation networks is defining the network (system of equations) entirely independently of how any of it gets resolved.  It helps with...\n\n\"hardware landscape is changing constantly\" \u2014 Don't commit to an evaluation strategy until you really know what you want to do.  Focus instead on interface and sense making.  Have a really rich system for exploring toy models, then use black boxes for the big tricky bits.\n\nI don't think very much about computational complexity.  If it's too hard calculate, the answer is probably random and not worth knowing.  I mean worst case optimization is always terrible because you're essentially finding something random: no structure beyond exhaustive search.  For instance graph-database join problems come up because pruning is happening in the wrong order or you don't have a good search heuristic.\n\n\"6th normal form\" \u2014 Think hash-tables with compound keys.  In most cases, they offer a better way to think about things tables of tuples because they show functional dependencies and entity-relationship cardinalities.  (Given a suit and a rank, you have a card.)\n\n\"mutability\" \u2014 Make time first-class and the rest follows.  Another way to think about it is that there is no time only another space-like dimension.\n\nUnordered and ordered collections are entirely different beasts.  Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "male_genie",
                "users": [
                    "UCGAK10LS",
                    "UD3AK9JRF"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "17a71757-7386-4610-afbe-5e10230e5556",
        "type": "message",
        "text": "Your last two paragraphs summarize my primary principles of the last two years, and if I hadn't committed to them I think I would have gotten stuck and failed in my quest by now :slightly_smiling_face:. The rest I've only come to realise more recently.",
        "user": "UCGAK10LS",
        "ts": "1615262098.144600",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615264468.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EDN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Your last two paragraphs summarize my primary principles of the last two years, and if I hadn't committed to them I think I would have gotten stuck and failed in my quest by now "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": ". The rest I've only come to realise more recently."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f8b8f259-6284-4f10-a767-614aeab46615",
        "type": "message",
        "text": "What's the difference between a \"constraint propagation network\" and \"constraint programming language\" though? I'm only just starting to look toward that kind of literature.",
        "user": "UCGAK10LS",
        "ts": "1615262139.144800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615262173.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qgn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What's the difference between a \"constraint propagation network\" and \"constraint programming language\" though? I'm only just starting to look toward that kind of literature."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "e6e5964c-3961-429f-af21-a0215a0e78bf",
        "type": "message",
        "text": "are there some \"benchmark\" apps for end user programming? I listed two benchmark apps here <https://twitter.com/molikto/status/1369116234155921411> they are in the category of \"productivity apps\", if we have a system where these apps can be easily expressed &amp; constructed, it will be very nice.",
        "user": "URUHW0TB3",
        "ts": "1615273603.148800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "URUHW0TB3",
            "ts": "1615273630.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "QOO7",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "are there some \"benchmark\" apps for end user programming? I listed two benchmark apps here "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/molikto/status/1369116234155921411"
                            },
                            {
                                "type": "text",
                                "text": " they are in the category of \"productivity apps\", if we have a system where these apps can be easily expressed & constructed, it will be very nice."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615273603.148800",
        "reply_count": 1,
        "reply_users_count": 1,
        "latest_reply": "1615313170.160600",
        "reply_users": [
            "UC2A2ARPT"
        ],
        "subscribed": false
    },
    {
        "client_msg_id": "2bce7f0f-2890-4db4-b458-6fc3d8e66a88",
        "type": "message",
        "text": "When I say \"propagation network,\" I basically mean Sussman/Radul Propagators <https://groups.csail.mit.edu/genesis/papers/radul%202009.pdf> <https://dspace.mit.edu/handle/1721.1/44215>.  I don't see much new on that front.\n\nAs for \"constraint programming language,\" that makes me think of SAT solvers and \"constraint logic programming\" \u2014 write in Prolog, then do SAT solving for some parts instead of (or together with) unification.\n\nThe other thing I know is optimization along the Linear Programming, Mixed Integer Programming, and Quadratic Programming vein.  That all seems to live in a world apart from any other programming community.",
        "user": "UA14TGLTC",
        "ts": "1615273805.149200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "uOz3/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "When I say \"propagation network,\" I basically mean Sussman/Radul Propagators "
                            },
                            {
                                "type": "link",
                                "url": "https://groups.csail.mit.edu/genesis/papers/radul%202009.pdf"
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "link",
                                "url": "https://dspace.mit.edu/handle/1721.1/44215"
                            },
                            {
                                "type": "text",
                                "text": ".  I don't see much new on that front.\n\nAs for \"constraint programming language,\" that makes me think of SAT solvers and \"constraint logic programming\" \u2014 write in Prolog, then do SAT solving for some parts instead of (or together with) unification.\n\nThe other thing I know is optimization along the Linear Programming, Mixed Integer Programming, and Quadratic Programming vein.  That all seems to live in a world apart from any other programming community."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UCGAK10LS",
                    "U013ZLJARC7",
                    "UD3AK9JRF"
                ],
                "count": 3
            }
        ]
    },
    {
        "client_msg_id": "9B533E25-E833-46C5-A034-0647E4C694AC",
        "type": "message",
        "text": "I recently (re-)investigated \u201cconstraint logic programming\u201d and concluded as you say, that it\u2019s merely logic programming plus \u201cextra support for constraint solving\u201d. Unfortunately, the \u201clogic programming\u201d part implies tuples and tables as discussed earlier :disappointed_relieved:. An example of a constraint programming language which is not a logic programming language would be <https://www.minizinc.org|MiniZinc>, which I happily stumbled onto in my undergrad years because  it was developed here in Melbourne :slightly_smiling_face:.",
        "user": "UCGAK10LS",
        "ts": "1615277156.155400",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "title": "MiniZinc",
                "title_link": "https://www.minizinc.org/",
                "text": "MiniZinc",
                "fallback": "MiniZinc",
                "from_url": "https://www.minizinc.org/",
                "service_icon": "https://www.minizinc.org/favicon/apple-icon-57x57.png",
                "service_name": "minizinc.org",
                "id": 1,
                "original_url": "https://www.minizinc.org"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1AxO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I recently (re-)investigated \u201cconstraint logic programming\u201d and concluded as you say, that it\u2019s merely logic programming plus \u201cextra support for constraint solving\u201d. Unfortunately, the \u201clogic programming\u201d part implies tuples and tables as discussed earlier "
                            },
                            {
                                "type": "emoji",
                                "name": "disappointed_relieved"
                            },
                            {
                                "type": "text",
                                "text": ". An example of a constraint programming language which is not a logic programming language would be "
                            },
                            {
                                "type": "link",
                                "url": "https://www.minizinc.org",
                                "text": "MiniZinc"
                            },
                            {
                                "type": "text",
                                "text": ", which I happily stumbled onto in my undergrad years because  it was developed here in Melbourne "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f989a28f-8088-424f-9066-35e77df6f6cd",
        "type": "message",
        "text": "Maybe an interesting angle to break open your head and allow increased weirdness and possibilities to enter would be to think of your primitives as\n`your thing : tuple-based data structures :: Signed Distance Functions : 3d meshes`\n<https://www.youtube.com/watch?v=8--5LwHRhjk>",
        "user": "U013ZLJARC7",
        "ts": "1615281425.155900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1615306102.000000"
        },
        "attachments": [
            {
                "service_name": "YouTube",
                "service_url": "https://www.youtube.com/",
                "title": "Painting a Selfie Girl, with Maths",
                "title_link": "https://www.youtube.com/watch?v=8--5LwHRhjk",
                "author_name": "Inigo Quilez",
                "author_link": "https://www.youtube.com/c/InigoQuilez",
                "thumb_url": "https://i.ytimg.com/vi/8--5LwHRhjk/hqdefault.jpg",
                "thumb_width": 480,
                "thumb_height": 360,
                "fallback": "YouTube Video: Painting a Selfie Girl, with Maths",
                "video_html": "<iframe width=\"400\" height=\"225\" src=\"https://www.youtube.com/embed/8--5LwHRhjk?feature=oembed&autoplay=1&iv_load_policy=3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "video_html_width": 400,
                "video_html_height": 225,
                "from_url": "https://www.youtube.com/watch?v=8--5LwHRhjk",
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/youtube.png",
                "id": 1,
                "original_url": "https://www.youtube.com/watch?v=8--5LwHRhjk"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "rVScF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Maybe an interesting angle to break open your head and allow increased weirdness and possibilities to enter would be to think of your primitives as\n"
                            },
                            {
                                "type": "text",
                                "text": "your thing : tuple-based data structures :: Signed Distance Functions : 3d meshes",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=8--5LwHRhjk"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "ED117D12-BA41-4373-B9B1-3BEACA0FDA03",
        "type": "message",
        "text": "<@U013ZLJARC7> Wait, what do the colons mean? :sweat_smile:",
        "user": "UCGAK10LS",
        "ts": "1615281605.156900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l0v",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " Wait, what do the colons mean? "
                            },
                            {
                                "type": "emoji",
                                "name": "sweat_smile"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "395ea721-57f7-4eb6-96c5-9e1808330896",
        "type": "message",
        "text": "your thing \"is to\" tuple-based data structures \"as\" signed distance functions \"is to\" 3d mesh :joy_cat:",
        "user": "U013ZLJARC7",
        "ts": "1615283591.157100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1615306121.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "1kvBf",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "your thing \"is to\" tuple-based data structures \"as\" signed distance functions \"is to\" 3d mesh "
                            },
                            {
                                "type": "emoji",
                                "name": "joy_cat"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "C07EC524-9845-4633-B74A-8F16575B29E2",
        "type": "message",
        "text": "Hmm... I\u2019d say that\u2019s backwards! Tuples are points, which can be used to define meshes. Formulas (my thing) are formulas, which can be used to express SDFs!",
        "user": "UCGAK10LS",
        "ts": "1615283745.159100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615283765.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "yNNI",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hmm... I\u2019d say that\u2019s backwards! Tuples are points, which can be used to define meshes. Formulas (my thing) are formulas, which can be used to express SDFs!"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "point_up",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "410b83cb-1b24-4aed-9784-a64e31b53e96",
        "type": "message",
        "text": "that's what I'm saying, lad",
        "user": "U013ZLJARC7",
        "ts": "1615287745.159400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Euq",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "that's what I'm saying, lad"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "joy",
                "users": [
                    "UCGAK10LS",
                    "UA14TGLTC"
                ],
                "count": 2
            },
            {
                "name": "ok_hand",
                "users": [
                    "UCGAK10LS"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6a6f6300-77c9-4b0e-82a7-2e157c07e0dc",
        "type": "message",
        "text": "<@UCGAK10LS> Reversing the polarity is what I get for typing a reply while on a Zoom call :face_with_rolling_eyes:",
        "user": "U013ZLJARC7",
        "ts": "1615306153.160300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ThF",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " Reversing the polarity is what I get for typing a reply while on a Zoom call "
                            },
                            {
                                "type": "emoji",
                                "name": "face_with_rolling_eyes"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "zany_face",
                "users": [
                    "UCGAK10LS",
                    "UA14TGLTC"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "ee702af0-f1cf-458e-9c4c-9af766eb8c3c",
        "type": "message",
        "text": "Stay tuned for the (imminently) upcoming episode of the FoC podcast, about Sketch-n-Sketch. We discuss such benchmarks.",
        "user": "UC2A2ARPT",
        "ts": "1615313170.160600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "I4l5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Stay tuned for the (imminently) upcoming episode of the FoC podcast, about Sketch-n-Sketch. We discuss such benchmarks."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615273603.148800",
        "parent_user_id": "URUHW0TB3",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UA14TGLTC",
                    "URUHW0TB3"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "9e0051cf-0552-4d38-9c16-fbc1d6dd645c",
        "type": "message",
        "text": "<@UCGAK10LS> What is your definition of a formula? Is it just a computable expression of type \"boolean\"? Or do you envisage restrictions that ensure that solutions can be found with reasonable effort (time, space, etc.)?",
        "user": "UJBAJNFLK",
        "ts": "1615362365.161600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "W47T",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " What is your definition of a formula? Is it just a computable expression of type \"boolean\"? Or do you envisage restrictions that ensure that solutions can be found with reasonable effort (time, space, etc.)?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "cb5f96e3-8c1f-4ef8-a17a-fb3a4862441b",
        "type": "message",
        "text": "Yes, essentially just Boolean expressions, though calling them that is misleading, since it suggests that the Boolean value is the \"output\", and the variables that form the expression are the \"inputs\", which is not how a constraint language works.\n\nThe language may end up having restrictions that guarantee time and space bounds, but again, I want to get the \"feel\" of the language right before I start imposing those kinds of restrictions, so I haven't given them much thought. (But I _have_ given termination thought).",
        "user": "UCGAK10LS",
        "ts": "1615362556.161800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615362603.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "PdiS",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yes, essentially just Boolean expressions, though calling them that is misleading, since it suggests that the Boolean value is the \"output\", and the variables that form the expression are the \"inputs\", which is not how a constraint language works.\n\nThe language may end up having restrictions that guarantee time and space bounds, but again, I want to get the \"feel\" of the language right before I start imposing those kinds of restrictions, so I haven't given them much thought. (But I "
                            },
                            {
                                "type": "text",
                                "text": "have",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " given termination thought)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "f6331c1b-82f3-49d6-8256-5fb283daa582",
        "type": "message",
        "text": "Thanks <@UCGAK10LS>. The background of my question was the user's point of view: how much does a user have to know about computation and/or constraint programming to understand what is and is not possible in a formula.",
        "user": "UJBAJNFLK",
        "ts": "1615391886.162300",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vj7Et",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks "
                            },
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": ". The background of my question was the user's point of view: how much does a user have to know about computation and/or constraint programming to understand what is and is not possible in a formula."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "7e4d40ef-27e1-43e6-82f9-fa2446c10a3f",
        "type": "message",
        "text": "<@UA14TGLTC> You wrote: \u201c_Unordered and ordered collections are entirely different beasts.\u00a0Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things._\u201d\n\nHow do you model ordered collections \u201cproperly\u201d? I\u2019m only used to programming languages/environments where I end up using lists/vectors/arrays, which of course impose arbitrary order. Sure, sometimes there are set data types that at least express that order doesn\u2019t matter, but it sounded like your advice was hinting at more than just picking the correct type \u2014 I might also be missing the relevant experience here with constraint languages\u2026",
        "user": "U5STGTB3J",
        "ts": "1615392408.162500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "f3UC",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " You wrote: \u201c"
                            },
                            {
                                "type": "text",
                                "text": "Unordered and ordered collections are entirely different beasts.\u00a0Always know what you're modeling and never allow for arbitrary orders to be imposted on unordered things.",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u201d\n\nHow do you model ordered collections \u201cproperly\u201d? I\u2019m only used to programming languages/environments where I end up using lists/vectors/arrays, which of course impose arbitrary order. Sure, sometimes there are set data types that at least express that order doesn\u2019t matter, but it sounded like your advice was hinting at more than just picking the correct type \u2014 I might also be missing the relevant experience here with constraint languages\u2026"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "69c142e8-78d4-4bd9-86d8-3cb81528f079",
        "type": "message",
        "text": "<@U5STGTB3J> I'm wondering if he's thinking in `data Nat = Zero | Suc Nat` terms...?",
        "user": "U013ZLJARC7",
        "ts": "1615394254.162800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iJyXA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " I'm wondering if he's thinking in "
                            },
                            {
                                "type": "text",
                                "text": "data Nat = Zero | Suc Nat",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " terms...?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "16d9a380-f8e6-4ec2-ab09-4578a29c1018",
        "type": "message",
        "text": "<@UJBAJNFLK> I don't know the answer to that yet, as I don't yet have a working programming language :innocent:",
        "user": "UCGAK10LS",
        "ts": "1615424650.166700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "snRn",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJBAJNFLK"
                            },
                            {
                                "type": "text",
                                "text": " I don't know the answer to that yet, as I don't yet have a working programming language "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "fb9577ea-7b97-4b19-943d-f5c56b00bf40",
        "type": "message",
        "text": "<@U5STGTB3J> Doing ordered collections \"properly\" means including only as much ordering data as is needed to capture the desired order. So, if you have a collection of elements, and those elements are in a total order, then you can annotate each element with a natural number indicating its position in the sequence. If your elements are in a _partial order_, then you could encode their relative position using something like a multiset (which are partially ordered by the \"inclusion\" (\u2286) relation) containing \"elements that precede this element\", or whatever value best _explains_ how the ordering was constructed and how it will be maintained as the elements change. (For example, maybe a nodes-and-edges model is better.)",
        "user": "UCGAK10LS",
        "ts": "1615425394.166900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Pdj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " Doing ordered collections \"properly\" means including only as much ordering data as is needed to capture the desired order. So, if you have a collection of elements, and those elements are in a total order, then you can annotate each element with a natural number indicating its position in the sequence. If your elements are in a "
                            },
                            {
                                "type": "text",
                                "text": "partial order",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", then you could encode their relative position using something like a multiset (which are partially ordered by the \"inclusion\" (\u2286) relation) containing \"elements that precede this element\", or whatever value best "
                            },
                            {
                                "type": "text",
                                "text": "explains",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " how the ordering was constructed and how it will be maintained as the elements change. (For example, maybe a nodes-and-edges model is better.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "97aef314-db05-4745-8c20-d8d6b142468d",
        "type": "message",
        "text": "<@U5STGTB3J> with order there are two challenges:\n1. Purity: Accidentally ordering unordered collections.  It means that you can't print a set without suppling an order.  It means you cannot loop over a set either.  You can map over a set, but all the results have to be independent.  Yes, debugging becomes kind of tricky.  When looking under the hood, it's fine to see the order, but for application level debugging, you need different ways of inspecting the unordered collections.  Back a long while ago Ruby, my weapon of choice, had unordered Hashes.  Given her intrinsically imperative nature, that went badly.  So the most Rubyesk of solutions was adopted: all Hashes are ordered by when you insert keys.  This has problems, but it is useful and unsurprising.\n2. Modeling: Having good ways of managing orders.  Consish lists are simple and effective.  Annotating data with indices leads to madness.  A decent expandable Array (push, pop, queue, drop, splice) works 95% of the time.  For that last 5%, you'll want some sort of omnibus tree or rope structure together with cursors, ranges, and the like.",
        "user": "UA14TGLTC",
        "ts": "1615429729.167100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "vl/",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U5STGTB3J"
                            },
                            {
                                "type": "text",
                                "text": " with order there are two challenges:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_list",
                        "elements": [
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Purity: Accidentally ordering unordered collections.  It means that you can't print a set without suppling an order.  It means you cannot loop over a set either.  You can map over a set, but all the results have to be independent.  Yes, debugging becomes kind of tricky.  When looking under the hood, it's fine to see the order, but for application level debugging, you need different ways of inspecting the unordered collections.  Back a long while ago Ruby, my weapon of choice, had unordered Hashes.  Given her intrinsically imperative nature, that went badly.  So the most Rubyesk of solutions was adopted: all Hashes are ordered by when you insert keys.  This has problems, but it is useful and unsurprising."
                                    }
                                ]
                            },
                            {
                                "type": "rich_text_section",
                                "elements": [
                                    {
                                        "type": "text",
                                        "text": "Modeling: Having good ways of managing orders.  Consish lists are simple and effective.  Annotating data with indices leads to madness.  A decent expandable Array (push, pop, queue, drop, splice) works 95% of the time.  For that last 5%, you'll want some sort of omnibus tree or rope structure together with cursors, ranges, and the like."
                                    }
                                ]
                            }
                        ],
                        "style": "ordered",
                        "indent": 0
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5984C0ED-07F6-4A5D-A6F9-EC80CCEDF773",
        "type": "message",
        "text": "In the \u201cfuture of coding\u201d, your point #2 should definitely be relegated to the language runtime and not appear anywhere in the language itself IMO. I consider it an implementation detail.",
        "user": "UCGAK10LS",
        "ts": "1615430005.169900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6uO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the \u201cfuture of coding\u201d, your point #2 should definitely be relegated to the language runtime and not appear anywhere in the language itself IMO. I consider it an implementation detail."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "297B70A3-0CBE-4DCC-8DD9-330E937E52D6",
        "type": "message",
        "text": "I\u2019d say the key is to give users of the language good ways to specific the abstract ordering information they need and ways to operate over such ordered collections",
        "user": "UCGAK10LS",
        "ts": "1615430110.172400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "21aie",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019d say the key is to give users of the language good ways to specific the abstract ordering information they need and ways to operate over such ordered collections"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "2b37460a-ec54-47cf-ad9c-4fac2734b400",
        "type": "message",
        "text": "In the language itself, you need to decide on what level or degree sequence munging you want to feel natural.  On one extreme, you might go with ordering by time column.  In that case, try to avoid use cases where mutable indicies (1, 2, 3) seem like a solution.  On the other extreme, you might want to support, I don't know, arbitrary selections of DOMish tree-nodes.  Yes, in an especially high-level language you'll likely want the application developer to be able to ignore the underlying representation.  (Often this means doing tricks to as to avoid allocating small arrays.)  Perhaps providing a DLS escape value for fixed sized arrays, or, I don't know whatever your GPU's shader language supports.  It becomes a matter of answering, \"What is this system naturally good for?\"  And the even better question, \"What is this system naturally bad at?\"",
        "user": "UA14TGLTC",
        "ts": "1615430736.172600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "UC0",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the language itself, you need to decide on what level or degree sequence munging you want to feel natural.  On one extreme, you might go with ordering by time column.  In that case, try to avoid use cases where mutable indicies (1, 2, 3) seem like a solution.  On the other extreme, you might want to support, I don't know, arbitrary selections of DOMish tree-nodes.  Yes, in an especially high-level language you'll likely want the application developer to be able to ignore the underlying representation.  (Often this means doing tricks to as to avoid allocating small arrays.)  Perhaps providing a DLS escape value for fixed sized arrays, or, I don't know whatever your GPU's shader language supports.  It becomes a matter of answering, \"What is this system naturally good for?\"  And the even better question, \"What is this system naturally bad at?\""
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "b70b45fb-c38a-41dd-9a85-fc6cd99ce9e3",
        "type": "message",
        "text": "Disclaimer: what follows is my thoughts on language design for \"the future of coding\" (the next decade), not for a near-term business need or specific market niche.\n\nI have trouble accepting the \"you have to make a performance trade-off\" hypothesis that I feel is alluded to (\"what is it bad at?\"). I feel it is invoking the myth that the higher-level your language is, the worse its execution efficiency must be. (Once upon a time, garbage collection overhead was ridiculed.) In reality every program is just a _specification_ and efficiency comes down to how well that specification can be translated into a hardware-consumable language. A smart mapping requires a smart implementation, and also a smart choice of hardware platform. I'm dead certain that CPUs and cache hierarchies are not the future, so assessing a language based on its ability to support \"cache locality\" and such is a dangerous mental trap. As I've previously said, implementation issues will be a fun puzzle that comes _after_ the language has been designed, and not a moment sooner. (As long as the language has a clear specification, a \"suboptimal\" implementation will be easy to develop.) The kinds of applications (and therefore markets) for which the language is \"fast enough\" will be revealed in the course of building the \"best\" implementation possible on each potential hardware platform, such as a CPU, GPU, or AI chip.",
        "user": "UCGAK10LS",
        "ts": "1615432621.172800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615432876.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "N5l",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Disclaimer: what follows is my thoughts on language design for \"the future of coding\" (the next decade), not for a near-term business need or specific market niche.\n\nI have trouble accepting the \"you have to make a performance trade-off\" hypothesis that I feel is alluded to (\"what is it bad at?\"). I feel it is invoking the myth that the higher-level your language is, the worse its execution efficiency must be. (Once upon a time, garbage collection overhead was ridiculed.) In reality every program is just a "
                            },
                            {
                                "type": "text",
                                "text": "specification",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and efficiency comes down to how well that specification can be translated into a hardware-consumable language. A smart mapping requires a smart implementation, and also a smart choice of hardware platform. I'm dead certain that CPUs and cache hierarchies are not the future, so assessing a language based on its ability to support \"cache locality\" and such is a dangerous mental trap. As I've previously said, implementation issues will be a fun puzzle that comes "
                            },
                            {
                                "type": "text",
                                "text": "after",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the language has been designed, and not a moment sooner. (As long as the language has a clear specification, a \"suboptimal\" implementation will be easy to develop.) The kinds of applications (and therefore markets) for which the language is \"fast enough\" will be revealed in the course of building the \"best\" implementation possible on each potential hardware platform, such as a CPU, GPU, or AI chip."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "6d941db8-75b4-4642-b8c7-d3545ad0b1af",
        "type": "message",
        "text": "You may not have been hinting that way, and if so just ignore the above :stuck_out_tongue:\n\nAnyway, if we can throw the \"efficiency is a problem\" hypothesis in the dustbin, the only real concern is _what does a user of the language experience_? How do we present the \"raw essence\" of order and nothing else? I think that's what the interesting problem here. You're right that oftentimes indices may not encode the _essence_ of the order the user is trying to express, and perhaps a graph model (which cons-lists and trees try to approximate) is a more faithful encoding, and better supports the operations that will be performed upon the collection. Happily, logic languages (and the kind of language I'm designing) are particularly good at representing and operating over graphs.",
        "user": "UCGAK10LS",
        "ts": "1615432778.173000",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615433005.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "fkj",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You may not have been hinting that way, and if so just ignore the above "
                            },
                            {
                                "type": "emoji",
                                "name": "stuck_out_tongue"
                            },
                            {
                                "type": "text",
                                "text": "\n\nAnyway, if we can throw the \"efficiency is a problem\" hypothesis in the dustbin, the only real concern is "
                            },
                            {
                                "type": "text",
                                "text": "what does a user of the language experience",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "? How do we present the \"raw essence\" of order and nothing else? I think that's what the interesting problem here. You're right that oftentimes indices may not encode the"
                            },
                            {
                                "type": "text",
                                "text": " essence ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "of the order the user is trying to express, and perhaps a graph model (which cons-lists and trees try to approximate) is a more faithful encoding, and better supports the operations that will be performed upon the collection. Happily, logic languages (and the kind of language I'm designing) are particularly good at representing and operating over graphs."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "cfd47c86-d2bc-4c81-9e83-38a9edd004e2",
        "type": "message",
        "text": "I better clarify.  I meant \"what is this language bad at expressing?\"  No performance consideration whatsoever.  You have to pick the most natural, idiomatic way to say things.  If you answer \"I want people to be able to do anything,\" then you get bloat.  Between molecular and kitchen-sink extremes there are a lot reasonable (and unreasonable) tradeoffs.\n\nConsider dynamic/scripting languages, which are all practically the same at some level.  (I did a talk promoting them forever ago when Java was king, and the Web was young.)  Consider Lua, Python, Ruby, and JavaScript.\n\nLua strives for a precise, beautiful minimalism.  \"Lua provides mechanism not policy. ... Instead of littering the language with lots of features, we provided ways for users to program the features themselves, in the way they wanted them, and only for those features they needed.\"\n\nPython is includes batteries plus \"there should be one \u2014 and preferably only one \u2014 obvious way to do it.\"  Prepare for ridicule if you don't like the one way.  (Generators, I'm looking at you.)\n\nMatz says, \"I'm trying to make Ruby natural, not simple.\"  Ruby is complicated, overcomplicated but in all the \"right\" ways.  Let's have methods, blocks, procs, and lambdas with multiple notations for each.  Let's have objects, classes, singleton classes, metaclasses <https://en.wikipedia.org/wiki/Metaclass#In_Ruby>, and mixin modules, which can be included, prepended, or extended.  Then add refinements <https://rubyreferences.github.io/rubyref/language/refinements.html> for kicks.  For concurrency, we have threads, UNIX processes, coroutines, continuations, and now \"Ractors\" <https://github.com/ruby/ruby/blob/master/doc/ractor.md>.  Yet somehow Ruby ends up fairly programmer friendly.\n\nContrast with JavaScript, which is simultaneously overcomplicated <https://www.destroyallsoftware.com/talks/wat> and underpowered, \"Given the process that created JavaScript and made it a de facto standard, we deserve something far worse.\"  (Maybe React, TypeScript, or whatever makes JS better.  I honestly get by with jQuery despite its clear shortcomings.)",
        "user": "UA14TGLTC",
        "ts": "1615452903.173400",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "ruby/ruby",
                "title_link": "https://github.com/ruby/ruby/blob/master/doc/ractor.md",
                "text": "The Ruby Programming Language [mirror]. Contribute to ruby/ruby development by creating an account on GitHub.",
                "fallback": "GitHub: ruby/ruby",
                "thumb_url": "https://avatars.githubusercontent.com/u/210414?s=400&v=4",
                "from_url": "https://github.com/ruby/ruby/blob/master/doc/ractor.md",
                "thumb_width": 400,
                "thumb_height": 400,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/ruby/ruby/blob/master/doc/ractor.md"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zQKv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I better clarify.  I meant \"what is this language bad at expressing?\"  No performance consideration whatsoever.  You have to pick the most natural, idiomatic way to say things.  If you answer \"I want people to be able to do anything,\" then you get bloat.  Between molecular and kitchen-sink extremes there are a lot reasonable (and unreasonable) tradeoffs.\n\nConsider dynamic/scripting languages, which are all practically the same at some level.  (I did a talk promoting them forever ago when Java was king, and the Web was young.)  Consider Lua, Python, Ruby, and JavaScript.\n\nLua strives for a precise, beautiful minimalism.  \"Lua provides mechanism not policy. ... Instead of littering the language with lots of features, we provided ways for users to program the features themselves, in the way they wanted them, and only for those features they needed.\"\n\nPython is includes batteries plus \"there should be one \u2014 and preferably only one \u2014 obvious way to do it.\"  Prepare for ridicule if you don't like the one way.  (Generators, I'm looking at you.)\n\nMatz says, \"I'm trying to make Ruby natural, not simple.\"  Ruby is complicated, overcomplicated but in all the \"right\" ways.  Let's have methods, blocks, procs, and lambdas with multiple notations for each.  Let's have objects, classes, singleton classes, metaclasses "
                            },
                            {
                                "type": "link",
                                "url": "https://en.wikipedia.org/wiki/Metaclass#In_Ruby"
                            },
                            {
                                "type": "text",
                                "text": ", and mixin modules, which can be included, prepended, or extended.  Then add refinements "
                            },
                            {
                                "type": "link",
                                "url": "https://rubyreferences.github.io/rubyref/language/refinements.html"
                            },
                            {
                                "type": "text",
                                "text": " for kicks.  For concurrency, we have threads, UNIX processes, coroutines, continuations, and now \"Ractors\" "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/ruby/ruby/blob/master/doc/ractor.md"
                            },
                            {
                                "type": "text",
                                "text": ".  Yet somehow Ruby ends up fairly programmer friendly.\n\nContrast with JavaScript, which is simultaneously overcomplicated "
                            },
                            {
                                "type": "link",
                                "url": "https://www.destroyallsoftware.com/talks/wat"
                            },
                            {
                                "type": "text",
                                "text": " and underpowered, \"Given the process that created JavaScript and made it a de facto standard, we deserve something far worse.\"  (Maybe React, TypeScript, or whatever makes JS better.  I honestly get by with jQuery despite its clear shortcomings.)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c55ef160-1786-49ed-abd0-b5f2d3e35897",
        "type": "message",
        "text": "I believe that (alleged) tradeoff is best handled by defining a general-purpose base language that can support embedded DSLs (in a *structured editing* environment where non-textual syntax is allowed). Each common task category (e.g. list manipulation) can have its own DSL, which is a thin veneer (a \"syntactic sugar\") over the base language. In short: we accept there is *no universal syntax* that intuitively expresses all computational tasks.\n\nIf we support user-defined syntaxes atop a common underlying semantics then I truly think \"people can do anything\" all in the same language environment.",
        "user": "UCGAK10LS",
        "ts": "1615617625.175800",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615617678.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xi2+H",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I believe that (alleged) tradeoff is best handled by defining a general-purpose base language that can support embedded DSLs (in a "
                            },
                            {
                                "type": "text",
                                "text": "structured editing",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " environment where non-textual syntax is allowed). Each common task category (e.g. list manipulation) can have its own DSL, which is a thin veneer (a \"syntactic sugar\") over the base language. In short: we accept there is "
                            },
                            {
                                "type": "text",
                                "text": "no universal syntax",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " that intuitively expresses all computational tasks.\n\nIf we support user-defined syntaxes atop a common underlying semantics then I truly think \"people can do anything\" all in the same language environment."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "a6a67965-d1ac-4d3d-9d4c-3bbbac27fc92",
        "type": "message",
        "text": "<@UA14TGLTC> I've spent some time today reading some of Alexey Radul's thesis on \"propagation networks\", and I find the idea underwhelming to be honest. The biggest issue is that they don't innovate on how to express compound data: they still advocate the use of Cons, and other hierarchical data structures. Additionally, their proposed means of abstracting a common pattern (subnetwork), is to define a Scheme function that parameterizes and can generate instances of the subnetwork. In other words, their semantics isn't \"complete\"; it needs to be embedded in a functional language!\n\nThe one idea that I agree with is basing computation on constraints (e.g. intervals) rather than values. But they haven't sold me on their broader approach.",
        "user": "UCGAK10LS",
        "ts": "1615692598.177100",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615692793.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "RQq9Q",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UA14TGLTC"
                            },
                            {
                                "type": "text",
                                "text": " I've spent some time today reading some of Alexey Radul's thesis on \"propagation networks\", and I find the idea underwhelming to be honest. The biggest issue is that they don't innovate on how to express compound data: they still advocate the use of Cons, and other hierarchical data structures. Additionally, their proposed means of abstracting a common pattern (subnetwork), is to define a Scheme function that parameterizes and can generate instances of the subnetwork. In other words, their semantics isn't \"complete\"; it needs to be embedded in a functional language!\n\nThe one idea that I agree with is basing computation on constraints (e.g. intervals) rather than values. But they haven't sold me on their broader approach."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "5C78AAD3-064F-4BE9-8678-D29674545ED9",
        "type": "message",
        "text": "You make a good point about abstraction/parametrization.  It\u2019s certainly where my attention is these days as most rules that I want depend on a context of 2-6 things.\n\nSome of the applied category theory people are interested in the topic of modeling abstraction and composition over general networks.",
        "user": "UA14TGLTC",
        "ts": "1615710818.180800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "pz+Xh",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "You make a good point about abstraction/parametrization.  It\u2019s certainly where my attention is these days as most rules that I want depend on a context of 2-6 things.\n\nSome of the applied category theory people are interested in the topic of modeling abstraction and composition over general networks."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "94EAFD0F-82B3-40FA-ACCB-D5EA0044AD2E",
        "type": "message",
        "text": "Yeah I spent a few weeks digging into the applied category stuff but I ended up concluding that it offers no obvious insights into programming language design (other than the overarching idea of letting mathematics and composable patterns guide your designs).",
        "user": "UCGAK10LS",
        "ts": "1615715028.184700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Vkk=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Yeah I spent a few weeks digging into the applied category stuff but I ended up concluding that it offers no obvious insights into programming language design (other than the overarching idea of letting mathematics and composable patterns guide your designs)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c51a5b0b-d1c6-4407-bd5e-15eed2d7e894",
        "type": "message",
        "text": "<@UCGAK10LS> Check out <https://youtu.be/mwxknB4SgvM?t=787|this section> (time code 787) of this Sussman talk to see if there's anything there for you in the Propagators idea. Your description above suggests you _might_ have gotten wrong-footed by implementation details.",
        "user": "U013ZLJARC7",
        "ts": "1615734322.185200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U013ZLJARC7",
            "ts": "1615741050.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "7sgE",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UCGAK10LS"
                            },
                            {
                                "type": "text",
                                "text": " Check out "
                            },
                            {
                                "type": "link",
                                "url": "https://youtu.be/mwxknB4SgvM?t=787",
                                "text": "this section"
                            },
                            {
                                "type": "text",
                                "text": " (time code 787) of this Sussman talk to see if there's anything there for you in the Propagators idea. Your description above suggests you "
                            },
                            {
                                "type": "text",
                                "text": "might",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have gotten wrong-footed by implementation details."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "8bce2825-309c-468b-b7fa-bac440e2eae1",
        "type": "message",
        "text": "<@U013ZLJARC7> I watched that section, and didn't see anything interesting beyond the general idea of constraint programming (which is all about refining constraints / accruing information). I have problems with more than just the implementation of their model: the very model itself demands language users to construct \"networks of machines\" (propagators), which I find unsalvageable. Why should a program consist of \"cells\"? They don't map clearly to human reasoning and logic. I'll assert the following: humans don't naturally describe _*goals*_ (N.B: I'm not talking about steps/strategies) within a searching or measuring task (a computation) in terms of storing and retrieving information from abstract \"cells\" of knowledge; instead we describe the factors/quantities in our domain, and the relationships/constraints between them (including iterative/recursive relationships). Propagators seem to be adding arbitrary hoops and hurdles on top of that, by asking us to think in terms of machines and memories.",
        "user": "UCGAK10LS",
        "ts": "1615766181.186100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "26xoN",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "U013ZLJARC7"
                            },
                            {
                                "type": "text",
                                "text": " I watched that section, and didn't see anything interesting beyond the general idea of constraint programming (which is all about refining constraints / accruing information). I have problems with more than just the implementation of their model: the very model itself demands language users to construct \"networks of machines\" (propagators), which I find unsalvageable. Why should a program consist of \"cells\"? They don't map clearly to human reasoning and logic. I'll assert the following: humans don't naturally describe "
                            },
                            {
                                "type": "text",
                                "text": "goals",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (N.B: I'm not talking about steps/strategies) within a searching or measuring task (a computation) in terms of storing and retrieving information from abstract \"cells\" of knowledge; instead we describe the factors/quantities in our domain, and the relationships/constraints between them (including iterative/recursive relationships). Propagators seem to be adding arbitrary hoops and hurdles on top of that, by asking us to think in terms of machines and memories."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "c7abccf0-58fe-4973-a1e4-c2979bcc0b2c",
        "type": "message",
        "text": "They may have reached this design by asking: \"how do we design a language for massively parallel &amp; distributed systems?\" (as Alexey does in his thesis) and then *falling into the trap* of thinking that such a language must be based on a network of machines, so that it can \"map naturally\" to a distributed system. This is a trap that language designers have always fallen into: start by thinking about the hardware you're targeting, and then design a language that you feel is \"appropriate\" for that hardware. That might be necessary if you want to bake specific performance guarantees into your language, but you'll always end up with something that demands users to think like a machine.\n\nIf that's not the reasoning behind their network model then I'm not sure what is. Alexey explicitly opts-out of justifying the design in his thesis. He says:\n&gt; I can therefore afford to present [propagator networks] on their own merits, with the promise that they turned out to actually work as my evidence of their validity, rather than documenting the tortuous intellectual path that led here.\nSince they haven't justified their design, it feels arbitrary and ideological. I've grown incredibly wary of making arbitrary choices in my own work.",
        "user": "UCGAK10LS",
        "ts": "1615766771.186300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1615767941.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "=kaED",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "They may have reached this design by asking: \"how do we design a language for massively parallel & distributed systems?\" (as Alexey does in his thesis) and then "
                            },
                            {
                                "type": "text",
                                "text": "falling into the trap",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of thinking that such a language must be based on a network of machines, so that it can \"map naturally\" to a distributed system. This is a trap that language designers have always fallen into: start by thinking about the hardware you're targeting, and then design a language that you feel is \"appropriate\" for that hardware. That might be necessary if you want to bake specific performance guarantees into your language, but you'll always end up with something that demands users to think like a machine.\n\nIf that's not the reasoning behind their network model then I'm not sure what is. Alexey explicitly opts-out of justifying the design in his thesis. He says:\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I can therefore afford to present [propagator networks] on their own merits, with the promise that they turned out to actually work as my evidence of their validity, rather than documenting the tortuous intellectual path that led here."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nSince they haven't justified their design, it feels arbitrary and ideological. I've grown incredibly wary of making arbitrary choices in my own work."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1615252973.136100",
        "parent_user_id": "UCGAK10LS"
    }
]