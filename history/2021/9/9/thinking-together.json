[
    {
        "client_msg_id": "7fe743b7-1704-438e-9238-a253931ad7f3",
        "type": "message",
        "text": "I'm thinking more about the _sensation of time_, as it pertains to the execution of code. (Yeah, back on my bullshit.) I see a spectrum here \u2014\u00a0a spectrum of different sensations of time for different ways we interact with computation.\n\nOn one end of the spectrum, we have raw math. There's not supposed to be any sensation of time in the evaluation of math. A variable _always_ has a specific value; relationships either exist or they don't. It might take you (or a computer) some time to crunch values and arrive at a result, but that's _absolutely_ _not_ supposed to be part of the aesthetic. Conal Elliot's Denotational Design is an application of this sort of thinking to software design. Lambda calculus, Curry-Howard, and some of the more hardcore FP languages all exist \u2014 infinitely, suspended frozen in midair \u2014 over here. Of course, no computer language is _actually_ timeless (that violated physics, and this is addressed in Church-Turing and related work, and we all agree never to try that again), but the desired _sensation_ \u2014 the aesthetic \u2014 is one in which time is not a constraint or concern.\n\nOn the other end of the spectrum, we have mechanical computers. There's no avoiding the sensation of time when operating these clockwork beasts. You're required to think about the passage of time as you plan an execution, or else the result will be nonsense, or malfunction. Nothing is instant, nothing exists until you build it. Here we find the CAP theorem, Turing machines, and Rich Hickey's The Language of the System, all of them toiling, sweating, grinding, churning.\n\n[Aside: note that Functional Programming is orthogonal to this spectrum \u2014 it is not bound to the _math_ side. On either extreme and anywhere in between, you can have programming that's about immutable values (or not), static vs dynamic binding, data &amp; behaviour co-located (or not), for-each vs map, place-oriented vs value-oriented, and so forth.]\n\nI've spent all my time over in the _mechanical labour camp_ \u2014\u00a0this is where Hest lives. So I don't have much insight at all into the _crystal tower of pure evaluation_. So beyond just suggesting \"Hey, talk about this spectrum\" (which, granted, I am suggesting), I'd also like to know what examples you can point to that obviously violate this common alignment of aesthetics. For example: what's the most _*I feel the passage of time in execution*_ you can get to when working with something like Coq, or Haskell, or APL? Is there some step debugger for SML that really lets you feel the iterative progress through execution? Or on the other side, what's out there that takes a process rooted in time \u2014 like CAP \u2014 and makes it shake that feeling of temporality? Look at something like Erlang/OTP \u2014 they take Prolog (timeless) and reify the sensation of process (\"let it fail\"). Who else is doing that? Is anyone doing it in the other direction?",
        "user": "UC2A2ARPT",
        "ts": "1631156760.159500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UC2A2ARPT",
            "ts": "1631163783.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "4lmu",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I'm thinking more about the "
                            },
                            {
                                "type": "text",
                                "text": "sensation of time",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", as it pertains to the execution of code. (Yeah, back on my bullshit.) I see a spectrum here \u2014\u00a0a spectrum of different sensations of time for different ways we interact with computation.\n\nOn one end of the spectrum, we have raw math. There's not supposed to be any sensation of time in the evaluation of math. A variable "
                            },
                            {
                                "type": "text",
                                "text": "always",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " has a specific value; relationships either exist or they don't. It might take you (or a computer) some time to crunch values and arrive at a result, but that's "
                            },
                            {
                                "type": "text",
                                "text": "absolutely",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " "
                            },
                            {
                                "type": "text",
                                "text": "not",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " supposed to be part of the aesthetic. Conal Elliot's Denotational Design is an application of this sort of thinking to software design. Lambda calculus, Curry-Howard, and some of the more hardcore FP languages all exist \u2014 infinitely, suspended frozen in midair \u2014 over here. Of course, no computer language is "
                            },
                            {
                                "type": "text",
                                "text": "actually",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " timeless (that violated physics, and this is addressed in Church-Turing and related work, and we all agree never to try that again), but the desired "
                            },
                            {
                                "type": "text",
                                "text": "sensation ",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u2014 the aesthetic \u2014 is one in which time is not a constraint or concern.\n\nOn the other end of the spectrum, we have mechanical computers. There's no avoiding the sensation of time when operating these clockwork beasts. You're required to think about the passage of time as you plan an execution, or else the result will be nonsense, or malfunction. Nothing is instant, nothing exists until you build it. Here we find the CAP theorem, Turing machines, and Rich Hickey's The Language of the System, all of them toiling, sweating, grinding, churning.\n\n[Aside: note that Functional Programming is orthogonal to this spectrum \u2014 it is not bound to the "
                            },
                            {
                                "type": "text",
                                "text": "math",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " side. On either extreme and anywhere in between, you can have programming that's about immutable values (or not), static vs dynamic binding, data & behaviour co-located (or not), for-each vs map, place-oriented vs value-oriented, and so forth.]\n\nI've spent all my time over in the "
                            },
                            {
                                "type": "text",
                                "text": "mechanical labour camp",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " \u2014\u00a0this is where Hest lives. So I don't have much insight at all into the "
                            },
                            {
                                "type": "text",
                                "text": "crystal tower of pure evaluation",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". So beyond just suggesting \"Hey, talk about this spectrum\" (which, granted, I am suggesting), I'd also like to know what examples you can point to that obviously violate this common alignment of aesthetics. For example: what's the most "
                            },
                            {
                                "type": "text",
                                "text": "I feel the passage of time in execution",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " you can get to when working with something like Coq, or Haskell, or APL? Is there some step debugger for SML that really lets you feel the iterative progress through execution? Or on the other side, what's out there that takes a process rooted in time \u2014 like CAP \u2014 and makes it shake that feeling of temporality? Look at something like Erlang/OTP \u2014 they take Prolog (timeless) and reify the sensation of process (\"let it fail\"). Who else is doing that? Is anyone doing it in the other direction?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "reply_count": 12,
        "reply_users_count": 8,
        "latest_reply": "1631352756.173700",
        "reply_users": [
            "UFPPABQ7P",
            "UDQBTJ211",
            "UBN9AFS0N",
            "UJFN50C00",
            "UJZS8UUJV",
            "UEBG0NPDK",
            "UC2A2ARPT",
            "U8A5MS6R1"
        ],
        "is_locked": false,
        "subscribed": true,
        "last_read": "1631237662.168000",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UCUSW7WVD",
                    "UJBAJNFLK",
                    "UDQBTJ211",
                    "UA14TGLTC"
                ],
                "count": 4
            }
        ]
    },
    {
        "client_msg_id": "5c6294d9-dad7-424b-8ba9-7ab3d4b45ab3",
        "type": "message",
        "text": "Potentially in this direction could be something like <http://temporal.io|temporal.io> , which is a workflow language that makes keeping value in the stack for weeks at a time, a comfortable endeavor. (The contrast is usually we put values into a database so they can survive an upgrade over the course of the weeks)",
        "user": "UFPPABQ7P",
        "ts": "1631186340.163300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UFPPABQ7P",
            "ts": "1631186360.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "l243",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Potentially in this direction could be something like "
                            },
                            {
                                "type": "link",
                                "url": "http://temporal.io",
                                "text": "temporal.io"
                            },
                            {
                                "type": "text",
                                "text": " , which is a workflow language that makes keeping value in the stack for weeks at a time, a comfortable endeavor. (The contrast is usually we put values into a database so they can survive an upgrade over the course of the weeks)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "6a360540-4fa3-4a03-81c2-53e31c76a1c5",
        "type": "message",
        "text": "Also, on another side of this that may or may not bear any fruit, is <https://www.liquidsoap.info/|https://www.liquidsoap.info/> , a language for programming media streams.",
        "user": "UFPPABQ7P",
        "ts": "1631186537.163600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "BIb",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Also, on another side of this that may or may not bear any fruit, is "
                            },
                            {
                                "type": "link",
                                "url": "https://www.liquidsoap.info/",
                                "text": "https://www.liquidsoap.info/"
                            },
                            {
                                "type": "text",
                                "text": " , a language for programming media streams."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "721db07f-c345-4948-8964-8f782e30b7e4",
        "type": "message",
        "text": "I don't really know enough about the Haskell end of this spectrum but my sense is that the units for it are probably something like \"percent of the code that has some kind of invariance guarantee\".\n\nIf you take something multi paradigm like Java or C++ it is possible to write very mathsy code by leaning in heavily on const, interfaces, classes etc. and earn yourself very strong guarantees about invariance over time. Different languages force or encourage you to bake more guarantees into your code but it's something that is possible in any language. Even something like Python, in the real world, will probably come with a stack of Organisational Practices and socially enforced norms that allow to _in practice_ make similar assumptions, even though you could in theory overwrite the + operator at runtime.\n\nAccepting these kinds of restrictions limits your expressivity but can superpower your understanding of a codebase because it lets you make massively compressing abstractions and draw very clean line_s (\"Ok... this can't\u00a0*possibly*\u00a0affect this... It must have come from A, B or C..._\").\n\nTime invariance is an affordance that lets you better \"play computer in your head\", as Bret Victor would say.\n\nSo basically I think the reason that Haskell programmers play down the actual execution of their code is they are backing themselves to have already run it accurately in their head beforehand.",
        "user": "UDQBTJ211",
        "ts": "1631193162.164400",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "NmnvA",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don't really know enough about the Haskell end of this spectrum but my sense is that the units for it are probably something like \"percent of the code that has some kind of invariance guarantee\".\n\nIf you take something multi paradigm like Java or C++ it is possible to write very mathsy code by leaning in heavily on const, interfaces, classes etc. and earn yourself very strong guarantees about invariance over time. Different languages force or encourage you to bake more guarantees into your code but it's something that is possible in any language. Even something like Python, in the real world, will probably come with a stack of Organisational Practices and socially enforced norms that allow to "
                            },
                            {
                                "type": "text",
                                "text": "in practice",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " make similar assumptions, even though you could in theory overwrite the + operator at runtime.\n\nAccepting these kinds of restrictions limits your expressivity but can superpower your understanding of a codebase because it lets you make massively compressing abstractions and draw very clean line"
                            },
                            {
                                "type": "text",
                                "text": "s (\"Ok... this can't\u00a0",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "possibly",
                                "style": {
                                    "bold": true,
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\u00a0affect this... It must have come from A, B or C...",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\").\n\nTime invariance is an affordance that lets you better \"play computer in your head\", as Bret Victor would say.\n\nSo basically I think the reason that Haskell programmers play down the actual execution of their code is they are backing themselves to have already run it accurately in their head beforehand."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "37bd374a-db77-43f3-a290-c8f63bbf3865",
        "type": "message",
        "text": "I basically believe you should start from the opposite end.\n\nComputers are physical machines that literally, actually, move and change with the forward arrow of time as part of the physical universe. Because they change in very small ways and very quickly, they kind of fly below our intuition radar. They are also highly deterministic compared to naturally occurring phenomena.\n\nStill, they actually do perform an irreversible action just like a computer built out of metal ball bearings falling through chutes (<https://www.turingtumble.com/>).\n\nIf you want to understand what happened, you should just record what happened and then interrogate that recording with a powerful suite of thinking tools.",
        "user": "UDQBTJ211",
        "ts": "1631193526.164600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "H897",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I basically believe you should start from the opposite end.\n\nComputers are physical machines that literally, actually, move and change with the forward arrow of time as part of the physical universe. Because they change in very small ways and very quickly, they kind of fly below our intuition radar. They are also highly deterministic compared to naturally occurring phenomena.\n\nStill, they actually do perform an irreversible action just like a computer built out of metal ball bearings falling through chutes ("
                            },
                            {
                                "type": "link",
                                "url": "https://www.turingtumble.com/"
                            },
                            {
                                "type": "text",
                                "text": ").\n\nIf you want to understand what happened, you should just record what happened and then interrogate that recording with a powerful suite of thinking tools."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT",
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "151f51ed-e718-4265-95ea-5500d460eaa7",
        "type": "message",
        "text": "Temporal Logic of Actions sounds like an in between in your spectrum:\n\n&gt; This paper introduces TLA, which I now believe is the best general formalism for describing and reasoning about concurrent systems. The new idea in TLA is that one can use actions\u2013formulas with primed and unprimed variables\u2013in temporal formulas. An action describes a state-transition relation. For example, the action x\u2019=x+1 means approximately the same thing as the programming-language statement x := x+1.\n<https://www.microsoft.com/en-us/research/publication/the-temporal-logic-of-actions/>",
        "user": "UBN9AFS0N",
        "ts": "1631193660.164800",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "A/Vr",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Temporal Logic of Actions sounds like an in between in your spectrum:\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This paper introduces TLA, which I now believe is the best general formalism for describing and reasoning about concurrent systems. The new idea in TLA is that one can use actions\u2013formulas with primed and unprimed variables\u2013in temporal formulas. An action describes a state-transition relation. For example, the action x\u2019=x+1 means approximately the same thing as the programming-language statement x := x+1."
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\n"
                            },
                            {
                                "type": "link",
                                "url": "https://www.microsoft.com/en-us/research/publication/the-temporal-logic-of-actions/"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "93F35BA6-AB4D-4C97-9C71-6D4A5A9E4EAE",
        "type": "message",
        "text": "This virtual time approach? <https://twitter.com/codefrau/status/1430715818115883008?s=20|https://twitter.com/codefrau/status/1430715818115883008?s=20>",
        "user": "UJFN50C00",
        "ts": "1631211675.166600",
        "team": "T5TCAFTA9",
        "attachments": [
            {
                "fallback": "<https://twitter.com/codefrau|@codefrau>: What is <https://twitter.com/croquetio|@croquetio> anyways?\n\nA thread :thread: <https://pbs.twimg.com/tweet_video_thumb/E9rrhZjVEAAplos.jpg>",
                "ts": 1629944207,
                "author_name": "Vanessa wrote a thing",
                "author_link": "https://twitter.com/codefrau/status/1430715818115883008",
                "author_icon": "https://pbs.twimg.com/profile_images/1400712341600178176/LNtov3Jt_normal.jpg",
                "author_subname": "@codefrau",
                "text": "What is <https://twitter.com/croquetio|@croquetio> anyways?\n\nA thread :thread:",
                "service_name": "twitter",
                "service_url": "https://twitter.com/",
                "from_url": "https://twitter.com/codefrau/status/1430715818115883008?s=20",
                "thumb_url": "https://pbs.twimg.com/tweet_video_thumb/E9rrhZjVEAAplos.jpg",
                "thumb_width": 1200,
                "thumb_height": 675,
                "video_html_width": 1200,
                "video_html_height": 675,
                "video_html": "<video autoplay loop muted poster=\"https://pbs.twimg.com/tweet_video_thumb/E9rrhZjVEAAplos.jpg\" width=\"1200\" height=\"675\"><source type=\"video/mp4\" src=\"https://video.twimg.com/tweet_video/E9rrhZjVEAAplos.mp4\"></video>",
                "id": 1,
                "original_url": "https://twitter.com/codefrau/status/1430715818115883008?s=20",
                "footer": "Twitter",
                "footer_icon": "https://a.slack-edge.com/80588/img/services/twitter_pixel_snapped_32.png"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ODo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "This virtual time approach? "
                            },
                            {
                                "type": "link",
                                "url": "https://twitter.com/codefrau/status/1430715818115883008?s=20",
                                "text": "https://twitter.com/codefrau/status/1430715818115883008?s=20"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "63ad7d45-9693-4abc-9ac6-52c10bd814fc",
        "type": "message",
        "text": "<@UC2A2ARPT>\n&gt; Functional Programming is orthogonal to this spectrum\nI don\u2019t get this. While I would normally think of functional programming as being on the timeless end of the spectrum, you make a good point that it can also be on other end. But isn\u2019t it the case that programming styles that _contrast_ with FP often _do_ have to be structured in time? To pick from your examples, how would you have mutable values without modeling time? Or with `forEach`  don\u2019t you need to have time to have side effects work?",
        "user": "UJZS8UUJV",
        "ts": "1631233109.167700",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UJZS8UUJV",
            "ts": "1631233840.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "EmDaM",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UC2A2ARPT"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Functional Programming is orthogonal to this spectrum"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don\u2019t get this. While I would normally think of functional programming as being on the timeless end of the spectrum, you make a good point that it can also be on other end. But isn\u2019t it the case that programming styles that "
                            },
                            {
                                "type": "text",
                                "text": "contrast",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " with FP often "
                            },
                            {
                                "type": "text",
                                "text": "do",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have to be structured in time? To pick from your examples, how would you have mutable values without modeling time? Or with "
                            },
                            {
                                "type": "text",
                                "text": "forEach",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "  don\u2019t you need to have time to have side effects work?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "aea42a8b-cb4b-4045-ac15-4198eecd8658",
        "type": "message",
        "text": "<@UDQBTJ211>\nAre you taking an anti-abstraction stance that programmers should be be aware of time as it exists in the internals of the language/environment they\u2019re using (because they\u2019ll have to deal with it eventually anyway)? Or are you just saying it\u2019s good for them to think about/deal with time in their code, but it\u2019s OK if it\u2019s abstracted into a different (likely more limited) form?",
        "user": "UJZS8UUJV",
        "ts": "1631237662.168000",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "iUsD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": "\nAre you taking an anti-abstraction stance that programmers should be be aware of time as it exists in the internals of the language/environment they\u2019re using (because they\u2019ll have to deal with it eventually anyway)? Or are you just saying it\u2019s good for them to think about/deal with time in their code, but it\u2019s OK if it\u2019s abstracted into a different (likely more limited) form?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "153a2736-2c49-480e-b0ba-c7bbcf459996",
        "type": "message",
        "text": "synchronous languages (Lucid, Esterel, Lustre) have a pretty qualitatively different experience of time",
        "user": "UEBG0NPDK",
        "ts": "1631294050.170600",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "zOO",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "synchronous languages (Lucid, Esterel, Lustre) have a pretty qualitatively different experience of time"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "44eadc90-f937-40cc-8e35-8cec48e67700",
        "type": "message",
        "text": "Great references and exploration of the topic \u2014 thanks everyone.\n\n<@UFPPABQ7P>\n&gt; keeping value in the stack for weeks at a time\nI love this idea. I'm so accustomed to non-live programming that I forget about the completely different sensation of time that you get from a live environment, where state is can be thought of as non-volatile by default.\n\n<@UDQBTJ211> \u2014\u00a0I like that your two comments are \"here's why [existing thing] is what it is\" and \"here's what I want to exist\". Both make sense to me!\n\n<@UBN9AFS0N> \u2014 Queued! Though unlike Lamport's earlier work (you know, _the hits_), this one looks like it might fly over my head a bit :$\n\n<@UJFN50C00> \u2014\u00a0Croquet sure is interesting, hey? Though I'm not sure how it relates here \u2014 I can imagine ways, but if you had something specific about it you wanted to highlight that'd be appreciated.\n\n<@UJZS8UUJV> \u2014 You're right, I under-considered what I was saying there. I was focused on pointing out that you _can_ have all that conventionally \"functional\" stuff within a programming system that does feel very mechanical / process-oriented. I didn't consider enough whether it's possible to have the non-FP stuff within a system that feels timeless. Good point, will have to think about this some more.\n\n<@UEBG0NPDK> \u2014 Nice pulls! I suppose the same applies to RT OSes, CAN Bus (etc), and perhaps even programming within a high-end game engine (eg: frame cadence, Carmack's preference for algorithms that are slower average-case with less variability, etc). Would love to just be able to just... order a study on this.",
        "user": "UC2A2ARPT",
        "ts": "1631295322.171500",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Iag",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Great references and exploration of the topic \u2014 thanks everyone.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UFPPABQ7P"
                            },
                            {
                                "type": "text",
                                "text": "\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "keeping value in the stack for weeks at a time"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I love this idea. I'm so accustomed to non-live programming that I forget about the completely different sensation of time that you get from a live environment, where state is can be thought of as non-volatile by default.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UDQBTJ211"
                            },
                            {
                                "type": "text",
                                "text": " \u2014\u00a0I like that your two comments are \"here's why [existing thing] is what it is\" and \"here's what I want to exist\". Both make sense to me!\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UBN9AFS0N"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 Queued! Though unlike Lamport's earlier work (you know, "
                            },
                            {
                                "type": "text",
                                "text": "the hits",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "), this one looks like it might fly over my head a bit :$\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJFN50C00"
                            },
                            {
                                "type": "text",
                                "text": " \u2014\u00a0Croquet sure is interesting, hey? Though I'm not sure how it relates here \u2014 I can imagine ways, but if you had something specific about it you wanted to highlight that'd be appreciated.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UJZS8UUJV"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 You're right, I under-considered what I was saying there. I was focused on pointing out that you "
                            },
                            {
                                "type": "text",
                                "text": "can",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " have all that conventionally \"functional\" stuff within a programming system that does feel very mechanical / process-oriented. I didn't consider enough whether it's possible to have the non-FP stuff within a system that feels timeless. Good point, will have to think about this some more.\n\n"
                            },
                            {
                                "type": "user",
                                "user_id": "UEBG0NPDK"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 Nice pulls! I suppose the same applies to RT OSes, CAN Bus (etc), and perhaps even programming within a high-end game engine (eg: frame cadence, Carmack's preference for algorithms that are slower average-case with less variability, etc). Would love to just be able to just... order a study on this."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "2c82c231-7f71-4c0b-836f-aadbab761311",
        "type": "message",
        "text": "ok, stream of conciousness incoming...\n\nOn the concept of math vs mechanics, I perceive math as this vast graph that always exists, but in imagination. Mechanics is about materializing parts of this graph in some physical form. The machine manifests a subset of this graph, and _traverses_ to other nodes, pulling in more and more of this graph, from the imaginary to the physical, as physical time progresses. If you type `2 + 3` in a system, you've got a graph with three nodes (2, 3, +, connected in a nice tree) and after some time, you've got a 4th node (5, connected to the [2,3+] bundle of nodes), but in mathland all 4 nodes (and the edges and more) pre-existed.\n\nOn the intersection of these ideas, CRDTs come to mind. You have the semi-lattice, which is very mathematical and static. However you have the actual values at different nodes, which correspond to one node in the lattice at any point in time, but they change over time and eventually _walk up_ the math lattice to meet at the top.\n\nCroquet came to my mind as well when reading the prompt. On the surface it is full-mechanical. The machines moves, step by step, and is implemented in that style. However look between steps - each step is functional, it *must* be deterministic - that's what keeps all the different systems in sync. There is no logical time within a step (e.g. can be considered instantaneous.. the next input cannot interrupt a step).",
        "user": "U8A5MS6R1",
        "ts": "1631319396.172900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U8A5MS6R1",
            "ts": "1631337808.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SQ4",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "ok, stream of conciousness incoming...\n\nOn the concept of math vs mechanics, I perceive math as this vast graph that always exists, but in imagination. Mechanics is about materializing parts of this graph in some physical form. The machine manifests a subset of this graph, and "
                            },
                            {
                                "type": "text",
                                "text": "traverses",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " to other nodes, pulling in more and more of this graph, from the imaginary to the physical, as physical time progresses. If you type "
                            },
                            {
                                "type": "text",
                                "text": "2 + 3",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " in a system, you've got a graph with three nodes (2, 3, +, connected in a nice tree) and after some time, you've got a 4th node (5, connected to the [2,3+] bundle of nodes), but in mathland all 4 nodes (and the edges and more) pre-existed.\n\nOn the intersection of these ideas, CRDTs come to mind. You have the semi-lattice, which is very mathematical and static. However you have the actual values at different nodes, which correspond to one node in the lattice at any point in time, but they change over time and eventually "
                            },
                            {
                                "type": "text",
                                "text": "walk up",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " the math lattice to meet at the top.\n\nCroquet came to my mind as well when reading the prompt. On the surface it is full-mechanical. The machines moves, step by step, and is implemented in that style. However look between steps - each step is functional, it *must* be deterministic - that's what keeps all the different systems in sync. There is no logical time within a step (e.g. can be considered instantaneous.. the next input cannot interrupt a step)."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    },
    {
        "client_msg_id": "3217a7ad-3f5e-4548-8d6d-68ed2e6402f8",
        "type": "message",
        "text": "<@UJZS8UUJV> Basically the first. You should at least be aware of which end of this spectrum is the actual bedrock, and which is the potentially leaky abstraction.\n\nI've used this example before but CPython and Pypy implement `list.pop(0)` (popping first item from a list) differently. CPython bumps a pointer, Pypy moves the list. So it's O(1) vs O(n). There is literally no way to discover this \"in system\". This is the sort of thing that comes up in end-user programming like data science and will actually confuse users. It can make the difference between a visualisation being interactive or not.\n\nThe weakness in my position is that in a lot of cases, you truly don't ever need to worry about how the abstraction is actually realised/implemented. Most actual use cases are just IFTTT style plumbing or CRUD apps with N in the hundreds.",
        "user": "UDQBTJ211",
        "ts": "1631352756.173700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "wrsD",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "user",
                                "user_id": "UJZS8UUJV"
                            },
                            {
                                "type": "text",
                                "text": " Basically the first. You should at least be aware of which end of this spectrum is the actual bedrock, and which is the potentially leaky abstraction.\n\nI've used this example before but CPython and Pypy implement "
                            },
                            {
                                "type": "text",
                                "text": "list.pop(0)",
                                "style": {
                                    "code": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " (popping first item from a list) differently. CPython bumps a pointer, Pypy moves the list. So it's O(1) vs O(n). There is literally no way to discover this \"in system\". This is the sort of thing that comes up in end-user programming like data science and will actually confuse users. It can make the difference between a visualisation being interactive or not.\n\nThe weakness in my position is that in a lot of cases, you truly don't ever need to worry about how the abstraction is actually realised/implemented. Most actual use cases are just IFTTT style plumbing or CRUD apps with N in the hundreds."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631156760.159500",
        "parent_user_id": "UC2A2ARPT"
    }
]