[
    {
        "client_msg_id": "67ba14e1-5c88-4c3c-b6c1-1a0dc0a3be79",
        "type": "message",
        "text": "*Calling all software engineers who know basic category theory:* some applied category theorists in the US are organizing a hackathon to explore how <https://topos.site/poly-course/|the theory of polynomial functors> can be applied to software development (new programming libraries and/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. :slightly_smiling_face: This would be an in-person event in the US, taking place ~March next year.\n\nThere is <https://topos.site/poly-course/|a short course and book draft> on the category of polynomial functors, outlining its applicability to *interactive systems* and *databases*. I expect these applications will be the focus of the hackathon.",
        "user": "UCGAK10LS",
        "ts": "1631142763.129900",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1631143061.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "ax1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Calling all software engineers who know basic category theory:",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " some applied category theorists in the US are organizing a hackathon to explore how "
                            },
                            {
                                "type": "link",
                                "url": "https://topos.site/poly-course/",
                                "text": "the theory of polynomial functors"
                            },
                            {
                                "type": "text",
                                "text": " can be applied to software development (new programming libraries and/or languages). The attendees would be a mix of software engineers (who know category theory) and category theorists. If you'd be interested in attending or brainstorming about such a hackathon let me know. I've offered to help organize it, but we need more input from software engineers. "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " This would be an in-person event in the US, taking place ~March next year.\n\nThere is "
                            },
                            {
                                "type": "link",
                                "url": "https://topos.site/poly-course/",
                                "text": "a short course and book draft"
                            },
                            {
                                "type": "text",
                                "text": " on the category of polynomial functors, outlining its applicability to "
                            },
                            {
                                "type": "text",
                                "text": "interactive systems",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " and "
                            },
                            {
                                "type": "text",
                                "text": "databases",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I expect these applications will be the focus of the hackathon."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631142763.129900",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1631490675.001200",
        "reply_users": [
            "UN57U8V53",
            "UCGAK10LS"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "thinking_face",
                "users": [
                    "UA14TGLTC"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "d253b9e8-2ca2-4ea5-9edb-b12620fa07e1",
        "type": "message",
        "text": "I\u2019m interested in this, but I am only familiar with the basics of CT.\n\nFYI: I\u2019ve been learning what I can about generating code from laymen-defined models+properties where the generated code \u201csmartly\u201d chooses between both runtime (based on collected metrics) and static (based on machine model) strategies (such as sort algorithm, data layouts, GPU vs. CPU targeting, batch/row sizes, etc). There\u2019s also a very difficult problem on providing feedback or even choices when \u201cthings\u201d are over-constrained/non-feasible.\n\nAny thoughts on if Poly could be a helpful way to model this problem? In the Poly book, they restrict the lens structure in a way I don\u2019t understand, so I don\u2019t know if it can model more complex optics like monadic lenses (which is one way to model+execute RT strategy decisions). I also really don\u2019t understand the implications of things like \u201cpreserving op-cartesian arrows.\u201d",
        "user": "UN57U8V53",
        "ts": "1631365343.173900",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "Jx1",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019m interested in this, but I am only familiar with the basics of CT.\n\nFYI: I\u2019ve been learning what I can about generating code from laymen-defined models+properties where the generated code \u201csmartly\u201d chooses between both runtime (based on collected metrics) and static (based on machine model) strategies (such as sort algorithm, data layouts, GPU vs. CPU targeting, batch/row sizes, etc). There\u2019s also a very difficult problem on providing feedback or even choices when \u201cthings\u201d are over-constrained/non-feasible.\n\nAny thoughts on if Poly could be a helpful way to model this problem? In the Poly book, they restrict the lens structure in a way I don\u2019t understand, so I don\u2019t know if it can model more complex optics like monadic lenses (which is one way to model+execute RT strategy decisions). I also really don\u2019t understand the implications of things like \u201cpreserving op-cartesian arrows.\u201d"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631142763.129900",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "aaadb00a-8b52-4973-ad31-ca1b9949cd6e",
        "type": "message",
        "text": "&gt; I\u2019ve been learning what I can about generating code from laymen-defined models+properties\nIt sounds like you're interested in *compilers* for high-level languages? Your description reminds me of MLIR, which aims to be a good framework for compiling programs from (vastly different) high-level domains, such as neural networks and hardware circuits. It definitely does all those static optimizations you describe.\n\nAs for whether Poly can help with this: my hunch is *no*, not right now. (Disclaimer though: I'm not a category theorist, I'm just a software engineer who's been in contact with the book authors.) Poly is being investigated as a *modelling language*, but not as a compiler. The main challenge right now is connecting Poly back to everyday programming constructs. We've got an understanding of how it connects to type systems, I/O, and databases, but other important stuff like recursion is missing. It's unclear how deep the Poly rabbit hole goes; it's still very early days. That's why there's a hackathon being planned: to support further exploration!\n\n&gt; I don\u2019t know if it can model more complex optics like monadic lenses\nNor do I. I don't even know what a monadic lens is :slightly_smiling_face:\n\n&gt; I also really don\u2019t understand the implications of things like \u201cpreserving op-cartesian arrows.\u201d\nThe book is mainly targeted at category theorists right now, and so its style is to list out a bunch of theorems on every aspect of Poly. Some of them have clear implications, some of them don't. My personal strategy has been to focus on the theorems that seem interesting to me as a software engineer :innocent:.",
        "user": "UCGAK10LS",
        "ts": "1631404772.174300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1631404783.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3=R",
                "elements": [
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I\u2019ve been learning what I can about generating code from laymen-defined models+properties"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nIt sounds like you're interested in "
                            },
                            {
                                "type": "text",
                                "text": "compilers",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for high-level languages? Your description reminds me of MLIR, which aims to be a good framework for compiling programs from (vastly different) high-level domains, such as neural networks and hardware circuits. It definitely does all those static optimizations you describe.\n\nAs for whether Poly can help with this: my hunch is "
                            },
                            {
                                "type": "text",
                                "text": "no",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", not right now. (Disclaimer though: I'm not a category theorist, I'm just a software engineer who's been in contact with the book authors.) Poly is being investigated as a "
                            },
                            {
                                "type": "text",
                                "text": "modelling language",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ", but not as a compiler. The main challenge right now is connecting Poly back to everyday programming constructs. We've got an understanding of how it connects to type systems, I/O, and databases, but other important stuff like recursion is missing. It's unclear how deep the Poly rabbit hole goes; it's still very early days. That's why there's a hackathon being planned: to support further exploration!\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I don\u2019t know if it can model more complex optics like monadic lenses"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nNor do I. I don't even know what a monadic lens is "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": "\n\n"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_quote",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I also really don\u2019t understand the implications of things like \u201cpreserving op-cartesian arrows.\u201d"
                            }
                        ]
                    },
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "\nThe book is mainly targeted at category theorists right now, and so its style is to list out a bunch of theorems on every aspect of Poly. Some of them have clear implications, some of them don't. My personal strategy has been to focus on the theorems that seem interesting to me as a software engineer "
                            },
                            {
                                "type": "emoji",
                                "name": "innocent"
                            },
                            {
                                "type": "text",
                                "text": "."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631142763.129900",
        "parent_user_id": "UCGAK10LS",
        "reactions": [
            {
                "name": "+1",
                "users": [
                    "UN57U8V53"
                ],
                "count": 1
            }
        ]
    },
    {
        "client_msg_id": "12e886c0-1694-4a95-898c-9aca4787e793",
        "type": "message",
        "text": "Hah, well my current hope is that the compiler input isn\u2019t a high level language, but a model (think more like minecraft or sketch)\nI\u2019m looking for the right model(s) to slowly increase power/complexity, basically adding a dimension at a time (and trying to keep people thinking about the \u201cwhat\u201d rather than the \u201chow\u201d when manipulating the model)",
        "user": "UN57U8V53",
        "ts": "1631443658.000200",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "qjua5",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hah, well my current hope is that the compiler input isn\u2019t a high level language, but a model (think more like minecraft or sketch)\nI\u2019m looking for the right model(s) to slowly increase power/complexity, basically adding a dimension at a time (and trying to keep people thinking about the \u201cwhat\u201d rather than the \u201chow\u201d when manipulating the model)"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631142763.129900",
        "parent_user_id": "UCGAK10LS"
    },
    {
        "client_msg_id": "77313594-efe7-461d-a58f-2234a55275a7",
        "type": "message",
        "text": "What do you mean by \"model\" here? That word has a lot of meanings!\n\nFor example, how do you wish me to perceive Minecraft as a model? I see it as a fully-fledged interactive application! But if I were to think of Minecraft as a _tool_ for making models, I can recall how people use Minecraft blocks to build _physical models_ of locations and buildings. But those aren't models of interactive systems. You can also use Minecraft's redstone system to build circuits, but that's equivalent to a low-level programming language, so I don't see it as something special. And of course you can write mods for Minecraft, but that's just conventional programming.",
        "user": "UCGAK10LS",
        "ts": "1631490675.001200",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "UCGAK10LS",
            "ts": "1631490781.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "lK/N",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "What do you mean by \"model\" here? That word has a lot of meanings!\n\nFor example, how do you wish me to perceive Minecraft as a model? I see it as a fully-fledged interactive application! But if I were to think of Minecraft as a "
                            },
                            {
                                "type": "text",
                                "text": "tool",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " for making models, I can recall how people use Minecraft blocks to build "
                            },
                            {
                                "type": "text",
                                "text": "physical models",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": " of locations and buildings. But those aren't models of interactive systems. You can also use Minecraft's redstone system to build circuits, but that's equivalent to a low-level programming language, so I don't see it as something special. And of course you can write mods for Minecraft, but that's just conventional programming."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1631142763.129900",
        "parent_user_id": "UCGAK10LS"
    }
]