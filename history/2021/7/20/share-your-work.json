[
    {
        "client_msg_id": "0f41ec70-9881-47ab-9ca3-c73b859e387d",
        "type": "message",
        "text": "Hi all,  this is my first post here.  Ever since I saw\u00a0<https://www.youtube.com/watch?v=Av0PQDVTP4A|this literate programming talk\u00a0>I have been messing with existing literate programming tools. After trying multiple tools, I ended up writing my own tool using python + sphinx + cog + markdown. I am calling it wheel.\n\nBecause of cog - I believe literate programming can enable many interesting things like arbitrary preprocessing and code generation instead of just mangle and tangle. In plannr I have experimented with adding some syntax to hylang, a dialect of lisp. I think literate programming is criss-cross programming :slightly_smiling_face: and enables _feature driven development_. I have documented my findings here\u00a0<https://xyzzyapps.link/wheel/why.html>\n\nWould love to\u00a0hear you guys think!\n\n*Links*\n\n1.\u00a0<https://xyzzyapps.link/wheel|Wheel>\u00a0- a literate programming tool with python + sphinx + cog + markdown.\n2. My main app\u00a0<https://plannr.xyzzyapps.link/|Plannr (currently beta)>\u00a0and the\u00a0<https://plannr.xyzzyapps.link/docs/index.html|literate documentation>\u00a0for it.\u00a0<https://plannr.xyzzyapps.link/docs/plannr.html|Source code>\u00a0inside the documentation.\n3. My music making app\u00a0<https://bitrhythm.xyzzyapps.link/|Bitrhythm>\u00a0and its\u00a0<https://bitrhythm.xyzzyapps.link/docs/index.html|documentation>",
        "user": "U0282PL61U1",
        "ts": "1626737092.172700",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "3=+",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Hi all,  this is my first post here.  Ever since I saw\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://www.youtube.com/watch?v=Av0PQDVTP4A",
                                "text": "this literate programming talk\u00a0"
                            },
                            {
                                "type": "text",
                                "text": "I have been messing with existing literate programming tools. After trying multiple tools, I ended up writing my own tool using python + sphinx + cog + markdown. I am calling it wheel.\n\nBecause of cog - I believe literate programming can enable many interesting things like arbitrary preprocessing and code generation instead of just mangle and tangle. In plannr I have experimented with adding some syntax to hylang, a dialect of lisp. I think literate programming is criss-cross programming "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " and enables "
                            },
                            {
                                "type": "text",
                                "text": "feature driven development",
                                "style": {
                                    "italic": true
                                }
                            },
                            {
                                "type": "text",
                                "text": ". I have documented my findings here\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://xyzzyapps.link/wheel/why.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nWould love to\u00a0hear you guys think!\n\n"
                            },
                            {
                                "type": "text",
                                "text": "Links",
                                "style": {
                                    "bold": true
                                }
                            },
                            {
                                "type": "text",
                                "text": "\n\n1.\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://xyzzyapps.link/wheel",
                                "text": "Wheel"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0- a literate programming tool with python + sphinx + cog + markdown.\n2. My main app\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://plannr.xyzzyapps.link/",
                                "text": "Plannr (currently beta)"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0and the\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://plannr.xyzzyapps.link/docs/index.html",
                                "text": "literate documentation"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0for it.\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://plannr.xyzzyapps.link/docs/plannr.html",
                                "text": "Source code"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0inside the documentation.\n3. My music making app\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://bitrhythm.xyzzyapps.link/",
                                "text": "Bitrhythm"
                            },
                            {
                                "type": "text",
                                "text": "\u00a0and its\u00a0"
                            },
                            {
                                "type": "link",
                                "url": "https://bitrhythm.xyzzyapps.link/docs/index.html",
                                "text": "documentation"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1626737092.172700",
        "reply_count": 4,
        "reply_users_count": 2,
        "latest_reply": "1626865196.182500",
        "reply_users": [
            "U01ULEWACPP",
            "U0282PL61U1"
        ],
        "is_locked": false,
        "subscribed": false,
        "reactions": [
            {
                "name": "cake",
                "users": [
                    "UC2A2ARPT"
                ],
                "count": 1
            },
            {
                "name": "heart",
                "users": [
                    "U01ULEWACPP",
                    "UE0H4170F"
                ],
                "count": 2
            }
        ]
    },
    {
        "client_msg_id": "13951bc4-01d4-417b-9f01-6246f287c1bc",
        "type": "message",
        "text": "I find my self nodding a lot reading through it: <https://xyzzyapps.link/wheel/why.html>\n\nI briefly looked through the \u201cCode Walkthrough\u201d of Plannr to get a better understanding. I wonder how you can get different perspectives on code besides chapters and pages.\n\nThinking in books: I understand that there is a table of contents and a linear flow through the book. There are also links. Is there also some sort of Appendix, Glossary or other forms of organization possible? For example, I found a couple of code snippets called \u201cWebsocket Reply Handlers\u201d that contained message types and handlers. I could imagine an index of all those that link to their implementation. Would that be possible / how would you set this up?",
        "user": "U01ULEWACPP",
        "ts": "1626777101.174100",
        "team": "T5TCAFTA9",
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "xFBIo",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I find my self nodding a lot reading through it: "
                            },
                            {
                                "type": "link",
                                "url": "https://xyzzyapps.link/wheel/why.html"
                            },
                            {
                                "type": "text",
                                "text": "\n\nI briefly looked through the \u201cCode Walkthrough\u201d of Plannr to get a better understanding. I wonder how you can get different perspectives on code besides chapters and pages.\n\nThinking in books: I understand that there is a table of contents and a linear flow through the book. There are also links. Is there also some sort of Appendix, Glossary or other forms of organization possible? For example, I found a couple of code snippets called \u201cWebsocket Reply Handlers\u201d that contained message types and handlers. I could imagine an index of all those that link to their implementation. Would that be possible / how would you set this up?"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1626737092.172700",
        "parent_user_id": "U0282PL61U1"
    },
    {
        "client_msg_id": "d8d1eddf-1398-4547-aad2-57986e692635",
        "type": "message",
        "text": "In the original implementation cweb extensive cross referencing capabilities are provided but yes there could be other perspectives on chapters. You can get cross references with  <https://github.com/zyedidia/Literate|this tool>.  My current notion is 1 chapter = 1 use case or 1 complete feature with backend, frontend and tests.",
        "user": "U0282PL61U1",
        "ts": "1626786361.174300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0282PL61U1",
            "ts": "1626786741.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "6E6=",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "In the original implementation cweb extensive cross referencing capabilities are provided but yes there could be other perspectives on chapters. You can get cross references with  "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/zyedidia/Literate",
                                "text": "this tool"
                            },
                            {
                                "type": "text",
                                "text": ".  My current notion is 1 chapter = 1 use case or 1 complete feature with backend, frontend and tests."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1626737092.172700",
        "parent_user_id": "U0282PL61U1"
    },
    {
        "client_msg_id": "b906bb07-e530-4283-a9b9-c1c6c52d61f3",
        "type": "message",
        "text": "Thanks! I really find this whole idea super interesting. I\u2019ve been keeping a written log of my programming progress with notes about features, implementations and screenshots. But linking that with actual code would be interesting. I believe a lot of challenges from coding comes from the lack of Organisation and verbalisation. And as described here, files/folders aren\u2019t enough and seem to be rather hacks. I like that in Processing (.org), you can create \u201ctabs\u201d when a single code file gets too long. You create a tab inside the IDE but that tab isn\u2019t a new file that you need to import. It is just a new \u201csnippet\u201d that will be appended together with the other tabs. I wonder: is Observable another example of literate programming? <https://observablehq.com> \u2014 I do have to say that your examples are better, because they have a table of contents! :slightly_smiling_face: In general I think that lists, maps, and other designed forms of access to code are really needed in contrast to just files, folders and naming conventions.",
        "user": "U01ULEWACPP",
        "ts": "1626861188.181300",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U01ULEWACPP",
            "ts": "1626861258.000000"
        },
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "SUnv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "Thanks! I really find this whole idea super interesting. I\u2019ve been keeping a written log of my programming progress with notes about features, implementations and screenshots. But linking that with actual code would be interesting. I believe a lot of challenges from coding comes from the lack of Organisation and verbalisation. And as described here, files/folders aren\u2019t enough and seem to be rather hacks. I like that in Processing (.org), you can create \u201ctabs\u201d when a single code file gets too long. You create a tab inside the IDE but that tab isn\u2019t a new file that you need to import. It is just a new \u201csnippet\u201d that will be appended together with the other tabs. I wonder: is Observable another example of literate programming? "
                            },
                            {
                                "type": "link",
                                "url": "https://observablehq.com"
                            },
                            {
                                "type": "text",
                                "text": " \u2014 I do have to say that your examples are better, because they have a table of contents! "
                            },
                            {
                                "type": "emoji",
                                "name": "slightly_smiling_face"
                            },
                            {
                                "type": "text",
                                "text": " In general I think that lists, maps, and other designed forms of access to code are really needed in contrast to just files, folders and naming conventions."
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1626737092.172700",
        "parent_user_id": "U0282PL61U1"
    },
    {
        "client_msg_id": "0822bdde-a656-421e-b428-cc69bd214707",
        "type": "message",
        "text": "I haven\u2019t used observable but I have used python notebooks. I think <https://github.com/fastai/nbdev|nbdev> comes close to literate programming. The difference lies in the flexibility of organisation and arbitrary reordering.  In literate programming you define chunks that can be reused wherever you want, whether in docs or code. If observable provides a named block that can be referenced and embedded anywhere then it gets close. I would emphasise that this is production code, not just examples which blogs and notebooks are typically used for!  Personally I find literate programming for noting down 1. todo\u2019s 2. bugs 3. bookmarks 4, design decisions and history 5. build commands 6. tests",
        "user": "U0282PL61U1",
        "ts": "1626865196.182500",
        "team": "T5TCAFTA9",
        "edited": {
            "user": "U0282PL61U1",
            "ts": "1626865252.000000"
        },
        "attachments": [
            {
                "service_name": "GitHub",
                "title": "GitHub - fastai/nbdev: Create delightful python projects using Jupyter Notebooks",
                "title_link": "https://github.com/fastai/nbdev",
                "text": "Create delightful python projects using Jupyter Notebooks - GitHub - fastai/nbdev: Create delightful python projects using Jupyter Notebooks",
                "fallback": "GitHub: GitHub - fastai/nbdev: Create delightful python projects using Jupyter Notebooks",
                "image_url": "https://repository-images.githubusercontent.com/222507066/59f8cf00-2f1c-11eb-8abd-5644325afacc",
                "from_url": "https://github.com/fastai/nbdev",
                "image_width": 405,
                "image_height": 250,
                "image_bytes": 304124,
                "service_icon": "https://a.slack-edge.com/80588/img/unfurl_icons/github.png",
                "id": 1,
                "original_url": "https://github.com/fastai/nbdev"
            }
        ],
        "blocks": [
            {
                "type": "rich_text",
                "block_id": "LsJv",
                "elements": [
                    {
                        "type": "rich_text_section",
                        "elements": [
                            {
                                "type": "text",
                                "text": "I haven\u2019t used observable but I have used python notebooks. I think "
                            },
                            {
                                "type": "link",
                                "url": "https://github.com/fastai/nbdev",
                                "text": "nbdev"
                            },
                            {
                                "type": "text",
                                "text": " comes close to literate programming. The difference lies in the flexibility of organisation and arbitrary reordering.  In literate programming you define chunks that can be reused wherever you want, whether in docs or code. If observable provides a named block that can be referenced and embedded anywhere then it gets close. I would emphasise that this is production code, not just examples which blogs and notebooks are typically used for!  Personally I find literate programming for noting down 1. todo\u2019s 2. bugs 3. bookmarks 4, design decisions and history 5. build commands 6. tests"
                            }
                        ]
                    }
                ]
            }
        ],
        "thread_ts": "1626737092.172700",
        "parent_user_id": "U0282PL61U1",
        "reactions": [
            {
                "name": "eyes",
                "users": [
                    "U01ULEWACPP"
                ],
                "count": 1
            }
        ]
    }
]